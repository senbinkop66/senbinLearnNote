# 初级算法

##  数组

### 1. 删除排序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```java
class Solution{
	public int removeDuplicates(int[] nums){
		int len=nums.length;
		if (len==0) return 0;
		if (len==1) return 1;
		int temp=nums[0];  //标志位
		int i=1;
		while (i<len){
			if (temp==nums[i]) {
				//因为是有序，所以相同就向前移动一位覆盖相同的一个
				for (int j=i; j<len-1; j++) {
					nums[j]=nums[j+1];
				}
				len--;  //长度减一
			}else{
				//不是重复的则把标志位后移
				temp=nums[i];
				i++;
			}
			
		}
		return len;
	}
}

public class TestArray1{
	
	public static void main(String[] args) {
		int[] testnums={0,0,1,1,1,2,2,3,3,4};
		Solution mysolution=new Solution();
		int newlen=mysolution.removeDuplicates(testnums);
		System.out.println(newlen);
		for (int i=0; i<newlen; i++) {
			if (i==newlen-1) {
				System.out.println(testnums[i]);
			}else{
				System.out.print(testnums[i]+" ,");
			}
		}
	}
}
```

待解决：实现的时间复杂度有点高，应该还可以减少移动次数，比如处理连续重复的情况.

### 2. 买卖股票的最佳时机 II

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票

```java
class Solution{
	public int maxProfit(int[] prices){
		int len=prices.length;
		if (len<=1) return 0;
		/* 分析可知需要小买大出收益最大，比较相邻的数值，以及连续增长的时候*/
		int sum=0;  //最大收益
		int flag=prices[0];  //标志位
		int i=1;
		while (i<len){
			if (flag>=prices[i]) {
				//当前比后一个比较的大时，属于亏损，,等于时没有意义。不交易
			}else{
				sum+=prices[i]-flag;  //后一个比前一个值大说明盈利，交易
			}
			flag=prices[i];  //设置标志位为当前值
			i++;
		}
		return sum;
	}
}

public class TestArray1{
	public static void main(String[] args) {
		int[] testprices={7,6,4,3,1};
		Solution mysolution=new Solution();
		int myMaxProfit=mysolution.maxProfit(testprices);
		System.out.println(myMaxProfit);
	}
}
```

可以不设置标志位减少内存消耗，可以直接比较,以及连续增加时的计算

使用动态规划解决

使用贪心算法解决

### 3. 旋转数组

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

暴力移动 (k%len)*len 次，测试会超时,此方法消耗过大

```java
public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大

		int flag=nums[len-1];  //最后一个元素
		for (int i=0;i<k;i++){
			for (int j=len-1; j>0; j--) {
				nums[j]=nums[j-1];
			}
			nums[0]=flag;
			flag=nums[len-1];
		}
	}
```

使用临时数组    借助辅助空间大小为k的数组

```java
class Solution{
	public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大
		
		int[] numsK=new int[k];  //辅助空间,用于保存后k个
		for (int i=0;i<k;i++) {
			numsK[i]=nums[len-1-i];
		}
		for (int i=len-1; i>=k; i--) {
			//前len-k个后移k位
			nums[i]=nums[i-k];
		}
		for (int i=k-1;i>=0;i--){
			//把保存的k个放在前面来
			nums[i]=numsK[k-1-i];
		}
	}
}
```

可以运行通过，但太耗内存，可以判断k与len-k的大小，然后辅助空间用于存储小的一个，虽然也耗内存

```java
import java.util.*;

class Solution{
	public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大
		
		int temp=nums[0];
		for (int i=0;i<k;i++) {
			//先把前k个与后k个换位置
			nums[i]=nums[len-k+i];
			nums[len-k+i]=temp;
			temp=nums[i+1];
		}
/*
		temp=nums[2*k-1];
		for (int i=0;i<len-k;i++) {
			nums[2*k-1+i]=nums[len-1-i];
			nums[len-1-i]=nums[len-1-i-k];
			nums[len-1-i-k]=temp;
			temp=nums[2*k+i];
		}
*/
	}
}

public class TestArray1{
	public static void main(String[] args) {
		int[] testnums={1,2,3,4,5,6,7,8,9,10};
		Solution mysolution=new Solution();
		int k=3;
		System.out.println(Arrays.toString(testnums));
		mysolution.rotate(testnums,k);
		System.out.println(Arrays.toString(testnums));
		int[] testnums2={1,2,3,4,5,6,7,8,9,10};
		k=7;
		mysolution.rotate(testnums2,k);
		System.out.println(Arrays.toString(testnums2));
	}
}
```

这个还存在问题

多次反转

环形旋转

### 4. 存在重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

暴力解法超时

```java
public boolean containsDuplicate(int[] nums){
		int len=nums.length;
		if (len<=1) return false;
		//从小到大排序
		for (int i=0;i<len-1;i++) {
			for (int j=i+1;j<len;j++){
				if (nums[i]==nums[j]) {
					return true;
				}
			}
		}
		return false;
		
	}
```

使用set

```java
public boolean containsDuplicate(int[] nums){
		int len=nums.length;
		if (len<=1) return false;
		
		//使用set
		Set<Integer> set=new HashSet<>();
		for (int n:nums){
			//当重复添加返回true
			if (!set.add(n)) {
				return true;
			}
		}
		return false;
	}
```

先排序，然后比较



### 5.  只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

使用异或运算，将所有值进行异或
异或运算，相异为真，相同为假，所以 a^a = 0 ;0^a = a，a^b=0
因为异或运算 满足交换律 a^b^a = a^a^b = b 所以数组经过异或运算，单独的值就剩下了

```java
	public int singleNumber(int[] nums){
		int len=nums.length;

		if (len==1) return nums[0];
		int result=0;
		for (Integer n:nums) {
			result^=n;
		}
		return result;
	}
```

```java
public int singleNumber(int[] nums){
		for (int i=1;i<nums.length;i++) {
			nums[0]^=nums[i];
		}
		return nums[0];
	}
```

使用set,重复添加时移除，最后只剩下一个

```java
	public int singleNumber(int[] nums){
		int len=nums.length;

		int result=nums[0];
		if (len<=1) return nums[0];
		
		//使用set
		Set<Integer> set=new HashSet<>();
		for (int n:nums){
			if (!set.add(n)) {
				set.remove(n);
			}
		}
		return (int) set.toArray()[0];
	}
```

两个方法速度都一般

### 6. 两个数组的交集 II

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
    nums1.sort((a,b)=>a-b);
    nums2.sort((a,b)=>a-b);
    let count1=1;
    let count2=0;
    let i;
    let j;
    let results=new Array();
    let temp=nums1[0];
    for (i=0,j=0;i<nums1.length,j<=nums2.length;){
        if (j==nums2.length || nums1[i]<nums2[j]) {
            i++;
            if (count2!==0) {
                if (nums1[i]==nums1[i-1]){
                    count1++;
                }else{
                    for ( let k=0;k<Math.min(count1,count2);k++){
                        results.push(temp);
                    }
                    temp=nums1[i];
                    count1=1;
                    count2=0;
                    if (j==nums2.length){ j++;}
                }
            }else{
                temp=nums1[i];
            }
        }else if(nums1[i]>nums2[j]){
            j++;
        }else{
            j++;
            count2++;
        }
    }
    if (count2!=0){
        for ( let k=0;k<Math.min(count1,count2);k++){
            results.push(temp);
        }
    }
    return results;
};

let str1 = [2, 4, 4, 5, 9,5, 9, 9];
let str2 = [4, 4,9, 5,4, 8, 9, 9 ];
let result=intersect(str1,str2);
//console.log(typeof result);
console.log(result);

//超时
```

使用双指针

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
    nums1.sort((a,b)=>a-b);
    nums2.sort((a,b)=>a-b);

    let i=0,j=0;
    let results=new Array();
    let temp=nums1[0];
    for (i=0,j=0;i<nums1.length,j<nums2.length;){
        if (nums1[i]==nums2[j]) {
            results.push(nums1[i]);
            i++;
            j++;
        }else{
            if (nums1[i]<nums2[j]) {
                i++;
            }else{
                j++;
            }
        }
    }
    return results;
};
```

### 7. 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    digits[digits.length-1]+=1;
    //从后往前循环到第二位
    for (let i=digits.length-1;i>0;i--){
        if (digits[i]<10){
            break;
        }else{
             digits[i]=0;
             digits[i-1]+=1;
        }
    }
    if (digits[0]===10) {
        //特例9999这种
        digits[0]=1;
        digits[digits.length]=0;
    }
    return digits;
};

let str1 = [2, 4, 4, 5, 9,5, 9, 9];
let str2 = [9, 9, 9 ];
let result=plusOne(str1);
//console.log(typeof result);
console.log(result);
```

### 8. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let flag1=nums.length-1;  //标识最后的最后一个非0的位置
    for (let i=nums.length-1;i>=0;i--) {
        if (nums[i]===0) {
            if (i!==flag1) {
                for (let j=i;j<flag1;j++){
                    nums[j]=nums[j+1];
                }
                nums[flag1]=0;
                flag1--;
            }else{
                flag1--;
            }
        }
    }
    return nums;
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=moveZeroes(str1);
//console.log(typeof result);
console.log(result);

```





## 字符串

### 1. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

对称交换

```java
class Solution {
	public void reverseString(char[] s) {
		if (s.length<=1) return;
		char c=s[0];
		//int len=Math.floor(s.length/2);
		for (int i=0;i<Math.floor(s.length/2);i++) {
			c=s[i];
			s[i]=s[s.length-1-i];
			s[s.length-1-i]=c;
		}
	}
}
class Solution {
	public void reverseString(char[] s) {
		int len=s.length;
		if (len<=1) return;
		char c;
		for (int i=0;i<len/2;i++) {
			c=s[i];
			s[i]=s[len-1-i];
			s[len-1-i]=c;
		}
	}
}
public class TestOperateString{
	public static void main(String[] args) {
		
		char[] testStr={'h','e','l','l','o','b'};
		Solution mysolution=new Solution();
		mysolution.reverseString(testStr);

		System.out.println(Arrays.toString(testStr));
	}
}
```

### 2. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

```java
import java.util.*;

class Solution {
	public int reverse(int x) {
		if (x>-10 && x<10) return x;
		long result=0;
		while(x!=0){
			result=result*10+x%10;
			x=x/10;
		}
		//检测是否溢出，溢出则返回0
		return (int) result==result ? (int) result :0;
	}
}


public class TestOperateString{
	public static void main(String[] args) {

		//int[] testnums={1,2,3,4,5,6,7,8,9,10};
		//char[] testStr={'h','e','l','l','o','b'};

		int n=-136469;

		Solution mysolution=new Solution();
		//mysolution.reverseString(testStr);
		int result=mysolution.reverse(n);
		System.out.println(result);
		//System.out.println(Arrays.toString(testStr));
	}
}
```

注意检查是否溢出

### 3. 字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**提示：**你可以假定该字符串只包含小写字母。

使用两个for循环

每一次内循环如果遇到相对则退出内循环，一次内循环结束没有相等的则说明没有重复值

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    let flag;
	for (let i=0;i<s.length;i++){
        flag=0;
		for (let j=0;j<s.length;j++){
            if (i!=j) {
                if (s[i]==s[j]) {
                    flag=1;
                    break;
                }
            }
		}
        if (flag==0) {
            return i;
        }
	}
    return -1;
};

let str1 = "leetcode";
let str2 = "aabbcdefg";
let result=firstUniqChar(str2);
console.log(result);
```

比较indexOf和lastIndexOf的返回值

只要第一个和最后一个的索引一致，则说明不重复

```js
var firstUniqChar = function(s) {
	for (let i=0;i<s.length;i++){
        if (s.indexOf(s[i])===s.lastIndexOf(s[i])) {
            return i;
        }
	}
    return -1;
};
```

计数字母

构建一个空对象，循环字符串，记录每个字母出现的次数和第一次出现的位置

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    var alphas=new Array();
    var counts=new Array();
    var indexs=new Array();
	for (let i=0;i<s.length;i++){
        let index0=alphas.indexOf(s[i]);
        if (index0!==-1) {
            counts[index0]+=1;
        }else{
            counts.push(1);
            alphas.push(s[i]);
            indexs.push(i);
        }
	}
    for (let i=0;i<counts.length;i++){
        if (counts[i]===1) {
            return indexs[i];
        }
    }
    return -1;
};
let str1 = "leetcode";
let str2 = "aabbcdeafg";
let result=firstUniqChar(str2);
console.log(result);
```



### 4. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

使用数组计数

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length!==t.length) {
        return false;
    }
    var alphas1=new Array();
    var alphas2=new Array();
    var counts1=new Array();
    var counts2=new Array();
    for (let i=0;i<s.length;i++){
        let index1=alphas1.indexOf(s[i]);
        let index2=alphas2.indexOf(t[i]);
        if (index1!==-1) {
            counts1[index1]+=1;
        }else{
            counts1.push(1);
            alphas1.push(s[i]);
        }
        if (index2!==-1) {
            counts2[index2]+=1;
        }else{
            counts2.push(1);
            alphas2.push(t[i]);
        }
    }
    if (alphas1.length!==alphas2.length) {return false;}
    for (let i=0;i<alphas1.length;i++){
        if (counts1[i]!==counts2[alphas2.indexOf(alphas1[i])]) {
            return false;
        }
    }
    return true;

};

let str1 = "anaagram";
let str2 = "naggaram";
let result=isAnagram(str1,str2);
console.log(result);
```

使用对象计数

```js

```

调用内置方法

```

```

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

### 5. 验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s=s.toLowerCase();
    s=s.replace(/[^a-z0-9]/g,"")
    console.log(s);
    for (let i=0;i<s.length/2;i++){
        if (s[i]!==s[s.length-1-i]) {
            return false;
        }
    }
    return true;
};


let str1 = "A man, a plan, a canal: Panama";
let result=isPalindrome(str1);
console.log(result);

```

### 6. 字符串转换整数 (atoi)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

```js
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    s=s.trim();
    let patt=/[^0-9+-]/
    if (patt.test(s[0])) {
        return 0;
    }
    let nums=new Array();
    nums.push(s[0]);
    for (let i=1;i<s.length;i++){
        if (/\D/.test(s[i])) {
            //查找到非数字停止
            break;
        }else{
            nums.push(s[i]);
        }
    }

    let num=nums.join("");
    if (num==="+" || num==="-") {return 0;}
    num=parseInt(num);
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "+-12";
let result=myAtoi(str1);
console.log(result);

```

直接调用内置函数

```js
var myAtoi = function(s) {
    s=s.trim();
    let num=parseInt(s);
    if (isNaN(num)) {
        return 0;
    }
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "words and 987";
let result=myAtoi(str1);
console.log(result);
```

### 7. 实现 strStr()

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (haystack.length<needle.length) {return -1;}
    if (needle==="") {return 0;}
    if (haystack.length===needle.length && haystack===needle) {return 0;}
    if (haystack.length===needle.length && haystack!==needle) {return -1;}
    for (let i=0;i<haystack.length-needle.length+1;i++){
        if (haystack[i]===needle[0]) {
            let flag=true;
            for (let j=1;j<needle.length;j++){
                if (haystack[i+j]!==needle[j]){
                    flag=false;
                    break;
                }
            }
            if (flag) {
                return i;
            }

        }
    }
    return -1;
};


let str1 = "heffdddllo";
let str2 = "ell";
let result=strStr(str1,str2);
console.log(result);

```

调用内置方法

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle);
};
```

### 8 外观数列

给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

countAndSay(1) = "1"
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。

前五项如下：

```tex
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

```

要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

```javascript
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    if (n===1) { return ""+1;}
    let oldStr="1";
    let newStr="";
    for (let i=2;i<=n;i++){
        let count=1;  //计数
        let num=oldStr[0];
        let j=1;
        while(j<oldStr.length){
            if (num===oldStr[j]) {
                count+=1;
                j++;
            }else{
                newStr+=""+count+""+num;
                count=1;
                num=oldStr[j];
                j++;
            }
        }
        newStr+=""+count+""+num;
        oldStr=newStr;
        newStr="";
        console.log(oldStr);
    }
    return oldStr;
};

let str1 = 10;
let result=countAndSay(str1);
//console.log(typeof result);
console.log(result);

/*
1
11
21
1211
111221
312211
13112221
1113213211
31131211131221
13211311123113112211
*/
```

### 9 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length===1) {return strs[0];}
    let minLen=strs[0].length;
    for (let i=0;i<strs.length;i++){
        if (strs[i].length===0) {
            return "";
        }
        if (strs[i].length<minLen) {
            minLen=strs[i].length;
        }
    }
    let alphas=new Array("");
    for (let i=0;i<minLen;i++){
        for (let j=1;j<strs.length;j++){
            if (strs[j][i]!=strs[0][i]) {
                return alphas.join("");
            }
        }
        alphas.push(strs[0][i]);
    }
    return alphas.join("");
};


let str1 = ["flower","flow","flight"];
let result=longestCommonPrefix(str1);
//console.log(typeof result);
console.log(result);

```

利用数组的 Reduce 方法实现的最简洁代码

取第一个字符串为公共前缀
逐个对比，返回两两元素的公共前缀
将 2 中的公共前缀和下一个元素对比，得到新的公共前缀

```

```



## 链表

### 1. 删除链表中的节点

请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。

题目数据保证需要删除的节点 不是末尾节点 。

```

```

