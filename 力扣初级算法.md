# 初级算法

##  数组

### 1. 删除排序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```java
class Solution{
	public int removeDuplicates(int[] nums){
		int len=nums.length;
		if (len==0) return 0;
		if (len==1) return 1;
		int temp=nums[0];  //标志位
		int i=1;
		while (i<len){
			if (temp==nums[i]) {
				//因为是有序，所以相同就向前移动一位覆盖相同的一个
				for (int j=i; j<len-1; j++) {
					nums[j]=nums[j+1];
				}
				len--;  //长度减一
			}else{
				//不是重复的则把标志位后移
				temp=nums[i];
				i++;
			}
			
		}
		return len;
	}
}

public class TestArray1{
	
	public static void main(String[] args) {
		int[] testnums={0,0,1,1,1,2,2,3,3,4};
		Solution mysolution=new Solution();
		int newlen=mysolution.removeDuplicates(testnums);
		System.out.println(newlen);
		for (int i=0; i<newlen; i++) {
			if (i==newlen-1) {
				System.out.println(testnums[i]);
			}else{
				System.out.print(testnums[i]+" ,");
			}
		}
	}
}
```

待解决：实现的时间复杂度有点高，应该还可以减少移动次数，比如处理连续重复的情况.

### 2. 买卖股票的最佳时机 II

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票

```java
class Solution{
	public int maxProfit(int[] prices){
		int len=prices.length;
		if (len<=1) return 0;
		/* 分析可知需要小买大出收益最大，比较相邻的数值，以及连续增长的时候*/
		int sum=0;  //最大收益
		int flag=prices[0];  //标志位
		int i=1;
		while (i<len){
			if (flag>=prices[i]) {
				//当前比后一个比较的大时，属于亏损，,等于时没有意义。不交易
			}else{
				sum+=prices[i]-flag;  //后一个比前一个值大说明盈利，交易
			}
			flag=prices[i];  //设置标志位为当前值
			i++;
		}
		return sum;
	}
}

public class TestArray1{
	public static void main(String[] args) {
		int[] testprices={7,6,4,3,1};
		Solution mysolution=new Solution();
		int myMaxProfit=mysolution.maxProfit(testprices);
		System.out.println(myMaxProfit);
	}
}
```

可以不设置标志位减少内存消耗，可以直接比较,以及连续增加时的计算

使用动态规划解决

使用贪心算法解决

### 3. 旋转数组

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

暴力移动 (k%len)*len 次，测试会超时,此方法消耗过大

```java
public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大

		int flag=nums[len-1];  //最后一个元素
		for (int i=0;i<k;i++){
			for (int j=len-1; j>0; j--) {
				nums[j]=nums[j-1];
			}
			nums[0]=flag;
			flag=nums[len-1];
		}
	}
```

使用临时数组    借助辅助空间大小为k的数组

```java
class Solution{
	public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大
		
		int[] numsK=new int[k];  //辅助空间,用于保存后k个
		for (int i=0;i<k;i++) {
			numsK[i]=nums[len-1-i];
		}
		for (int i=len-1; i>=k; i--) {
			//前len-k个后移k位
			nums[i]=nums[i-k];
		}
		for (int i=k-1;i>=0;i--){
			//把保存的k个放在前面来
			nums[i]=numsK[k-1-i];
		}
	}
}
```

可以运行通过，但太耗内存，可以判断k与len-k的大小，然后辅助空间用于存储小的一个，虽然也耗内存

```java
import java.util.*;

class Solution{
	public void rotate(int[] nums,int k){
		int len=nums.length;
		if (len<=1 || k==0 || k%len==0) return;
		
		//计算k与len的关系,分析可知不管为多少都是移动k%len次
		k=k%len;  //此后len一定比k大
		
		int temp=nums[0];
		for (int i=0;i<k;i++) {
			//先把前k个与后k个换位置
			nums[i]=nums[len-k+i];
			nums[len-k+i]=temp;
			temp=nums[i+1];
		}
/*
		temp=nums[2*k-1];
		for (int i=0;i<len-k;i++) {
			nums[2*k-1+i]=nums[len-1-i];
			nums[len-1-i]=nums[len-1-i-k];
			nums[len-1-i-k]=temp;
			temp=nums[2*k+i];
		}
*/
	}
}

public class TestArray1{
	public static void main(String[] args) {
		int[] testnums={1,2,3,4,5,6,7,8,9,10};
		Solution mysolution=new Solution();
		int k=3;
		System.out.println(Arrays.toString(testnums));
		mysolution.rotate(testnums,k);
		System.out.println(Arrays.toString(testnums));
		int[] testnums2={1,2,3,4,5,6,7,8,9,10};
		k=7;
		mysolution.rotate(testnums2,k);
		System.out.println(Arrays.toString(testnums2));
	}
}
```

这个还存在问题

多次反转

环形旋转

### 4. 存在重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

暴力解法超时

```java
public boolean containsDuplicate(int[] nums){
		int len=nums.length;
		if (len<=1) return false;
		//从小到大排序
		for (int i=0;i<len-1;i++) {
			for (int j=i+1;j<len;j++){
				if (nums[i]==nums[j]) {
					return true;
				}
			}
		}
		return false;
		
	}
```

使用set

```java
public boolean containsDuplicate(int[] nums){
		int len=nums.length;
		if (len<=1) return false;
		
		//使用set
		Set<Integer> set=new HashSet<>();
		for (int n:nums){
			//当重复添加返回true
			if (!set.add(n)) {
				return true;
			}
		}
		return false;
	}
```

先排序，然后比较



### 5.  只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

使用异或运算，将所有值进行异或
异或运算，相异为真，相同为假，所以 a^a = 0 ;0^a = a，a^b=0
因为异或运算 满足交换律 a^b^a = a^a^b = b 所以数组经过异或运算，单独的值就剩下了

```java
	public int singleNumber(int[] nums){
		int len=nums.length;

		if (len==1) return nums[0];
		int result=0;
		for (Integer n:nums) {
			result^=n;
		}
		return result;
	}
```

```java
public int singleNumber(int[] nums){
		for (int i=1;i<nums.length;i++) {
			nums[0]^=nums[i];
		}
		return nums[0];
	}
```

使用set,重复添加时移除，最后只剩下一个

```java
	public int singleNumber(int[] nums){
		int len=nums.length;

		int result=nums[0];
		if (len<=1) return nums[0];
		
		//使用set
		Set<Integer> set=new HashSet<>();
		for (int n:nums){
			if (!set.add(n)) {
				set.remove(n);
			}
		}
		return (int) set.toArray()[0];
	}
```

两个方法速度都一般

### 6. 两个数组的交集 II

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？



```

```



## 字符串

### 1. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

对称交换

```java
class Solution {
	public void reverseString(char[] s) {
		if (s.length<=1) return;
		char c=s[0];
		//int len=Math.floor(s.length/2);
		for (int i=0;i<Math.floor(s.length/2);i++) {
			c=s[i];
			s[i]=s[s.length-1-i];
			s[s.length-1-i]=c;
		}
	}
}
class Solution {
	public void reverseString(char[] s) {
		int len=s.length;
		if (len<=1) return;
		char c;
		for (int i=0;i<len/2;i++) {
			c=s[i];
			s[i]=s[len-1-i];
			s[len-1-i]=c;
		}
	}
}
public class TestOperateString{
	public static void main(String[] args) {
		
		char[] testStr={'h','e','l','l','o','b'};
		Solution mysolution=new Solution();
		mysolution.reverseString(testStr);

		System.out.println(Arrays.toString(testStr));
	}
}
```

### 2. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

```java
import java.util.*;

class Solution {
	public int reverse(int x) {
		if (x>-10 && x<10) return x;
		long result=0;
		while(x!=0){
			result=result*10+x%10;
			x=x/10;
		}
		//检测是否溢出，溢出则返回0
		return (int) result==result ? (int) result :0;
	}
}


public class TestOperateString{
	public static void main(String[] args) {

		//int[] testnums={1,2,3,4,5,6,7,8,9,10};
		//char[] testStr={'h','e','l','l','o','b'};

		int n=-136469;

		Solution mysolution=new Solution();
		//mysolution.reverseString(testStr);
		int result=mysolution.reverse(n);
		System.out.println(result);
		//System.out.println(Arrays.toString(testStr));
	}
}
```

注意检查是否溢出

### 3. 字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**提示：**你可以假定该字符串只包含小写字母。

#### 使用两个for循环

每一次内循环如果遇到相对则退出内循环，一次内循环结束没有相等的则说明没有重复值

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    let flag;
	for (let i=0;i<s.length;i++){
        flag=0;
		for (let j=0;j<s.length;j++){
            if (i!=j) {
                if (s[i]==s[j]) {
                    flag=1;
                    break;
                }
            }
		}
        if (flag==0) {
            return i;
        }
	}
    return -1;
};

let str1 = "leetcode";
let str2 = "aabbcdefg";
let result=firstUniqChar(str2);
console.log(result);
```

#### 比较indexOf和lastIndexOf的返回值

只要第一个和最后一个的索引一致，则说明不重复

```js
var firstUniqChar = function(s) {
	for (let i=0;i<s.length;i++){
        if (s.indexOf(s[i])===s.lastIndexOf(s[i])) {
            return i;
        }
	}
    return -1;
};
```

#### 计数字母

构建一个空对象，循环字符串，记录每个字母出现的次数和第一次出现的位置

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    var alphas=new Array();
    var counts=new Array();
    var indexs=new Array();
	for (let i=0;i<s.length;i++){
        let index0=alphas.indexOf(s[i]);
        if (index0!==-1) {
            counts[index0]+=1;
        }else{
            counts.push(1);
            alphas.push(s[i]);
            indexs.push(i);
        }
	}
    for (let i=0;i<counts.length;i++){
        if (counts[i]===1) {
            return indexs[i];
        }
    }
    return -1;
};
let str1 = "leetcode";
let str2 = "aabbcdeafg";
let result=firstUniqChar(str2);
console.log(result);
```



### 4. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

使用数组计数

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length!==t.length) {
        return false;
    }
    var alphas1=new Array();
    var alphas2=new Array();
    var counts1=new Array();
    var counts2=new Array();
    for (let i=0;i<s.length;i++){
        let index1=alphas1.indexOf(s[i]);
        let index2=alphas2.indexOf(t[i]);
        if (index1!==-1) {
            counts1[index1]+=1;
        }else{
            counts1.push(1);
            alphas1.push(s[i]);
        }
        if (index2!==-1) {
            counts2[index2]+=1;
        }else{
            counts2.push(1);
            alphas2.push(t[i]);
        }
    }
    if (alphas1.length!==alphas2.length) {return false;}
    for (let i=0;i<alphas1.length;i++){
        if (counts1[i]!==counts2[alphas2.indexOf(alphas1[i])]) {
            return false;
        }
    }
    return true;

};

let str1 = "anaagram";
let str2 = "naggaram";
let result=isAnagram(str1,str2);
console.log(result);
```

使用对象计数

```js

```

调用内置方法

```

```

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

### 5. 验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```

```

