

## PDD

------

### 多多的数字组合

多多君最近在研究某种数字组合：
定义为：每个数字的十进制表示中(0~9)，每个数位**各不相同**且各个数位之和等于N。
满足条件的数字可能很多，找到其中的最小值即可。

数据范围：1<= n <= 1000
进阶：空间复杂度 O(1), 时间复杂度O(n)

分析：

1，2，3，4，5，6，7，8，9最多和为45，所以大于45输出-1，小于10直接输出，10到45一定有答案。
**右边的数越大，结果越小**。因为不同位数的话，位数越多，结果越大（1234>19)。同等位数，大的数要先选来确保最后选的数足够小（678>489)。

```js
function solution(n){
	if (n > 45) {
		return -1;
	}
	if (n < 10) {
		return n;
	}
	let ans = 0;
	const stack = [];
	for (let i = 9; i >= 1; i--){
		if (n > 0 && n >= i) {
			n -= i;
			stack.push(i);
		}
	}
	while (stack.length){
		ans = ans*10 + stack.pop();
	}
	return ans;
}

let N = parseInt(readline());
console.log(solution(N));

//let result = solution(12);
//console.log(result);
```

---

### 多多的字符变换

多多君最近在研究字符串之间的变换，可以对字符串进行若干次变换操作:

1. 交换任意两个相邻的字符，代价为0。
2. 将任意一个字符a修改成字符b，代价为 |a - b|（绝对值）。

现在有两个长度相同的字符串X和Y，多多君想知道，如果要将X和Y变成两个一样的字符串，需要的最少的代价之和是多少。

##### **输入描述:**

```
共三行，第一行，一个整数N，表示字符串的长度。
（1 <= N <= 2,000）
接下来两行，每行分别是一个字符串，表示字符串X和Y。
（字符串中仅包含小写字母）
```

##### **输出描述:**

```
共一行，一个整数，表示将X和Y变换成一样的字符串需要的最小的总代价。
```

因为交换字符没有代价，所以将两个字符串分别排序然后逐位比较计算代价即可

```js
function solution(str1, str2, n){
	str1 = str1.split("").sort();
	str2 = str2.split("").sort();
	let ans = 0;
	for (let i = 0; i < n; i++){
		if (str1[i] !== str2[i]) {
			ans += Math.abs(str1[i].charCodeAt() - str2[i].charCodeAt());
		}
	}
	return ans;
}

let N = parseInt(readline());
let X = readline();
let Y = readline();
console.log(solution(X, Y, N));

// console.log(solution("abca", "abcd", 4));
```

---

### 多多的求和计算

多多路上从左到右有N棵树（编号1～N），其中第i个颗树有和谐值Ai。

多多鸡认为，如果一段连续的树，它们的和谐值之和可以被M整除，那么这个区间整体看起来就是和谐的。
现在多多鸡想请你帮忙计算一下，满足和谐条件的区间的数量。

##### **输入描述:**

```
第一行，有2个整数N和M，表示树的数量以及计算和谐值的参数。
（ 1 <= N <= 100,000, 1 <= M <= 100  ）
第二行，有N个整数Ai, 分别表示第i个颗树的和谐值。
（ 0 <= Ai <= 1,000,000,000 ）
```

##### **输出描述:**

```
共1行，每行1个整数，表示满足整体是和谐的区间的数量。
```

##### **输入例子1:**

```
5 2
1 2 3 4 5
```

##### **输出例子1:**

```
6
```

计算数组的前缀和，并以前缀和与m的余数remain为key，余数为remain的前缀和个数为value构建hash表。**由于相同余数的前缀区间任选两个所构成的中间区间一定和谐**（因为大的那个前缀区间求和减去小的前缀区间求和，刚好把那个多出来的余数减掉了，因此中间区间求和一定能被m整除），所以对所有key的value求取2的组合数，把它们都加起来就能够得到所有和谐区间的总数。

而C2n=(n-1)*n/2恰好就是0~n-1的高斯求和公式，因此在计算value值的时候我们就可以顺便通过累加把总数给求了，从而省掉之后遍历hash表所有key计算组合数的时间。

```js
function solution(nums, n, m){
	let ans = 0;
	let sum = 0;
	const record = new Map();
	//遍历数组nums之前，record提前放入 0:1 键值对，代表求第 0 项前缀和之前，前缀和 mod K 等于 0 这种情况出现了 1 次。
	record.set(0, 1);
	for (let item of nums){
		sum += item;  //前缀和
		let model = sum % m ;  //取余数
		record.set(model, record.has(model) ? record.get(model) + 1 : 1);
	}
	for (let val of record.values()){
		ans += val*(val - 1) /2;
	}
	return ans;
}

let line1 = readline().split(" ")
let N = parseInt(line1[0]);
let M = parseInt(line1[1]);
let nums = readline().split(" ").map((item) => parseInt(item));
console.log(solution(nums, N, M));

// let N = 5, M = 2;
// let nums = [1, 2, 3, 4, 5];
// let result = solution(nums, N, M);
// console.log(result);
```

---

### 多多的骰子组合

多多君拼团购买了N个骰子，为了方便后面进行活动，多多君需要将这些骰子进行分类。

两个骰子为同类的定义是：

```
将其中一个骰子通过若干次上下、左右或前后翻转后，其与另一个骰子对应的``6``面数字均相等。
```

现在多多君想知道不同种类的骰子的数量分别有多少。

##### **输入描述:**

```
第一行1个整数N，表示骰子的数量。（1 <= N <= 1,000）

接下来N行，每行6个数字（1～6，且各不相同）
其中第i行表示第i个骰子当前上、下、左、右、前、后这6面的数字。
```

##### **输出描述:**

```
共2行:
第一行1个整数M，表示不同种类的骰子的个数
第二行M个整数，由大到小排序，表示每个种类的骰子的数量
```

##### **例子说明1:**

```
第二个骰子相当于是第一个骰子从左向右旋转了一面得到，属于同类。
```

##### **输入例子2:**

```
3
1 2 3 4 5 6
1 2 6 5 3 4
1 2 3 4 6 5
```

##### **输出例子2:**

```
2
2 1
```

```
第三个骰子无法通过任何旋转变换成第一个或第二个骰子。
```

我们取每个骰子：以1作为上面，然后得到侧边四面的4个数字的顺序。

如果任意两个骰子的这个侧面4个数字顺序是一样的，那么这两个骰子就是同类。

此外结合如下规律：  

  \1. 骰子6面可以分为3对，每对两面，比如 12 、34 、56  

  \2. 骰子按对顺序调换不改变骰子顺序，比如 123456 与 561234 是同一类  

  \3. 举例：骰子为 123456， 1位上面侧边四面为 3564 

  \4. 举例：骰子为 345612， 1位上面侧边四面为 3564  

  \5. 举例：骰子为 213456， 1位上面侧边四面为 6453

```js
function solution(nums){
	let ans = 0;
	const record = new Map();
	nums.forEach((item) => {
		let val = 0;
		for (let i = 0; i < 6; i++){
			if (item[i] === 1) {
				if (i % 2 === 0) {
					val = item[( i+ 2) % 6] * 1000 + item[(i + 4) % 6] * 100 + item[(i + 3) % 6] * 10 + item[(i + 5) % 6];
				}else{
					val = item[( i+ 4) % 6] * 1000 + item[(i + 2) % 6] * 100 + item[(i + 3) % 6] * 10 + item[(i + 1) % 6];
				}
				break;
			}
		}
		for (let i = 0, temp = val; i < 3; ++i){
			temp = Math.floor(temp / 10) + (temp % 10 * 1000);
			val = Math.min(val, temp);
		}
		record.set(val, record.has(val) ? record.get(val) + 1 : 1);
	});
	let output2 = [...record.values()];
	output2.sort((a, b) => b - a);
	console.log(record.size);
	console.log(output2.join(" "));
}

let N = parseInt(readline());
let nums = [];
let i = 0;
while (i < N){
	let line = readline().split(" ").map((item) => parseInt(item));
	nums.push(line);
	i++;
}
solution(nums);

// let nums = [
// [1, 2, 3, 4, 5, 6],
// [1, 2, 6, 5, 3, 4],
// [1, 2, 3, 4, 6, 5]];

// solution(nums);
```

---

