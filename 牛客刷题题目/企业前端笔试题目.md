

## PDD

------

### 多多的数字组合

多多君最近在研究某种数字组合：
定义为：每个数字的十进制表示中(0~9)，每个数位**各不相同**且各个数位之和等于N。
满足条件的数字可能很多，找到其中的最小值即可。

数据范围：1<= n <= 1000
进阶：空间复杂度 O(1), 时间复杂度O(n)

分析：

1，2，3，4，5，6，7，8，9最多和为45，所以大于45输出-1，小于10直接输出，10到45一定有答案。
**右边的数越大，结果越小**。因为不同位数的话，位数越多，结果越大（1234>19)。同等位数，大的数要先选来确保最后选的数足够小（678>489)。

```js
function solution(n){
	if (n > 45) {
		return -1;
	}
	if (n < 10) {
		return n;
	}
	let ans = 0;
	const stack = [];
	for (let i = 9; i >= 1; i--){
		if (n > 0 && n >= i) {
			n -= i;
			stack.push(i);
		}
	}
	while (stack.length){
		ans = ans*10 + stack.pop();
	}
	return ans;
}

let N = parseInt(readline());
console.log(solution(N));

//let result = solution(12);
//console.log(result);
```

---

### 多多的字符变换

多多君最近在研究字符串之间的变换，可以对字符串进行若干次变换操作:

1. 交换任意两个相邻的字符，代价为0。
2. 将任意一个字符a修改成字符b，代价为 |a - b|（绝对值）。

现在有两个长度相同的字符串X和Y，多多君想知道，如果要将X和Y变成两个一样的字符串，需要的最少的代价之和是多少。

##### **输入描述:**

```
共三行，第一行，一个整数N，表示字符串的长度。
（1 <= N <= 2,000）
接下来两行，每行分别是一个字符串，表示字符串X和Y。
（字符串中仅包含小写字母）
```

##### **输出描述:**

```
共一行，一个整数，表示将X和Y变换成一样的字符串需要的最小的总代价。
```

因为交换字符没有代价，所以将两个字符串分别排序然后逐位比较计算代价即可

```js
function solution(str1, str2, n){
	str1 = str1.split("").sort();
	str2 = str2.split("").sort();
	let ans = 0;
	for (let i = 0; i < n; i++){
		if (str1[i] !== str2[i]) {
			ans += Math.abs(str1[i].charCodeAt() - str2[i].charCodeAt());
		}
	}
	return ans;
}

let N = parseInt(readline());
let X = readline();
let Y = readline();
console.log(solution(X, Y, N));

// console.log(solution("abca", "abcd", 4));
```

---

### 多多的求和计算

多多路上从左到右有N棵树（编号1～N），其中第i个颗树有和谐值Ai。

多多鸡认为，如果一段连续的树，它们的和谐值之和可以被M整除，那么这个区间整体看起来就是和谐的。
现在多多鸡想请你帮忙计算一下，满足和谐条件的区间的数量。

##### **输入描述:**

```
第一行，有2个整数N和M，表示树的数量以及计算和谐值的参数。
（ 1 <= N <= 100,000, 1 <= M <= 100  ）
第二行，有N个整数Ai, 分别表示第i个颗树的和谐值。
（ 0 <= Ai <= 1,000,000,000 ）
```

##### **输出描述:**

```
共1行，每行1个整数，表示满足整体是和谐的区间的数量。
```

##### **输入例子1:**

```
5 2
1 2 3 4 5
```

##### **输出例子1:**

```
6
```

计算数组的前缀和，并以前缀和与m的余数remain为key，余数为remain的前缀和个数为value构建hash表。**由于相同余数的前缀区间任选两个所构成的中间区间一定和谐**（因为大的那个前缀区间求和减去小的前缀区间求和，刚好把那个多出来的余数减掉了，因此中间区间求和一定能被m整除），所以对所有key的value求取2的组合数，把它们都加起来就能够得到所有和谐区间的总数。

而C2n=(n-1)*n/2恰好就是0~n-1的高斯求和公式，因此在计算value值的时候我们就可以顺便通过累加把总数给求了，从而省掉之后遍历hash表所有key计算组合数的时间。

```js
function solution(nums, n, m){
	let ans = 0;
	let sum = 0;
	const record = new Map();
	//遍历数组nums之前，record提前放入 0:1 键值对，代表求第 0 项前缀和之前，前缀和 mod K 等于 0 这种情况出现了 1 次。
	record.set(0, 1);
	for (let item of nums){
		sum += item;  //前缀和
		let model = sum % m ;  //取余数
		record.set(model, record.has(model) ? record.get(model) + 1 : 1);
	}
	for (let val of record.values()){
		ans += val*(val - 1) /2;
	}
	return ans;
}

let line1 = readline().split(" ")
let N = parseInt(line1[0]);
let M = parseInt(line1[1]);
let nums = readline().split(" ").map((item) => parseInt(item));
console.log(solution(nums, N, M));

// let N = 5, M = 2;
// let nums = [1, 2, 3, 4, 5];
// let result = solution(nums, N, M);
// console.log(result);
```

---

### 多多的骰子组合

多多君拼团购买了N个骰子，为了方便后面进行活动，多多君需要将这些骰子进行分类。

两个骰子为同类的定义是：

```
将其中一个骰子通过若干次上下、左右或前后翻转后，其与另一个骰子对应的``6``面数字均相等。
```

现在多多君想知道不同种类的骰子的数量分别有多少。

##### **输入描述:**

```
第一行1个整数N，表示骰子的数量。（1 <= N <= 1,000）

接下来N行，每行6个数字（1～6，且各不相同）
其中第i行表示第i个骰子当前上、下、左、右、前、后这6面的数字。
```

##### **输出描述:**

```
共2行:
第一行1个整数M，表示不同种类的骰子的个数
第二行M个整数，由大到小排序，表示每个种类的骰子的数量
```

##### **例子说明1:**

```
第二个骰子相当于是第一个骰子从左向右旋转了一面得到，属于同类。
```

##### **输入例子2:**

```
3
1 2 3 4 5 6
1 2 6 5 3 4
1 2 3 4 6 5
```

##### **输出例子2:**

```
2
2 1
```

```
第三个骰子无法通过任何旋转变换成第一个或第二个骰子。
```

我们取每个骰子：以1作为上面，然后得到侧边四面的4个数字的顺序。

如果任意两个骰子的这个侧面4个数字顺序是一样的，那么这两个骰子就是同类。

此外结合如下规律：  

  \1. 骰子6面可以分为3对，每对两面，比如 12 、34 、56  

  \2. 骰子按对顺序调换不改变骰子顺序，比如 123456 与 561234 是同一类  

  \3. 举例：骰子为 123456， 1位上面侧边四面为 3564 

  \4. 举例：骰子为 345612， 1位上面侧边四面为 3564  

  \5. 举例：骰子为 213456， 1位上面侧边四面为 6453

```js
function solution(nums){
	let ans = 0;
	const record = new Map();
	nums.forEach((item) => {
		let val = 0;
		for (let i = 0; i < 6; i++){
			if (item[i] === 1) {
				if (i % 2 === 0) {
					val = item[( i+ 2) % 6] * 1000 + item[(i + 4) % 6] * 100 + item[(i + 3) % 6] * 10 + item[(i + 5) % 6];
				}else{
					val = item[( i+ 4) % 6] * 1000 + item[(i + 2) % 6] * 100 + item[(i + 3) % 6] * 10 + item[(i + 1) % 6];
				}
				break;
			}
		}
		for (let i = 0, temp = val; i < 3; ++i){
			temp = Math.floor(temp / 10) + (temp % 10 * 1000);
			val = Math.min(val, temp);
		}
		record.set(val, record.has(val) ? record.get(val) + 1 : 1);
	});
	let output2 = [...record.values()];
	output2.sort((a, b) => b - a);
	console.log(record.size);
	console.log(output2.join(" "));
}

let N = parseInt(readline());
let nums = [];
let i = 0;
while (i < N){
	let line = readline().split(" ").map((item) => parseInt(item));
	nums.push(line);
	i++;
}
solution(nums);

// let nums = [
// [1, 2, 3, 4, 5, 6],
// [1, 2, 6, 5, 3, 4],
// [1, 2, 3, 4, 6, 5]];

// solution(nums);
```

---

### 多多的魔术盒子

多多鸡有N个魔术盒子（编号1～N），其中编号为i的盒子里有i个球。
多多鸡让皮皮虾每次选择一个数字X（1 <= X <= N），多多鸡就会**把球数量大于等于X个的盒子里的球减少X个**。
通过观察，皮皮虾已经掌握了其中的奥秘，并且发现只要通过一定的操作顺序，可以用最少的次数将所有盒子里的球变没。

那么请问聪明的你，是否已经知道了应该如何操作呢？

##### **输入描述:**

```
第一行，有1个整数T，表示测试用例的组数。
（1 <= T <= 100）
接下来T行，每行1个整数N，表示有N个魔术盒子。
（1 <= N <= 1,000,000,000）
```

##### **输出描述:**

```
共T行，每行1个整数，表示要将所有盒子的球变没，最少需要进行多少次操作。
```

##### **输入例子1:**

```
3
1
2
5
```

##### **输出例子1:**

```
1
2
3
```

要用最少的次数把所有盒子减到0，第一次必然是减少中间盒子的球数

比如 1，2，3，4，5， 第一次减3 得到1，2，0，1，2 ,这时我们可以看到左右两边相等的，分冶求解

```js
function solution(nums, n){
	const dfs = (num) => {
		if (num < 3) {
			return num;
		}else{
			return 1 + dfs(Math.floor(num / 2));
		}
	}

	for (let i = 0; i < n; i++){
		console.log(dfs(nums[i]));
	}
}

let N = parseInt(readline());
let nums = [];
let i = 0;
while (i < N){
	let line = parseInt(readline());
	nums.push(line);
	i++;
}
solution(nums, N);

// let nums = [1, 2, 5];
// solution(nums, 3);
```

---

### 多多的排列函数

数列 {An} 为N的一种排列。

例如N=3，可能的排列共6种：

```
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
```

定义函数F:

![img](https://www.nowcoder.com/equation?tex=F(x)%20%3D%20%5Cleft%5C%7B%0A%5Cbegin%7Baligned%7D%0A%26%20A_1%20%26%20(x%20%3D%201)%20%5C%5C%0A%26%20%7C%20F(x%20-%201)%20-%20A_x%20%7C%20%26%20(x%20%3E%201)%20%5C%5C%0A%5Cend%7Baligned%7D%0A%5Cright.)

其中|X|表示X的绝对值。

现在多多鸡想知道，在所有可能的数列 {An} 中，F(N)的最小值和最大值分别是多少。



##### **输入描述:**

```
第一行输入1个整数T，表示测试用例的组数。
( 1 <= T <= 10 )
第二行开始，共T行，每行包含1个整数N，表示数列 {An} 的元素个数。
( 1 <= N <= 100,000 )
```

##### **输出描述:**

```
共T行，每行2个整数，分别表示F(N)最小值和最大值
```

##### **输入例子1:**

```
2
2
3
```

##### **输出例子1:**

```
1 1
0 2
```

##### **例子说明1:**

```
对于N=3：
- 当{An}为3，2，1时可以得到F(N)的最小值0
- 当{An}为2，1，3时可以得到F(N)的最大值2
```

```
F(1)=A1
F(2) = |F(1)-A2| =|A1-A2|
F(3) = |F(2)-A3| =||A1-A2|-A3|
```

每四个数 例如 5，6，7，8，我们把它们两两一组 |||8-6|-7|-5|=0，最小值是0；猜测最小值的变化也是4个一组 

  看到min只有2种取值。0，1，最大值自然就是N-getmin(N-1)

```js
function solution(nums, n){
	const getMinFn = (num) => {
		num %= 4;
		if (num === 0 || num ===3) {
			return 0;
		}else{
			return 1;
		}
	}
	const getMaxFn = (num) => {
		return num - getMinFn(num - 1);
	}

	for (let i = 0; i < n; i++){
		console.log(getMinFn(nums[i]) + " " + getMaxFn(nums[i]));
	}
}

let N = parseInt(readline());
let nums = [];
let i = 0;
while (i < N){
	let line = parseInt(readline());
	nums.push(line);
	i++;
}
solution(nums, N);

// let nums = [2, 3, 5];
// solution(nums, 3);
```

---

### 多多的电子字典

多多鸡打算造一本自己的电子字典，里面的所有单词都只由a和b组成。
每个单词的组成里a的数量不能超过N个且b的数量不能超过M个。
多多鸡的幸运数字是K，它打算把所有满足条件的单词里的字典序第K小的单词找出来，作为字典的封面。

##### **输入描述:**

```
共一行，三个整数N, M, K。(0 < N, M < 50, 0 < K < 1,000,000,000,000,000)
```

##### **输出描述:**

```
共一行，为字典序第K小的单词。
```

##### **输入例子1:**

```
2 1 4
```

##### **输出例子1:**

```
ab
```

##### **例子说明1:**

```
满足条件的单词里，按照字典序从小到大排列的结果是
a
aa
aab
ab
aba
b
ba
baa
```

```

dp[n][m]表示n个a，m个b的单词数量
dp[n][m] = 1 + dp[n-1][m] + 1 + dp[n][m-1]
根据K倒推，是前半部分，还是后半部分，来确定第一个字母是 a，还是b
```

```
function solution(n, m, k){
	const dp = new Array(n);
	for (let i = 0; i < n; i++){
		dp[i]=new Array(m);
		dp[i][0]= i.toString();
	}
	for (let i = 0; i < m; i++){
		dp[0][i] = i.toString();
	}
	for (let i = 1; i <=n; i++){
		for (let j = 1; j <= m; j++){
			dp[i][j] = 1 + dp[i - 1][j] + 1 + dp[i][ j - 1];
		}
	}
	while (k > 0){
		if (n > 0 && m > 0) {
			if (dp[n - 1][m]) {}
		}
	}
}

// let line1 = readline().split(" ");
// let N = parseInt(line1[0]);
// let M = parseInt(line1[1]);
// let K = parseInt(line1[2]);

// solution(N, M, K);

solution(2, 1, 4);
```

---

### 骰子期望

```
扔n个骰子，第i个骰子有可能投掷出Xi种等概率的不同的结果，数字从1到Xi。所有骰子的结果的最大值将作为最终结果。求最终结果的期望。
```

##### **输入描述:**

```
第一行一个整数n，表示有n个骰子。（1 <= n <= 50）
第二行n个整数，表示每个骰子的结果数Xi。(2 <= Xi <= 50)
```

##### **输出描述:**

```
输出最终结果的期望，保留两位小数。
```

##### **输入例子1:**

```
2
2 2
```

##### **输出例子1:**

```
1.75
```

对于最终结果k，只要n个骰子中有一个掷出了k，其余的点数均小于等于k，那最终结果就是k。 

  A.计所有骰子的点数都不超过k的概率为P(x<=k) 

  B.计所有骰子的点数都小于k的概率为P(x<=k-1) 

  很明显，事件A是包含事件B的，最终结果为k（即事件A-B）的概率为P(x=k)=P(x<=k)-P(x<=k-1)。而对于一组骰子X=[X1,X2,...,Xn]，最终结果的可能取值就是[2,max(X)]

```js
function solution(nums, n){
	//计算最大的点数
	let maxPoint = 0;
	for (let i = 0; i < n; i++){
		maxPoint = Math.max(maxPoint, nums[i]);
	}
	let preE = 0;
	let ans = 0;
	for (let k = 1; k <= maxPoint; k++){
		let curE = 1;
		//计算每个骰子点数不超过k的概率，注意有些骰子掷不到点数k
		for (let i = 0; i < n; i++){
			curE *= Math.min(k, nums[i]) / nums[i];
		}
		ans += (curE - preE) * k;
		preE = curE;
	}
	console.log(ans.toFixed(2));
}

let N = parseInt(readline());
let line2 = readline().split(" ");
let nums = [];
let i = 0;
while (i < N){
	nums.push(parseInt(line2[i]));
	i++;
}
solution(nums, N);

//solution([2, 2], 2);
```

---

### 二维表第k大数

在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下

```
n = 3, m = 3
1   2   3
2   4   6
3   6   9
```

给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。

例如上面的例子里，

从大到小为(9, 6, 6, 4, 3, 3, 2, 2, 1)

```
k = 1, v = 9
k = 2, v = 6
k = 3, v = 6
...
k = 8, v = 2
k = 9, v = 1
```

##### **输入描述:**

```
只有一行是3个数n, m, k 表示场地的宽高和需要查询的k。使用空格隔开。
```

##### **输出描述:**

```
给出第k大的数的值。
```

##### **输入例子1:**

```
3 3 4
```

##### **输出例子1:**

```
4
```

二分查找

```js
function solution(n, m, k){
	let left = 0, right = m * n;
	k = m * n - k + 1;
	while(left <= right){
		let mid = (left + right) >> 1;
		// 假定以mid作为最大数的所在行curRow; 由矩阵的特点可知：
		// curRow的上一行所有的数都将小于mid，缩小查找范围
		let curRow = mid / m;
		// 同理，获取所在列curCol
		let curCol = mid / n;
		let cnt = curRow * m + curCol * (n - curRow);
		// 剩下右下角一个小矩形
		for (let i = curRow + 1; i <= n; i++){
			for (let j = curCol + 1; j <= m && (i * j <= mid); j++){
				cnt++;
			}
		}
		if (cnt < k) {
			left = mid + 1;
		}else{
			right = mid - 1;
		}
	}
	console.log(left);
}

solution(3,3,4);
```

---

