----

# HTML/CSS部分

---

## 1.1 请问HTML5有哪些新特性？

首先，HTML 是一种标记语言，全称超文本标记语言，HTML5是第五个版本。对比传统HTML（HTML4、XHTML 各版本），有以下新特性：

1. **文档的类型声明不同**

HTML5的文档声明相比传统HTML来说更为简便，有利于程序员快速阅读和开发。具体写法：<!DOCTYPE html>

  **2. 新增语义化、结构化标签**

传统HTML没有语义化、结构化标签，不方便阅读，不清楚哪里是网页头部、尾部。HTML5新增的语义化、结构化标签主要有：

| <header>     | 网页或节的页眉/头部                |
| ------------ | ---------------------------------- |
| <footer>     | 网页或节的页脚/尾部                |
| <nav>        | 导航栏（一般集中放一些页面链接）   |
| <aside>      | 侧边栏                             |
| <article>    | 网页中一段独立的“文章”，可独立阅读 |
| <section>    | 节，有主题的内容组（一般含有标题） |
| <figcaption> | 图片标题                           |
| <figure>     | 图片与图片标题的组合               |
| <main>       | 主内容                             |
| <time>       | 时间                               |
| <video>      | 视频                               |
| <datalist>   | 选项列表                           |
| <summary>    | 包含 details 元素的标题            |

 **3. 增强型表单，**以便更好地控制与验证input

新增的input类型：color、date、datetime、datetime-local、email、month、number、range、search、tel、time、url、week

新增表单属性（输入限制）：placehoder、required、pattern、autofocus、multiple、step、min/max、height/wdith

  **4. 图像标签**

新增<canvas>、<svg>标签用于在网页绘制图形

  **5. 多媒体标签**

新增<audio>标签，以供引入音频

  **6. 新增的一些功能性API**

WebStorage本地存储，HTML5新增了两种客户端本地存储数据方法：

- localStorage：长期有效的数据存储，
- sessionStorage：只针对当前会话的数据存储。

地理定位，可使用getCurrentPosition()函数直接获取用户位置

WebSocket协议，能从客户端使用简单的语法推动消息到服务器，为客户端与服务端之间提供了一种全双工通信机制

requestAnimationFrame请求动画关键帧，把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般频率为每秒60帧

Drag 和 Drop拖放，抓取对象以后拖到另一个位置

---

### **1.什么是<!DOCTYPE>声明？**

对标记语言的文档类型声明，告知浏览器该页面使用的是哪个 HTML 版本，浏览器的解析器用什么文档标准解析页面文档，必须在 HTML 文档的第一行，且位于 <html> 标签之前，但不属于HTML标签

在 HTML5 中只有一种：<!DOCTYPE html>，HTML 4.01 中有三种模式：分别是：Strict、Transitional 和 Frameset

---

###  **2. 什么是语义化标签？**

能传达标签所包含内容类型的信息，开发者能直观地分辨标签和属性的用途

常见语义化标签：<hn>：h1~h6，分级标题；<header>：头部；<nav>：导航栏；<main>：主要内容；<footer>：尾部

常见非语义化标签：<div>、<span>

语义化标签的一些**优点**：

代码结构清晰，即使没有css的情况下，也能够呈现出清晰的内容结构

有利于SEO，爬虫依赖**标签**来确定关键字权重，可以和搜索引擎建立良好的沟通，帮助抓取更多的有效信息

提升用户体验，例如title、alt属性可以解释名称、图片信息

代码可读性强，便于团队开发和维护，让其他开发人员能快速理解HTML结构，减少差异化。

便于其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，网页渲染效率高

----

###   **3.** **cookie、localStorage、sessionStorage区别？**

cookie是服务器发给客户端的一种特殊认证信息，通常以文本的方式保存在客户端，始终在同源的http请求中携带（即使不需要），以供服务器验证当前浏览器用户身份，常见应用场景：验证用户身份、保存上次登录信息、统计浏览次数

sessionStorage和localStorage仅用于本地保存，不会自动把数据发给服务器

|                | 有期时间                                           | 作用域                                                       | 存储大小                           | 存储位置 |
| -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | -------- |
| cookie         | 在过期时间前一直有效（即使浏览窗口器关闭）         | domain本身以及domain下的所有子域名（跨域请求的 cookie在fetch时需要设置 withCredentials） | 不能超过4k                         | 浏览器端 |
| localStorage   | 长期存储，浏览器窗口关闭数据不丢失（除非主动删除） | 所有同源窗口共享                                             | 虽有存储大小限制，但可达到5M或更大 |          |
| sessionStorage | 临时存储，当前浏览器窗口关闭后自动删除             | 不同浏览器窗口不共享                                         |                                    |          |

----

### **4.** **WebSocket协议及实现原理？**

HTTP协议有一个局限：通信只能由客户端发起，服务器端不能实时发送最新数据给客户端（具有被动性）

数据交互有两种模式：Push（推模式）、Pull（拉模式）

- Push：客户端与服务端建立好**网络长连接**，服务器有相关数据，直接通过长连接通道推送到客户端

- Pull：客户端主动向服务端**发出请求**，拉取相关数据


那怎么获取最新数据呢？ 传统有两种方式：轮询、长轮询

- 轮询：开启一个定时器，每隔一段时间调用Ajax请求一次数据


- 长轮询：本质也是轮询，不过是阻塞型（一直打电话，没收到就不挂电话），客户端发起连接后，如果没消息，就一直不返回Response给客户端，直到有消 息才返回或超时。基于事件的触发，一个事件接一个事件。


而**WebSocket协议只需要发送一次请求**，只要服务器有最新数据就会自动发送给客户端，不用重复请求（类似天气预报，每当天气有变化则会自动更新最新天气状况）

**WebSocket协议没有同源限制，**客户端可与任意服务器通信，可用于解决跨域

实现原理：

WebSocket是一个应用层协议，必须依赖 HTTP 协议进行第一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 再无关联。WebSocket进行了**HTTP握手 + 双工的TCP数据传输**

协议以frame形式传输数据，会将一条消息分为几个frame，按照先后顺序传输。大数据可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况，可以边生成数据边传递消息，传输效率高

```js
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

```



---

## 1.2 请问CSS3有哪些新特性？

CSS 为层叠样式表，用来定义页面中的HTML各标签如何显示，控制页面的整体布局与样式。

CSS3为W3C组织发布的最新版CSS，主要有以下新特性：

**1. 选择器**

CSS3增加了很多选择器，以供样式绑定使用，常用的主要有：

:nth-child(n)：匹配其父标签的第n个子元素，不论元素类型，n可以是数字、关键字、公式

:nth-of-type(n)：选择与之其匹配的父元素的第N个子元素

:frist-child：相对于父级做参考，“所有”子元素的第一个子元素，并且“位置”要对应

:empty：选择没有子元素的每个元素

[abc*="def"]：选择adc属性值中包含子串"def"的所有元素

  **2. 动画**

CSS3新增创建动画方法，通过@keyframes 规则创建动画，在规则中指定 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果，用百分比来规定变化发生的时间，或用"from" 和 "to"（等同于 0% 和 100%）

利用animation属性将动画绑定到指定选择器上，至少绑定动画名称与时长

  **3. 形状变换**

CSS3新增了transform属性实现元素的旋转、缩放、倾斜平移等形状变换。主要有以下新方法：

translate()：元素从当前位置在x 坐标、y 坐标上移动

rotate()：元素顺时针旋转给定的角度（负值则逆时针旋转）

scale()：通过向量形式定义的缩放值来放大或缩小元素尺寸

skew()：元素按照一定的角度进行倾斜转换

  **4. 文本**

CSS3新增text-shadow属性可实现文本阴影，text-overflow属性可规定当文本溢出盒子时呈现效果

  **5. 边框**

CSS3新增边框属性，可呈现更多的边框效果，有以下3个边框属性：

border-radius：创建圆角矩形

box-shadow：给盒子添加阴影效果

border-image：可利用图片创建边框

  **6. 过渡**

CSS3提供transition 属性呈现元素由A样式过渡至B样式，常用两个值定义过渡效果：transition-property：过渡的属性列表，transition-duration：过渡持续的时间

  **7.** **盒模型定义**

在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用CSS实现准确布局、处理元素排列的关键。

完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。

[盒模型的各个部分](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#盒模型的各个部分)

 CSS中组成一个块级盒子需要:

- **Content box**: 这个区域是用来显示内容，大小可以通过设置 [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height).
- **Padding box**: 包围在内容区域外部的空白区域； 大小通过 [`padding`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding) 相关属性设置。
- **Border box**: 边框盒包裹内容和内边距。大小通过 [`border`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/border) 相关属性设置。
- **Margin box**: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 [`margin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin) 相关属性设置。

CSS3增加了新的用户界面属性来调整标签尺寸、盒尺寸以及外部轮廓等，常用属性有：

resize：指定一个标签可由用户调整大小

outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

box-sizing：允许以确切的方式定义适应某个区域的具体内容，可定义盒模型，有三个值：content-box：边框和padding不包含在元素的宽高之内、border-box：边框和padding包含在元素的宽高之内、inherit：从父标签继承 box-sizing 属性值

 **8.Flex布局**

弹性布局，使页面布局更加方便与灵活，舍弃传统上下排列页面元素，采用双轴排列方式，水平主轴与垂直交叉轴，并按照比例对元素进行放大与缩小，可利用简洁语法实现自适应布局

通过6个属性设置**容器属性**：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content，设置容器的轴线方向、元素对齐方向、换行

通过6个属性设置**元素属性**：order、flex-grow、flex-shrink、flex-basis、flex、align-self，设置元素的排列顺序、放大/缩小比例、多余空间分配方案、对齐方案

---

### 1.盒模型与宽高计算方式？

前端页面都由一个个盒子组成，每个盒子由content、padding、border、margin4部分组成。目前主要有两种盒模型：标准盒模型与IE盒模型（怪异盒模型），不同盒模型盒子的宽高值不同

标准盒模型：width 和 height 指content区域的宽度和高度，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸

IE盒模型（怪异盒模型）：width 和 height 指content+border+padding的宽度和高度

如何设置盒模型？

1、若定义了完整的<!DOCTYPE>声明，会直接触发标准盒模型，若<!DOCTYPE>声明缺失，则会由浏览器自己判定，IE浏览器中IE9以下（IE6.IE7.IE8）的版本触发IE盒模型，其他浏览器会默认为标准盒模型

2、可通过box-sizing属性来设置盒模型解析模式：

- content-box： 默认值，border和padding不算到width范围内，可以理解为标准盒模型，
- border-box：border和padding划到width范围内，可以理解为怪异盒模型

**[标准盒模型]**

在标准模型中，如果你给盒设置 `width` 和 `height`，实际设置的是 *content box*。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。

假设定义了 `width`, `height`, `margin`, `border`, and `padding`:

```css
.box {
  width: 350px;
  height: 150px;
  margin: 25px;
  padding: 25px;
  border: 5px solid black;
}
```

如果使用标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。

> **注**: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到margin。

[替代（IE）盒模型](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#替代（ie）盒模型)

你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px).

默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 `box-sizing: border-box` 来实现。 这样就可以告诉浏览器使用 `border-box` 来定义区域，从而设定您想要的大小。

```css
.box {
  box-sizing: border-box;
} 
```

如果你希望所有元素都使用替代模式，而且确实很常用，设置 `box-sizing` 在 `<html>` 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 [the CSS Tricks article on box-sizing](https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/)。

```css
html {
  box-sizing: border-box;
}
*, *::before, *::after {
  box-sizing: inherit;
}
```

---

### 2.[块级盒子（Block box） 和 内联盒子（Inline box）](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#块级盒子（block_box）_和_内联盒子（inline_box）)

在 CSS 中我们广泛地使用两种“盒子” —— **块级****盒子** (**block box**) 和 **内联盒子** (**inline box**)**。**这两种盒子会在**页面流**（page flow）和**元素之间的关系**方面表现出不同的行为:

一个被定义成块级的（block）盒子会表现出以下行为:

- 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽
- 每个盒子都会换行
- [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height) 属性可以发挥作用
- 内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”

除非特殊指定，诸如标题(`<h1>`等)和段落(`<p>`)默认情况下都是块级的盒子。

如果一个盒子对外显示为 `inline`，那么他的行为如下:

- 盒子不会产生换行。
-  [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height) 属性将不起作用。
- 垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 `inline` 状态的盒子推开。
- 水平方向的内边距、外边距以及边框会被应用且会把其他处于 `inline` 状态的盒子推开。

用做链接的 `<a>` 元素、 `<span>`、 `<em>` 以及 `<strong>` 都是默认处于 `inline` 状态的。

我们通过对盒子[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 属性的设置，比如 `inline` 或者 `block` ，来控制盒子的外部显示类型。

[补充: 内部和外部显示类型](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#补充_内部和外部显示类型)

在这里最好也解释下**内部** 和 **外部** 显示类型。如上所述， css的box模型有一个外部显示类型，来决定盒子是块级还是内联。

同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 **[正常文档流](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow)** 布局，也意味着它们和其他块元素以及内联元素一样(如上所述).

但是，我们可以通过使用类似 `flex` 的 `display` 属性值来更改内部显示类型。 如果设置 `display: flex`，在一个元素上，外部显示类型是 `block`，但是内部显示类型修改为 `flex`。 该盒子的所有直接子元素都会成为flex元素，会根据 [弹性盒子（Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox) [）](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)规则进行布局，稍后您将了解这些规则。

---



## 1.3 请问你了解行内元素、块级元素、空元素吗，它们如何互相转换？

- 行内元素、块级元素、空元素定义

行内元素（内联元素）：与其他元素水平方向依次排列，处于同一行，通常不会以新行开始，宽度就是内容的宽度，不可改变

块级元素：总在新一行开始，一个元素独占一行，宽度默认100%（继承父元素宽度）

两者区别总结如下表：

|                   | 行内元素                                                     | 块级元素                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 容纳内容          | 只能容纳文本或其他内联元素                                   | 容纳内联元素或其他块元素                                     |
| 设置宽度width     | 无效                                                         | 有效                                                         |
| 设置高度height    | 无效                                                         | 有效                                                         |
| 设置内边距padding | 左右有效，上下无效                                           | 有效                                                         |
| 设置外边距margin  | 左右有效，上下无效                                           | 有效                                                         |
| 常见元素          | <a>、<span>、<strong>、<i>、 <button>、<em>、<label>、<textarea>、<kbd>...... | <div>、<hn>、<p> 、<ul>、<ol>、<li>、<header>、<footer>、<form>、<nav>...... |

**空元素**：官方术语为**自闭合标签**，没有内容的 HTML 元素，没有闭合标签，在开始标签就关闭了，常见标签：

```
<br>、<hr>、<img>、<input>、<link>、<meta>
```



----

### 1.行内元素和块级元素转换方式

**1、display属性**

display：inline-block 行内元素——>行内块元素

display：block 行内元素——>块级元素

display：inline 块级元素——>行内元素

**2、float**

设置行内元素float：left/right，则该行内元素**隐式转换**为块级元素 ，且有浮动特性

**3、position**

设置行内元素position：absolute/fixed 会把行内元素**隐式转换**为块级元素，且有定位特性

---

### 2.置换元素定义与特点？

置换元素：内容不受CSS视觉格式化模型控制，渲染模型不考虑对此内容渲染，拥有固定尺寸的元素（有且仅有置换元素有固定尺寸），浏览器依据元素的标签和属性来决定具体显示内容，又名**替换元素**

块级元素包含置换元素、非置换元素；行内元素同样包含置换元素、非置换元素；行内置换元素有可修改的宽高属性，其默认值即元素的固有宽高

常见置换元素有：视图元素<img>、<object>、<video>等

表单元素<textarea>、<input>、<select>等

某些元素只在一些特殊情况下表现为可替换元素，如 <audio>、<canvas>等

---

### 3. 空元素

一个**空元素（empty element）**可能是 HTML，SVG，或者 MathML 里的一个不能存在子节点（例如内嵌的元素或者元素内的文本）的[element](https://developer.mozilla.org/zh-CN/docs/Glossary/Element)。

[HTML](https://www.w3.org/html/wg/drafts/html/CR/)，[SVG](https://www.w3.org/TR/SVG2/) 和 [MathML](https://www.w3.org/Math/draft-spec/) 的规范都详细定义了每个元素能包含的具体内容（define very precisely what each element can contain）。许多组合是没有任何语义含义的，比如一个 [``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio) 元素嵌套在一个 [``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/hr) 元素里。

在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， `<input type="text"></input>` 的闭标签是无效的 HTML。

在 HTML 中有以下这些空元素：

```html
<area>
<base>
<br>
<col>
<colgroup> when the span is present
<command>
<embed>
<hr>
<img>
<input>
<keygen>
<link>
<meta>
<param>
<source>
<track>
<wbr>
```

**Note**: 在极少数情况下，空元素被错误地称为“无效元素”(void elements)。

----

## 1.4 请问CSS选择器有哪些，应该如何计算优先级？

CSS选择器可将CSS样式表与HTML元素进行一一绑定，实现一对一，一对多、多对一的样式控制。CSS样式具有三大特性：继承、 优先级和层叠

**继承**：即子类元素继承父类的样式

**优先级**：指不同类别样式的权重比较

**层叠**：当数量相同时，后者覆盖前者

CSS选择器分类众多，主要可分为以下几类：

| 标签选择器                 | 如：body,div,p,ul,li                                   |
| -------------------------- | ------------------------------------------------------ |
| 类选择器                   | 如：class="head",class="head_logo"                     |
| ID选择器                   | 如：id="name",id="name_txt"                            |
| 全局选择器（通配符选择器） | 如：*号                                                |
| 组合选择器                 | 如：.head .head_logo（各选择器用空格键分开）           |
| 后代选择器                 | 如：#head .nav ul li 从父集到子孙集的选择器            |
| 群组选择器                 | div,span,img {color:Red} 即具有相同样式的标签分组显示  |
| 继承选择器                 | 如：div p（各选择器用空格键分开）                      |
| 伪类选择器                 | 如：a元素的伪类，4种状态：link、visited、active、hover |
| 字符串匹配属性选择器       | 如：^  $  *三种，分别对应开始、结尾、包含              |
| 子选择器                   | 如：div>p （大于号>分隔）                              |
| 相邻选择器                 | 如：h1+p（加号+分隔）                                  |

CSS优先级算法：

对于同一优先级选择器，后写的会覆盖先写的样式

当两个不同选择器都作用到同一个HTML元素时，如果定义的属性值有冲突，那么应该受哪个选择器控制？CSS有一套固定的优先级排序：

属性后面使用!important > 作为style属性行内样式>ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器= 伪元素选择器 > 通配符选择器 > 继承选择器 > 浏览器默认属性

当有多个级别组合的选择器时，往往利用上述优先级排序无法得出优先级，故有以下优先级计算方式：

每个选择器对应一个初始"四位数"：0、0、0、0

若是 行内选择器，则加1、0、0、0

若是 ID选择器，则加0、1、0、0

若是 类选择器/属性选择器/伪类选择符，则分别加0、0、1、0

若是 标签选择器/伪元素选择器，则分别加0、0、0、1

最终优先级由级别权重与出现次数决定，统计元素对应的所有选择器的权重与次数，最终得到的”四位数“，从左到右进行比较，大的优先级越高。

需注意：

- !important的优先级是最高的，但出现冲突时则需比较“四位数”
- 通配符选择器、子选择器、相邻选择器、同胞选择器权重值为0
- 优先级相同时，则采用就近原则，选择最后出现的样式

---

### 1.优先级

浏览器通过**优先级**来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类[选择器](https://developer.mozilla.org/en-US/CSS/CSS_Reference#selectors)组成的匹配规则。

优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。

而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。

当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的 CSS 规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。

[选择器类型](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#选择器类型)

下面列表中，选择器类型的优先级是递增的：

1. [类型选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors)（例如，`h1`）和伪元素（例如，`::before`）
2. [类选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors) (例如，`.example`)，属性选择器（例如，`[type="radio"]`）和伪类（例如，`:hover`）
3. [ID 选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors)（例如，`#example`）。

**通配选择符**（universal selector）（[`*`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors)）**关系选择符**（combinators）（[`+`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator), [`>`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator), [`~`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator), ['` `'](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator), [`||`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Column_combinator)）和 **否定伪类**（negation pseudo-class）（[`:not()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not)）对优先级没有影响。（但是，在 `:not()` 内部声明的选择器会影响优先级）。

给元素添加的**内联样式** (例如，`style="font-weight:bold"`) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。

---

### 2. [`!important` 例外规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#!important_例外规则)

当在一个样式声明中使用一个 `!important` 规则时，此声明将覆盖任何其他声明。虽然，从技术上讲，`!important` 与优先级无关，但它与最终的结果直接相关。使用 `!important` 是一个**坏习惯**，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找bug变得更加困难了。当两条相互冲突的带有 `!important` 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用。

**一些经验法则：**

- **一定**要优先考虑使用样式规则的优先级来解决问题而不是 `!important`
- **只有**在需要覆盖全站或外部 CSS 的特定页面中使用 `!important`
- **永远不要**在你的插件中使用 `!important`
- **永远不要**在全站范围的 CSS 代码中使用 `!important`

- **与其使用** **`!important`****，你可以：**

1. 更好地利用 CSS 级联属性

2. 使用更具体的规则。在您选择的元素之前，增加一个或多个其他元素，使选择器变得更加具体，并获得更高的优先级。

   ```html
   <div id="test">
     <span>Text</span>
   </div>
   ```

   

   ```css
   div#test span { color: green; }
   div span { color: blue; }
   span { color: red; }
   ```

   

   无论 css 语句的顺序是什么样的，文本都会是绿色的（green），因为这一条规则是最有针对性、优先级最高的。（同理，无论语句顺序怎样，蓝色 blue 的规则都会覆盖红色 red 的规则）

3. 对于（2）的一种特殊情况，当您无其他要指定的内容时，请复制简单的选择器以增加特异性。

   ```css
   #myId#myId span { color: yellow; }
   .myClass.myClass span { color: orange; }
   ```

   

什么的情况下可以使用 `!important`：

A) 覆盖内联样式

你的网站上有一个设定了全站样式的 CSS 文件，同时你（或是你同事）写了一些很差的内联样式。

全局的CSS文件会在全局范围内设置网站的外观，而直接在各个元素上定义的内联样式可能会覆盖您的全局CSS文件。 内联样式和!important都被认为是非常不好的做法，但是有时你可以在CSS文件里用!important去覆盖内联样式。

在这种情况下，你就可以在你全局的 CSS 文件中写一些 `!important` 的样式来**覆盖掉那些直接写在元素上的行内样式**。

```css
<div class="foo" style="color: red;">What color am I?</div>
```



```css
.foo[style*="color: red"] {
  color: firebrick !important;
}
```



许多JavaScript框架和库都添加了内联样式。 有时候可以用`!important`与优先级高的选择器一起使用，**以重写覆盖这些内联样式**。

B) 覆盖优先级高的选择器

```css
#someElement p {
  color: blue;
}

p.awesome {
  color: red;
}
```

在外层有 `#someElement` 的情况下，你怎样能使 `awesome `的段落变成红色呢？这种情况下，如果不使用 `!important` ，第一条规则永远比第二条的优先级更高

**怎样覆盖** `!important`

A)很简单，只需再添加一条 带 `!important` 的CSS规则，再给这个给选择器更高的优先级（添加一个标签，ID或类）；或是添加一样选择器，把它的位置放在原有声明的后面。

一些拥有更高优先级的例子：

```css
   table td { height: 50px !important; }
.myTable td { height: 50px !important; }
#myTable td { height: 50px !important; }
```



B)或者使用相同的选择器，但是置于已有的样式之后：

```css
td { height: 50px !important; }
```

C)或干脆改写原来的规则，以避免使用 `!important`。

```css
[id="someElement"] p {
  color: blue;
}

p.awesome {
  color: red;
}
```

将id作为属性选择器的一部分而不是id选择器，将使其具有与类相同的特异性。 上面的两个选择器现在具有相同的权重。 在优先级相同情况下，后面定义的CSS样式会被应用。

---

## 1.5 请问伪元素与伪类有什么区别？

伪类：本质上是为了弥补常规CSS选择器的不足，存在DOM文档中(无标签，找不到，只有符合触发条件时才能看到 )，逻辑上存在但在文档树中却无须标识的“幽灵”分类。

伪元素：本质上是创建了一个有内容的虚拟容器，不实际存在于DOM文档树中，仅在逻辑上存在，是虚拟的元素，代表某个元素的子元素

比如，有以下HTML代码：

```html
<div>
    <p>a</p>
    <p>b</p>
</div>

```

想要第一个p标签字体颜色变蓝色，使用伪类就很简单：

```css
p:first-child{
    color:blue;
}
```

不用伪类呢？ 就需要为第一个p标签添加一个类class，再通过类选择器添加颜色属性：

```html
<div>
    <p class="first-child">a</p>
    <p>b</p>
</div>
<style type="text/css">
.first-child{
    color:blue;
}
</style>
```

使用伪元素来实现该效果：

```css
p::first-child{
    color:blue;
}
```

不用伪元素呢？则需要在第一个p标签中创建一个span标签，再通过span标签选择器添加颜色属性

```html
<div>
    <p><span>a</span></p>
    <p>b</p>
</div>
<style type="text/css">
p span{
    color:blue;
}
</style>

```

- 伪类是通过添加“class类”来实现，伪元素是通过添加“元素”来实现，**二者本质区别：是否创造了新元素**
- **可同时使用多个伪类**，而只能同时使用一个伪元素，伪类可理解为添加类，所以可以多个，**而伪元素在一个选择器中只能出现一次，并且只能出现在末尾**
- 伪类和伪元素的语法不同：伪类单冒号，如：:link 、:hover ；伪元素双冒号，如：::after、::before

常见的伪类及功能分类如下图可见：

![img](E:\pogject\学习笔记\image\js\常见的伪类及功能分类)

常见的伪元素如下表可见：

| 伪元素                                   | 作用                                   |
| ---------------------------------------- | -------------------------------------- |
| ::before（CSS2中为 :before）             | 在选中元素之前添加内容                 |
| ::after（CSS2中为 :after）               | 在选中元素之后添加内容                 |
| ::first-letter（CSS1中为 :first-letter） | 向选取文字块的第一个字符添加特殊样式   |
| ::first-line（CSS1中为 :first-line）     | 向选取文字块的首行字符添加特殊样式     |
| ::placeholder                            | 选取字段的占位符文本(提示信息)         |
| ::selection                              | 选取文档中高亮(反白)的部分             |
| ::inactive-selection                     | 选取非活动状态时文档中高亮(反白)的部分 |
| ::marker                                 | 选取列表自动生成的项目标记符号         |

---

## 1.6 请问什么是DOM结构？

浏览器渲染页面都是从解析HTML文档开始的，HTML文档中定义了该页面所有组成元素以及分布结构，解析时，将元素转换为一个个DOM节点，再根据各元素间的所属关系，转换为DOM树，如下图示例所示，每个页面都有对应的DOM树

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632984775830/DAD918C8A9ED0031746ADC00AD5450C8)

----

## 1.7 请问你了解哪些CSS常用单位？

可将单位分为绝对单位与相对单位，**绝对单位**即固定长度的单位，不会变化，主要有：pt：Points 磅、in：Inches 英寸、mm：Millimeter 毫米、cm：Centimeter 厘米、q：Quarter millimeters 1/4毫米。

**相对单位**会随着参考值得变化而变化，在开发中使用频率更高，主要有：

- **px：**Pixel CSS像素，是web页面图像显示的基本单元，区别于物理像素，不是一个确定的物理量，也不是一个点或者小方块，而是CSS中的一个抽象概念，是一个相对单位，受上下文影响，默认情况（zoom100%）下1个CSS像素等于1个物理像素，若手动将页面放大或缩小，1个CSS像素就不等于1个物理像素。

在一些高PPI（每英寸像素数）的设备上，1个CSS像素默认相当于多个物理像素。比如iPhone的屏幕对比一般的手机屏幕会看起来更精细清晰一些，iPhone6、7、8都是两倍屏手机，1个CSS像素等于2个物理像素，对比一般的手机屏幕会看起来更清晰一些。

- **rem：**Root element meter 通过根文档（ body/html ）内文本的字体尺寸计算尺寸，如下代码示例，若未指定字体大小则为浏览器默认字体大小（浏览器默认字体大小为16px)。

```html
<body>     
<div class="element"></div> 
</body>  
<style type="text/css">  
body {     
    font-size: 14px; 
} 
.element {     
    font-size: 16px;     
    width: 2rem;     /* 2rem === 28px */ 
} 
</style>

```

- **em：**Element meter 通过当前对象内文本的字体尺寸计算尺寸，若未指定字体大小则继承自上级元素，直至 body，若body未指定则为浏览器的默认字体尺寸。

```html
<body>     
<div class="element"></div> 
</body>  
<style type="text/css"> 
body {     
    font-size: 14px; 
} 
.element {     
    font-size: 16px;     
    width: 2em;     /* 2em === 32px */ } 
</style>

```

- **%：**百分比，笼统的说是相对于父元素的百分比，不同CSS属性，百分比的表现有所不同。常见使用场景：

- - width、height：width**相对于父元素**的宽；height相对于父元素的高进行百分比计算
  - 定位relative：top、bottom相对父元素的高;  left 、right相对于父元素的宽进行计算
  - border-radius：**相对自身标签的宽高**设置每个边角的**垂直和水平**半径
  - margin: left、right、top、bottom**相当于父元素的宽度**进行计算
  - 定位absolute：top、bottom**相对定位元素**的高；left 、right相对于定位元素的宽进行计算，同时位于absolute中的其他属性如width heiht margin等**都对当于定位元素**进行计算
  - line-hight设置内联元素垂直居中时，%**相对于文本的行高**进行计算，非父元素

- **vh vw：**view height/view width，相对于视口的高度和宽度，视口指屏幕可见范围，1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。假设浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px

---

1. **物理像素与CSS像素有什么换算关系呢？**

CSS像素*DPR = 物理像素

像素比（DPR）：一个CSS像素占用几个物理像素

---

## 2.1 请问有哪些CSS浏览器兼容问题以及解决方案？

目前，浏览器厂商众多，Chrome，Frirefox，Safari，Edge，IE6……对于同一段CSS代码，不同厂商、甚至同一厂商不同版本的解析效果极大可能不一致，其根本原因是浏览器内核不同，这就导致了页面显示效果不统一，产生了CSS兼容性问题

目前对兼容问题的解决方案：

- **浏览器CSS样式初始化**

在所有CSS开始前，对某些属性初始化，以防不同浏览器的显示效果不一样，通常不推荐一味地使用通配符统一初始化样式

```css
*{
 margin: 0;
 padding: 0;
}
```

- **浏览器私有属性**

可直接在某个属性中额外添加浏览器私有写法，确保浏览器能识别该属性值，有两种开发思路，分别是渐近增强和优雅降级

**渐进增强：**先写某些特殊浏览器能识别的私有属性，再写通用写法确保大部分浏览器能正常显示

```html
<style type="text/css">
.test {
  -webkit-transform:rotate(-3deg); /*Chrome/Safari*/
  -moz-transform:rotate(-3deg); /*Firefox*/
  -ms-transform:rotate(-3deg); /*IE*/
  -o-transform:rotate(-3deg); /*Opera*/
   transform:rotate(-3deg);
  background-color: #fe3388;
  width: 300px;
  height: 300px;
}
</style>
<body>
<div class="test"></div>
</body>
```

**优雅降级：**先确保大部分浏览器能正常显示，再写某些特殊浏览器能识别的私有属性

```html
<style type="text/css">
.test {
  width: 300px;
  height: 300px;
  background-color: #fe3388;
  transform:rotate(-3deg);
  -webkit-transform:rotate(-3deg); /*Chrome/Safari*/
  -moz-transform:rotate(-3deg); /*Firefox*/
  -ms-transform:rotate(-3deg); /*IE*/
  -o-transform:rotate(-3deg); /*Opera*/
}
</style>
<body>
<div class="test"></div>
```

- **CSS hack语法（**一般情况下，尽量避免使用CSS hack，过多滥用会造成html文档混乱，不易管理与维护）

1. **条件hack**，IE浏览器专有的hack方式，微软官方推荐

```css
<!--[if IE]> 	
这段文字只在IE浏览器显示 	
<![endif]-->
<!--[if gte IE 6]> 	
这段文字只在IE6以上(包括)版本IE浏览器显示 	
<![endif]-->
```

  **2.** **属性级hack** CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果

```css
.test {
  color: red; /* All browsers */
  *color: blue;  /* IE7，IE6 */
  _color: skyblue;  /* IE6 */
}
```

  **3.** **选择符级hack，**在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀

```css
*html /* *前缀只对IE6生效*/
*+html /* *+前缀只对IE7生效*/
@media screen\9{...} /*只对IE6/7生效*/
@media \0screen {body { background: red; }} /*只对IE8有效*/
@media \0screen\,screen\9{body { background: blue; }} /*只对IE6/7/8有效*/
@media screen\0 {body { background: green; }} /*只对IE8/9/10有效*/
@media screen and (min-width:0\0) {body { background: gray; }} /*只对IE9/10有效*/ 
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} /*只对IE10有效*/
```

- **自动化插件**

在解析CSS文件时，插件会自动添加浏览器前缀至CSS代码中，如Autoprefixer

---

## 2.2 请问Flex的常见写法：flex:1表达什么含义？

虽说Flex具有众多属性，但在实际开发常简写为：flex：1，再结合display：flex，就能轻松打造出自适应布局，这也是Flex布局最大的优势。实际上flex为：flex-grow flex-shrink flex-basic三者的缩写。

flex-grow：定义在分配多余空间时，盒子的放大比例，默认为0，**即存在剩余空间，也不放大**

flex-shrink：定义在分配多余空间时，盒子的缩小比例（多余空间可能是负值），默认为1，**即空间不足将缩小**

flex-basis：定义在分配多余空间之前，**盒子占据的主轴空间**（可理解为基准值），通常根据该属性计算多余空间，默认为auto，即盒子自身大小

flex取值不同，空间分配计算值不同，有以下几种常见情况：

|                | flex-grow | flex-shrink | flex-basis | 解释                                                         |
| -------------- | --------- | ----------- | ---------- | ------------------------------------------------------------ |
| flex: 2 3 23px | 2         | 3           | 23px       | 当flex有三个值时，则依次分配给flex-grow、flex-shrink、flex-basic |
| flex: none     | 0         | 0           | auto       | 当 flex 为none时，则计算值为0 0 auto                         |
| flex: auto     | 1         | 1           | auto       | 当 flex 为auto时，则计算值为1 1 auto                         |
| flex: 1        | 1         | 1           | 0%         | 当 flex 为一个非负数字，该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0% |
| flex: 0%       | 1         | 1           | 0%         | 当 flex 为一个长度或百分比，该数字为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1 |
| flex: 23px     | 1         | 1           | 23px       |                                                              |
| flex: 2 3      | 2         | 3           | 0%         | 当 flex 为两个非负数字，则分别为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% |
| flex: 2 23px   | 2         | 1           | 23px       | 当 flex 为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 |

关于 flex-basis 的取值情况：

- auto：盒子本身大小
- 百分比：根据其包含块（即伸缩父容器）的主尺寸计算
- 0：盒子本身大小，当盒子大小未定义时，按其内容来来计算
- 可以代替width属性定义盒子大小，**同时声明width属性和flex-basic属性时，会以flex-basic的值来计算**

针对以下Flex布局，算出三个盒子自适应后的最终宽度。

```html
<style type="text/css">
.parent {
    display: flex;
    width: 600px;
}
.item-1 {
    width: 140px;
    flex: 2 1 0%;
    background-color: red;
    height: 50px;
}
.item-2 {
    width: 100px;
    flex: 2 1 auto;
    background-color: green;
    height: 50px;
}
.item-3 {
    flex: 1 1 200px;
    background-color: blue;
    height: 50px;
}
</style>

<body>
<div class="parent">
    <div class="item-1"></div>
    <div class="item-2"></div>
    <div class="item-3"></div> 
</div>
</body>
```

```
主轴上父容器总尺寸： 600px

子元素总基准值（flex-basis）：0% + auto + 200px = 300px，其中

0% 即 600*0% = 0 宽度

auto 对应取盒子自身尺寸：100px

故剩余空间： 600px - 300px = 300px

剩余空间为正，需要扩大子元素，伸缩放大(flex-grow)系数之和为： 2 + 2 + 1 = 5

剩余空间分配如下：

item-1 和 item-2 各分配 2/5，各得 300*2/5 = 120px

item-3 分配 1/5，得 300*1/5 = 60px

各项目最终宽度为：

item-1 = 0% + 120px = 0 + 120px = 120px

item-2 = auto + 120px = 100px + 120px = 220px

item-3 = 200px + 60px = 260px
```

---

## 2.3 请问清除浮动有哪些常用方法？

目前常用清除浮动的方法主要有：

  **1.** **给父元素添加 overflow：hidden（BFC布局）**

overflow：hidden为隐藏溢出，当内容超过其父元素时，可以用该方式将溢出的部分裁剪掉，使页面更加美观

当子元素浮动，给父元素添加overflow：hidden，按照该属性特性，将子元素超出的部分截掉，但是子元素有浮动，无法裁剪，只能父元素增加高度去包裹住子元素，从而使得父元素拥有高度，且高度随子元素自适应变化，从而清除浮动效果

代码比较简洁，可以通过触发BFC方式，但是因为本身overflow的本质是溢出隐藏的效果，所以有的时候也会有一些问题存在，比如内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素。

```html
<style type="text/css">
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
    overflow: hidden;
    /* 加上这句话，就可以清除浮动   overflow = hidden|auto|scroll 都可以实现*/
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
  overflow: hidden;
}
</style>

<body>
<div class="wrap">
   <div class="float">浮动</div>
   <div class="nofloat">不想被浮动影响</div>
</div>
</body>
```

这里父容器是没有设置固定高度的，本来第一个子元素浮动之后，父元素的高度会塌陷到跟第二个子元素一样高，但由于这里分别给第二个子元素和父元素都设置了overflow:hidden ，所以它们都生成了一个新的BFC区域，根据上文提供的BFC布局规则可以得知：**BFC区域不会与float box 重叠**；**计算BFC高度时浮动元素的高度也参与计算**。所以就得到清除浮动的效果。说得比较绕，但其实清除浮动得根据自己开发中的实际情况合理使用。  

**2. 给需要清除浮动元素添加clear:both**

clear: both：元素的左侧和右侧均不允许出现浮动元素（摘自W3C），添加了 clear属性的元素只能通过调整自身来使自己不要和浮动元素排列在一起，不能移动别的元素。若一个元素同时设置了 float：left 和 clear：left，左边不能有浮动元素，那么这个元素就要调整自己，排到下一行，因设置了 float: left，这个元素会往左边靠拢，所以这个元素会跑到下一行，同时往左浮动

```css
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
  clear: both;
}
```

  **3. 给浮动元素下方添加空盒子**

给该空盒子清除浮动（一般用clear:both），把父元素撑开，需要注意：必须是块级元素，此方法早期比较常用，会给页面增加无意义标签，**通常不建议页面中设置多个无意义标签。**

```html
<style type="text/css">
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
}
.clear{
  clear: both;
}
</style>

<body>
<div class="wrap">
   <div class="float">浮动</div>
   <div class="clear"></div>
     <br class="clear" />    <!--也可以使用br等别的块级元素来清除浮动-->
   <div class="nofloat">不想被浮动影响</div>
</div>
</body>
```

  **4. 利用after伪元素清除浮动::after**

该种方式的原理和方法3一样，添加一个内容为空的伪类，同时清除浮动（一般用clear:both），**这里用伪类代替了空盒子，避免增加无意义标签**

```html
<style type="text/css">
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
}
.clearfix:after{
  content:".";  /*尽量不要为空，一般写一个点*/
  display: block;
  height: 0;
  clear: both;
  overflow: hidden;
  visibility: hidden;
}
   .clearfix {
    *zoom: 1;   /*  *只有IE6,7识别 */
}
</style>

<body>
<div class="wrap clearfix">
   <div class="float">浮动</div>
   <div class="nofloat">不想被浮动影响</div>
</div>
```

**5. 利用after伪元素空余字符法**

```css
.clearfix::after{
    content:"\200B";   /* content:'\0200'; 也可以 */
    display:block;
    height:0;
    clear:both;
}

.clearfix {
    *zoom: 1; 
}
```

  **6.** **让父元素也浮动**

以浮制浮，父元素与子元素一起脱离文档流浮动，这样父元素就能自适应子元素高度，此方法有较大弊端，一定会影响父元素之后的元素排列，影响页面整体布局

```css
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
    float: left;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
}
```

  **7. 给父元素添加固定高度**

此方法仅适用于子元素高度已知并且固定情况

----

## 2.4 请问有哪些常见margin问题，有什么解决办法？

### **1. 父元素margin塌陷,父子边距重合**

边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。

只发生在垂直方向，父元素和第一个/最后一个子元素设置了同方向的margin值，两个属性之间没有其他内容进行隔离，导致父元素margin-top/margin-bottom塌陷

父子元素的边界重叠

```html
<style>
  .parent {
    background: #e7a1c5;
  }
  .parent .child {
    background: #c8cdf5;
    height: 100px;
    margin-top: 10px;
  }
</style>
<section class="parent">
  <article class="child"></article>
</section>
```

以为期待的效果：

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/1696b9ade2b71502.png)

而实际上效果如下:

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/1696b9aded524e48.png)

在这里父元素的高度不是 110px，而是 100px，在这里发生了高度坍塌。

**产生原因：**

 是如果块元素的 `margin-top` 与它的第一个子元素的 `margin-top` 之间没有 `border`、`padding`、`inline` `content`、 `clearance` 来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的 margin-bottom 之间没有 `border`、`padding`、`inline` `content`、`height`、`min-height`、 `max-height` 分隔，那么外边距会塌陷。**子元素多余的外边距会被父元素的外边距截断。**

**解决办法**：

父子元素的边界重叠得解决方案： 在父元素上加上 overflow:hidden;使其成为 BFC。

```html
<style>
  .parent {
    background: #e7a1c5;
    overflow:hidden;
  }
  .parent .child {
    background: #c8cdf5;
    height: 100px;
    margin-top: 10px;
  }
</style>
<section class="parent">
  <article class="child"></article>
</section>
```



常见解决办法：

- 给父级元素设置边框或内边距
- **触发BFC布局**，改变父级元素渲染规则，将父级元素独立，可给父级盒子添加：position：absolute/fixed、display：inline-block、float：left/right、overflow：hidden等一些触发BFC的属性，但是使用的时候都会带来不同的问题，具体使用中还需根据具体情况选择
- 给子元素前面添加一个空的兄弟元素，其overflow设为hidden，起隔离作用

```html
    <style type="text/css">
      .parent{
        width: 500px;
        height: 500px;
        background-color: blue;
        margin: 20px;
      }
      .child{
        width: 200px;
        height: 200px;
        background-color: orange;
        margin: 50px;
      }
      .sub{
        overflow: hidden;
      }
    </style>
      </head>

<body>
<div class="parent">
  <div class="sub"></div>
  <div class="child"></div>
</div>
```

重叠意义：外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。

解决方法： 

外层元素padding代替
内层元素透明边框 border:1px solid transparent;
内层元素绝对定位 postion:absolute:
外层元素 overflow:hidden;
内层元素 加float:left;或display:inline-block;
内层元素padding:1px;

----

###  **2. 同级元素margin重叠**

只发生在垂直方向，在同一个BFC区域内，相邻的兄弟元素会出现margin重叠情况，通常是上一个盒子的margin-bottom和下一个盒子的margin-top，叠加后的间距通常是：**两者为正取大值**（如下图所示效果），**一正一负/两者为负取两者之和**

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632985623694/974EDA43625E4786A64431DC1560371A)

```html
    <style type="text/css">
      .parent{
        width: 500px;
        height: 800px;
        background-color: gray;
        margin: 20px;
        overflow: hidden;
      }
      .child1{
        width: 200px;
        height: 200px;
        background-color: blue;
        margin: 100px;
      }
      .child2{
        width: 200px;
        height: 200px;
        background-color: green;
        margin: 50px;
      }
    </style>
      </head>

<body>
<div class="parent">
  <div class="child1"></div>
  <div class="child2"></div>
</div>
```

**分析原因：**在于child1的margin-bottom的参照元素是child2，而child2的margin-top的参照元素恰好是child1，这就导致了它俩之间的间距就会以**两值中最大的那个**为实际效果。这个现象其实和我们生活中很多场景很像，仔细想想应该不难理解。

常见解决办法：

触发BFC布局，改变元素渲染规则，将其中一个元素独立出来

**解决方法**：只设置一个元素的margin-top或者margin-bottom，避免margin重叠。 

```

```

---

###  **3. 空元素自身margin重叠**

若一个无内容的空元素，同时设置了margin-top与margin-bottom，则会发生重叠，如下图所示效果

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632985644955/FF6C2EB8F4D5CC20E8B3FCF9601FC281)

---

## 2.5 请问display:none、visibility:hidden、opacity:0有什么异同点？

相同点：都可以让网页中某个元素隐藏

不同点：

- **空间占据**

display:none：元素没有被渲染，不存在于Render Tree中，不保留元素位置，在页面上彻底消失，可理解为：看不见摸不到

visibility:hidden：存在于Render Tree中，元素在网页上不可见，但元素位置没有改变，可理解为：看不见但摸得到

opacity:0 ：会占据空间

- **子元素**

display:none：所有子元素都会被隐藏，占据的空间会消失，不可点击，也不可被访问

visibility:hidden：具有继承性，给父元素设置，子元素也会继承，但若重新给子元素设置visibility: visible，子元素又会显示

opacity:0 ：具有继承性，**不能**通过设置子元素的 opacity:1 使其显示

- **DOM结构**

display:none：影响DOM结构，会触发回流，计数器不会计数，浏览器渲染开销大

visibility:hidden：不影响DOM结构，计数器仍运行，只会触发重绘

opacity:0 ：只会触发重绘

- **事件绑定**

display:none和visibility:hidden：元素上绑定的事件无法触发

opacity:0 ：元素上绑定的事件可以触发

---

## 2.6 请问src和href有什么异同点？

相同点：都具有引用功能

不同点：

**href：**表示超文本引用，通常用于link、a等元素，**href是引用和页面关联**，在当前元素和引用资源之间建立联系

**src：**source的缩写，表示资源引用，通常用于img，script，iframe等元素，**指向外部资源的位置**，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，如js脚本，img图片等元素

href和src的区别
1.href：Hypertext Reference的缩写，超文本引用，它指向一些网络资源，建立和当前元素或者说是本文档的链接关系。在加载它的时候，不会停止对当前文档的处理，浏览器会继续往下走。常用在a、link等标签。

```html
<a href="http://www.baidu.com"></a>
<link type="text/css" rel="stylesheet" href="common.css">
```

如上面所显示的那样，当浏览器加载到link标签时，会识别这是CSS文档，并行下载该CSS文档，但并不会停止对当前页面后续内容的加载。这也是不建议使用@import加载CSS的原因。

2.src：source的所写，表示的是对资源的引用，它指向的内容会嵌入到当前标签所在的位置。由于src的内容是页面必不可少的一部分，因此浏览器在解析src时会停下来对后续文档的处理，直到src的内容加载完毕。常用在script、img、iframe标签中，我们建议js文件放在HTML文档的最后面。如果js文件放在了head标签中，可以使用window.onload实现js的最后加载。

```html
<img src="img/girl.jpg">
  
<frame src="top.html">
  
<iframe src="top.html">
  
<script src="show.js">
```

总结：href用于建立当前页面与引用资源之间的关系（链接），而src则会替换当前标签。遇到href，页面会并行加载后续内容；而src则不同，浏览器需要加载完毕src的内容才会继续往下走。

---

# 页面布局

---

## 3.1 请问定位布局position属性有哪些取值？

定位布局：页面元素CSS样式采用position属性，可在top/bottom/right/left四个方向进行位置移动，从而达到定位效果，position属性可取以下7个值：

  **1. 相对定位 relative**

- 不会使元素脱离文档流（原本位置会被保留，即改变位置也不会占用新位置）
- 相对于自身原本位置移动（没有定位偏移量则对元素无影响）
- 不影响元素本身特性（无论块级元素或行内元素，保留其原本特性）
- 常用于提升层级，从而改变元素覆盖关系，若两个都为定位元素，后面的会覆盖前面

  **2. 绝对定位 absolute**

- 使元素完全脱离文档流（在文档流中不再占原来位置）
- 行内元素设置定位效果后，支持设置宽高
- 区块元素设置定位效果后，未设置宽度时由内容撑开宽度
- **相对于最近一个有定位的父元素进行偏移**，如果不存在就逐级向上排查，直到相对于body元素，即相对于浏览器窗口（必须有参照物）
- 子绝父相，一般配合相对定位使用，（将父元素设置相对定位，子元素相对于父元素偏移）
- 可提升层级

  **3. 固定定位 fixed**

- 直接相对于浏览器窗口进行“绝对定位”
- 浮动在页面中，元素位置不会随浏览器窗口滚动条滚动而变化
- 不会受文档流动影响

  **4. 粘性定位 sticky**

- 基于用户的滚动来定位，在相对定位与绝对定位两者间切换。滚动前相当于position:relative，当页面滚动超出目标区域时，相当于position:fixed，会将元素固定在目标位置
- 相对于离它最近的具有滚动框的父级元素，如果父级元素都不可以滚动，那相对于浏览器窗口计算偏移量
- 如top: 50px，在sticky元素到达距离相对定位的元素顶部50px的位置时固定，无论怎么滚动，都不再向上移动
- 兼容性不好，如Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位，通常需要结合CSS3兼容方案

  **5. 静态定位 static**

- 默认定位，遵循正常的文档流
- 元素不会受到影响

  **6. 继承值 inherit**

- 从父元素继承 position 属性值

  **7. 初始值 initial**

- initial 关键字可用于任何 HTML 元素上任何 CSS 属性
- 可将所有CSS属性恢复到初始状态

---

###  **1. fixed定位会出现失效情况吗？有什么解决办法吗？**

存在常见3种fixed定位失效情况：

​    (1) 父元素的transform属性值不为none时，子元素的fixed失效（比较常见，仅在部分浏览器中失效）

​    失效原因：当元素祖先的 transform 属性非 none 时，**定位容器由视口改为该祖先**（摘自MDN）

​    解决办法：

​    经过实验发现，absolute定位在该情况下不会失效，**可利用absolute定位模拟fixed效果**，

主要**实现思路**：将html的滚动条禁用，开启body滚动条，对该元素absolute定位，并不设置父级元素定位，会相对document定位，但其滚动条未开启，不会受body滚动影响

```

```

   (2)  perspective属性值不为none时（不常见）

​    浏览器都不支持 perspective 属性，Chrome 和 Safari 支持替代的 -webkit-perspective 属性，目前可行办法就是删掉perspective属性

​    (3)  元素的will-change中指定了任意 CSS 属性

​    目前可行办法就是尽量避免给fixed定位元素设置will-change

---

## 3.2 请问你了解浮动布局float属性吗？

浮动布局：为方便页面设计，给元素设置float属性，将元素脱离文档流，浮动框进行左右移动，直至外边缘遇到包含框或者另一个浮动框边缘，**再通过margin属性调整位置**，float属性可取3个值：left：左浮动、right：右浮动、none：不浮动（默认）

浮动的影响：

- 改变块级元素的排列方式，内容从上下排列显示变成水平排列显示
- 浮动元素会脱离文档流，**不占位**，盒子重叠，内容不重叠
- 浮动的块级元素的宽度由内容撑开，行内元素可设宽高、margin和padding均有效，**可理解为隐式转换为inline-block元素**

---

### 1. 浮动布局最常产生什么问题？

通常父级盒子不设置高度时，高度将由内容或子元素撑开，当子元素浮动脱离文档流后， 父盒子就会出现高度塌陷，边框变成一条线，通常需要清除浮动来解决该问题

---

### 2.怎么理解css文档流/元素脱离文档流后有什么特点

文档流处在文档的最底层，它规定了一个页面的位置和元素布局等规则。
我们所创建的元素都处在文档流中，文档流所指定的规则比如块级元素独占一行，内联元素不会独占一行，内联元素不能设置高宽，父元素的高度由子元素撑开等。文档流之所以称为流，是它的布局像流一样从上到下在从左到右。
而元素脱离文档流之后，该元素便不再遵循文档流的规则，比如块级元素不再独占一行，内联元素脱离文档流之后可以设置高宽，脱离的元素不能撑开父元素，不再在文档流中占有位置等。
而脱离文档流的设置有两种：float，position：absolute

1、float
（我的理解是通过设置float来脱离文档流，脱离后的元素会遵循文档流之外的另一套规则，暂且称为浮动规则）。
规则如下：
①、产生字围效果，元素不会盖住文字，文字会绕着元素布局。
②、元素层级提高，会盖住非浮动的元素。
③、父元素的垂直外边距不会和子元素重叠。
④、浮动元素不会超过超过上面的非浮动元素，会排列在非浮动块元素的下一行。
⑤、元素浮动后会尽量向页面的左上或右上浮动，直到遇到父元素边框或其它浮动元素（浮动的元素不会脱离父元素，浮动还是相对于父元素浮动）。
⑥、浮动的元素不会超过它上边的兄弟元素，最多一边齐。
⑦、文档流中子元素的宽度默认为父元素的100%，脱离文档流之后，块元素的高宽度都只能由内容撑开，而且浮动的子元素无法撑开父元素（除非父元素也是浮动元素）。
⑧、内联元素浮动后会变成块级元素。

2、position:absolute
（我的理解是通过设置绝对定位来脱离文档流，脱离后的元素会遵循文档流之外的另一套规则，暂且称为绝对定位规则）。
规则如下：
①、 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的，没有这种祖先元素，则相对于浏览器窗口（以左上角为坐标（0，0））
②、定位元素会提高一个层级。
③、内联元素变块级元素，高宽都只能由内容撑开。
④、当一个文档流中的元素前的一个元素开启了绝对定位，则这个文档流中的元素会向上移动，被前元素覆盖。（其实跟浮动规则差不多），如果没有这样的情况，则开启了绝对定位的元素如果不设置偏移量，位置不会发生变化。

浮动规则≠绝对定位规则，两者不相通
这句话的意思是一个浮动元素和一个定位元素会重叠，且绝对定位元素的层级高于浮动元素的层级（按照浮动规则，浮动的兄弟元素是不会相互覆盖的）。

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<style type="text/css">
		#box1{
			width: 400px;
			height: 400px;
			/* position: absolute; */
			float: left;
			background-color: red;
		}
		#box2{
			width: 100px;
		    height: 100px;
			background: green;
			float:left;
			/* position: absolute; */
	</style>
	<body>
		<div id="box1">	
		</div>
		<div id="box2">
		</div>
	</body>
</html>

```

（当两个元素都开启绝对定位且不设置偏移量时，两个元素也会像上面这个图一样相互覆盖）

---

## 3.3 请问BFC布局有哪些特点、触发条件以及实际应用？

BFC（Block Formatting Context）：格式化上下文，也称BFC布局，是Web页面中盒模型布局的CSS渲染模式，**指一个独立的渲染区域，与其他元素隔离，不受外部布局影响**

BFC布局特点：

- 在BFC区域内，内部盒子会在垂直方向上一个接一个地放置
- 在BFC区域内，内部盒子垂直方向上的距离由margin决定。（可理解为：属于同一个BFC的两个相邻盒子的上下margin会发生重叠）
- 同一个BFC区域内，**设置了float属性的盒子不会重叠**
- BFC就是页面上的一个隔离的独立容器，容器内外元素互不影响
- 计算BFC的高度时，区域内的浮动元素也参与计算

BFC布局触发条件（满足任意一个即可形成BFC）：

- 根元素<html>
- 浮动元素：float不为none
- 绝对定位元素：position（absolute、fixed）
- display为inline-block、table-cells、table-caption、flex、inline-flex
- overflow不为visible（hidden、auto、scroll）

BFC布局实际应用：

- 清除浮动，通过设置overflow:hidden解决父元素坍塌问题
- 垂直margin合并，BFC区域内两个相邻元素的垂直外边距会发生叠加，**叠加后的外边距为两者外边距的最大值。这样可保持各区域间上下间距一致**，比如多个段落之间与顶部底部的边距保持一致
- 防止垂直 margin 合并，**反之可以在元素外层包裹一层容器，并触发该容器生成一个新的BFC布局**，与相邻元素隔离开来
- 实现自适应双栏、三栏布局，利用浮动、定位、Flex布局原理可实现多种自适应布局

---

## 3.4 请问如何将一个<div>盒子在页面垂直水平居中？

### 元素宽高固定时（设元素宽高为100px）：

- **absolute + 负margin**

```html
<style type="text/css">
  .box{
    width: 100px;
    height: 100px;
    background-color: gray;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
</style>
<body>
  <div class="box"></div>
</body>
```

- **absolute + margin auto**

```css
  .box{
    width: 100px;
    height: 100px;
    background-color: gray;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: auto;
  }
```

- **absolute + calc()**

```css
  .box{
    width: 100px;
    height: 100px;
    background-color: gray;
    position: absolute;
    top: calc(50% - 50px);
    left: calc(50% - 50px);
  }
```

### 元素宽高未知时：

- absolute + transform

```html
<style type="text/css">
  .box{
    background-color: gray;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
  }
</style>
<body>
  <div class="box">元素宽高未知</div>
</body>
```

- table，需要先打造一个表格结构，再将盒子放入单元格中，表格单元格中的**内容本身就是垂直居中的**，此法弊端：增加了很多冗余代码

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    text-align: center;
  }
  .box{
    background-color: gray;
    display: inline-block;
  }
</style>
<body>
  <body>
  <table>
    <tbody>
      <tr>
        <td class="wrap">
          <div class="box">元素宽高未知</div>
        </td>
      </tr>
    </tbody>
  </table>
</body>
```

- css-table，CSS新增的table属性，直接把普通元素，变为table元素的现实效果，原理与用table一样，但没有那么多的冗余代码

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    display: table-cell;
    text-align: center;
    vertical-align: middle;
  }
  .box{
    background-color: gray;
    display: inline-block;
  }
</style>
<body>
  <div class="wrap">
      <div class="box">元素宽高未知</div>
  </div>
</body>
```

- flex布局

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .box{
    background-color: gray;
  }
</style>
<body>
  <div class="wrap">
      <div class="box">元素宽高未知</div>
  </div>
</body>
```

- grid布局，CSS新出的网格布局，代码量少，但兼容性不太好

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    display: grid;
  }
  .box{
    background-color: gray;
    align-self: center;
    justify-self: center;
  }
</style>
<body>
  <div class="wrap">
      <div class="box">元素宽高未知</div>
  </div>
</body>
```

总结：宽高固定时，推荐absolute + 负margin；宽高不固定，推荐flex

---

## 3.5 请问实现自适应两栏布局（左定宽，右宽度自适应）有哪些方法？

```html
<style type="text/css">
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;
  }
</style>
<body>
  <div class="wrap">
    <div class="left">左侧固定内容</div>
    <div class="right">右侧内容自适应</div>
  </div>
</body>
```

- **float**

```css
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;
      
    float: left;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;
      
    margin-left: 200px;
  }
```

- **absolute**

```css
  .wrap{
    position: relative;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    position: absolute;
    top: 0;
    left: 0;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    margin-left: 200px;
  }
```

- **table**

```css
  .wrap{
    display: table;
    width: 100%;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    display: table-cell;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    display: table-cell;
  }
```

- **calc()**

```css
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    float: left;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    float: left;
    width: calc(100% - 200px);
  }
```

- **inline-block+calc()**

```css
  .wrap{
    width: 100%;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    display: inline-block;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    display: inline-block;
    width: calc(100% - 200px);  /* 谷歌和火狐都不能达到目的*/
  }
```

- **flex布局**

```css
  .wrap{
    display: flex;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    flex: 0 0 auto;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    flex: 1;
  }
```

---

## 3.6 请问实现自适应三栏布局（左右定宽，中间宽度自适应）有哪些方法？

- 左边左浮动，右边右浮动，中间自适应，需注意：**中间盒子必须放在DOM结构的最后**，若放在第一个，会占据第一行文档流位置，左右两边的盒子只能在第二行浮动

```html
<style type="text/css">
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    float: left;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    float: right;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    margin: 0 400px 0 200px; /*为左右两盒子留出位置*/
  }
</style>
<body>
  <div class="wrap">
    <div class="left">左侧固定内容</div>
    
    <div class="right">右侧宽度固定</div>
    
    <div class="center">中间宽度自适应</div>
  </div>
```

- 左右两盒子绝对定位，中间自适应，三个盒子的先后顺序无要求

```html
<style type="text/css">
  .wrap{
    position: relative;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    position: absolute;
    top: 0;
    left: 0;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    position: absolute;
    top: 0;
    right: 0;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    margin: 0 400px 0 200px; /*为左右两盒子留出位置*/
  }
</style>
<body>
  <div class="wrap">
    <div class="left">左侧固定内容</div>
    <div class="center">中间宽度自适应</div>
    <div class="right">右侧宽度固定</div>
  </div>
</body>
```

- flex布局，左右两盒子定宽，中间盒子flex：1，flex-grow：1、flex-shrink：1、flex-basic：0%，中间盒子的宽度：自动分配父元素除去左右盒子后的宽度，其次，弹性布局中盒子默认水平方向排列，需注意：必须最外层加一个大盒子，且中间盒子必须放在中间，按左中右顺序排列

```css
  .wrap{
    display: flex;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    flex: 1;  /*等同于flex-grow：1、flex-shrink：1、flex-basic：0%*/
  }
```

- 圣杯布局法，浮动+负margin，此方法逻辑上稍复杂，建议大家一步步理解后再实践一下，**center盒子必须放在DOM结构第一个**

```html
<div class="container">
    <div class="center"></div>
    <div class="left"></div>
    <div class="right"></div>
</div>
```

**步骤1：center盒子**宽度100%，左右两边盒子定宽

**步骤2：三个盒子**先设置相对定位，再左浮动，脱离文档流

为什么用relative 而不用 absolute呢？因为**设置absolute会让float失效**，而relative就不存在这个问题

**步骤3：left盒子** margin-left：-100%（直接将left盒子拉到center盒子左边），这里效果不等同取left盒子宽度（left盒子会跑到center盒子右边），margin设置-100%就等价于把left盒子向左移动视窗宽度的距离，等价于left盒子直接放置到最左边

**步骤4：left盒子**会覆盖center盒子左边部分内容，要把center盒子内容拉出来，在外围container加上左右padding，值分别为左右两盒子宽度，此时left盒子也会跟过来，left盒子设置left：-自身盒子宽度

**步骤5：right盒子** margin-left：-自身盒子宽度，移动到center盒子右边，不需要盒子处于最左端，所以不需要-100%，仅让它回到第一行即可

**步骤6：right盒子** right -自身盒子宽度，就可以让它不覆盖center盒子右边部分内容

完整的CSS代码如下：

```html
<style type="text/css">
  .wrap{
    padding: 0 400px 0 200px;
  }
  .center,.left,.right{
    position: relative;
    float: left;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    margin-left: -100%;
    left: -200px;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    margin-left: -400px;
    right: -400px;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    width: 100%;
  }
</style>
<body>
  <div class="wrap">
    <div class="center">中间宽度自适应</div>
    <div class="left">左侧固定内容</div>
    <div class="right">右侧宽度固定</div>
  </div>
</body>
```

- 双飞翼布局法，前半部分与圣杯布局基本一致，三栏全部float浮动，但左右两盒子加上负margin让其跟中间盒子并排，以形成三栏布局。

**不同处：**对于中间盒子被覆盖问题的解决思路：直接在center盒子内部创建子盒子用于放置内容，对该子盒子设置margin-left和margin-right为左右两盒子留出位置

简单地说，对比圣杯布局，双飞翼布局比圣杯布局多创建了一个div，但不用相对布局

```html
<style type="text/css">
  .center,.left,.right{
    position: relative;
    float: left;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    margin-left: -100%;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    margin-left: -400px;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    width: 100%;
  }
  .main{
    margin: 0 400px 0 200px;
  }
</style>
<body>
  <div class="wrap">
    <div class="center">
      <div class="main">中间宽度自适应</div>
    </div>
    <div class="left">左侧固定内容</div>
    <div class="right">右侧宽度固定</div>
  </div>
</body>
```

---

# js部分

---

## 1.1 请问在JS中有哪些数据类型？

JavaScript 语言中类型集合由原始值和对象组成。

**原始值**（直接表示在语言底层的不可变数据）

除对象类型（object）以外的其它任何类型定义的不可变的值（值本身无法被改变）。例如（与 C 语言不同），JavaScript 中字符串是不可变的（译注：如，JavaScript 中**对字符串的操作一定返回了一个新字符串**，原始字符串并没有被改变）。我们称这些类型的值为“*原始值*”。

- 布尔类型
- Null 类型
- Undefined 类型
- 数字类型
- BigInt 类型
- 字符串类型
- 符号类型(symbol)

符号（Symbols）类型是**唯一**且**不可修改**的原始值，并且可以用来作为对象的键(key)，在某些语言当中也有与之相似的类型（原子类型，atoms）。

**对象**（一组属性的集合）

在计算机科学中, 对象（object）是指内存中的可以被[标识符](https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier)引用的一块区域。



JS数据类型一共有7种，分为基本数据类型和引用数据类型

- **基本数据类型**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol、BigInt

Symbol：ES6引入了一种新的原始数据类型，表示独一无二的值，**主要用于解决属性名冲突的问题**，做为标记

BigInt：新增数据类型，是ES2020新增加的，精度大于 2^53 - 1， 是比Number类型支持的范围更大的整数值，在对大整数执行运算时，使用BigInt，会减少整数溢出问题

创建方式：BigInt(value)、在一个整数字面量后面加 n 

```js
let a = 10n; 
let b = BigInt(10);  
console.log(a === b);     // true
```

注意：由于在Number 与 BigInt 之间进行转换会损失精度，**建议仅在值可能大于2^53 时使用 BigInt类型**，并且不在两种类型之间进行相互转换。

与Number不同点：

（1）不能用于 Math 对象中的方法；

（2）不能和任何 Number 实例混合运算，两者必须转换成同一种类型（ BigInt 变量在转换成 Number 变量时可能会丢失精度）



- **引用数据类型**：对象(Object)，其中包含了日期（Date）、函数（Function)、数组（Array）、正则（RegExp）等

两者总结区别：

（1）声明变量时不同的内存分配：

基本：存储在栈中的简单数据段，它们的值直接存储在变量访问的位置

原因：**基本类型数据占据的空间是固定的**，所以将他们存储在较小的内存区域——栈，便于迅速查寻变量的值

引用：存储在堆中的对象，存储在变量处的值是一个指针，指向存储对象的内存地址

 原因：**引用类型数据的大小会改变**，不能把它放在栈中，否则会降低变量查寻速度，**相反，地址的大小是固定的，可以存在栈中**

（2）不同的内存分配机制也带来了不同的访问机制

引用：js中不允许直接访问保存在堆内存中的对象，在访问一个对象时，**首先得到对象在堆内存中的地址**，按照这个地址去获得对象中的值（引用访问）

基本：可直接访问

（3）复制变量时的不同

基本：变量复制时，会将原始值的副本赋值给新变量，此后两变量是完全独立的，他们只是拥有相同的值而已（深拷贝）

引用：变量复制时，会把内存地址赋值给新变量，新旧变量都指向了堆内存中的同一个对象，任何一个作出的改变都会影响另一个（浅拷贝）（深拷贝浅拷贝对比详见下3.3）

（4）参数传递的不同（把实参复制给形参的过程）

由于内存分配的差别，两者在传参时也有区别

基本：只是把变量里的值传递给参数，**之后参数和这个变量互不影响**

引用：**传递的值也就是这个内存地址**，这也就是为什么函数内部对这个参数的修改会体现在外部，因为它们都指向同一个对象

----

## 1.2 请问Undefined与Null有何异同点？

共同点：都是基本类型，保存在栈中

不同点：

Undefined表示"缺少值"，**就是此处应该有一个值，但是还没有定义**，转为数值时为NaN。典型用法：

- 变量被声明了，但没有赋值时，就等于undefined
- 调用函数时，应该提供的参数没有提供，该参数等于undefined
- 对象没有赋值的属性，该属性的值为undefined
- 函数没有返回值时，默认返回undefined

Null：

表示"没有对象"，**即该处不应该有值**，转为数值时为0。典型用法是：

- 作为函数的参数，表示该函数的参数不是对象
- 作为对象原型链的终点

注意：

```js
undefined == null; //true
undefined === null; //false
```

ECMAScript 规范： null 和  undefined 的行为很相似，并且**都表示 一个无效的值**，那么它们所表示的内容也具有相似性，故他们相等。

全等操作 === 在比较相等性的时候，两者不是同一类型值，会发生类型转换，故两者不全等。

```js
Number(undefined); // NaN
Number(null); // 0

```

---

## 1.3 请问如何判断js变量的数据类型？

常见判断方法有以下四种：

- **typeof xx**

返回一个字符串（小写），用来判断：Undefined、String、Number、Boolean、Symbol、Object、Function，无法检测引用类型里的Array

```bash
> typeof(undefined)
'undefined'
> typeof("abc")
'string'
> typeof(100)
'number'
> typeof(false)
'boolean'
> typeof(Symbol(2))
'symbol'

> typeof(BigInt(200))
'bigint'
```

优点：可区分Object与Function

缺点：

（1）对于 Null ，返回 object 类型

```js
> typeof(null)
'object'
```

原因：Null类型只有一个null值，该值表示一个**空对象指针**（出自JavaScript高级程序设计）

**typeof的检测原理**：不同的对象在底层都表示为二进制，在js中二进制前**（低）三位存储其类型信息**为：000: Object、100：String、110： Boolean、1： Number。**null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回"object"。**

  （2） 对于Array、Date、RegExp都会返回object，不能更详细的区分

```js
var fn=function(){};
let obj={a:1};
let arr=[1,2,3];
let now=new Date();
let reg=/abc/;

console.log(typeof(fn));  //function
console.log(typeof(obj));  //object
console.log(typeof(arr));  //object
console.log(typeof(now));  //object
console.log(typeof(reg));  //object
```

- **xx instanceof xx**

返回true/false，**只能判断引用类型** ，无法检测基本类型

判断原理：**判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上**。简单来说：能验证new构造函数创建出来的实例，左边的对象是否是右边的类的实例，**属于验证式判断类型**

缺点：**只能用来判断两个对象是否属于实例关系**， 而不能判断一个对象实例具体属于哪种类型（**原型链上的都会返回true**）

```js
console.log('abc' instanceof String);// false 
console.log( String('abc') instanceof String);// true 

console.log(12 instanceof Number);// false 
console.log(new Number(12) instanceof Number);// true 

console.log(true instanceof Boolean);// false 
console.log(new Boolean(true) instanceof Boolean);// true 

console.log({name:'yy'} instanceof Object);// true 
console.log(new Object({name:'yy'}) instanceof Object);// true 

console.log(['12','123'] instanceof Object);// true 
console.log(['12','123'] instanceof Array);// true 
console.log(new Array('12',32) instanceof Object);// true 
console.log(new Array('12',32) instanceof Array);// true 

console.log(function(){} instanceof Object);// true 
console.log(function(){} instanceof Function);// true 
console.log(new Function() instanceof Function);// true 

console.log(new Date() instanceof Object);// true 
console.log(new RegExp instanceof Object);// true 

console.log(new String('abc') instanceof Object);// true 
console.log(new Number(12) instanceof Object);// true

console.log(null instanceof Object);  //false
console.log(undefined instanceof Object);  //false
console.log(Symbol(2) instanceof Object);  //false
console.log(BigInt(2) instanceof Object);  //false
```



- **xx.constructor === xx**

返回true/false，判断原理：

当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用

具体来说：当 var f = new F() 时，F被当成了构造函数，f是F的实例对象，**此时F原型上的constructor传递到了f上，因此f.constructor === F**

缺点：不可判断Null、Undefined是无效的对象，**没有constructor存在**

constructor 是不稳定的，如创建的对象更改了原型，无法检测到最初的类型

```js
console.log("abc".constructor===String);  //true
console.log(new Number(2).constructor===Number);  //true
console.log([1,2,3].constructor===Array);  //true
console.log(false.constructor===Boolean);  //true
console.log(new Function().constructor===Function);  //true
console.log(new Date().constructor===Date);  //true
console.log(/abc/.constructor===RegExp);  //true

console.log(document.constructor===HTMLDocument);  //true
```

- **Object.prototype.toString.call(xx)**

返回“[object type]”（字符串），**能判断所有类型**，万金油方法

判断原理：**JS中的所有对象都是继承自Object对象的**，通过call方法（显式绑定）改变this指向，利用Object.prototype上的原生toString()方法判断数据类型

```js
console.log(Object.prototype.toString.call(123));  // [object Number]
console.log(Object.prototype.toString.call("abc"));  //[object String]
console.log(Object.prototype.toString.call(undefined));  //[object Undefined]
console.log(Object.prototype.toString.call(null));  //[object Null]
console.log(Object.prototype.toString.call(false));  //[object Boolean]

console.log(Object.prototype.toString.call(Symbol(2)));  //[object Symbol]
console.log(Object.prototype.toString.call(100n));  //[object BigInt]

console.log(Object.prototype.toString.call({}));  //[object Object]
console.log(Object.prototype.toString.call([]));  //[object Array]

console.log(Object.prototype.toString.call(new Date()));  //[object Date]
console.log(Object.prototype.toString.call(new RegExp("abc","g")));  //[object RegExp]

console.log(Object.prototype.toString.call(function(){}));  //[object Function]
```

-----

## 1.4 请问===与==有何区别？相等与全等的区别

==：相等(值)

**先转换再比较**（强制转换）

- 有布尔值，把false->0， true->1， 调用Number()方法
- 字符串 和 数值，字符串转数值 ；调用Number()方法
- 对象 和 非对象，调用对象的valueOf()和toString()方法把对象转换成基础类型的值再比较，**除Date对象外，会优先尝试使用valueOf()方法**
- 有一个是NaN， 则返回false。 即使两个都是NaN，也返回false，**因为按照规则，NaN不等于NaN**
- 两个操作数都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象，则返回ture 因为对象存的是地址值
- 比较相等性之前， **不能将 null和 undefined转换成其他任何值**

```bash
> 1==true
true
> 2==false
false
> 2===true
false
> 1=="1"
true
> []==""
true

> []==false
true
> []=={}
false
> []==[]
false
> {}=={}
false
> null==undefined
true
> 1==NaN
false

> 0==undefined
false
> 0==null
false

> false==0
true
> false==null
false
> false==undefined
false


```

**=== ： 全等(类型和值）**

**先判断类型再比较**， 类型不同直接不等，不转换类型

```bash
> 0===0
true
> []===[]
false
> 2===2
true
```

---

## 1.5 请问你了解js作用域吗？

**1，js作用域**

作用域：在运行时代码中的某些特定部分中变量、函数和对象的**可访问性**。换句话说，作用域决定了代码区块中变量和其他资源的可见性，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。

**作用域最大作用**：隔离变量，不同作用域下同名变量不会有冲突

作用域是分层的，**内层作用域可以访问外层作用域的变量**，反之不行

**2， JavaScript 没有块级作用域（ES6之前）**，只有全局作用域和函数作用域，ES6引入块级作用域（相关知识会在第5章中分析）

全局作用域（浏览器）：window

- 最外层函数 和在最外层函数外面定义的变量拥有全局作用域

- **所有末定义直接赋值的变量自动声明为拥有全局作用域**
- 所有window对象的属性拥有全局作用域，如window.name、window.location、window.top等

- nodejs 的全局对象：global，**声明全局变量的方式为: global.变量名**

- 在各个模块下都可以直接访问 global 对象

- 一个文件就是一个模块，通过 require 引入模块


函数作用域：

- 声明在函数内部的变量


**3，作用域链**

当我们需要某个变量的值时，先去它最近的作用域去找，如果找不到，就找它的上级作用域，依次类推，直到找到全局，如全都未定义，那就抛出一个错误，如下代码所示

```js
var a = 1
function A(){
    function B(){
        console.log(a);
    }
    return B();
}
A();//1

```

常见面试题：

```js
var a=10;
function A(){
    alert(a);
};
function B(){
    var a=20;
    A();
}
B();//10

```

为什么输出10，而不是20？**js中变量的作用域链与定义时的环境有关，与执行时无关**。调用函数B，B中调用了函数A，函数A里面没定义变量a，函数A只是被B调用且不传参，因此函数A无权使用函数B的局部变量a，而在上方还有一个全局变量a，因此这里输出10

---

## 1.6 请问什么是变量提升？什么是函数提升？

js区别于C、C++、Java语言，在ES6之前，JavaScript没有块级作用域，只有**全局作用域**和**函数作用域**。

这题在面试时尽量用具体代码举例说明

先看下面代码：

```js
console.log(a);

var a=2;  //undefined
```

变量 a 在使用前没有先进行声明，会抛出 ReferenceError异常?还是输出 2 ？事实上都不对，正确答案是输出 undefined（已声明未定义值）

这就是一个典型的 **变量提升** 现象

js 实际上会将 var a = 2 看成两个声明： var a和 a = 2。第一个定义声明在**编译阶段**进行，**第二个赋值声明被留在原地等待执行阶段**

因此上面代码会以如下形式进行处理：

```js
var a; 
console.log(a); 
a = 2;
```

**所有的声明（变量和函数）都会被“移动”到各自作用域的最前端**，这个过程被称为 **变量（函数）提升**

再看一个高频考题：

```js
var a=true;

foo();  //undefined

function foo(){   //函数声明
	if (a) {
		var a=10;
	}
	console.log(a);
}
```

最终的答案是 undefined，代码实际js执行情况如下：

```js
function foo() { 	
    var a; 	
    if(a) { 		
    	a = 10; 	
    } 	
    console.log(a); 
} 
var a;  
a = true;  
foo();

```

首先， foo(...) {} 的位置被移到了 foo();的前面，**这是函数发生了提升**，在 foo(...) {} 中，为什么会输出 undefined，而不是10？

原因：**JavaScript 中没有块级作用域，**所以 var a = 10会被 JavaScript 分为两步：var a; **会被提升到函数作用域中的最顶端**，声明了一个局部变量 a，在 foo(...) {} 的函数作用域中，**这个重名局部变量 a 会屏蔽全局变量 a**，换句话说，在对 a 的赋值声明之前，在 foo(...) {}中，a 的值都是 undefined，无法进入 if(a) {...} 中，所以最后打印出来 undefined

注意：在 JavaScript 中，函数有两种方式进行声明，函数声明会被提升，**但函数表达式却不会被提升**

```js
var a = true; 
foo();  //TypeError: foo is not a function

var foo = function() { 	//函数表达式
    if(a) { 		
    	var a = 10; 	
	} 	
	console.log(a); 
}

```

```js
var a; 
var foo；  
a = true; 
foo();  
foo = function() { 
    if(a) {      
    	var a = 10;    
    } 
    console.log(a); 
}
```

当执行到foo()时，foo 还没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo()对 undefined 值进行函数调用而导致非法操作，因此会抛出 TypeError 异常

函数优先：函数声明和变量声明都会被提升。**但函数会首先被提升，然后才是变量提升**

```js
foo();  // 1

function foo(){  //函数声明
	console.log("1");
}

foo();  // 1

var foo = function() { 	//函数表达式
	console.log("2"); 
}


foo();  //2
```

输出 1 而不是 2！这段代码片段会被引擎理解为：

```js
function foo() { 	
    console.log('1'); 
}  
var foo;
foo();  
foo = function() {
 	console.log('2'); 
 }
```

---

## 1.7 请问js有哪些常见报错类型？它们有什么区别？

在js中常有6种错误类型：TypeError、ReferenceError、SyntaxError、RangeError、EvalError、URIError。其中 TypeError 和 ReferenceError 日常开发会经常碰到。

**TypeError：**类型错误(调用不存在的方法)，变量或参数不是预期类型时发生的错误

```js
var a;

console.log(a.b); //TypeError: Cannot read properties of undefined (reading 'b')
```

变量 a 存在，但a的b属性不存在

**ReferenceError：**引用错误(要用的变量没找到)

```js
console.log(b)  //ReferenceError: b is not defined
```

对 b 进行 **RHS**查询，在所有嵌套作用域中遍寻不到变量

**SyntaxError：**语法错误（给关键字赋值、变量名不符合规范）

```js
//var 1;  //SyntaxError: Unexpected number

function=1;  //SyntaxError: Unexpected token '='
```

**RangeError：**范围错误(参数超范围)，主要有：数组长度为负数、Number对象的方法参数超出范围、函数堆栈超过最大值

```js
// 1、数组长度为负数
[].length = -5      // Uncaught RangeError: Invalid array length

// 2、Number对象的方法参数超出范围
var num = new Number(12.34)
console.log(num.toFixed(-1))   //RangeError: toFixed() digits argument must be between 0 and 100    at Number.toFixed (<anonymous>)

```

**EvalError：**非法调用 eval()，eval()函数没有被正确执行

```js
var myEval = eval;
myEval("alert('call eval')");
// 需要注意的是：ES5以上的JavaScript中已经不再抛出该错误，但依然可以通过new关键字来自定义该类型的错误提示。

new Error([message[fileName[lineNumber]]])
// 第一个参数是错误提示信息，第二个是文件名，第三个是行号。

```

**URIError：**URI不合法，相关函数的参数不正确。

```js
decodeURI("%")     // URIError: URI malformed
```

---

### **1、什么是LHS和RHS查询？**

如上所说，对于var a = 2， js引擎会将它分为两步完成：var a 和 a = 2

变量的赋值操作会执行两个动作：首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在引用域中查找该变量，如果能够找到就会对它赋值

LHS和RHS就是js对变量的两种查找操作， 查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行

LHS（Left-hand Side）和RHS（Right-hand Side）通常是指**等号（赋值运算）**的**左右边的查询**，但并不一定意味就是"="的左侧和右侧，赋值操作还有其他几种形式，因此在概念上最好将其理解为：**“赋值操作的目标是谁**（LHS）”以及“**谁是赋值操作的源头**（RHS）”

可以参考下面代码加以理解：

```js
function foo(a) { 	
    var b = a; 	
    return a + b; 
}  
var c = foo(2);
```

代码中一共有3个LHS查询和4个RHS查询

LHS：

```
第2、5行中的b = ...、c = ...，变量在赋值操作的左边，对 b、c 需要 LHS 查询

第5行调用 foo(2) 时，需要将实参2赋值给形参a，所以对 a 需要 LHS 查询
```

RHS：

```
第2行 b = a， a 在赋值操作的右边，需要知道 a的值，对 a 需要 RHS 查询

第3行 reutrn a + b， 需要知道 a 和 b 的值， 分别对 a 和 b 都进行 RHS 查询

第6行 c = foo(2)，foo(2) 在赋值操作的右边，需要知道 foo(2)的值，对 foo(2) 需要 RHS 查询
```

当**RHS****查询不成功**时：会抛出 ReferenceError异常

当**LHS查询不成功**时：会自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS查询的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）

---

## 2.1 请问你了解js中的闭包吗？

概念一：闭包是指有权访问另一个函数作用域中的变量的函数（概念出自《JavaScript高级程序设计》）

概念二：一个函数和对其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包，也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。（概念出自MDN）

可以简单理解为：闭包就是一个函数，一个外部函数通过调用函数并return返回出内部函数，此内部函数就是一个闭包

js作用域只能函数内部向外层访问，闭包就是将函数内部和函数外部连接起来的一座桥梁，能够在函数外部访问到函数内部作用域的局部变量的函数

```js
function f1(){
	var n=10;
	function f2(){  //f2函数就是闭包
		console.log(n);  
	}
	return f2;  //重点在这里，将闭包函数作为返回值，做到f1能访问到f2的内部局部变量
}

var result=f1();
result();  //10
```

此时f2函数形成了一个闭包，因f2函数里需要访问f1作用域下的n变量，但他们不处于同一个作用域，故两者相互牵引，需要输出n，f1中的变量n就必须存在，作用域链在f1中找到n，输出n时，垃圾回收机制会认为f2还没有执行完成，但此时作用域链查找已经到了f1作用域下，所以n的内存空间不会被垃圾回收机制清除

闭包**优点**：

- 可以读取函数内部的变量
- 延长局部变量寿命，不被垃圾回收机制销毁
- 封装变量（模仿块级作用域）

高频考题：

```js
for(var i=0;i<5;i++){
      setTimeout(function(){
            console.log(i); //输出5个5
      });
} 
```

预期应该是输出0、1、2、3、4，但实际是输出5个5，因为setTimeout事件是被异步触发的，当事件被触发的时候，for循环早已经结束

可利用闭包解决该问题：将每次循环的i值封闭起来， 当沿着作用域链从内到外查找变量i时，会先找到被封闭在闭包环境中的i

```js
//1、在setTimeout外部创建一个自执行函数，并将i当作参数传递进闭包
for(var i=0;i<5;i++){
    (function(num){
        setTimeout(function(){
            console.log(num);   // 输出0，1，2，3，4         
        }, num*1000);
      }
    )(i)
}

//2、在setTimeout内部函数创建一个闭包，并将i当作参数传递进去
for(var i=0;i<5;i++){
        setTimeout(function(num){
            return function(){ //用匿名函数打造一个num变量副本
            	console.log(num);   // 输出0，1，2，3，4 
            }
        }(i), i*1000);
} 
```

**闭包缺点：**

- 闭包会导致变量不会被垃圾回收机制所清除，会大量消耗内存
- 使用不恰当可能会造成**内存泄漏**的问题

**避免闭包引起的内存泄漏**：

1、在退出函数之前，将不使用的局部变量全部删除或者赋值为null

将变量设置为null：切断变量与它此前引用的值之间的连接，当垃圾回收器下次运行时，会删除这些值并回收它们占用的内存

2、避免变量的循环赋值和引用

----

## 2.2 请问js垃圾回收机制是什么工作原理？

js语言有 自动垃圾回收机制，执行环境会管理 代码执行过程中使用的内存，垃圾收集器会定期（周期性）找出不再继续使用的变量，然后释放其内存

不再使用的变量：**生命周期结束的变量**（局部变量），**全局变量的生命周期直至浏览器卸载页面才会结束**

**栈内存 垃圾回收：**

栈内存中的垃圾回收其实就是**销毁执行栈中的执行上下文**，**栈顶**就是正在执行函数的执行上下文， 当函数执行完毕后，执行栈中对应的执行上下文会被销毁

**ESP** 是执行栈中用来记录当前执行状态的指针， 当执行完一行后**，ESP 指针下移**，即**该行对应的上下文被回收**。 可理解为js引擎就是通过ESP指针的下移操作完成栈内存中的垃圾回收

**堆内存 垃圾回收：**

js中堆内存的垃圾回收主要建立在 代际假说 和 分代收集 两个概念上

**代际假说：**

- 大部分对象的存活时间都很短，分配完内存以后很快就变得不可访问
- “不死”的对象，存活时间都很长

**分代收集：**

- 堆内存分为 新生代 和 老生代 两个区域
- **新生代**区域：存放的都是存活时间比较短，占内存比较小的对象
- **老生代**区域：存放的都是存活时间比较长，占内存比较大的对象

**主垃圾回收器和副垃圾回收器：**

新生代区域：副垃圾回收器

老生代区域：主垃圾回收器

这两个垃圾回收器的大致工作流程是相同的，可以简化为三步：

（1）、标记待回收的内存

（2）、垃圾内存回收

（3）、内存碎片整理（频繁的垃圾回收后，会产生很多不连续的内存空间，不利于后续数据的存储）

副垃圾回收器 工作流程

主要是对**新生代区域**进行垃圾回收，新生代区域的内存空间比较小，大约是 1~8M

采用的是 Scavenge 算法 进行垃圾回收，主要是将新生代区域 分成两部分：**空闲区域** 和**对象区域**， Scavenge 算法具体工作流程：

（1）、所有进入新生代区域新产生的对象都会存放到对象区域中

（2）、当对象区域被写满的时候会进行垃圾回收

（3）、垃圾回收器会标记垃圾数据（使用“标记清除算法”）

（4）、标记完成后对象区域会**将有效数据按照一定顺序存放到空闲区域的一端**

（5）、存放好后，对象区域和空闲区域会角色互换

（6）、清空当前的空闲区域的内存空间

其中，因为是对象区域的有效数据按照一定顺序放到了空闲区域中，所以也顺便完成内存碎片的整理

注意：新生代区域的空间很小，经常很快被填满，js有一个对象晋升策略解决这种情况：

对象晋升策略规定**：两次垃圾回收还存活的对象就会被移动到老生代区域**

**主垃圾回收器 工作流程**

对老生代区域进行垃圾回收，老生代区域的内存空间要大很多，用 Scavenge算法 效率明要低很多，还是按照以下三步进行垃圾回收：

（1）、通过标记清除算法，标记垃圾数据

（2）、标记垃圾数据后，主垃圾回收器开始进行垃圾回收，**把可回收对象加入到空闲列表中**

（3）、 剩下就是内存碎片整理，主垃圾回收器会将存活的对象移动到一端，然后清理掉边界以外的内存

---

### **1、什么是标记清除算法与引用计数算法？**

两算法都是针对垃圾数据标记的

**标记清除：**js中**最常用**的垃圾回收方式，当变量进入环境时，（一般是在函数中声明一个变量），将这个变量标记为“进入环境”。而当变量离开环境时，则将其标记为“离开环境”。**逻辑上讲，永远不能回收 进入环境的变量 所占用的内存，因为当执行流进入相应的环境，就可能会用到它们**

```js
function test(){
    var a =10;//被标记 ，进入环境
    var b =20;//被标记 ，进入环境
}
test();//执行完毕 之后 a、b又被标离开环境，被回收
```

**引用计数：**跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数是1；若同一个值又被赋给另一个变量，则该值的引用次数再加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1

当这个值的**引用次数变成0时**，则表示没有办法再访问这个值了，其占用的内存空间可回收

```js
function test(){
    var a ={};//a的引用次数为0
    var b = a ;//a的引用次数加1，为1 
    var c = a;//a的引用次数再加1，为2
    var b ={};//a的引用次数减1，为1
}
```

注意：引用计数算法是js早期的垃圾标记算法，现在几乎不怎么用，该算法存在一个问题：**无法应对互相引用的情况**，当两个对象互相引用时，就会永远无法被回收，从而造成内存泄漏。 基于这个问题，后来提出了标记-清除算法

---

## 2.3 请问js有哪几种常见的内存泄露情况？

**1、闭包**

闭包可以延长局部变量寿命，若使用不当则会导致内存泄露

**2、意外的全局变量**

js中如果不用var声明变量，该变量将被视为window对象(全局对象)的属性，也就是全局变量，**目前开发场景中：主要还是使用let和const较多**

```js
function foo(arg) {
    bar = "this is a hidden global variable";
}
function foo(arg) {
    window.bar = "this is an explicit global variable";
}
```

上面代码中两个函数是等价的，**调用完函数后，变量仍然存在，会导致泄漏**

如果不注意this的话，也可能发生内存泄露：

```js
function foo() {
    this.variable = "potential accidental global";
}
foo();// 没有对象调用foo, 也没有给它绑定this, 所以this是window
```

解决办法：加上“use strict”，**启用严格模式来避免**，**严格模式会组织创建意外的全局变量**

**3、被遗忘的定时器或者回调**

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

如上代码，**若id为Node的元素从DOM中被移除，但定时器仍会存在**，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放

**4、没有清理的DOM元素引用**

```js
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
}
function removeButton(){
	document.body.removeChild(document.getElementById('button'));
}
```

虽用removeChild移除了button，但是还在elements对象里保存着button的引用，DOM元素还在内存里面

---

## 2.4 请问你了解js的原型链吗？

与其他面向对象语言不同，ES6之前js没有引入类（class）的概念，js并非通过类而是直接通过构造函数来创建实例

**构造函数与实例原型**

在js中，每当定义一个函数(普通函数、类)时候，都会天生自带一个prototype属性，这个属性**指向函数的原型对象**，并且这个属性是一个对象数据类型的值

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632988937142/6792CAEEBFCDBCFC9E66B7976460013F)



原型对象可看作一个公共的区域，**所有同一个类的实例都可以访问到原型对象**，可将对象都有的内容，统一设置到原型对象中

`__proto__`

**每个对象**(除null外)都会有`__proto__`属性，这个属性会指向该对象的原型

注意：`__proto__ `是 ES 标准中 [[proto]] 指针，**不建议在代码中直接编写` proto `属性**，应该通过 **Object.getPrototypeOf(）**来获取原型

**`person.__proto__ === Person.prototype `![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632988972481/CE5C7C6471A9A7C318E42BC23AE5A324)**



**constructor**

**每个原型都有一个constructor属性**，**指向该关联的构造函数**

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632988988342/C2935E207F25D2B293E277867849672F)

**原型链**

在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为**原型链**

注意：Object是js中所有**对象数据类型**的基类（最顶层的类），Object.prototype 没有原型，（`Object.prototype.__proto__ `的值为 null）

```js
console.log(Object.prototype);  // [Object: null proto
console.log(Object.prototype.__proto__);  // null

let a = 1;
console.log(a.__proto__);  // {}
```

像下图中：person → Person → Object ，普通人继承人类，人类继承对象类

当访问**对象的一个属性或方法时**，会先在对象自身中寻找，如果有则直接使用，**如果没有则会去原型对象中寻找**，如果找到则直接使用。如果没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632989014554/847EB5079F1C884C1E9B01D4CDD52E60)



看一道经典面试题：

```js
var F=function(){}

Object.prototype.a=function(){
	console.log("a()");
}

Function.prototype.b=function(){
	console.log("b()")
}

var f=new F();

F.a();  //a()
F.b();  //b()
f.a();  //a()
f.b();  //TypeError: f.b is not a function
```

这道题有几个考点：1、原型与原型链 2、实例对象、构造函数、Object、Function的关系

代码分析：F是个构造函数，而f是构造函数F的一个实例

有：

```js
console.log(F instanceof Object);  //true
console.log(F instanceof Function);  //true
```

F是Object 和 Function两个的实例，即F既能访问到a，也能访问到b

故：F.a() 输出 a()   F.b()  输出  b()



对于f，并不是Function的实例，**因为它本来就不是构造函数**，只能访问Object原型链

有：

```js
console.log(f instanceof Object);  //true
console.log(f instanceof Function);  //false
```

故：f.a() 输出  a() f.b()报错

具体分析下，它们是如何在原型链上查找的：

**F.a() 查找路径：**

F自身：没有 → `F.__proto__`(Function.prototype)：没有 → `F.__proto__.__proto__`(Object.prototype)：输出 a()

```js
console.log(F.__proto__);  //{ b: [Function (anonymous)] }
console.log(F.__proto__.__proto__);  //[Object: null prototype] { a: [Function (anonymous)] }
```

**F.b() 查找路径：**

F自身：没有 → `F.__proto__`(Function.prototype)：b()

**f.a的查找路径：**

f自身：没有 → `f.__proto__`(Object.prototype)：输出a()

```js
console.log(Object.getPrototypeOf(f));  //{}
console.log(f.__proto__.__proto__);  //[Object: null prototype] { a: [Function (anonymous)] }
```

**f.b的查找路径：**

f自身：没有 → `f.__proto`__(Object.prototype)：没有 → f.`__proto__.__proto__ `(Object.prototype.`__proto__`)：找不到，所以报错

---

## 2.5 请问js有哪些继承方式？

js常用继承方式主要有6种：原型链继承、构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承

创造一个超类型的构造函数Super()，为它设置静态属性name、原型链方法getSuper()

```js
function Super(){
    this.name =["super"];
}
Super.prototype.getSuper = function(){
    return this.name;
}
```

再创造一个子类构造函数Sub()，使用以上6种继承方法让Sub()继承Super()

```js
function Sub(){
    
}
```

---

### 1. 原型链继承

（将 子类的原型对象 指向 超类型的实例）**函数式继承**

```js
function Super(){
	this.name=["super"];
}
Super.prototype.getSuper=function(){
	return this.name;
}

function Sub(){

}

Sub.prototype=new Super();  //将Sub的原型对象Sub.prototype指向Super的实例

var sub1=new Sub();  //创建Sub的实例sub1
sub1.name.push("sub1");

console.log(sub1.getSuper());  // [ 'super', 'sub1' ]

var sub2=new Sub();  //创建Sub的实例sub2
sub2.name.push("sub2");

console.log(sub2.getSuper());  //[ 'super', 'sub1', 'sub2' ]
```

这样可以在Sub中继承 Super的属性name 以及 原型链方法getSuper，然而在sub1中修改name时，sub2的name也会受到影响

这种继承方式的**缺点**是：

（1）所有实例共享 超类中的属性

（2）子类的实例 不能向超类型构造函数传参

---

### 2.构造函数继承

（子类中使用call调用超类）**函数式继承**

```js
function Super(name){
	this.name=name;
}
Super.prototype.getSuper=function(){
	return this.name;
}

function Sub(name){
	Super.call(this,name);  //在Sub中使用call去调用Super
}


var sub1=new Sub("sub1");  //创建Sub的实例sub1,

//console.log(sub1.getSuper());  //(不能继承原型链方法）TypeError: sub1.getSuper is not a function
console.log(sub1.name);  //  sub1

var sub2=new Sub();  //创建Sub的实例sub2

//console.log(sub2.getSuper());  //(不能继承原型链方法）TypeError: sub2.getSuper is not a function
console.log(sub2.name);  //undefined

var sup1=new Super();
console.log(sup1.getSuper());  //undefined
```

在Sub中用call调用Super，继承了Super的所有静态属性。在实例sub1、sub2中，各自对name的修改也互不影响，**实现了属性不共享，子类的实例也能向超类型构造函数传参**  

这种继承方式的**缺点**是：

（1）、不能继承原型链方法

---

### 3.组合继承

（原型链继承+构造函数继承）函数式继承

```js
function Super(name){
	this.name=name;
}
Super.prototype.getSuper=function(){
	return this.name;
}

function Sub(name){
	Super.call(this,name);  //第二次调用，构造函数继承
}

Sub.prototype=new Super();  //第一次调用，原型链继承
Sub.prototype.constructor=Sub;

var sub1=new Sub("sub1");  //创建Sub的实例sub1,

console.log(sub1.getSuper());  //sub1
console.log(sub1.name);  //  sub1
console.log(sub1 instanceof Sub);  // true
console.log(sub1 instanceof Super);  // true

var sub2=new Sub("sub2");  //创建Sub的实例sub2

console.log(sub2.getSuper());  // sub2
console.log(sub2.name);  //sub2

```

在子类Sub中，使用 call继承超类型的属性 + 原型链继承原型链的方法和属性，弥补了上面两种继承方式的三个缺点

这种继承方式的**缺点**是：

（1）、调用了两次超类型的构造函数

第一次：Sub.prototype = new Super()，调用一次超类型构造函数

第二次：Sub内使用call方法，又调用了一次超类型构造函数，且之后每次实例化子类sub1、sub2...的过程中（ new Sub() ），都会调用超类型构造函数

---

### 4.原型式继承

创造了一个 临时的构造函数F，将 F的原型 指向传进来的对象参数，再返回F的实例）

```js
function object(o){
	function F(){}
	F.prototype=o;
	return new F();
}

var person={
	name:"js",
	friends:["css","ts"]
}

var people1=object(person);
// var people1 = Object.create(person);在传入一个参数的情况下，Object.create()和object()相同
people1.name="python";
people1.friends.push("pip");

console.log(people1.name);  //python
console.log(people1.friends);  //[ 'css', 'ts', 'pip' ]

var people2=object(person);
people2.name="java";
people2.friends.push("jar");

console.log(people2.friends);  //[ 'css', 'ts', 'pip', 'jar' ]

console.log(person.name);  //js
console.log(person.friends);  //[ 'css', 'ts', 'pip', 'jar' ]
```

原型式继承和原型链继承类似，区别：前者是完成了一次对 对象的浅拷贝，**后者是对构造函数进行继承**

**缺点**也是一致的：属性会被共享

---

### 5.寄生式继承

（基于原型式继承的封装）

```js
function object(o){
	function F(){}
	F.prototype=o;
	return new F();
}

function createAnother(o){
	var clone=object(o);
	clone.sayHi=function(){
		console.log("hi");
	}
	return clone;
}

var person={
	name:"js",
	friends:["css","ts"]
}

var people1=createAnother(person);
// var people1 = Object.create(person);在传入一个参数的情况下，Object.create()和object()相同
people1.name="python";
people1.friends.push("pip");

console.log(people1.name);  //python
console.log(people1.friends);  //[ 'css', 'ts', 'pip' ]

var people2=createAnother(person);
people2.name="java";
people2.friends.push("jar");

console.log(people2.friends);  //[ 'css', 'ts', 'pip', 'jar' ]

people1.sayHi();  // hi
people2.sayHi();  // hi
```

此方法使用较少，本质上可以通过寄生式继承 **实现子类方法sayHi的复用**，后面通过createAnother()创造出来的对象，都拥有sayHi方法

---

### 6.寄生组合式继承

在组合继承中，**若需要优化一次调用，那一定是第一次调用**：原型链继承，利用原型式继承便可实现

Sub.prototype = new Super()，实质上就是一次对超类型原型对象的拷贝

```js
function object(o){
	function F(){}
	F.prototype=o;
	return new F();
}

function inheritPrototype(subType,superType){
	//复制超类型的原型对象
	var clone=object(superType.prototype);
	//将构造函数指向子类型
	clone.constructor=subType;
	subType.prototype=clone;
}

function Super(name){
	this.name=name;
}
Super.prototype.getSuper=function(){
	return this.name;
}

function Sub(name){
	Super.call(this,name);  //第二次调用，构造函数继承
}


// 优化前：
// Sub.prototype = new Super();        //第一次调用
// Sub.prototype.constructor = Sub;
// 优化后：
inheritPrototype(Sub,Super);

var sub1=new Sub("sub1");  //创建Sub的实例sub1,

console.log(sub1.getSuper());  //sub1
console.log(sub1.name);  //  sub1
console.log(sub1 instanceof Sub);  // true
console.log(sub1 instanceof Super);  // true

var sub2=new Sub("sub2");  //创建Sub的实例sub2

console.log(sub2.getSuper());  // sub2
console.log(sub2.name);  //sub2
```

子类对超类型的原型对象的继承，分为以下几个步骤：

（1）、封装一个 inheritPrototype 函数

（2）、利用object（或Object.create()）复制出超类型的原型对象

（3）、将原型对象的构造函数指向自身（把名字改成自己的：clone.constructor = subType，**constructor相当于一张身份证，身份证上的名字一定得是自己）**

（4）、将拷贝出来的对象传递给子类的原型对象

结合性记忆：原型链继承+构造函数继承 = 组合继承；为了优化: 组合继承→原型式继承→寄生式继承→寄生组合式继承

---

## 2.6 请问js在new过程中到底做了什么？

在js日常开发中，常new一个构造函数或类得到对应实例，下面代码分别是利用ES5 构造函数与ES6 class类实现一个简单的创建实例

```js
// ES5 构造函数 
var Parent = function (name, age) {     
    this.name = name;     
    this.age = age; 
}; 
Parent.prototype.sayName = function () {           
    console.log(this.name); 
}; 
var child = new Parent('echo', 26); 
child.sayName() //echo

//ES6 class类
class Parent {     
    constructor(name, age) {         
        this.name = name;         
        this.age = age;     
    }     
    sayName() {         
        console.log(this.name);     
    } 
}; 
const child = new Parent('echo', 26); 
child.sayName() //echo
```

对于var child = new Parent('echo', 26)，要创建 Parent 的新实例，必须使用 new 操作符，以这种方式调用构造函数有以下几个步骤：

（1）、创建一个新对象，如var child =｛｝

（2）、新对象的`_proto_`属性指向构造函数的原型对象，

（3）、将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）

（4）、执行构造函数中的代码，将属性添加给child中的this对象

（5）、若构造器没有手动返回对象，则返回第一步创建的对象（新对象child）

通俗理解：在new一个对象时，新对象（新实例）没有prototype属性，所以把prototype属性赋值给新对象的`_proto_`属性

**`new`** 关键字会进行如下的操作：

1. 创建一个空的简单JavaScript对象（即`{}`）；
2. 为步骤1新创建的对象添加属性`__proto__`，将该属性链接至构造函数的原型对象 ；
3. 将步骤1新创建的对象作为`this`的上下文 ；
4. 如果该函数没有返回对象，则返回`this`。

---

## 2.7 请问如何js原生方法实现new方法？

可根据上题中的new()操作步骤加以理解性记忆，下面是参考代码：

```js
//定义 new 方法
let newMethod = function(Parent, ...rest){

	// 1.以构造器的prototype属性为原型，创建新对象；
	let newObj = Object.create(Parent.prototype);

	// 2.将this和调用参数传给构造器执行
	let result = Parent.apply(newObj, rest);

	// 3.如果构造器没有手动返回对象，则返回第一步的对象（4）
	return typeof result==="object" ? result : newObj;
};

function Person(name,age){
	this.name=name;
	this.age=age;
}

let person=newMethod(Person,"kop",66);
console.log(person.name);  // kop
console.log(person.age);  //66
```

---

## 3.1 请问你了解js中的this绑定机制吗？

this特点：

1. this是js的关键字之一，**它是对象自动生成的一个内部对象**，只能在对象内部使用
2. 随着使用场合的不同，this的值会发生变化，并不是一成不变的
3. this指向完全取决于：**什么地方以什么方式调用**，而不是 创建时

this 4种绑定机制：默认绑定、隐式绑定、显示绑定、new绑定，箭头函数的this不适用于这4种绑定机制，需要单独分析，将会在后续ES6新特性章节中做重点分析

### 1.默认绑定

（函数调用时无任何调用前缀的情景）  没有其他绑定规则存在时的默认规则，**也是函数调用中最常见情况**

```js
function fn1(){
  let fn2=function(){
    console.log(this);  //Window
    fn3();
  };
  console.log(this);  //Window
  fn2();
};

function fn3(){
  console.log(this);  //Window
};

fn1();

/*
<ref *1> Object [global] {
  global: [Circular *1],
  clearInterval: [Function: clearInterval],
  clearTimeout: [Function: clearTimeout],
  setInterval: [Function: setInterval],
  setTimeout: [Function: setTimeout] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  queueMicrotask: [Function: queueMicrotask],
  performance: Performance {
    nodeTiming: PerformanceNodeTiming {
      name: 'node',
      entryType: 'node',
      startTime: 0,
      duration: 107.68200016021729,
      nodeStart: 0.7476000785827637,
      v8Start: 7.08810019493103,
      bootstrapComplete: 55.69720005989075,
      environment: 25.186300039291382,
      loopStart: -1,
      loopExit: -1,
      idleTime: 0
    },
    timeOrigin: 1652074920565.308
  },
  clearImmediate: [Function: clearImmediate],
  setImmediate: [Function: setImmediate] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  }
}
*/
```

代码中无论函数声明在哪，在哪调用，**由于函数调用时前面并未指定任何对象，这种情况下this指向全局对象window**

注意：在严格模式下（use strict），全局对象将无法使用默认绑定，会报undefined错误

```js
function fn1(){
  console.log(this);  //Window
  console.log(this.a);  // 1
}

function fn2(){
  "use strict";
  console.log(this);  //undefined
  console.log(this.a);  // Uncaught TypeError: Cannot read properties of undefined (reading 'a')
}

var a=1;

fn1();
fn2();

```

### 2.隐式绑定

在函数调用时，前面存在调用它的对象，即函数的调用是在该对象上触发的，**调用位置上存在上下文对象，那this就会隐式绑定到该对象上**

```js
function foo(){
	console.log(this.a);
}

var a=2;
var obj={
	a:3,
	foo:foo
};

obj.foo();  // 3
```

代码中foo函数被当做引用属性，被添加到obj对象上。调用过程：获取obj.foo属性→ 根据引用关系找到foo函数，执行调用

这里对foo的调用存在上下文对象obj，**this进行了隐式绑定，即this绑定到了obj上，this.a被解析成了obj.a**

多层调用链（面试高频考题）（函数调用前存在多个对象，**this指向距离调用自己最近的对象**）

```js
function foo(){
	console.log(this.a);
}

var a=2;

var obj1={
	a:4,
	foo:foo
};

var obj3 = {
	b:10,
	foo: foo
}

var obj2={
	a:3,
	obj1:obj1,
	obj3: obj3,
	foo:foo
};


foo();  // 2
obj1.foo();  // 4
obj2.foo();  // 3
obj2.obj1.foo();  //4

obj2.obj3.foo();  // undefined
```

代码中调用链不只一层，存在obj1、obj2两个对象，先获取obj2.obj1→通过引用获取到obj1对象，再访问 obj1.foo →最后执行foo函数调用，获取最后一层调用的上下文对象，即obj1，所以结果是4（obj1.a）

#### 隐式丢失

在一些特殊情况下，**会存在隐式绑定丢失问题**，最常见：参数传递、变量赋值

**参数传递**

```js
function foo(){
	console.log(this.a);
}

function fn1(param){
	param();
}

var a=2;

var obj1={
	a:4,
	foo:foo
};

fn1(obj1.foo);  // 2
```

代码中将 obj.foo 作为参数传递进 fn1 中执行，**只是单纯地传递了一个函数而已**，this并没有跟函数绑在一起，**发生了隐式丢失**，this依旧指向window

**变量赋值（本质上与传参相同）**

```js
function foo(){
  console.log(this.a);
}

var a=2;

var obj1={
  a:4,
  foo:foo
};

let fn1=obj1.foo;
fn1();  // 2

```

### 3.显式绑定（call、apply、bind）

```js
function foo(){
	console.log(this.a);
}

var a=4;

let obj1={
	a:1,
};
let obj2={
	a:2,
};
let obj3={
	a:3,
};

foo();  // 4
foo.call(obj1);  // 1
foo.apply(obj2);  // 2

foo.bind(obj3)();  // 3

foo.apply(null);  // 4
foo.apply(undefined);  // 4
foo.bind(null)();  // 4
foo.bind(undefined)();  // 4
```

代码中，我们分别通过call、apply、bind改变了函数fn的this指向

通常，js中调用一个函数时（函数调用），函数处于一个被动的状态，**而call与apply让函数从被动变主动**，函数能主动选择自己的上下文，这种写法又称之为**函数应用**

注意：若使用函数应用的方法改变this指向时，**指向参数是null或者undefined，那么 this 将指向全局对象**

### 4.new 绑定

```js
function Fn(){
	this.a=1;
}

let obj=new Fn();

console.log(obj.a);  // 1
```

代码中，构造函数调用创建了一个新对象obj，而在函数体内，this将指向新对象obj上（可以抽象理解为新对象就是this）

---

**this绑定优先级**

如果一个函数调用存在多种绑定方法，this最终指向是什么呢？this绑定优先级为：

显式绑定 > 隐式绑定 > 默认绑定

new绑定 > 隐式绑定 > 默认绑定

注意：**不存在显式绑定和new绑定同时生效的场景**，若同时写会直接报错

---

### **1、作用域链与原型链有什么区别？**

作用域链：当**访问一个变量**时，首先在当前作用域查找标识符，如果没有找到就去**父作用域**找，作用域链**顶端**是全局对象window，如果window都没有这个变量则**报错**

原型链：当**在对象上访问某属性**时，首先会查找当前对象，如果没有就顺着**原型链**往上找，原型链**顶端**是null，如果全程都没找到则**返回undefined**，而不是报错

---

## 3.2 请问call、apply与bind有什么区别？

call、apply与bind：都能用于改变this绑定

**apply与call：**

都是函数应用，**指定this的同时也会执行函数**，参数传递方式不同

call与apply的绑定**只适用当前调用，调用完毕即失效**，下次要用还得重新绑

**call：**接受一个参数列表，第一个参数指向this，**其余的参数在函数执行时都会作为函数形参传入函数**

**apply：**除了第一个参数作为this指向外，其它参数都被包裹在一个**数组**中，在函数执行时同样会作为形参传入

```js
let o = {
    a: 1
};
function fn(b, c) {
    console.log(this.a + b + c);
};
// fn.call(this, arg1, arg2, ...);
fn.call(o, 2, 3); // 6
// fn.apply(this, [arg1, arg2, ...]);
fn.apply(o, [2, 3]); // 6
```

**bind：**

绑定this后**并不会立马执行**，而是**返回一个全新的boundFcuntion绑定函数**

bind属于**硬绑定**，返回的boundFunction的this指向**无法再次**通过bind、apply或 call **修改**

```js
let obj1={
	a:1
}
let obj2={
	a:2
}

function fn(b,c){
	console.log(this.a + b + c);
}

let fn1=fn.bind(obj1,2,3);

fn1();  //6

//尝试再次传入形参
fn1(4,4);  // 6

//尝试改变this
fn1.call(obj2);  //6
```

代码中， 当执行fn1时，**本质上等于window.fn1()**，如果this还能被改变，那this岂不是得指向window，那bind方法就毫无意义了

----

## 3.3 请问什么是浅拷贝？什么是深拷贝？两者有何区别？

深拷贝与浅拷贝简单区分方法：假设B复制了A，当修改A时，B是否改变，若B也跟着变化，说明是**浅拷贝**；若B没变化，则是**深拷贝**

注意：一般情况下，**深拷贝只针对较为复杂的object类型数据**

在js中， 分基本数据类型与引用数据类型，这两类数据存储分别是：

**基本数据类型**：名与值都存储在**栈内存**中，例如let a=1：

| 名   | 值   |
| ---- | ---- |
| a    | 1    |

当b=a时，b复制了a的值，栈内存会新开辟一个内存给b，例如：

| 名   | 值   |
| ---- | ---- |
| a    | 1    |
| b    | 1    |

当修改a=2时，对b并不会造成影响，因为此时的b具有独立的存储空间，不受a的影响了

----

**引用数据类型**：名存在**栈内存**中，值存在于**堆内存**中，栈内存会提供一个引用的地址指向堆内存中的值

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632990546361/CED43FA80498C5A06F84AEBC056ECA6F)

当b=a时，其实b复制了a的引用地址，而并非堆内存中的值

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632990559186/967F55AE7D26B8CCB6590C26CFCDAD2B)

而当a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，自然b也受影响，这就是所谓的浅拷贝

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632990569165/E829A2CEBAE11215E510B538F34432B5)

----

## 3.4 请问js如何实现深拷贝？

1. 递归复制所有层级属性

   （面试高频撕代码题）

可理解为一层层地复制对象中的属性， 直到值为基础类型，缺点：代码较为复杂

```js
//使用递归的方式实现数组、对象的深拷贝

function deepClone(obj){
	//判断要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝
	var objClone=Array.isArray(obj) ? [] : {};
	//进行深拷贝的不能为空，并且是对象
	if (obj && typeof obj === "object") {
		for (key in obj){
			if (obj.hasOwnProperty(key)) {
				if (obj[key] && typeof obj[key] === "object") {
					objClone[key]=deepClone(obj[key]);
				}else{
					objClone[key]=obj[key];
				}
			}
		}
	}
	return objClone;
}

let obj1={
	a:1,
	b:{
		c:2
	},
	d:[3,4,5],
	e:true
}

let obj2=deepClone(obj1);

obj2.b.c=66;

console.log(obj1.b.c);  //2
console.log(obj2.b.c);  //66
```

2. 借助JSON对象的parse和stringify

利用js的内置对象JSON来进行**数组对象**的深拷贝，缺点：无法实现对象中**方法**的深拷贝

```js
function deepClone(obj){
	var _obj=JSON.stringify(obj);
	var objClone=JSON.parse(_obj);
	return objClone;
}

let nums = [1, 2, 3];
let nums2 = deepClone(nums);
nums[1] = 4;
console.log(nums);  //  [ 1, 4, 3 ]
console.log(nums2);  //  [ 1, 2, 3 ]

let obj = {
	a: 1,
	foo : function(){
		console.log("foo");
	}
}

let obj2 = deepClone(obj);

console.log(obj);  //  { a: 1, foo: [Function: foo] }
console.log(obj2);  //  { a: 1 }
```

stringify() → JavaScript对象序列化为JSON字符串

parse() → 把JSON字符串解析为原生JavaScript值

3. 通过jQuery的extend方法

```js
var array = [1,2,3,4];
var newArray = $.extend(true,[],array);    
```

4. Object.assign()拷贝

当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，**此方法，在二级属性以后就是浅拷贝**

```js

let obj1={
	a:1,
	b:{
		c:2
	},
	d:[3,4,5],
	e:true
}

let obj2=Object.assign({}, obj1);

obj2.b.c=66;
obj2.a=10;

console.log(obj1.a);  //1
console.log(obj2.a);  //10

console.log(obj1.b.c);  //66
console.log(obj2.b.c);  //66
```

5. lodash函数库

lodash是一个很热门的函数库，可利用lodash.cloneDeep()[实现深拷贝](https://www.lodashjs.com/docs/lodash.cloneDeep#_clonedeepvalue)

```bash
$ cnpm i lodash --save
```



```js
var _ = require("lodash");

let obj1={
	a:1,
	b:{
		c:2
	},
	d:[3,4,5],
	e:true
}

let obj2=_.cloneDeep(obj1);

obj2.b.c=66;
obj2.a=10;

console.log(obj1.a);  //1
console.log(obj2.a);  //10
console.log(obj1.b.c);  //2
console.log(obj2.b.c);  //66
```



---

## 3.5 请问js如何判断一个变量是空对象？

**1.for in** 

利用for in 循环遍历对象和对象原型上的**可枚举属性**

缺点：**只能遍历可枚举属性**，若一个对象上只有不可枚举属性的话，会判断错误

```js
function isEmptyObj(obj){
	for (let i in obj){
		return false;  //能遍历，不为空
	}
	return true;
}

let a={};
let b=[];
let c="";

console.log(isEmptyObj(a));  // true
console.log(isEmptyObj(b));  // true
console.log(isEmptyObj(c));  // true
```



  **2.** **Object.keys()** 

```js
console.log(Object.keys(obj).length===0)
```

Object.keys能返回对象自身上**所有可枚举属性的名称**所构成的数组，若数组长度为0，那就是一个空对象

缺点：如for in断一样，Object.keys方法也只返回可枚举属性

```js
let a={};
let b=[];
let c="";

console.log(Object.keys(a).length===0);  // true
console.log(Object.keys(b).length===0);  // true
console.log(Object.keys(c).length===0);  // true
```

  **3. 将对象转化为json字符串**

```js
console.log(JSON.stringify(obj)==='{}')
```

```js
let a={};
let b=[];
let c="";

console.log(JSON.stringify(a));  // {}
console.log(JSON.stringify(b));  // []
console.log(JSON.stringify(c));  // ""
```

  **4.** **Object.getOwnPropertyNames()**

```js
console.log(Object.getOwnPropertyNames(obj).length == 0)
```

Object.getOwnPropertyNames方法获取到对象中的属性名，存到一个数组中，返回数组对象，若数组长度为0，则是空对象

缺点：此方法是Object.keys的改进，**可获取到不可枚举属性**，**但该方法无法获取Symbol属性**

```js
let a={
	[Symbol("a")]:1
};
let b=[];
let c="";

console.log(Object.getOwnPropertyNames(a).length===0);  // true
console.log(Object.getOwnPropertyNames(b).length===0);  // false
console.log(Object.getOwnPropertyNames(c).length===0);  // false
```

  **5. Reflect.ownKeys()**

```js
console.log(Reflect.ownKeys(obj).length===0)
```

Reflect.ownKeys也可以返回对象自身属性名所构成的数组，**该方法可以返回不可枚举属性以及Symbol属性**

```js
let a={
	[Symbol("a")]:1
};
let b=[];
let c="";

console.log(Reflect.ownKeys(a).length===0);  // false
console.log(Reflect.ownKeys(b).length===0);  // true
console.log(Reflect.ownKeys(c).length===0);  // TypeError: Reflect.ownKeys called on non-object
```

---

### **1、什么可枚举属性？什么是不可枚举属性？**

可枚举属性是指内部**可枚举标志**（enumerable）设置为true的属性，不可枚举属性即是enumerable为false（摘自MDN）

---

### **2、js遍历对象各个方法区别总结**

| 方法                           | 基本属性 | 原型链属性 | 不可枚举属性 | symbol属性 |
| ------------------------------ | -------- | ---------- | ------------ | ---------- |
| for in                         | ✔        | ✔          | ✖            | ✖          |
| Object.keys()                  | ✔        | ✖          | ✖            | ✖          |
| Object.getOwnPropertyNames()   | ✔        | ✖          | ✔            | ✖          |
| Object.getOwnPropertySymbols() | ✖        | ✖          | ✔            | ✔          |
| Reflect.ownKeys()              | ✔        | ✖          | ✔            | ✔          |

**for in （遍历key）**：可遍历到原型对象上的属性 ，用hasOwnProperty()方法过滤, 可遍历得到字符串类型的键值，通常不适用于数组遍历

**Object.values() 、Object.keys() ：**可自动过滤原型链上的属性

**Object.getOwnPropertyNames()：**可遍历不可枚举的属性

**Reflect.ownkeys()：** 可遍历不可枚举的属性 和 Symbol属性

---

## 3.6 请问js有哪些遍历数组的方法？

 **1.** **for循环**

用临时变量将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果比较明显，写法比较繁琐

```js
for(let j = 0,len=arr.length; j < len; j++) {
    
}
```

  **2.** **forEach（）**

遍历数组中的每一项，没有返回值，即使有return，也不会返回任何值，对原数组没有影响，不支持IE浏览器，执行速度比map()快

```js
//参数：item数组中的当前索引的值, index当前项的索引, array原始数组
arr.forEach((item,index,array)=>{
    
})    
```

  **3.** **map（）**

**创建一个新的数组，新数组的每一个元素由调用数组中的每一个元素执行提供的函数得来**，有return返回值

return的意义：不影响原来的数组，**只是把原数组克隆一份**，改变克隆的数组中的对应项

```js
let a=[1,2,3,4,5];

let b=a.map((item,index,arr)=>{
	return item**2;
});

console.log(a);  //[ 1, 2, 3, 4, 5 ]
console.log(b);  // [ 1, 4, 9, 16, 25 ]
```



  **5.** **for of**

遍历value，适用遍历数组对象、字符串、map、set等**拥有迭代器对象**的集合，**不能遍历对象**，**因为没有迭代器**

与forEach()区别：可以正确响应break、continue和return语句

与for in 区别：无法循环遍历对象，**不会遍历自定义属性**

```js
for (var value of arr) { 
    console.log(value); 
}

let a=[1,2,3,4,5];

for (let i of a){
	console.log(i);  // 1 2 3 4 5
}

let obj={
	a:1,
	b:2
}

for (let o of obj){  //TypeError: obj is not iterable
	console.log(o);
}
```

  **6.** **reduce()**

接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，得出最终计算值

相当于：**为数组中的每一个元素依次执行回调函数**，不包括数组中被删除或从未被赋值的元素

```js
arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)
```



各参数意义：

| function()   | 必需 | 用于执行每个数组元素的函数     |
| ------------ | ---- | ------------------------------ |
| total        | 必需 | 初始值, 或者计算结束后的返回值 |
| currentValue | 必需 | 当前元素                       |
| currentIndex | 可选 | 当前元素的索引                 |
| arr          | 可选 | 当前元素所属的数组对象         |
| initialValue | 可选 | 传递给函数的初始值             |

一起看几个reduce()的实际应用（面试时可能要求撕代码）

- **简单用法：数组求和，求乘积**

```js
let a=[1,2,3,4,5];

console.log(a.reduce((prev,curr,index,arr) => prev+curr));  //15
console.log(a.reduce((prev,curr,index,arr) => prev*curr));  //120

```

- **复杂用法：**

计算数组中每个元素出现的次数

```js
let nums=[1,2,3,4,5,2,3,5];

let ans=nums.reduce((prev,curr)=>{
	if (curr in prev) {
		prev[curr]++;
	}else{
		prev[curr]=1;
	}
	return prev;
},{})
console.log(ans);  //{ '1': 1, '2': 2, '3': 2, '4': 1, '5': 2 }

```

数组去重（ 面试高频撕代码题）

```js
let nums=[1,2,3,4,5,2,3,5];

let ans=nums.reduce((prev,curr)=>{
	if (!prev.includes(curr)) {
		return prev.concat(curr);
	}else{
		return prev;
	}
},[])
console.log(ans);  //[ 1, 2, 3, 4, 5 ]

```

将多维数组转化为一维（又名数组扁平化， 面试高频撕代码题）

```js
let nums=[1,2,3,[4,5,[2,3]],5];

var FlatArr=function(arr){
	return arr.reduce((prev,curr)=>prev.concat(Array.isArray(curr) ? FlatArr(curr) : curr),[]);
}

let ans=FlatArr(nums);
console.log(ans);  //[1, 2, 3, 4, 5, 2, 3, 5 ]

```

---

# js高级

----

## 4.1 请问什么是函数防抖？什么是函数节流？

**函数防抖**(debounce)：触发高频事件后n秒内，函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

**函数节流**(throttle)：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

两者**都是为了限制函数的执行频次**，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象

可结合下图对两者进行区分：

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633667352451/6AF15ACD40C68A84BAD11D4A2F5981F6)

**防抖：**

实现思路：在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时

特点：如果事件在规定的时间间隔内被不断的触发，则调用方法被不断的延迟，**当遇到不断触发但是仍然需要触发的情况，应该选用节流**

只有当高频事件停止，**最后一次事件触发的超时调用才能在wait时间后执行**

```js
function debounce(fn,wait){
	var timeout;  //用来存放定时器的返回值，一触发就重新计时
	return function(){
		var context=this;
		//把前一个 setTimeout clear 掉
		clearTimeout(timeout);
		//又创建一个新的 setTimeout,保障间隔时间内持续触发，不会执行fn函数
		timeout=setTimeout(function(){
			fn.apply(context);
		},wait);
	}
}
```

防抖 (debounce)

防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。

特点：等待某种操作停止后，加以间隔进行操作

- 持续触发不执行
- 不触发的一段时间之后再执行

想要了解一个概念，必先了解概念所应用的场景。在 JS 这个世界中，有哪些防抖的场景呢

1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
2. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖
3. 文本编辑器实时保存，当无任何更改操作一秒后进行保存
4. `mousemove` 鼠标滑动事件
5. Select 去服务端动态搜索功能

代码如下，可以看出来**防抖重在清零 `clearTimeout(timer)`**

```javascript
function debounce (f, wait) {
  let timer
  return (...args) => {
    clearTimeout(timer)
    timer = setTimeout(() => {
      f(...args)
    }, wait)
  }
}
```

---

**节流：**（每隔一段时间发一次 Ajax 请求，用节流）

规定一个单位时间，**在这个单位时间内，只能有一次触发事件的回调函数执行**，如果在同一个单位时间内某事件被触发多次，只有一次能生效

实现思路：通过判断是否到达一定时间来触发函数，**若没到规定时间则使用计时器延后**，而下一次事件则会重新设定计时器

```js
function throttle(fn,delay){
	let canRun=true;  //通过闭包保存一个标记
	return function(){
		//在函数开头判断标记是否为true,不为true 则return
		if (!canRun) {
			return;
		}
		//立即设置为false
		canRun=false;
		//将外部传入的函数的执行放在setTimeout中
		setTimeout(()=>{
			//最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了
			//当定时器没有执行的时候标记永远是false,在开头被return掉
			fn.apply(this,arguments);
			canRun=true;
		},delay);
	};
}
```

节流 (throttle)

节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。

特点：每等待某种间隔后，进行操作

- 持续触发并不会执行多次
- 到一定时间 / 其它间隔 ( 如滑动的高度 )再去执行

1. `scroll` 事件，每隔一秒计算一次位置信息等
2. 浏览器播放事件，每个一秒计算一次进度信息等
3. input 框实时搜索并发送请求展示下拉列表，没隔一秒发送一次请求 (也可做防抖)
4. 埋点场景。商品搜索列表、商品橱窗等，用户滑动时 定时 / 定滑动的高度 发送埋点请求
5. 运维系统查看应用运行日志时，每 n 秒刷新一次

代码如下，可以看出来**节流重在开关锁 `timer=null`**

```javascript
function throttle (f, wait) {
  let timer
  return (...args) => {
    if (timer) { return }
    timer = setTimeout(() => {
      f(...args)
      timer = null
    }, wait)
  }
}
```



----

## 4.2 请问js有哪些数组去重方法？

### **1.for循环（两次嵌套）+ 新数组**

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	let flag=true;  //元素是否存在重复
	const result=new Array();
	for(let i=0;i<arr.length;i++){
		flag=true;
		for(let j=i+1;j<arr.length;j++){
			if (arr[i]===arr[j]) {
				//遇到重复的退出该次循环,即保留的是重复元素中最后面的一个
				flag=false;
				break;
			}
		}
		if (flag) {  //如果从该元素往后没有重复
			result.push(arr[i]);
		}
	}
	return result;
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 4, 5, 3, 2 ]
```

涉及到多次遍历，执行时间较长

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	if (arr.length===0){
		return arr;
	}
	let flag=true;  //元素是否存在重复
	const result=new Array();
	result.push(arr[0]);

	for(let i=1;i<arr.length;i++){
		flag=true;
		for(let j=0;j<result.length;j++){
			if (arr[i]===result[j]) {  //比较新数组中是否存在
				//存在则退出该次循环
				flag=false;
				break;
			}
		}
		if (flag) {  //不存在则加入
			result.push(arr[i]);
		}
	}
	return result;
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **2.for循环（两次嵌套）+ splice （ES5中最常用）**

双层循环，外层循环元素，内层循环时比较值，值相同时，删除这个值

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	if (arr.length===0){
		return arr;
	}
	for(let i=0;i<arr.length;i++){
		for(let j=i+1;j<arr.length;j++){
			if (arr[i]===arr[j]) {
				//遇到重复的删除后一个
				arr.splice(j,1);
				j--;  //这个减一很关键
			}
		}
	}
	return arr;
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **3.for 循环（一次） + indexOf() + 新数组**

对方法1进行改进，对新数组判定是否有该字符，可以调用 Array.prototype.indexOf 函数，执行时间缩减了很多

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	if (arr.length===0){
		return arr;
	}
	const result=new Array();
	for(let i=0;i<arr.length;i++){
		if (result.indexOf(arr[i])===-1) {
			result.push(arr[i]);
		}
	}
	return result;
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **4.sort 排序后去重**

利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素对比

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	if (arr.length===0){
		return arr;
	}
	arr=arr.sort();
	const result=new Array();
	result.push(arr[0])
	
	for(let i=1;i<arr.length;i++){
		if (arr[i]!==arr[i-1]) {
			result.push(arr[i]);
		}
	}
	return result;
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **5.Map哈希映射**

利用 ES6 中的 Map 集合替代前面方法中的新数组，调用Map.has替代indexOf()，Map.set 替代push()，执行速度比前面的方法都要快

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	if (arr.length===0){
		return arr;
	}
	let m=new Map();
	const result=new Array();

	for(let i=0;i<arr.length;i++){
		if (m.has(arr[i])) {
			//map.set(arr[i], true);
			m.set(arr[i],m.get(arr[i])+1);  //可以查看重复元素及其次数
		}else{
			//map.set(arr[i], false);   // 如果没有该key值
			m.set(arr[i],1);
			result.push(arr[i]);
		}
	}
	console.log(m);  //Map(5) { 1 => 1, 2 => 3, 3 => 2, 4 => 1, 5 => 1 }
	return result;
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **6.new Set() + Array.from()**

利用 ES6 中的 Set 集合，Set 集合是一种无重复元素的列表，new Set(arr)会自动剔除重复元素，Array.from(...)将 Set 集合转换为数组

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	return Array.from(new Set(arr));
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **7.new Set() + …(展开运算符)**

思路与方法6一致，只是将 Set 集合转换为数组的实现方法从 Array.from(...) 改成了 ...(展开运算符)

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	return [...new Set(arr)];
}

console.log(removeRepeatElementOfArray(nums));  // [ 1, 2, 3, 4, 5 ]
```

### **8.for循环(一次) + 新对象**

将创建一个新数组，**改成创建一个新对象**，判定对象的 key 值，存在跳过，不存在则将字符以对象的 key 值存储

执行时间：所有的方法中最短的，**因为js对象的属性是基于Hash表实现**，对属性进行访问的时间复杂度可以达到O(1)，故此方法的时间复杂度为O(n) ；上述一般双重循环时间复杂度为O(n^2)

```js
let nums=[1,2,3,2,4,5,3,2];

function removeRepeatElementOfArray(arr){
	let obj={};
	for (let i=0; i < arr.length; i++){
		if (!obj[arr[i]]) {
			obj[arr[i]]=1;
		}
	}
	return Object.keys(obj);
}

console.log(removeRepeatElementOfArray(nums));  // [ '1', '2', '3', '4', '5' ]
```

---

## 4.3 请问你了解js事件循环机制（Event Loop）吗？

js是一门主要运行在浏览器的脚本语言，主要用途之一是操作DOM元素

若js同时有两个线程，对同一个DOM元素进行操作，这时浏览器应该听哪个线程的？如何判断优先级？为了避免这种问题，js必须是一门单线程语言。

**主线程**：即主线程会不停的从执行栈中读取事件，直至执行完所有栈中的同步代码

**任务队列**：当遇到一个异步事件后，js并不会一直等待异步事件返回结果，而是会将这个事件挂在与执行栈不同的队列中，即任务队列

**异步任务**：分为 宏任务（macrotask） 与 微任务 (microtask)，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行

**常见宏任务**(macrotask)：

script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)

**常见微任务**(microtask)：

Promise、 MutaionObserver、process.nextTick(Node.js环境）

Event Loop(事件循环)：宏任务 > 所有微任务 > 宏任务（主要针对V8）

1. 执行栈选择最先进入队列的宏任务(通常是script整体代码)，如果有则执行
2. 检查是否存在 Microtask，如果存在则不停地执行，直至清空 microtask 队列
3. 更新render(每一次事件循环，浏览器都可能会去更新渲染)
4. 重复以上步骤

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633673400290/7F695AB6524E72C0BC007BEFD17FC007)

一起看两道经典面试题：（主要考察执行顺序问题，考察频率极高）

```js
//题目一

setTimeout(function(){
	console.log(1);
});

new Promise(function(resolve,reject){
	console.log(2);
	resolve();
}).then(function(){
	console.log(3);
});

console.log(4);

// 2 4 3 1
```

**先执行script同步代码**：先执行Promise中的console.log(2)，再执行console.log(4)

**再执行微任务**：Promise的then函数

最后执行定时器中的console.log(1)，最终输出顺序为：2，4，3，1

注意：**对于Promise，本身是同步的**， **Promise.then是异步的**

```js
//题目二（稍微复杂一点，建议结合分析多看几遍）

console.log("script start");

async function async1(){
    //await  操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。
	await async2();
	console.log("async1 end");
}

async function async2(){
	console.log("async2 end");
}

async1();

setTimeout(function(){
	console.log("setTimeout");
},0);

new Promise(function(resolve,reject){
	console.log("Promise");
	resolve();
}).then(function(){
	console.log("promise1");
}).then(function(){
	console.log("promise2");
});

console.log("script end");

/*
script start
async2 end
Promise
script end
async1 end
promise1
promise2
setTimeout
*/
```

首先执行同步代码：

（1）、执行 console.log('script start')

（2）、执行 async1() ，马上执行 async2函数：console.log('async2 end')

（3）、执行 new Promise()中的同步函数：console.log('Promise')

（4）、最后执行 console.log('script end')，同步代码执行完毕

看剩下的异步代码：

（5）、setTimeout是宏任务，留到最后

----

剩下微任务：

```js
async function async1() {
  await async2()
  console.log('async1 end') 
}
new Promise(resolve => {
  resolve()
})
.then(function() {
  console.log('promise1') 
})
.then(function() {
  console.log('promise2') 
})
```

（6）、根据队列的先入先出方式，先执行 await async2() 后面的函数 console.log('async1 end') 

（7）、执行promise的resolve函数

```js
new Promise(resolve => { resolve() })
```

也就是两个then： console.log('promise1') 、console.log('promise2')

（8）、 最后执行宏任务 setTimeout函数 console.log('setTimeout')

综上所述，以上代码执行的顺序是：

“script start”、“async2 end”、“Promise”、“script end”、“async1 end”、“promise1”、 “promise2 ”、“setTimeout”

----

## 4.4 请问setTimeout与setInterval有何区别？

setTimeout() 是在载入后，延迟指定时间后，去执行一次表达式，次数只有一次

setInterval() 是指定某个任务每隔一段时间就执行一次，可以无限次的定时执行

通俗理解：setTimeout()是**延时器**，setInterval()是**定时器**

注意：setTimeout和setInterval都是不能保证时间精度的，他们的第二个参数（延时）**只能保证何时把代码添加到浏览器的任务队列中**，**不能保证添加到队列就会立即执行**

若队列前面还有其他任务，主线程被占用，那么就要等这些任务执行完再执行

---

## 4.5 请问js有哪几种方式创建对象？

1. 使用 Object 直接创建对象

```js
// 创建对象
var newObj = new Object()；
// 添加属性
newObj.property1 = value1;
newObj.property2 = value2;
// 添加方法
newObj.method1 = function () { };
newObj.method2 = function (a, b, c) { };
```

2. 使用new关键字调用 构造器 创建对象

```js
// 创建对象
function 对象名（参数1，参数2…）{
    this.property1 = 参数1;
    this.method1 = function ( ) { }
}
// 使用对象
var obj = new 对象名（参数1，参数2）;  
```

3. 使用JSON创建对象 （JOSN格式中**属性名要加双引号**）

```js
var object = {属性名1：属性值1，属性名2：属性值2，.....}
```

4. 组合使用**构造函数**和**原型模式**

```js
function Student(name, sex, grade){     
    this.name=name;     
    this.sex=sex;     
    this.grade=grade; 
}   
Student.prototype.sayName=function(){        
    console.log(this.name); 
}   
Student.prototype.school="nongda";
```

构造函数用于**定义实例的属性**，原型模式用于**定义方法和共享的属性**，可极大节约内存

-----

## 4.6 请问你了解js严格模式吗？

设立"严格模式"的意义：

- 消除js语法中的一些不合理、不严谨之处，减少一些怪异行为
- 消除代码运行的一些不安全之处，保证代码运行的安全
- 提高编译器效率，增加运行速度

使用"use strict"便可进入严格模式，通常有两种调用方法：

**针对整个文件**：将"use strict"放在文件的第一行，则整个文件都将以"严格模式"运行。

**针对单个函数**：将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行。

严格模式与非严格模式的一些常见区别：

- 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。**严格模式禁止这种用法，全局变量必须显式声明**，然后再使用

```js
'use strict'
a = 1 // 严格模式下将报错，非严格模式a变量会提升至全局作用域
```

- 严格模式创建了第三种作用域：eval作用域

正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。**严格模式下，eval语句本身就是一个作用域**，不再能够生成全局变量了，**它所生成的变量只能用于eval内部**

```js
'use strict'
eval('var a = 1')
console.log(typeof a) // 严格模式下为undefined;非严格模式下为number
```

- **禁止this关键字指向全局对象**，使用构造函数时，**如果忘了加new，this不再指向全局对象**
- **禁止删除变量**（ delete x）； 删除对象上不存在的属性也会报错

```js
function usualMode() {
    function fn() {} 
    var a = 1
    delete a // 不会报错，但实际上也没能删除变量a
    delete fn // 同delete a
}
usalMode() // 正常执行
 
function strictMode() {
    'use strict'
    function fn() {} 
    var a = 1
    delete a
}
strictMode() // 将报错
```

- 严格模式禁用with语法，使用将报错

```js
function usualMode() {
    with({a: 1}) {
    	console.log(a)
    }
}
usalMode() // 正常输出 1
 
function strictMode() {
    'use strict'
    with({a: 1}) {
    	console.log(a)
    }
}
strictMode() // 将报错
```

----

# ES6

---

## 1.1 请问什么是ES6，它有哪些新特性？

ECMAScript规定了浏览器脚本语言（js）的标准，ES6是一个泛指，包含ES5.1版以后的js的下一代标准，涵盖了ES2015、ES2016、ES2017等，（ES2015/2016/2017是正式名称，特指发布的正式版本语言标准的年份），通常提到的ES6一般指ES2015标准，有时也泛指“下一代js语言”

ES6相对于更加简洁，大幅度提高了开发效率，主要新增了以下特性：

（1）let声明变量、const声明常量

（2）箭头函数

（3）解构赋值变量（数组、变量）

```js
let [a, b, c] = [1, 2, 3];
let[a,[[b], c]]=[1,[[2],3]]; //a：1 b：2 c：3
```

（4）Set、Map数据结构

（5）Symbol数据类型

（6）Promise对象

（7）async、await

（8）class类

（9）ES 模块化（Moudule）

（10）函数默认参数

（11）函数的rest参数（...变量名），用于获取函数的多余参数，就不需要用arguments对象

```js
function add(...values){
    let sum = 0;
    for(var val of values){     
        sum += val;
    }
    return sum;
}
add(2,5,3)  //10
```

（12）模板字符串

（13）… 展开运算（延展操作符）

（14）元编程Proxy、Reflet

（15）迭代器Iterator 和 for...of 

（16）新增了一些Object对象方法

----

## 1.2 请问var、let 和 const 有何区别？

**作用域不同**：

var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的

let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效

**变量提升现象**：

var声明的变量会被**提升到作用域顶部**，并初始化为undefined

let、 const 声明的变量**会被提升到顶部，但在声明代码前不能使用**（暂时性死区），会被初始化undefined

**变量/常量**：

var 和 let 声明变量，const 声明只读常量

**暂时性死区**：

var 可以先使用，后声明，值为undefined

let 、const 必须先声明，后使用；**且const必须初始化赋值**

在let、const声明之前就访问对应的变量与常量，会抛出ReferenceError，产生**原因**：

由let/const声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，**但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问**（摘自ES2015语言标准）

简单来说：用let/const声明的变量会先在作用域中被创建出来，**但此时还未进行词法绑定，是不能被访问的**，会抛出错误。

从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为**TDZ(暂时性死区)**

----

### **1、const声明的变量是绝对的不可变吗？**

实际上，不是const变量的值不得改动，**而是变量指向的那个内存地址不得改动**。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量

对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，**const只能保证这个指针是不变的**，至于它指向的数据结构是否变化，是不可控的

---

## 1.3 请问ES6新增的Symbol数据类型有何特点？

**symbol** 是一种基本数据类型 （[primitive data type](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)）。`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："`new Symbol()`"。

每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。更进一步的解析见—— [glossary entry for Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol)。



为保证每个属性的名字都是独一无二，**从根本上防止属性名冲突**，ES6 引入Symbol数据类型

Symbol是第7种基础数据类型，表示独一无二的值，Symbol 值通过Symbol函数生成，对象的属性名现在可以有两种类型，**一种是本来的字符串**，另一种就是**新增的 Symbol 类型**

Symbol 数据类型特点：

（1）、凡属性名属于 Symbol 类型，就是独一无二的，可以保证不会与其他属性名产生冲突

（2）、Symbol数据类型可用 typeof 检测出来，返回“symbol”

（3）、Symbol函数前不能使用 new 操作，会报错，**因为生成的 Symbol 是一个基础类型的值，不是对象**，可理解为它是一种类似于字符串的数据类型

（4）、Symbol函数的参数只表示对当前Symbol值的描述，就算参数相同，Symbol函数的返回值是不相等的

```js
// 没有参数的情况 
let s1 =Symbol();
let s2 =Symbol();  
s1 === s2 // false  

// 有参数的情况 
let s1 =Symbol('foo');
let s2 =Symbol('foo');  
s1 === s2 // false
```

（5）、在Symbol 作为属性名，遍历对象的时，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()遍历返回

但它并不是私有属性，Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。**该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值**

**Reflect.ownKeys()方法**可以返回所有类型的键名，包括常规键名和 Symbol 键名

**常用方法：Symbol.for()：（全局注册）**

接受一个字符串作为参数，随后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，**并将其注册到全局，可以实现重新使用同一个 Symbol 值。**

----

## 1.4 请问ES6 class与ES5构造函数有什么联系？（如何用ES5的方式实现class？）

class其实是一个语法糖，使得js的编码更清晰、更人性化、风格更贴合面向对象的思想，为代码编译器、检查器提供方便

js生成新对象的传统方法是通过**构造函数**定义的，这种写法与传统的面向对象语言差异较大。故ES6引入了**class作为对象的生成模板**

```js
//ES5写法
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.toString = function() {
    return'('+ this.name + ','+ this.age + ')';
}

var person = new Person('TOM', 20);
console.log(person);// Person { name: 'Mia', age: 18 }

//ES6写法
class Person {
    constructor(name, age) {
    	this.name = name;
    	this.age = age;
    }
    toString() {    
    	return'('+ this.name + ','+ this.age + ')';
    }
}
var person = new Person('TOM', 20);
console.log(person);// Person { name: 'Mia', age: 18 }
```

由上述代码可得出：

（1）class类可以看做是**构造函数的另一种写法**

（2）class类的**数据类型就是函数**，typeof Person === 'function'为true

（3）也可以说class的**底层依然是function构造函数**

class类与构造函数区别：

（1）class内部定义的方法都是**不可枚举的**（non-enumerable），ES5中prototype的方法是可枚举的

（2）class**必须使用new调用**，否则会报错

（3）继承：class用extends实现继承

```js
class Person{
    constructor(skin,language){
        this.skin=skin;
        this.language=language;
    }
    say(){         
        console.log('I am a Person')
    }
}
```

**（1）子类没有constructor时**

```js
class American extends Person{
    aboutMe(){         
        console.log(this.skin+' '+this.language)
    }
}
```

子类American继承父类Person，子类没有定义constrcutor，**则会默认添加一个**，并且在constrcutor中调用super函数，相当于调用父类的构造函数。**调用super函数是为了在子类中获得父类的this，调用之后this指向子类**，也就是父类.prototype.constructor.call(this)

**（2）子类有constructor**

```js
class Chinese extends Person{
    constructor(skin,language,positon){
        //console.log(this);//在没有调用super之前输出this会报错
        super(skin,language);
        //super();//不给父类构造函数传参，父类的构造数的值为undefined       
        console.log(this);
        this.positon=positon;
    }
    aboutMe(){         
        console.log(this.x+' '+this.y+' '+this.positon);
    }
}
```

子类必须在constructor方法中调用super方法，否则new实例时会报错。**因为子类没有自己的this对象，而是继承父类的this对象**。**如果不调用super函数，子类就得不到this对象。**super()作为父类的构造函数，只能出现在子类的constructor()中；但是super指向父类的原型对象，可以调用父类的属性和方法

----

## 1.5 请问你了解js模块化吗？

js模块化所解决的问题：

**命名冲突**：一些变量和函数命名可能相同

**文件依赖**：一些需要从外部引入的文件数目、顺序

js模块化将按照功能将一个软件切分成许多单独部分，每个部分为一个模块，然后再组装起来。分模块进行使用与维护，提高开发效率。

js模块化发展过程：

**（1）script标签**

最早期的js文件加载方式，把每个文件看做一个模块，接口通常直接暴露在全局作用域（定义在window对象中）

缺点：加载顺序取决于script标签书写顺序

易污染全局作用域

各文件间的依赖关系较繁琐

**（2）CommonJS**

每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载，**在浏览器端，模块需要提前编译打包处理。**

```js
//暴露模块:
module.exports = value 或 exports.xxx = value

//引入模块：
require(xxx)
//如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

// module add.js
module.exports = function add (a, b) { return a + b; }
// main.js
var {add} = require('./math');
console.log('1 + 2 = ' + add(1,2);
```

**CommonJS加载模块是同步的，**只有加载完成，才能执行后面的操作，造成一个重大的局限：**不适用于浏览器**

同步加载对服务器端影响不大，可把所有的模块都存在本地硬盘，同步加载，等待时间就是读取硬盘时间。**但对于浏览器，因为模块都放在服务器端，等待时间取决于网速的快慢，长时间等待会造成浏览器处于”假死”状态**

**浏览器端的模块不能采用同步加载，**只能采用异步加载，便有了AMD

**（3）AMD**

非同步加载模块，允许指定回调函数，浏览器端一般采用AMD

优点： 

（1）适合在浏览器环境中异步加载模块 （2）可以并行加载多个模块

```js
//定义没有依赖的模块
define(function(){
    return 模块
})
//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})
//引入使用模块
require(['module1', 'module2'], function(m1, m2){
   //使用m1/m2
})
```

**（4）CMD**

**专门用于浏览器端**，模块的加载是异步的，模块使用时才会加载执行（延迟执行）

```js
//定义没有依赖的模块
define(function(require, exports, module){
    exports.xxx = value
    module.exports = value
})

//定义有依赖的模块
define(function(require, exports, module){
    //引入依赖模块(同步)
    var module2 = require('./module2')
    //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
    //暴露模块
    exports.xxx = value
})
//引入使用模块
define(function (require) {
    var m1 = require('./module1')
    var m4 = require('./module4')
    m1.show()
    m4.show()
})
```

CMD与AMD区别：

最大的区别是对依赖模块的执行时机处理不同，二者皆为异步加载模块

AMD**依赖前置**，js可以方便知道依赖模块是谁，立即加载

CMD**就近依赖**，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，延迟执行

**（4）UMD**

严格上说，UMD不能算是一种模块规范，它主要用来处理CommonJS、AMD、CMD的差异兼容，使模块代码能在不同的模块环境下都能正常运行，**是模块定义的跨平台解决方案**

**（5）ES6模块化**

设计思想：尽可能静态化，**使得编译时就能确定模块的依赖关系、输入和输出变量**，CommonJS 和 AMD 模块，都只能在运行时确定

```js
//导出模块方式
var a = 0;
export { a }; //第一种

export const b = 1; //第二种 

let c = 2;
export default { c }//第三种 

let d = 2;
export default { d as e }//第四种，别名

//导入模块方式
import { a } from './a.js' //针对export导出方式，.js后缀可省略
import main from './c' //针对export default导出方式,使用时用 main.c
import 'lodash' //仅仅执行lodash模块，但是不输入任何值
```

主要由export和import两个命令构成，export用于规定模块的对外接口，import用于输入其他模块提供的功能

**总结与对比：**

**CommonJS：**主要用于服务端，同步加载模块，并不适合在浏览器环境

**AMD：**在浏览器中异步加载模块，且可并行加载多个模块，但开发成本相对高，代码阅读和书写较困难，模块定义方式语义不顺畅

**CMD：**与AMD相似，都用于浏览器，依赖就近，延迟执行，很容易在Node.js中运行

**ES6模块化：**异步加载，有一个独立的模块依赖的解析阶段，实现相对简单，浏览器和服务器通用模块解决方案

---

## 2.1 请说说ES6新增了哪些对象方法？

**（1）Object.is()**

ES5中用 == 和 === 比较两个值是否相等，两者都有缺陷，== 会自动转换数据类型，=== NaN不等于自身，以及 +0 等于 -0。ES6 提出“Same-value equality”（**同值相等**）算法，即在所有环境中，只要两个值是一样的，则相等，Object.is()就是实现这个算法的新方法，用来比较两个值是否严格相等（除了两个特例，基本与 === 一致）

```js
Object.is('foo','foo') // true 
Object.is({},{}) // false

//与===的不同之处
Object.is(+0,-0) // false 
Object.is(NaN,NaN) // true

console.log(+0 === -0);  //  true
console.log(NaN === NaN);  //  false
```

**（2）Object.assign()**

用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）

常见用途：为对象添加属性、方法，克隆对象，合并多个对象，为属性指定默认值

```js
const target ={a:1};  
const source1 ={b:2}; 
const source2 ={c:3};  

Object.assign(target, source1, source2); 
console.log(target); // {a:1, b:2, c:3}
```

注意：

- Object.assign()方法是**浅拷贝**，而不是深拷贝，**若源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用**
- Object.assign()拷贝的属性是有限制的，**只拷贝源对象的自身属性**，不拷贝继承属性，不拷贝不可枚举属性
- 一旦遇到同名属性时，会直接替换，后面的属性会覆盖前面的属性
- 若**参数不是对象，则会先转成对象**；由于undefined和null无法转成对象，若它们作为参数，就会报错  

**（3）`__proto__`属性：**本质上是一个内部属性，而不是一个正式的对外的 API，若一个对象本身部署了`__proto__`属性，该属性的值就是对象的原型，实际上是调用了Object.prototype.`__proto__`

**（4）Object.setPrototypeOf()：**功能与`__proto__`相同，用于设置一个对象的原型对象，相较于`__proto__`是ES6推荐的方法

**（5）Object.getPrototypeOf() ：**用于读取一个对象的原型对象

**（6）Object.keys()：**遍历对象自身（不含继承的）所有可遍历属性的键名，以数组的方式返回

**（7）Object.values()：**遍历对象自身（不含继承的）所有可遍历属性的值，以数组的方式返回

**（8）Object.entries() ：**遍历对象自身（不含继承的）所有可遍历属性的健值对，以数组的方式返回（只输出属性名非 Symbol 值的属性）

```js
var obj ={ foo:'bar', baz:42}
Object.keys(obj) // ["foo", "baz"]
Object.values(obj) // ["bar", 42]
Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ]
```

**（9）Object.fromEntries()：**将一个键值对数组转为对象，Object.entries()逆操作

```js
Object.fromEntries([['foo','bar'],['baz',42]]) // { foo: "bar", baz: 42 }
```

**（10）Object.getOwnPropertyDescriptors()：**用来**获取一个对象的所有自身属性的描述符**，返回一个对象，所有原来的对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象

```js
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};
console.log(Object.getOwnPropertyDescriptors(obj));
/*
{
  foo: { value: 123, writable: true, enumerable: true, configurable: true },
  bar: {
    get: [Function: get bar],
    set: undefined,
    enumerable: true,
    configurable: true
  }
}
*/
```

---

## 2.2 请说说ES6新增了哪些数组方法？

**（1）扩展运算符**

扩展运算符：...，将一个数组转为用逗号分隔的参数序列，**该运算符主要用于函数调用**

```js
console.log(...[1,2,3]) // 1 2 3  
console.log(1,...[2,3,4],5) // 1 2 3 4 5 
```

**（2）Array.from（）**

用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）

```js
let arrayLike ={
    '0':'a',
    '1':'b',
    '2':'c',    
    length:3
};

// ES5的写法 
var arr1 =[].slice.call(arrayLike); // ['a', 'b', 'c']  
// ES6的写法 
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

**（3）数组实例的find（）和findIndex（）**

Array.prototype.find（）：用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，**返回该成员**。如没有符合条件的成员，则返回undefined

```js
[1,4,-5,10].find((n)=> n <0) // -5
```

Array.prototype.findIndex（）：与find方法非常类似，返回第一个符合条件的数组**成员的位置**，如所有成员都不符合条件，则返回-1

```js
[1,5,10,15].findIndex(function(value, index, arr){
    return value > 9;
}) // 2
```

**（4）数组实例的includes（）**

Array.prototype.includes（）：返回一个布尔值，表示某个数组是否包含给定的值，第二个参数表示搜索的起始位置，默认为0，与字符串的includes方法类似

```js
[1,2,3].includes(2) // true 
[1,2,3].includes(3,3); // false
```

---

## 2.3 请问你了解Set、Map数据结构吗？

- **Set**

类似于数组，但**成员的值是唯一的**，没有重复值

最常见应用：去除数组重复值、去除字符串里面的重复字符

```js
// 去除数组的重复成员 
[...newSet(array)]

// 去除字符串里面的重复字符
[...newSet('ababbc')].join('') // "abc"
```

- **WeakSet**

类似于Set，也是不重复的值的集合，与Set区别：

（1）WeakSet 的成员**只能是对象**，不能是其他类型的值

（2）WeakSet 中的对象都是**弱引用**，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果其他对象都不再引用该对象，那垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中

- **Map**

js对象本质上是键值对的集合（Hash 结构），但是只能用字符串当作键名，**一些非字符串类型的值作为键名前，都会被自动转换为字符串**

Map 正是为解决此问题，它类似于对象，也是键值对的集合，但是键名的范围不限于字符串，**各种类型的值（包括对象）都可以当作键名**

相比Object 结构，Object 是“字符串——值”对应，**Map是“值——值”的对应**

- **WeakMap**

结构于Map类似，也是用于生成键值对的集合，与Map区别：

（1）**只接受对象作为键名**（null除外），不接受其他类型的值作为键名

（2）WeakMap的键名所指向的对象，不计入垃圾回收机制

---

## 2.4 请你了解ES6中的迭代器与生成器吗？

Iterator迭代器是一种接口，为各种不同的数据结构提供统一的访问机制，**任何数据结构只要部署了 Iterator 接口，就可以完成迭代操作**（即遍历，依次处理该数据结构的所有成员）

**Iterator 的主要作用：**

（1）为各种数据结构，提供一个统一的、简便的访问接口

（2）使得数据结构的成员能够按某种次序排列

（3）当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口

**常见默认调用 Iterator 场景：**

for...of循环、解构赋值、扩展运算（...）、yield*

遍历数组也会调用遍历器接口，**任何接受数组作为参数的地方，几乎都调用了遍历器接口**，如Array.from()、Map()、Set()等



**Generator生成器**是一种异步编程解决方案，Generator 是一个状态机，封装了多个内部状态；它是一个迭代器对象生成函数，

执行 Generator 函数会返回一个迭代器对象，也就是说，**Generator 函数除了状态机，还是一个遍历器对象生成函数**。返回的迭代器对象，可以依次遍历 Generator 函数内部的每一个状态。

Generator 对比普通函数，外观上有两个主要特征：function关键字与函数名之间有一个**星号**，函数体内部使用yield表达式，定义不同的内部状态

```js
function* helloWorldGenerator(){   
    yield 'hello';    //yield表达式
    yield 'world';    //yield表达式
    return'ending';
}

var hw = helloWorldGenerator();
```

代码块定义了一个 Generator 函数：helloWorldGenerator，它内部有两个yield表达式，有三个状态：hello，world 和 return 语句（结束执行）

不同于普通函数，调用 **Generator 函数后不执行**，返回的不是函数运行结果，**而返回一个指向内部状态的指针对象**（迭代器对象）

且必须调用遍历器对象的**next方法**，使得指针移向下一个状态。可理解为：每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。Generator 函数是分段执行的，**yield表达式是暂停执行的标记**，而**next方法可以恢复执行**。

---

## 2.5 请问箭头函数与普通函数有哪些区别？

在外观上， 箭头函数省去了function关键字，使用“箭头”=>定义函数，使表达更加简洁，

```js
// 箭头函数写法 
var f = v => v; 
// 正常函数写法 
var f = function(v){
    return v;
};

// 箭头函数写法 
var f =() => 5; 
// 正常函数写法 
var f = function(){
    return 5
};

// 箭头函数写法 
var sum =(num1, num2)=> num1 + num2; 
// 正常函数写法 
var sum = function( num1, num2 ){
    return num1 + num2;
};
```

箭头函数很大程度简化了回调函数

```js
// 正常函数写法 
[1,2,3].map(function(x){
    return x * x;
}); 

// 箭头函数写法 
[1,2,3].map(x => x * x);
```

注意：

（1）箭头函数不会创建自己的this，**只会从自己的作用域链的上一层继承this**

（2）箭头函数的**this是定义时所在的对象**，不是使用时所在的对象

（3）箭头函数的**this指向是固定的**

（4）**不能**做构造函数，**不可**使用new命令，会报错

（5）箭头函数是**没有原型，没有prototype属性**，故不可使用new

（6）没有自己的arguments对象，**箭头函数中访问arguments实际上是外层局部（函数）执行环境中的值**

（7）**不可使用yield命令**，不能用作Generator 函数

一起看两道箭头函数的this指向的高频考题：（极有可能出代码题（面试官给代码，答输出））

箭头函数的this指向取决于外层作用域中的this，**外层作用域或函数的this指向谁，箭头函数中的this便指向谁**；且一旦箭头函数的this绑定成功，也无法被再次修改，**类似于硬绑定**

```js
var a = 'window'
var obj1 = {
    a: 1,
    fn1: function () {
            return () => console.log(this.a)
    }
}
var obj2 = {
    a: 2
};

obj1.fn1()(); // 1
obj1.fn1().call(obj2); // 1 

obj1.fn1.call(obj2)(); // 2
```

obj1.fn1()()等价于：

```js
var fn = obj1.fn1(); //fn1的this指向obj1,箭头函数this参考fn1的this
window.fn();//无法改变箭头函数this
```

obj1.fn1().call(obj2)等价于：

```js
var fn = obj1.fn1(); 
fn.call(obj2);//显式绑定无法改变this
```

obj1.fn1.call(obj2)()等价于：

```js
var fn = obj1.fn1.call(obj2);//fn1的this此时指向obj2,箭头函数的this跟着变化
window.fn();//隐式绑定无法改变箭头函数this
```

**注意：虽无法直接改变箭头函数this指向，但可以修改外层作用域的this间接修改箭头函数this**

```js
var name = 'window'  
function Person(a) {   
    this.a = a;   
    this.fn1 = () => console.log(this.a);   
    this.fn2 = function () {     
        return () => console.log(this.a);   
    }; 
};
var obj1 = new Person(1); 

var obj2 = new Person(2);  

obj1.fn1(); // 1
obj1.fn1.call(obj2); // 1

obj1.fn2()(); // 1
obj1.fn2().call(obj2); // 1

obj1.fn2.call(obj2)(); // 2
```

obj1.fn1()：构造函数在new的过程中this指向了obj1，于是箭头函数的this也指向obj1

obj1.fn1.call(obj2)等价于：

```js
var fn = obj1.fn1;//箭头函数this指向obj1 
fn.call(obj2);//箭头函数this无法改变
```

obj1.fn2()()：fn2指向obj1，箭头函数this同样指向obj1

obj1.fn2().call(obj2)：箭头函数无法被直接修改

obj1.fn2.call(obj2)()等价于：

```js
var fn = obj1.fn2.call(obj2);//fn2的this此时指向obj2,箭头函数的this跟着变化
window.fn();//隐式绑定无法改变箭头函数this
```



----

## 2.6 请说说你对Promise的理解？

**Promise三个优点：**

（1）可以很好地解决异步编程，将异步操作以同步操作的流程表达出来

（2）让回调函数变成更加规范的链式写法，避免了层层嵌套的回调“地域”

（3）可以处理并行任务，提供统一的对外接口

**Promise三种状态：**

（1）pending：进行中

（2）fulfilled(resolved)：已成功

（3）rejected：已失败

**Promise三个特点：**

（1）对象的状态不受外界影响，虽执行器函数的执行是**同步**的，但在Promise的状态未从Pending状态变更到其他状态前，then和catch里面的回调函数会放在队列里面等待状态变更以后才执行（**异步**）

（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果

（3）只有两种状态改变可能：pending→fulfilled、pending→rejected

**Promise三个缺点：**

（1）一旦新建Promise就会立即执行，**无法中途取消**

（2）**若不设置回调函数**，Promise内部抛出的错误，不会反应到外部

（3）当处于pending状态时，**无法得知操作现阶段处于哪一个阶段**

---

## 3.1 请问你能手写Promise吗？

Promise对象是一个构造函数，主要用来生成Promise实例

构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve函数 和 reject函数

```js
//创建一个Promise实例
const promise =new Promise(function(resolve, reject){ 
    // ... some code 
    if(/* 异步操作成功 */){
        resolve(value);
    }else{
        reject(error);
    }
});
```

**resolve 函数：**将 Promise 对象的状态从 pending → fulfilled ，在异步操作成功时调用，并将异步操作的结果，作为参数传递给注册在 then 方法上的回调函数（then方法的第一个参数）；

**reject 函数：**将 Promise 对象的状态从 pending → rejected ，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递给注册在 then 方法上的回调函数（then方法的第二个参数）

**then方法：**定义在原型对象 Promise.prototype 上，作用是为 Promise 实例添加状态改变时的回调函数，返回一个新的 Promise 实例（不是原来那个）。第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数

一步步写出Promise的结构（注意：写法有很多，大家一定要注重思考，理解Promise的工作原理，不要死记硬背一种代码）

下面是ES6版本的整体代码，摘自网络，仅供参考：

```js
// 先定义三个常量表示状态
const PENDING="pending";
const FULFILLED="fulfilled";
const REJECTED="rejected";

// 新建 MyPromise 类
class MyPromise{
	constructor(executor){
		// executor 是一个执行器，进入会立即执行
		// 并传入resolve和reject方法
		try{
			executor(this.resolve,this.reject);
		}catch(error){
			this.reject(error);
		}
	}
	
	status=PENDING;  // 储存状态的变量，初始值是 pending
	value=null;  // 成功之后的值
	reason=null;  // 失败之后的原因
	onFulfilledCallbacks=[];  //存储成功回调函数
	onRejectedCallbacks=[];  //存储失败回调函数

	// 更改成功后的状态
	resolve=(value)=>{
		// 只有状态是等待，才执行状态修改
		if (this.status===PENDING) {
			// 状态修改为成功
			this.status=FULFILLED;
			// 保存成功之后的值
			this.value=value;
			// resolve里面将所有成功的回调拿出来执行
			while(this.onFulfilledCallbacks.length){
				// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空
				this.onFulfilledCallbacks.shift()(value);
			}
		}
	}

	// 更改失败后的状态
	reject=(reason)=>{
		// 只有状态是等待，才执行状态修改
		if (this.status===PENDING) {
			// 状态成功为失败
			this.status=REJECTED;
			// 保存失败后的原因
			this.reason=reason;
			// resolve里面将所有失败的回调拿出来执行
			while(this.onRejectedCallbacks.length){
				this.onRejectedCallbacks.shift()(reason);
			}
		}
	}

	then(onFulfilled,onRejected){
		const realOnFulfilled=typeof onFulfilled==="function" ? onFulfilled : value=>value;
		const realOnRejected=typeof onRejected==="function" ? onRejected : reason=>{ throw reason};
		// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去
		const promise2=new MyPromise((resolve,reject)=>{
			const fulfilledMicrotask=()=>{
				//创建一个微任务等待 promise2 完成初始化
				queueMicrotask(()=>{
					try{
						//获取成功回调函数的执行结果
						const x=realOnFulfilled(this.value);
						//传入 resolvePromise 集中处理
						resolvePromise(promise2,x,resolve,reject);
					}catch(error){
						reject(error);
					}
				});
			}

			const rejectedMicrotask=()=>{
				// 创建一个微任务等待 promise2 完成初始化
				queueMicrotask(()=>{
					try{
						//调用失败回调，并且把原因返回
						const x=realOnRejected(this.reason);
						//传入 resolvePromise 集中处理
						resolvePromise(promise2,x,resolve,reject);
					}catch(error){
						throw error;
					}
				});
			}

			//判断状态
			if (this.status===FULFILLED) {
				fulfilledMicrotask();
			}else if (this.status===REJECTED) {
				rejectedMicrotask();
			}else if(this.status===PENDING){
				// 等待
				// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来
				// 等到执行成功失败函数的时候再传递
				this.onFulfilledCallbacks.push(fulfilledMicrotask);
				this.onRejectedCallbacks.push(rejectedMicrotask);
			}
		});
		return promise2;
	}

	//resolve 静态方法
	static resolve(parameter){
		//如果传入 MyPromise 就直接返回
		if (parameter instanceof MyPromise) {
			return parameter;
		}
		//转成常规方式
		return new MyPromise(resolve=>{
			resolve(parameter);
		});
	}

	// reject 静态方法
	static reject(reason){
		return new MyPromise((resolve,reject)=>{
			reject(reason);
		});
	}
}

function reslovePromise(promise2,x,resolve,reject){
	//如果相等了，说明return的是自己，抛出类型错误并返回
	if (promise2===x) {
		return reject(new TypeError("Chaining cycle detected for promise #<Promise>"));
	}
	//判断x是不是 MyPromise 实例对象
	if (x instanceof MyPromise) {
		//执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected
		//x.then(value=>resolve(value),reason=>reject(reason));
		// 简化之后
		x.then(resolve,reject);
	}else{
		//普通值
		resolve(x);
	}
}

module.exports=MyPromise;
```

**Promise.all()：**

将多个Promise，包装成一个新的Promise，只有当所有Promise都成功，新的Promise才成功，一个失败就返回失败的Promise

一些日常开发中十分实用的点：

（1）Promise.all()获得的成功结果的数组里面的数据顺序和Promise.all()接收到的数组顺序是一致的，即便后面的结果返回得慢

（2）Promise.all()可以充分利用并行的优势，**返回结果的时间是最长请求的时间**，这样可以更快处理请求的结果

**Promise.race()：**

将多个Promise，包装成一个新的Promise，**新Promise的结果由第一个完成的Promise决定**， 第一个成功则返回成功的Promise，第一个失败直接返回失败的Promise

```js
/*Promise 函数对象all方法，返回一个promise 只有当所有promise都成功，才成功，一个失败就失败*/
function all(promises){
    const values = new Array(promises.length) //用来保存所有成功value的数组,长度等于promises的长度
    //定义计数器，用来保存成功promise的数量
    let resolvedCount = 0
    
    //返回一个新的promise
    return new Promise((resolve,reject) =>{
        //遍历promises获取每个promise的结果
        promises.forEach((p,index) => {
            Promise.resolve(p).then(
                value => {
                //成功一次 加一
                    resolvedCount++
                // p成功，将成功的value保存values,不能直接push，得按照promises的顺序存
                    values[index] = value
                    //如果全部成功了，将return的promises改为成功
                    if (resolvedCount===promises.length) {
                        resolve(values)
                    }
                },
                reason => { //一个失败，整个失败
                    reject(reason)
                }
            )
        })
    })
}

/*Promise 函数对象race方法，返回一个promise，其结果由第一个完成的promise决定，看传入的promise数组 里谁最先完成，看第一个完成的是成功/失败*/
function race(promises){
    return new Promise((resolve,reject) =>{
    //遍历promises获取每个promise的结果
        promises.forEach((p,index) => {
            Promise.resolve(p).then(
                value => {
               //一旦有成功的，return的promise变为成功
                    resolve(value)
                },
                reason => { //一个失败，return的promise变为失败
                    reject(reason)
                }
            )
        })
    })
}
```

----

## 3.2 请问你了解async/await吗？

async/await本质上就是一个语法糖，底层实现是带有执行器的 Generator 函数，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await

可简单理解为 async 用于申明一个 函数 是异步的，**而 await 可认为是 async wait 简写**，用于等待一个异步方法执行完成

**async 函数：**返回的是一个 Promise 对象。如果在函数中 return一个直接量，async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象

```js
Promise.resolve(x)
//可看作为下面这句的简写
new Promise(resolve => resolve(x))
```

**Promise.resolve(x)：**可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例

若最外层没有 await 获取其返回值的情况下，应该用原来的方式：.then()链来处理返回的个 Promise 对象

**await ：**通常情况 async 函数返回一个 Promise 对象，**故 await 可以用于等 Promise 对象，实际上它在等一个返回值**。不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量

注意：await 是一个运算符，用于组成表达式，**表达式的运算结果取决于等到的返回值**：

（1）、返回值不是一个 Promise 对象，运算结果直接为该返回值

（2）、返回值是一个 Promise 对象，**await 会阻塞后面的代码**，等 Promise 对象完成resolve，随后得到 resolve 的值，作为 await 表达式运算结果，**通常 async 函数调用不会造成阻塞**，因为**它内部所有的阻塞都被封装在一个 Promise 对象中异步执行了**

**async/await 的优势：**处理 then 链，相当于进一步优化回调问题

可利用如下代码进行对比，假设有一共任务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。先用 setTimeout模拟异步操作：

```js
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}
function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}
function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}
function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

用 Promise 方式来实现这三个步骤的处理：

```js
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}

doIt();
```

用 async/await 实现：

```js
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}

doIt();
```

这个代码看起来会更清晰明了，几乎跟同步代码一样

---

## 3.3 请问async/await中如何进行错误处理？

await 后的异步操作出错，等同于async函数返回的 Promise 对象被reject，**所以最好把await 命令放在 try...catch 代码块中**

```js
//写法示例
async function myFunction(){
    try{     
        await somethingThatReturnsAPromise();
    }catch(err){     
        console.log(err);
    }
} 
```

此外，可在 await 后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误

对于多个 **await**命令后面的异步操作，**如果不存在继发关系，最好让它们同时触发**（可用promise.all()）

```js
let foo = await getFoo();
let bar = await getBar();

// 改写成：
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
```

注意：await **只能用在async函数之中**，如果用在普通函数，会报错

---

## 3.4 请问什么是Proxy？

Proxy 是 ES6 为了操作对象引入的一个新API，可以对目标对象的读取、函数调用等操作进行拦截，然后进行处理

**Proxy不直接操作对象，更像一种代理模式**，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些额外操作

基本用法：

一个 Proxy 对象由两个部分组成： target 、handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数：target 为目标对象， handler 是一个对象，声明了代理 target 的指定行为

```js
//具体实例:
let target = {     
    name: 'Tom',     
    age: 24 
} 
let handler = {     
    get: function(target, key) {         
        console.log('getting '+key);         
        return target[key]; // 不是target.key     
    },     
    set: function(target, key, value) {        
        console.log('setting '+key);         
        target[key] = value;     
    } 
} 
let proxy = new Proxy(target, handler) 
proxy.name     // 实际执行 handler.get 
proxy.age = 25 // 实际执行 handler.set 
// getting name 
// setting age
 // 25
```

Proxy的常用实例方法：

（1）、**get(target, propKey, receiver)，**用于 target 对象上 propKey 的读取操作

```js
let exam ={     
    name: "Tom",     
    age: 24 
} 
let proxy = new Proxy(exam, {   
    get(target, propKey, receiver) {     
        console.log('Getting ' + propKey);     
        return target[propKey];   
    } 
}) 
proxy.name  
// Getting name 
// "Tom"
```

（2）、set(target, propKey, value, receiver)，用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那set方法将不起作用

```js
let validator = {     
    set: function(obj, prop, value) {         
        if (prop === 'age') {             
            if (!Number.isInteger(value)) {                 
                throw new TypeError ('The age is not an integer');}                                          }            
             if (value > 200) {                 
                 throw new RangeError('The age seems invalid'); }         
             }         // 对于满足条件的 age 属性以及其他属性，直接保存                     
             obj[prop] = value;     
         } 
 };

 let proxy= new Proxy({}, validator) 
 proxy.age = 100; 
 proxy.age           // 100 
 proxy.age = 'oppps' // 报错 
 proxy.age = 300     // 报错
```

---

## 3.5 请问什么是Reflect ？

Reflect 同样也是 ES6 为了操作对象引入的一个新API，可以**用于获取目标对象的行为**，与 Object 类似，但是更易读，它的方法与 Proxy 是对应的

ES6 将Object的一些明显属于语言内部的方法移植到了 Reflect 对象上（现阶段某些方法同时存在于 Object 和 Reflect 对象上）

Reflect 对象对某些方法的返回结果进行了修改，使其更合理

Reflect 对象使用函数的方式实现了 Object 的命令式操作

（1）、**Reflect.get(target, name, receiver)，**查找并返回 target 对象的 name 属性

```js
let exam = {     
    name: "Tom",     
    age: 24,     
    get info(){         
        return this.name + this.age;     
    } 
} 
Reflect.get(exam, 'name'); // "Tom"  
// 当target对象中存在 name 属性的getter方法， getter方法的this会绑定

// receiver 
let receiver = {     
    name: "Jerry",     
    age: 20 
} 
Reflect.get(exam, 'info', receiver); // Jerry20  

// 当 name 为不存在于target对象的属性时，返回 undefined 
Reflect.get(exam, 'birth'); // undefined   

// 当 target 不是对象时，会报错 
Reflect.get(1, 'name'); // TypeError
```

（2）、**Reflect.set(target, name, value, receiver)，**将 target 的name属性设置为 value，返回值为 boolean ，true 表示修改成功，false 表示失败（当 target 为不存在的对象时，会报错）

```js
let exam = {     
    name: "Tom",     
    age: 24,     
    set info(value){         
        return this.age = value;     
    } 
} 
exam.age; // 24 
Reflect.set(exam, 'age', 25); // true 
exam.age; // 25   

// value为空时会将name属性清除 
Reflect.set(exam, 'age', ); // true 
exam.age; // undefined   

// 当target对象中存在name属性setter方法时，setter方法中的this会绑定receiver, 所以修改的实际上是receiver的属性, 
let receiver = {     
    age: 18 
} 
Reflect.set(exam, 'info', 1, receiver); // true 
receiver.age; // 1   
let receiver1 = {     
    name: 'oppps' 
} 
Reflect.set(exam, 'info', 1, receiver1); 
receiver1.age; // 1
```

（3）**、Reflect.ownKeys(target)，**用于返回 target 对象的所有属性，等同于 Object.getOwnPropertyNames +Object.getOwnPropertySymbols

```js
var exam = {   
    name: 1,   
    [Symbol.for('age')]: 4 
} 
Reflect.ownKeys(exam) // ["name", Symbol(age)]
```

----





----

# DOM事件相关

---

## 1.1 请问什么是同源策略？

源：就是**协议、域名和端口号**

同源策略：SOP（Same origin policy）是由Netscape公司1995年引入浏览器的一种约定，是浏览器最核心、最基本的安全功能，若缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，若两个URL的协议、域名、端口号都相同，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个ip地址，也是非同源的

非同源的URL在没有明确授权的情况下，不能读写对方资源（不能相互通信）

同源策略将限制以下几种行为：

（1）Cookie、LocalStorage 和 IndexDB 无法读取

（2）DOM 和 Js对象无法获得

（3）AJAX 请求不能发送

以下两种不受同源策略的限制：

（1）**页面中的链接**，**重定向**以及**表单提交**是不会受到同源策略限制

（2）**跨域资源的引入**，但是js不能读写加载的内容，如嵌入到页面中的<script src="..."></script>，<img>，<link>，<iframe>等

注意：

同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制

当A与B非同源时，从域名A下的一个页面获取域名B下的一个资源，是不被浏览器允许的， **浏览器还是会发出这个请求，但是它会拦截响应内容**（因为非同源，**不安全**）（请求是页面发出的，页面在浏览器中显示，**故发出的请求是通过浏览器代为执行**）

----

## 1.2 请问什么是跨域？有哪些常用的跨域方式？

受浏览器同源策略的限制，非同源的两个URL间不能通信，非同源的脚本不能操作其他源下面的对象，但在实际开发场景中， 这种情况经常出现， 此时**需要通过跨域进行非同源通信**

常见跨域解决方式：

（1）通过jsonp跨域

注意：jsonp和json并没有什么关系

原理：利用<script>标签进行跨域 **只能实现GET请求**

举例：a.com/jsonp.html想得到b.com/main.js中的数据

在a.com的jsonp.html里创建一个回调函数，动态添加<script>元素，向服务器发送请求，请求地址后面加上查询字符串，通过callback参数指定回调函数的名字，请求地址为：http://b.com/main.js?callback=xxx，在main.js中调用这个回调函数xxx，并且以JSON数据形式作为参数传递，完成回调，我们来看看代码：

```js
function addScriptTag(src) { 
    var script = document.createElement('script');
    script.setAttribute("type","text/javascript");  
    script.src = src;   
    document.body.appendChild(script); 
}  
window.onload = function () {
    addScriptTag('http://b.com/main.js?callback=foo');
}  //window.onload是为了让页面加载完成后再执行

function foo(data) {
    console.log(data.name+"欢迎您"); 
};
```

###### JSONP的介绍

JSONP：利用在页面中创建 `<script>` 节点的方法向不同域提交HTTP请求的方法。

JSONP跨域的基本原理：由于`script` 标签不受浏览器同源策略的影响，允许跨域引用资源。因此，通过动态创建 script 标签，然后利用 `src` 属性进行跨域。

JSONP的优点：不受同源策略的限制；兼容性好，在老的浏览器中可以运行；请求完毕后可以通过调用 callback 的方式回传结果。

JSONP的缺点：只支持 `GET` 这种HTTP请求；jsonp在调用失败的时候不会返回各种HTTP状态码；安全性：callback传入的参数是在后端进行了一次拼接，这即代表存在注入的可能，如果后端设计不当，是有可能出现安全风险的。

###### JSONP的封装

```javascript
// jsonp的封装
function jsonp(params) {
    // 创建script标签并加入到head中
    var callbackName = params.jsonp;
    var head = document.getElementsByTagName('head')[0];
    // 设置传递给后台的回调参数名
    params.data['callback'] = callbackName;
    var data = formatParams(params.data);
    var script = document.createElement('script');
    // 发送请求
    script.src = params.url + '?' + data;
    // 创建jsonp回调函数
    window[callbackName] = function (res) {
        head.removeChild(script);
        clearTimeout(script.timer);
        window[callbackName] = null;
        params.success && params.success(res);
    };
    head.appendChild(script);
    // 为了得知此次请求是否成功，设置超时处理
    if (params.time) {
        script.timer = setTimeout(function () {
            window[callbackName] = null;
            head.removeChild(script);
            params.error && params.error({
                message: '超时'
            });
        }, 500);
    }
}

// 格式化参数
function formatParams(data) {
    var arr = [];
    for (var name in data) {
        arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name]));
    };
    // 添加一个随机数，防止缓存
    arr.push('v=' + random());
    return arr.join('&');
}
        
// 获取随机数
function random() {
    return Math.floor(Math.random() * 10000 + 500);
}
```

###### JSONP的调用

```js
jsonp({
    url: url,
    jsonp: 'jsonpCallback',
    data: dataParams,
    success: function (res) {
        params.success && params.success();
    },
    error: function (error) {}
})
```



**（2）nginx反向代理跨域**

**原理：** 同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

**实现：**通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录

**（3） 跨域资源共享（CORS）**

**普通跨域请求：**只服务端设置Access-Control-Allow-Origin即可，前端无须设置

**带cookie请求**：前后端都需要设置。

```js
// 前端设置是否带cookie 
xhr.withCredentials = true
```

注意：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页

**（4）WebSocket协议跨域**

WebSocket 是HTML5一种新的协议，实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现（具体原理分析详见第三章-1.1-延伸考点4）

**（5）document.domain + iframe跨域**

**注意：**仅限主域相同，子域不同的跨域应用场景

**原理：**两个页面都通过js强制设置document.domain为基础主域，就实现了同域

**（6）location.hash + iframe**

**原理：** a与b跨域相互通信，通过中间页c来实现， 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信

**A域：**a.html -> B域：b.html -> A域：c.html

a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象

```html
//a.html
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);

    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>

//b.html
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>

//c.html
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

**（7）window.name + iframe跨域**

window.name属性的独特之处：**name值在不同的页面（甚至不同域名）加载后依旧存在**，并且**可以支持非常长的 name 值**（2MB）

通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域，可以巧妙地绕过了浏览器的跨域访问限制，同时又是安全操作

**（8）postMessage跨域**

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可解决以下问题：

a.页面和其打开的新窗口的数据传递

b.多窗口之间消息传递

c.页面与嵌套的iframe消息传递

d.上面三个场景的跨域数据传递

用法：postMessage(data，origin)

data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化

origin：协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"

例如：从a.html (http://www.domain1.com/a.html) ->        b.html(http://www.domain2.com/b.html) 

```html
//a.html
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');   // 向domain2传送跨域数据
    };
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);     // 接受domain2返回数据
</script>

//b.html
<script>
    window.addEventListener('message', function(e) {             alert('data from domain1 ---> ' + e.data);  //接收domain1的数据 
    var data = JSON.parse(e.data);         
    if (data) {             
    data.number = 16;             
    window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');     // 处理后再发回domain1
    }     
}, false);
 </script>
```

----

## 1.3 请问你了解浏览器的渲染机制？

首先，浏览器的渲染机制中有几个基本概念名称：

（1）、DOM：浏览器将HTML解析成树形的数据结构

（2）、CSSOM：浏览器将CSS解析成树形的数据结构

（3）、Render Tree：DOM和CSSOM合并后生成Render Tree（渲染树）

（4）、Layout：计算出Render Tree每个节点的具***置

（5）、Painting：通过显卡，将Layout后的节点内容分别呈现到屏幕上

浏览器整个渲染流程如下：

（1）、用户输入一个URL后，浏览器就会向服务器发出一个请求，请求URL对应的资源

（2）、接到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一颗DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点

（3）、将CSS解析成CSSOM树

（4）、根据DOM树与CSSOM树，构建Render Tree

（5）、浏览器会根据Render Tree能知道网页中哪些有节点，各个节点的CSS，以及各个节点的从属关系

（6）、计算出每个节点在屏幕中的位置后，最后一步就是Painting，根据计算出的规则，把内容画到屏幕上

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633683890278/9F4F2AB266BD95CA60C23F32300F594A)

注意：

浏览器在获得HTML文件后，是自上而下的加载，并在加载过程中进行解析与渲染

加载过程中：

遇到外部CSS文件和图片等静态资源时，浏览器会另外发送一个异步请求

遇到js文件时，HTML文件会挂起渲染的进程，等待js文件加载完毕后，再继续进行渲染，因为js可能会修改DOM，导致后续HTML资源白白加载，这也是为什么建议将js文件写在底部body标签前

----

## 1.4 请问如何解决浏览器加载js时的阻塞问题吗？

**（1）、推迟加载**

若页面初始的渲染并不依赖于js或CSS可以用推迟加载，最后在加载js和CSS，把引用外部文件的代码写在最后

**（2）、defer延迟加载**

```html
<script src="" defer></script>
```

在文档解析完成开始执行，并且在DOMContentLoaded事件之前执行完成，会按照在文档出现的顺序去下载解析，效果和把script放在文档最后</body>之前是一样

​    注意：defer最好用在引用外部文件中使用，用了defer不要使用document.write()方法，使用defer时最好不要请求样式信息，因为样式表可能尚未加载，浏览器会禁止该脚本等待样式表加载完成，相当于样式表阻塞脚本执行

**（3）、异步加载**

async异步加载：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执行



```html
 <script type="text/javascript" src="a.js" async></script>
```

**script dom element：**用js动态创建一个script元素添加在document中

注意：会阻止onload事件

```html
<script type="text/javascript">
    (function() {
     var s = document.createElement('script');
     s.type = 'text/javascript';
     s.async = true;                   //这句可以删除，但是效果不变。
     s.src = 'js/a.js';
     var x = document.getElementsByTagName('script')[0];
     x.parentNode.insertBefore(s, x);
 })();
</script>
```

**onload时异步加载：**与script dom element法差不多，但不是同时执行js和html，是等html的文件、图片之类的、页面所有的资源全部加载完成后再下载执行js，这样的方法可以避免阻塞onload事件的触发

**注意：**DOMContentLoaded与onload事件不同，DOMContentLoaded是页面解析完成，页面的dom元素可以使用，但是页面的图片、视频等资源可能还没加载完成

----

## 1.5 请问你了解什么是重绘？什么是回流？两者有何区别？

【考点映射】

- 重绘、回流、两者区别

【频率】★★★★★

【难度】☆

【参考答案】

**重绘：**

更换某个元素颜色，这样的行为是不影响页面布局，DOM树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染

常见情况：

（1）、回流必定引发重绘，但重绘也会单独触发

（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）

**回流：**

增删DOM节点，或修改一个元素的宽高，页面布局发生变化，DOM树结构发生变化，需要重新构建DOM树，而DOM树与渲染树是紧密相连的，DOM树构建完，渲染树也会随之对页面进行再次渲染

**常见情况：**

（1）、页面渲染初始化

（2）、DOM树变化（添加或者删除可见的DOM元素、元素位置改变）

（3）、Render树变化（元素尺寸改变：边距、填充、边框、宽度和高度）

（4）、浏览器窗口尺寸改变，resize事件发生

（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；

（6）、查询布局信息，包括offestLeft/Top/Width/Height、scrollLeft/Top/Width/Height、clientLeft/Top/Width/Height、浏览为了返回最新值，会触发回流

-----

## 2.1 请问在浏览器中输入 URL后，浏览器会做哪些工作？

【考点映射】

- 浏览器整个渲染过程

【频率】★★★★★

【难度】☆☆

【参考答案】

从输入URL到渲染出整个页面包括三个部分：

**（1）、DNS解析URL**

DNS解析就是寻找哪个服务器上有请求的资源，因为ip地址不易记忆，一般会使用URL域名（如[www.baidu.com](http://www.baidu.com/)）作为网址，DNS解析就是将域名“翻译”成IP地址

具体过程：

a、浏览器缓存：浏览器会按照一定的频率，缓存DNS记录

b、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会取操作系统中找

c、路由缓存：路由器也有DNS缓存

d、ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求

e、根服务器：ISP的DNS服务器找不到，就要向根服务器发出请求，进行递归查询

**（2）、浏览器发送请求与服务器交互**

a、浏览器利用tcp协议通过三次握手与服务器建立连接

http请求包括header和body，header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie，body中有请求的内容

b、浏览器根据解析到的IP地址和端口号发起http的get请求

c、服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

d、若状态码为200显示响应成功，浏览器接收到返回的HTML页面后，开始渲染页面

**（3）、浏览器对接收到的HTML页面进行渲染**

a、浏览器根据深度遍历的方式把HTML节点遍历成DOM树

b、将CSS解析成CSSOM树

c、将DOM树和CSSOM树构造成Render树

d、根据Render树计算所有节点在屏幕中的位置，进行布局（回流）

e、遍历Render树并调用硬件API绘制所有节点（重绘）

---

## 2.2 请问你了解浏览器缓存吗？

缓存可以重复利用文件，降低网络负荷，提高网页打开速度，提升用户体验

缓存分类：

从宏观上分为私有缓存和共享缓存，共享缓存就是那些能被各级代理缓存的缓存，私有缓存就是用户专享的，各级代理不能缓存

从微观上可以分为以下几类：

a、浏览器缓存

b、代理服务器缓存

c、CDN缓存

d、数据库缓存

e、应用层缓存

主要对浏览器的缓存进行分析：

![img](https://uploadfiles.nowcoder.com/compress/mw1000/images/20211008/897353_1633685850116/826C8F1D891122B9999FE81E1D55CA33)

**（1）、HTTP缓存：主要分为强缓存与协商缓存**

- 强缓存

强可理解为强制的意思，当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体由 respone header 的cache-control 控制，常见的设置是max-age public private no-cache no-store等，各类设置对应情况：

a、cache-control: max-age=xxxx，public

客户端和代理服务器都可以缓存该资源，客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code200 ，如果用户做了刷新操作，就向服务器发起http请求

b、cache-control: max-age=xxxx，private

只让客户端可以缓存该资源；代理服务器不缓存，客户端在xxx秒内直接读取缓存，statu code:200

c、cache-control: max-age=xxxx，immutable

客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

d、cache-control: no-cache

跳过设置强缓存，但不妨碍设置协商缓存；通常做了强缓存，只有强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端

e、cache-control: no-store

不缓存，客户端、服务器都不缓存

- 协商缓存

可理解为强缓存就是为资源设置一个有效时间，每次请求资源时都会检查是否过期，只有过期才会去请求服务器（可有效减少请求次数），当强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程协商缓存生效，返回304和Not Modified

在 response header里面的设置etag、last-modified

etag：每个文件具有唯一一个“标识”

last-modified：文件的修改时间，精确到秒

每次请求返回携带response header中的etag和last-modified，在下次请求时request header也会带上，服务端对比etag标识，判断资源是否更改，如更改直接返回新的资源，并更新response header的etag、last-modified，如资源不变，etag、last-modified不变，对客户端来说，每次请求都进行了协商缓存，即：

发请求-->资源是否过期？-->过期（没过期为强缓存）-->请求服务器-->服务器对比资源是否真的过期？-->没过期-->返回304状态码-->客户端用缓存的老资源

当服务端发现资源过期时：

服务器对比资源是否真的过期-？->过期-->返回200状态码-->客户端像第一次接收该资源一样，记录cache-control中的max-age、etag、last-modified等信息

**（2）、本地存储**

主要有：localStorage，sessionStorage和cookie，WebSql和IndexDB主要用在前端有大容量存储需求的页面上，如在线编辑浏览器或者网页邮箱，可以将数据存储在浏览器，应该根据不同的场景进行使用

- Cookie

由服务器生成，且前端也可设置，保存在客户端本地的一个文件，通过response header的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器

其中包含的信息：

a、用户ID、密码、浏览过的网页、停留的时间等信息，当该用户再打开该网站时，网站通过读取Cookie，就可以做出相应的动作，如身份校验、提示语等

b、还保存host属性，即网站的域名或ip，一个网站只能读取它自己放置的信息，不能读取其他网站的Cookie文件

Cookie 优点：给用户更人性化的使用体验，如自动登陆、提示语；弥补了HTTP无连接特性；可作为站点统计访问量依据

Cookie 缺点：无法解决多人共用电脑问题，具有安全隐患；Cookie文件容易被误删除；可人为修改host文件，可以非法访问目标站点的Cookie；容量较小，不能超过4kb；直接在response header上带数据安全性差

- LocalStorage（本地存储）

主要是开发人员在前端设置，一旦数据保存在本地后，就可避免再向服务器请求数据，从而减少不必要的数据请求，可以长期存储数据，没有时间限，遵循同源策略，不同的网站不能直接共用

一般浏览器localStorage支持的是5M大小，不同的浏览器会略有不同

LocalStorage 优点：拓展了Cookie的4k限制；可以将第一次请求的5M大小数据直接存储到本地，相比于Cookie节约带宽

LocalStorage 缺点：需要手动删除，否则长期存在；浏览器大小不一，版本的支持也不一样；只支持string类型的存储，JSON对象需要转换；本质上是对字符串的读取，存储内容过多会消耗内存空间，导致卡顿

- SessionStorage（会话存储）

同样是开发人员在前端设置，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据，大多数浏览器限制为5MB

- WebSQL

WebSQL 是在浏览器上模拟数据库，可以使用JS来操作SQL进行数据读写，使用 SQL 来操纵客户端数据库的 API（异步），现阶段使用较少

- IndexedDB

随浏览器的功能日益强大，越来越多的网站将大量数据储存在客户端，可减少从服务器获取数据，直接从本地获取数据

现有浏览器数据储存方案，都不适用于储存大量数据：Cookie 大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 大小在2.5MB 到 10MB 之间（各家浏览器不同），且不提供搜索功能，不能建立自定义的索引。

IndexedDB 是浏览器提供的本地数据库，可被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。但IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库

----



---

## 2.3 请问Cookie和Session的机制是什么？两者有什么区别？

cookie 机制是通过检查客户身上的“通行证”来确定客户身份，session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。session 可理解为在服务器上建立一份客户档案，客户来访的时候只需要查询客户档案表是否有该客户，**session 是基于 cookie 实现的**

cookie 和 session 的区别：

存储位置： cookie 存在于客户端，临时文件夹中；session 存在于服务器的内存中，一个 session 域对象为一个用户浏览器服务

安全性： cookie 是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；session 存放于服务器的内存中，所以安全性好

**生命周期**(以 20 分钟为例) ：cookie 的生命周期是累计的，从创建时，就开始计时，20 分钟后 cookie 生命周期结束； session 的生命周期是间隔的，从创建时，开始计时，在 20 分钟内，没有访问 session，那 session 生命周期被销毁。如在 20 分钟内（如在第 19 分钟时）访问过 session，那将重新计算 session 的生命周期。关机会造成 session 生命周期的结束，但是对 cookie 没有影响

**访问范围**： cookie 为多个用户浏览器共享；session 为一个用户浏览器独享

---

## 2.4 请问GET请求和POST请求区别？

参数传递：GET 参数通过 url 传递，POST 放在 body 中（http 协议规定，url 在请求头中，所以大小限制很小）

长度限制：GET 请求在 url 中传递的参数是有长度限制的，POST 没有

参数类型：对参数的数据类型，GET 只接受 ASCII字符（发起之前需要进行 UrlEncoding），而 POST 没有限制

回退影响：GET 在浏览器回退时是无害的，POST 会再次提交请求

安全性：GET 比 POST 不安全，参数直接暴露在 url 中，不能用来传递敏感信息

请求过程：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包（大多数浏览器）。对于 GET 请求，浏览器会把 http 的 header 和 data 一并发送出去，服务器响应200（返回数据）；而 POST请求，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应200 ok（返回数据）

-----

## 2.5 请问HTTP状态码有哪些分类，你了解哪些状态码？

| **类别** | **原因短语**                 |                                    |
| -------- | ---------------------------- | ---------------------------------- |
| 1XX      | Informational（信息性状态码) | 接受的请求正在处理                 |
| 2XX      | Success（成功状态码）        | 请求正常处理完毕                   |
| 3XX      | Redirection（重定向）        | 需要进行附加操作以完成请求         |
| 4XX      | Client error（客户端错误）   | 客户端请求出错，服务器无法处理请求 |
| 5XX      | Server Error（服务器错误）   | 服务器处理请求出错                 |

常见HTTP 状态码：

**1xx（请求状态）：**

100 ： 继续，请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分

101 ：切换协议，请求者已要求服务器切换协议，服务器已确认并准备切换

**2xx（成功）：**

200：成功，服务器已经成功处理了请求

201：已创建，请求成功并且服务器创建了新的资源

202：已接受，服务器已接受请求，但尚未处理

203：非授权信息，服务器已经成功处理了请求，但返回的信息可能来自另一来源

204：无内容，服务器成功处理了请求，但没有返回任何内容

205：重置内容，服务器成功处理了请求，但没有返回任何内容

206：部分内容，服务器成功处理了部分GET请求

**3xx（重定向）：**

300：多种选择，针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择

301：永久移动，请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置

302：临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

303：查看其它位置，请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码

304：未修改，自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容

305：使用代理，请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理

307：临时性重定向，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求

**4xx（客户端请求错误）：**

400：错误请求，服务器不理解请求的语法

401：未授权，请求要求身份验证。对于需要登录的网页，服务器可能返回此响应

403：禁止，服务器拒绝请求

404：未找到，服务器找不到请求的网页

405：方法禁用，禁用请求中指定的方法

406：不接受，无法使用请求的内容特性响应请求的网页

407：需要代理授权，此状态码与401（未授权）类似，但指定请求者应当授权使用代理

408：请求超时，服务器等候请求时发生超时

409：冲突，服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息

410：已删除，如果请求的资源已永久删除，服务器就会返回此响应

411：需要有效长度，服务器不接受不含有效内容长度标头字段的请求

412：未满足前提条件，服务器未满足请求者在请求者设置的其中一个前提条件

413：请求实体过大，服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力

414：请求的URI过长，请求的URI（通常为网址）过长，服务器无法处理

415：不支持媒体类型，请求的格式不受请求页面的支持

416：请求范围不符合要求，如果页面无法提供请求的范围，则服务器会返回此状态码

417：未满足期望值，服务器未满足“期望”请求标头字段的要求

**5xx（服务器错误）：**

500：服务器内部错误，服务器遇到错误，无法完成请求

501：尚未实施，服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码

502：错误网关，服务器作为网关或代理，从上游服务器无法收到无效响应

503：服务器不可用，服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态

504：网关超时，服务器作为网关代理，但是没有及时从上游服务器收到请求

505：HTTP版本不受支持，服务器不支持请求中所用的HTTP协议版本

-----

## 3.1 请谈谈你对浏览器的理解？

浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式

HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，但各浏览器厂商纷纷开发自己的扩展功能，对规范遵循并不完善，这便导致了严重的兼容性问题

简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少

**shell** 是指**浏览器外壳**：例如菜单，工具栏等，主要是提供给用户界面操作，参数设置，是调用内核来实现各种功能的

**内核** 是**浏览器的核心**，是基于标记语言显示内容的程序或模块

---

## 3.2 请谈谈你对浏览器内核的理解？

浏览器内核主要分成两部分：

**渲染引擎：**其职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件显示 PDF 格式

**JS 引擎：**解析和执行 javascript 来实现网页的动态效果

起初渲染引擎和 JS 引擎区分并不明确，而后 JS 引擎越来越独立，内核就倾向于只指渲染引擎

**目前常见的浏览器内核：**

**IE 浏览器：**Trident 内核，也俗称 IE 内核

**Chrome 浏览器：**统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核

F**irefox 浏览器：**Gecko 内核，俗称 Firefox 内核

**Safari 浏览器：**Webkit 内核

**Opera 浏览器：**最初是自家公司的 Presto 内核，后来从 Webkit 又转到了 Blink 内核

**360浏览器、猎豹浏览器内核：**IE + Chrome 双内核

**搜狗、遨游、QQ 浏览器内核：**Trident（兼容模式）+ Webkit（高速模式）

---

## 3.3 请问你了解ajax请求吗？

传统请求方法的缺点:

传统的web请求是用户触发一个http请求服务器，服务器收到后，响应到用户，并返回一个新的页面，每当服务器处理客户端请求时，客户都只能空闲等待，哪怕只是一次很小的交互，都要返回一个完整的HTML页，并且浪费时间和带宽去重新读取整个页面，这导致了用户界面的响应比本地应用慢得多

ajax 是一种用于创建快速页的技术，通过在后台与服务器进行少量数据交换，可使网页实现异步更新，在不重新加载整个网页的情况下，对网页的某部分进行更新

ajax请求步骤：

a、创建XMLHTTPRequest对象（通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据，常用于ajax请求）

b、使用open方法设置和服务器的交互信息

c、设置发送的数据，开始和服务器端交互

d、注册事件

e、更新界面

---

## 3.4 请问ajax是如何发请求的？

get请求：

```js
//一、创建XMLHTTPRequest对象
var ajax = new XMLHttpRequest();

//二、设置请求url参数，（请求的类型，请求的url，可以带参数，动态的传递参数starName到服务端）
ajax.open('get','getStar.php?starName='+name);

//三、发送请求
ajax.send();

//四、注册事件onreadystatechange状态改变就会调用
ajax.onreadystatechange = function () {
    if (ajax.readyState==4 &&ajax.status==200) {
	//五、if条件为true，数据请求成功，并且请求的页面是存在的　　　　           
    	console.log(ajax.responseText);
    }
}
```

关于if判断语句中的状态值：

**status：**服务器的Http状态码，若是200，则表示OK，404，表示为未找到

**readyState属性**有五个状态值：

0：uninitialized：未初始化，已经创建了XMLHttpRequest对象但是未初始化

1：loading：已经开始准备好要发送了

2：loaded,：已经发送，但是还没有收到响应

3：interactive：正在接受响应，但是还没接收完

4：completed：接受响应完毕

**post请求：**

```js
//一、创建XMLHTTPRequest对象
var ajax = new XMLHttpRequest();

//二、设置请求的类型及url
//post请求一定要添加请求头才行不然会报错
ajax.setRequestHeader("Content-type","application/x-www-form-urlencoded");
ajax.open('post', '02.post.php' );

//三、发送请求
ajax.send('name=fox&age=18');

ajax.onreadystatechange = function () {
// 判断服务器是否正确响应
    if (ajax.readyState == 4 && ajax.status == 200) {
        console.log(ajax.responseText);
    } 
};
```

可进行一定的封装：

```js
function ajax_method(url,data,method,success) {
    //创建XMLHTTPRequest对象
    var ajax = new XMLHttpRequest();
    // get请求
    if (method=='get') {
        if (data) {
            // 如果有值
            url+='?';
            url+=data;
        }else{
        }
        // 设置请求方法以及url
        ajax.open(method,url);
        // 发送请求
        ajax.send();
    }else{
        // post请求，url是不需要改变
        ajax.open(method,url);
        // 需要设置请求报文
        ajax.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        // 判断data，send发送数据
        if (data) {
            // 如有值从send发送
            ajax.send(data);
        }else{
            //直接发送
            ajax.send();
        }
    }
    // 注册事件
    ajax.onreadystatechange = function () {
        // 在事件中获取数据，并修改显示界面
        if (ajax.readyState==4 && ajax.status==200) {
            // console.log(ajax.responseText);
            // 将数据让外面可以使用
            // return ajax.responseText;
            // 当onreadystatechange被调用时，证明数据请求成功
            // ajax.responseText;
            // 可外面传入一个 function 作为参数 success
            success(ajax.responseText);
        }
    }
}
```

Promise版本的ajax请求：

```js
var getJSON = function(url) {
    var promise = new Promise(function(resolve, reject) {
        var client = new XMLHttpRequest();
        client.open("GET", url);
        client.onreadystatechange = handler;
        client.responseType = "json";
        client.setRequestHeader("Accept", "application/json");
        client.send();
    
        function handler() {
            if (this.readyState !== 4) {
                return;      
            }
            if (this.status === 200) {
                resolve(this.response);      
            } else {
                reject(new Error(this.statusText));      
            }    
        };  
    });
    return promise;
};  
  
getJSON("http://rap.taobao.org/mockjs/9768/Rap/get").then(function(response) {
    console.log('Contents: ',response);
}, function(error) {
    console.error('出错了', error);
});
```

----

## 3.5 请问ajax、axios、fetch请求有何区别？

- **axios**

一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XMLHTTPRequest对象的封装，只不过它是Promise的实现版本，符合最新的ES规范，具有以下特征：

a、从浏览器中创建 XMLHttpRequest

b、支持 Promise API

c、客户端防止CSRF

d、提供了一些并发请求的接口（实际开发中方便了很多的操作）

e、从 node.js 创建 http 请求

f、拦截请求和响应

g、转换请求和响应数据

h、支持取消请求

i、自动转换JSON数据

- **fetch**

号称是ajax替代品，在ES6时产生，是基于promise设计的。相比ajax，fetch代码结构更加简单，参数类型与ajax类似，但fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象

**fetch优点：**

a、符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里

b、写法更加简洁方便

---

# 计算机网络

---

## 1.1 请问你了解OSI七层模型吗？

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633686837830/D6A70DA7466DF3865BABC8FDAA316E4C)

- **应用层**

​    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。

- **表示层**

​    表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

- **会话层**

​    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

- **传输层**

​    传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

- **网络层**

​    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

- **数据链路层** 

​    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

   数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。

​    MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。

- **物理层**   

​    实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

---

## 1.2 请问你了解TCP/IP五层协议吗？它与OSI七层模型有什么关系吗？

TCP/IP协议包含四个概念层，其中有三层对应于OSI模型中的相应层，TCP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。

- **网络接口层**

用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。

- **网络层**

对应于OSI七层模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。

- **传输层**

对应于OSI七层模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。

- **应用层**

对应于OSI七层模型的应用层、表达层与会话层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。

TCP/IP五层协议与OSI的七层模型对应关系如下：

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633686981137/E3C7704B2554F5FA5553E2FF7A4E7F55)

----

## 1.3 请问你能阐述下TCP与UDP的区别吗？

TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。

TCP：

充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。

TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

UDP：

不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。

即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。

TCP与UDP区别：

1、TCP面向连接（如打电话要先拨号建立连接），UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达，UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节；UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

---

## 1.4 请问你能阐述下TCP三次握手与四次挥手的过程吗？

TCP的三次握手与四次挥手的过程可参考以下图例加以理解：

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633687013651/32F84793188E87383042FB2218BE6D50)

TCP三次握手：

1、客户端发送SYN包来建立连接。包信息: [SYN=1,ACK=0] Seq=1000(随机生成的初始序号client_isn,目前假设1000)；Len=0；MSS=1460(通常情况下是1460)；

2、服务端收到包之后，提取SYN的报文信息，然后分配TCP缓存和变量，发送允许连接的报文段。包信息 [SYN=1,ACK=1] Seq=666(随机生成的初始序号server_isn,目前假设535);Ack=1000(上一个包的Seq)+1;Len=0;MSS=1200(这个不是固定的，根据当前窗口来判断能接受的最大报文段长度)在第三次握手之前分配缓存容易收到SYN洪泛的拒绝服务攻击

3、客户端接受到服务端的确认包之后，发送确认包[ACK=1,SYN=0] Seq=1001(上一个包的Ack), Ack=666(上一个包的Seq)+1;之后就可以正常通信了。前两次不能有效负载，第三次就可以携带客户数据了，后面在通信的时候标志位都将置为0

TCP四次挥手：

1、客户端给服务器发送TCP包，用来关闭客户端到服务器的数据传送。将标志位FIN\=1 表示请求断开连接，同时把Seq = u

2、服务器收到FIN后,先检验Ack \=u+1，发回一个ACK = 1(标志位ACK=1)表示确认断开连接请求，同时把Seq = v ,服务器开始断开工作

3、服务器断开工作完成，发送一个FIN \= 1请求断开连接，ACK=1 (标志位ACK=1)表示确认断开连接请求, 同时把Seq =w

4、客户端收到服务器发送的FIN\=1之后，发回ACK=1(标志位ACK=1)确认关闭请求，同时把Ack= w+1 服务器在检验Ack\= 服务器Seq+1之后关闭连接，客户端在等待2msl时间后关闭连接

注意：为什么建立连接只要三次握手，但是断开连接要四次挥手？

因为三次握手的第二次由服务器发送SYN建立连接的信息和ACK确认建立连接的信息是在同一个报文中传输的，而四次挥手的由服务器发送的ACK 确认断开请求的信息和FIN 发送断开连接的信息是在两个报文中传输的

---

## 1.5 请问在浏览器中输入[www.baidu.com](http://www.baidu.com/)后执行了哪些过程？

- 客户端浏览器通过DNS解析到[www.baidu.com](http://www.baidu.com/)的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
- 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
- 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
- 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

---

## 1.6 请问TCP如何保证数据的可靠传输的呢？

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

TCP通过以下方式保证数据传输的可靠性：

**数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据

**对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层

**丢弃重复数据**：对于重复数据，能够丢弃重复数据

**应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒

**超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段

**流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议

----

## 1.7 请问TCP如何拥塞控制呢？

防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。

几种常见拥塞控制方法：

慢开始(slow-start )、拥塞避免(congestion avoidance )、快重传( fastretransmit )和快恢复( fastrecovery )。

---

## 2.1 请问你了解超文本传送协议HTTP吗？

HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议的主要特点可概括如下：

- 支持客户/服务器模式。
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

---

## 2.2 请问HTTP和HTTPS两者有哪些区别？

HTTP协议是超文本传输协议，HTTPS是安全的超文本传输协议，是安全版的HTTP协议，使用安全套接字层(SSL)进行信息交换，

HTTPS协议主要针对解决HTTP协议以下不足：

1、通信使用明文（不加密），内容可能会被窃听

  2、不验证通信方身份，应此可能遭遇伪装

3、无法证明报文的完整性（即准确性），所以可能已遭篡改

  HTTP+加密+认证+完整性保护=HTTPS，HTTP端口 80， HTTPS端口**443**

  HTTPS采用对称加密、SSL位于应用层于传输层TCP之间，原本数据由应用层直接交由传输层处理，现在会经过SSL加密再进行传输。

注意：HTTPS也不是绝对安全的，针对SSL的中间人攻击方式主要有两类，分别是SSL劫持攻击和SSL剥离攻击。

SSL劫持攻击就是 SSL证书欺骗攻击，将自己接入到客户端和目标网站之间； 在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥。

---

## 2.3 请问对称加密与非对称加密有什么区别？

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢**，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。**

---

## 2.4请问HTTP的请求和响应由哪几个部分组成？

- HTTP请求信息由3部分组成：

1、请求方法（GET/POST）、URI、协议/版本

2、请求头(Request Header)：Content-Type、端口号Host、Cookie

3、请求正文：包含客户提交的查询字符串信息，请求头和请求正文之间是一个空行

- HTTP响应也由3个部分构成：

1、状态行：状态代码及描述 如404、500等

2、响应头(Response Header)：Content-Type 、Server、Date

3、响应正文：html代码

----

## 2.5 请问IP地址分为哪几类？

IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。

每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：

**A类地址：**以0开头，第一个字节范围：0~127；

**B类地址：**以10开头，第一个字节范围：128~191；

**C类地址：**以110开头，第一个字节范围：192~223；

**D类地址：**以1110开头，第一个字节范围为224~239；

**E类地址：**以1111开头，保留地址

**（1）、A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”**

一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。

A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。

**（2）、B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”**

一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。

B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。

**（3）、C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”**

一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。

C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。

**（4）、D类地址:多播地址，用于1对多通信，最高位必须是“1110”**

D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。

**（5）、E类地址:为保留地址，最高位必须是“1111”**

----

## 2.6 请简介ARP的工作原理。

ARP是地址解析协议，其工作原理为：

（1）、首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系；

（2）、当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址；

（3）、当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址；

（4）、源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

---

# 网络攻防

----

## 3.1 请问什么是SQL注入攻击？

SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

一般我们提交的表单数据（未经过滤的情况下）都会拼接到 SQL 查询语句中的，就例如：

```sql
SELECT * FROM users WHERE name='aaa'
```



其中 name 的参数就是从表单中传过来的数据，如果传的参数是一条 SQL 语句，那么就可能骗过了 SQL 数据库，从而执行了一段恶意的代码，达到了攻击效果。

如何防范SQL注入？

- 把应用服务器的数据库权限降至最低，尽可能地减少 SQL 注入攻击带来的危害。
- 避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。
- 对进入数据库的特殊字符（'"\尖括号&*;等）进行转义处理，或编码转换。
- 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。
- 在测试阶段，建议使用专门的 SQL 注入检测工具进行检测。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。
- 善用数据库操作库，有些库包可能已经做好了相关的防护，只需阅读其文档，看是否支持相应的功能即可。

---

## 3.2 请问什么是XXS攻击？

**跨站脚本攻击**XSS （Cross Site Scripting），其重点不在于跨站点，**而在于脚本的执行**。那么XSS的原理是：

恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。

**反射性XSS**的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。

**反射型XSS的攻击步骤如下：**

\1. 攻击者在url后面的参数中加入恶意攻击代码。

\2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。

\3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。

\4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。

**存储型XSS**的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。

**存储型XSS的攻击步骤如下：**

\1. 攻击者将恶意代码提交到目标网站数据库中。

\2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。

\3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。

\4. 那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。

**如何防范？**

\1. 后端需要对提交的数据进行过滤。

\2. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。

DOM型XSS的攻击步骤如下：

\1. 攻击者构造出特殊的URL、在其中可能包含恶意代码。

\2. 用户打开带有恶意代码的URL。

\3. 用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。

\4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。

**DOM XSS 是基于文档对象模型的XSS。一般有如下DOM操作：**

\1. 使用document.write直接输出数据。

\2. 使用innerHTML直接输出数据。

\3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。

----

## 3.3 请问什么是CSRF攻击？

CSRF（Cross-site request forgery），中文名称为**跨站请求伪造**，也被称为：one click attack/session riding，缩写为：CSRF/XSRF

在CSRF攻击中攻击者盗用用户的身份，发送恶意请求。CSRF可能造成的危险：冒名发送邮件，发消息，盗取账号，购买商品，虚拟货币转账等等

**CSRF的防御：**

CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。

1、服务端进行CSRF防御

服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

- Cookie Hashing

所有表单都包含同一个伪随机值，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。

- 验证码

每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，**这个方案可以完全解决CSRF**

- One-Time Tokens(不同的表单包含一个不同的伪随机值)

在实现One-Time Tokens时，需要注意一点：并行会话的兼容。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。

---

