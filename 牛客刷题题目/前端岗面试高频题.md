----

# HTML/CSS部分

---

## 1.1 请问HTML5有哪些新特性？

首先，HTML 是一种标记语言，全称超文本标记语言，HTML5是第五个版本。对比传统HTML（HTML4、XHTML 各版本），有以下新特性：

1. **文档的类型声明不同**

HTML5的文档声明相比传统HTML来说更为简便，有利于程序员快速阅读和开发。具体写法：<!DOCTYPE html>

  **2. 新增语义化、结构化标签**

传统HTML没有语义化、结构化标签，不方便阅读，不清楚哪里是网页头部、尾部。HTML5新增的语义化、结构化标签主要有：

| <header>     | 网页或节的页眉/头部                |
| ------------ | ---------------------------------- |
| <footer>     | 网页或节的页脚/尾部                |
| <nav>        | 导航栏（一般集中放一些页面链接）   |
| <aside>      | 侧边栏                             |
| <article>    | 网页中一段独立的“文章”，可独立阅读 |
| <section>    | 节，有主题的内容组（一般含有标题） |
| <figcaption> | 图片标题                           |
| <figure>     | 图片与图片标题的组合               |
| <main>       | 主内容                             |
| <time>       | 时间                               |
| <video>      | 视频                               |
| <datalist>   | 选项列表                           |
| <summary>    | 包含 details 元素的标题            |

 **3. 增强型表单，**以便更好地控制与验证input

新增的input类型：color、date、datetime、datetime-local、email、month、number、range、search、tel、time、url、week

新增表单属性（输入限制）：placehoder、required、pattern、autofocus、multiple、step、min/max、height/wdith

  **4. 图像标签**

新增<canvas>、<svg>标签用于在网页绘制图形

  **5. 多媒体标签**

新增<audio>标签，以供引入音频

  **6. 新增的一些功能性API**

WebStorage本地存储，HTML5新增了两种客户端本地存储数据方法：

- localStorage：长期有效的数据存储，
- sessionStorage：只针对当前会话的数据存储。

地理定位，可使用getCurrentPosition()函数直接获取用户位置

WebSocket协议，能从客户端使用简单的语法推动消息到服务器，为客户端与服务端之间提供了一种全双工通信机制

requestAnimationFrame请求动画关键帧，把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般频率为每秒60帧

Drag 和 Drop拖放，抓取对象以后拖到另一个位置

---

### **1.什么是<!DOCTYPE>声明？**

对标记语言的文档类型声明，告知浏览器该页面使用的是哪个 HTML 版本，浏览器的解析器用什么文档标准解析页面文档，必须在 HTML 文档的第一行，且位于 <html> 标签之前，但不属于HTML标签

在 HTML5 中只有一种：<!DOCTYPE html>，HTML 4.01 中有三种模式：分别是：Strict、Transitional 和 Frameset

---

###  **2. 什么是语义化标签？**

能传达标签所包含内容类型的信息，开发者能直观地分辨标签和属性的用途

常见语义化标签：<hn>：h1~h6，分级标题；<header>：头部；<nav>：导航栏；<main>：主要内容；<footer>：尾部

常见非语义化标签：<div>、<span>

语义化标签的一些**优点**：

代码结构清晰，即使没有css的情况下，也能够呈现出清晰的内容结构

有利于SEO，爬虫依赖标签来确定关键字权重，可以和搜索引擎建立良好的沟通，帮助抓取更多的有效信息

提升用户体验，例如title、alt属性可以解释名称、图片信息

代码可读性强，便于团队开发和维护，让其他开发人员能快速理解HTML结构，减少差异化。

便于其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，网页渲染效率高

----

###   **3.** **cookie、localStorage、sessionStorage区别？**

cookie是服务器发给客户端的一种特殊认证信息，通常以文本的方式保存在客户端，始终在同源的http请求中携带（即使不需要），以供服务器验证当前浏览器用户身份，常见应用场景：验证用户身份、保存上次登录信息、统计浏览次数

sessionStorage和localStorage仅用于本地保存，不会自动把数据发给服务器

|                | 有期时间                                           | 作用域                                                       | 存储大小                           | 存储位置 |
| -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | -------- |
| cookie         | 在过期时间前一直有效（即使浏览窗口器关闭）         | domain本身以及domain下的所有子域名（跨域请求的 cookie在fetch时需要设置 withCredentials） | 不能超过4k                         | 浏览器端 |
| localStorage   | 长期存储，浏览器窗口关闭数据不丢失（除非主动删除） | 所有同源窗口共享                                             | 虽有存储大小限制，但可达到5M或更大 |          |
| sessionStorage | 临时存储，当前浏览器窗口关闭后自动删除             | 不同浏览器窗口不共享                                         |                                    |          |

----

### **4.** **WebSocket协议及实现原理？**

HTTP协议有一个局限：通信只能由客户端发起，服务器端不能实时发送最新数据给客户端（具有被动性）

数据交互有两种模式：Push（推模式）、Pull（拉模式）

Push：客户端与服务端建立好网络长连接，服务器有相关数据，直接通过长连接通道推送到客户端

Pull：客户端主动向服务端发出请求，拉取相关数据

那怎么获取最新数据呢？ 传统有两种方式：轮询、长轮询

轮询：开启一个定时器，每隔一段时间调用Ajax请求一次数据

长轮询：本质也是轮询，不过是阻塞型（一直打电话，没收到就不挂电话），客户端发起连接后，如果没消息，就一直不返回Response给客户端，直到有消 息才返回或超时。基于事件的触发，一个事件接一个事件。

而**WebSocket协议只需要发送一次请求**，只要服务器有最新数据就会自动发送给客户端，不用重复请求（类似天气预报，每当天气有变化则会自动更新最新天气状况）

**WebSocket协议没有同源限制，**客户端可与任意服务器通信，可用于解决跨域

实现原理：

WebSocket是一个应用层协议，必须依赖 HTTP 协议进行第一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 再无关联。WebSocket进行了**HTTP握手 + 双工的TCP数据传输**

协议以frame形式传输数据，会将一条消息分为几个frame，按照先后顺序传输。大数据可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况，可以边生成数据边传递消息，传输效率高

---

## 1.2 请问CSS3有哪些新特性？

CSS 为层叠样式表，用来定义页面中的HTML各标签如何显示，控制页面的整体布局与样式。

CSS3为W3C组织发布的最新版CSS，主要有以下新特性：

**1. 选择器**

CSS3增加了很多选择器，以供样式绑定使用，常用的主要有：

:nth-child(n)：匹配其父标签的第n个子元素，不论元素类型，n可以是数字、关键字、公式

:nth-of-type(n)：选择与之其匹配的父元素的第N个子元素

:frist-child：相对于父级做参考，“所有”子元素的第一个子元素，并且“位置”要对应

:empty：选择没有子元素的每个元素

[abc*="def"]：选择adc属性值中包含子串"def"的所有元素

  **2. 动画**

CSS3新增创建动画方法，通过@keyframes 规则创建动画，在规则中指定 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果，用百分比来规定变化发生的时间，或用"from" 和 "to"（等同于 0% 和 100%）

利用animation属性将动画绑定到指定选择器上，至少绑定动画名称与时长

  **3. 形状变换**

CSS3新增了transform属性实现元素的旋转、缩放、倾斜平移等形状变换。主要有一下新方法：

translate()：元素从当前位置在x 坐标、y 坐标上移动

rotate()：元素顺时针旋转给定的角度（负值则逆时针旋转）

scale()：通过向量形式定义的缩放值来放大或缩小元素尺寸

skew()：元素按照一定的角度进行倾斜转换

  **4. 文本**

CSS3新增text-shadow属性可实现文本阴影，text-overflow属性可规定当文本溢出盒子时呈现效果

  **5. 边框**

CSS3新增边框属性，可呈现更多的边框效果，有以下3个边框属性：

border-radius：创建圆角矩形

box-shadow：给盒子添加阴影效果

border-image：可利用图片创建边框

  **6. 过渡**

CSS3提供transition 属性呈现元素由A样式过渡至B样式，常用两个值定义过渡效果：transition-property：过渡的属性列表，transition-duration：过渡持续的时间

  **7.** **盒模型定义**

CSS3增加了新的用户界面属性来调整标签尺寸、盒尺寸以及外部轮廓等，常用属性有：

resize：指定一个标签可由用户调整大小

outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

box-sizing：允许以确切的方式定义适应某个区域的具体内容，可定义盒模型，有三个值：content-box：边框和padding不包含在元素的宽高之内、border-box：边框和padding包含在元素的宽高之内、inherit：从父标签继承 box-sizing 属性值

 **8.Flex布局**

弹性布局，使页面布局更加方便与灵活，舍弃传统上下排列页面元素，采用双轴排列方式，水平主轴与垂直交叉轴，并按照比例对元素进行放大与缩小，可利用简洁语法实现自适应布局

通过6个属性设置容器属性：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content，设置容器的轴线方向、元素对齐方向、换行

通过6个属性设置元素属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self，设置元素的排列顺序、放大/缩小比例、多余空间分配方案、对齐方案

---

### 1.盒模型与宽高计算方式？

前端页面都由一个个盒子组成，每个盒子由content、padding、border、margin4部分组成。目前主要有两种盒模型：标准盒模型与IE盒模型（怪异盒模型），不同盒模型盒子的宽高值不同

标准盒模型：width 和 height 指content区域的宽度和高度，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸

IE盒模型（怪异盒模型）：width 和 height 指content+border+padding的宽度和高度

如何设置盒模型？

1、若定义了完整的<!DOCTYPE>声明，会直接触发标准盒模型，若<!DOCTYPE>声明缺失，则会由浏览器自己判定，IE浏览器中IE9以下（IE6.IE7.IE8）的版本触发IE盒模型，其他浏览器会默认为标准盒模型

2、可通过box-sizing属性来设置盒模型解析模式：content-box： 默认值，border和padding不算到width范围内，可以理解为标准盒模型，border-box：border和padding划到width范围内，可以理解为怪异盒模型

---

## 1.3 请问你了解行内元素、块级元素、空元素吗，它们如何互相转换？

- 行内元素、块级元素、空元素定义

行内元素（内联元素）：与其他元素水平方向依次排列，处于同一行，通常不会以新行开始，宽度就是内容的宽度，不可改变

块级元素：总在新一行开始，一个元素独占一行，宽度默认100%（继承父元素宽度）

两者区别总结如下表：

|                   | 行内元素                                                     | 块级元素                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 容纳内容          | 只能容纳文本或其他内联元素                                   | 容纳内联元素或其他块元素                                     |
| 设置宽度width     | 无效                                                         | 有效                                                         |
| 设置高度height    | 无效                                                         | 有效                                                         |
| 设置内边距padding | 左右有效，上下无效                                           | 有效                                                         |
| 设置外边距margin  | 左右有效，上下无效                                           | 有效                                                         |
| 常见元素          | <a>、<span>、<strong>、<i>、 <button>、<em>、<label>、<textarea>、<kbd>...... | <div>、<hn>、<p> 、<ul>、<ol>、<li>、<header>、<footer>、<form>、<nav>...... |

**空元素**：官方术语为**自闭合标签**，没有内容的 HTML 元素，没有闭合标签，在开始标签就关闭了，常见标签：<br>、<hr>、<img>、<input>、<link>、<meta>

----

### 1.行内元素和块级元素转换方式

**1、display属性**

display：inline-block 行内元素——>行内块元素

display：block 行内元素——>块级元素

display：inline 块级元素——>行内元素

**2、float**

设置行内元素float：left/right，则该行内元素隐式转换为块级元素 ，且有浮动特性

**3、position**

设置行内元素position：absolute/fixed 会把行内元素隐式转换为块级元素，且有定位特性

---

### 2.置换元素定义与特点？

置换元素：内容不受CSS视觉格式化模型控制，渲染模型不考虑对此内容渲染，拥有固定尺寸的元素（有且仅有置换元素有固定尺寸），浏览器依据元素的标签和属性来决定具体显示内容，又名**替换元素**

块级元素包含置换元素、非置换元素；行内元素同样包含置换元素、非置换元素；行内置换元素有可修改的宽高属性，其默认值即元素的固有宽高

常见置换元素有：视图元素<img>、<object>、<video>等

表单元素<textarea>、<input>、<select>等

某些元素只在一些特殊情况下表现为可替换元素，如 <audio>、<canvas>等

----

## 1.4 请问CSS选择器有哪些，应该如何计算优先级？

CSS选择器可将CSS样式表与HTML元素进行一一绑定，实现一对一，一对多、多对一的样式控制。CSS样式具有三大特性：继承、 优先级和层叠

继承：即子类元素继承父类的样式

优先级：指不同类别样式的权重比较

层叠：当数量相同时，后者覆盖前者

CSS选择器分类众多，主要可分为以下几类：

| 标签选择器                 | 如：body,div,p,ul,li                                   |
| -------------------------- | ------------------------------------------------------ |
| 类选择器                   | 如：class="head",class="head_logo"                     |
| ID选择器                   | 如：id="name",id="name_txt"                            |
| 全局选择器（通配符选择器） | 如：*号                                                |
| 组合选择器                 | 如：.head .head_logo（各选择器用空格键分开）           |
| 后代选择器                 | 如：#head .nav ul li 从父集到子孙集的选择器            |
| 群组选择器                 | div,span,img {color:Red} 即具有相同样式的标签分组显示  |
| 继承选择器                 | 如：div p（各选择器用空格键分开）                      |
| 伪类选择器                 | 如：a元素的伪类，4种状态：link、visited、active、hover |
| 字符串匹配属性选择器       | 如：^ $ *三种，分别对应开始、结尾、包含                |
| 子选择器                   | 如：div>p （大于号>分隔）                              |
| 相邻选择器                 | 如：h1+p（加号+分隔）                                  |

CSS优先级算法：

对于同一优先级选择器，后写的会覆盖先写的样式

当两个不同选择器都作用到同一个HTML元素时，如果定义的属性值有冲突，那么应该受哪个选择器控制？CSS有一套固定的优先级排序：属性后面使用!important > 作为style属性行内样式>ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器= 伪元素选择器 > 通配符选择器 > 继承选择器 > 浏览器默认属性

当有多个级别组合的选择器时，往往利用上述优先级排序无法得出优先级，故有以下优先级计算方式：

每个选择器对应一个初始"四位数"：0、0、0、0

若是 行内选择器，则加1、0、0、0

若是 ID选择器，则加0、1、0、0

若是 类选择器/属性选择器/伪类选择符，则分别加0、0、1、0

若是 标签选择器/伪元素选择器，则分别加0、0、0、1

最终优先级由级别权重与出现次数决定，统计元素对应的所有选择器的权重与次数，最终得到的”四位数“，从左到右进行比较，大的优先级越高。

需注意：

- !important的优先级是最高的，但出现冲突时则需比较“四位数”
- 通配符选择器、子选择器、相邻选择器、同胞选择器权重值为0
- 优先级相同时，则采用就近原则，选择最后出现的样式

---

## 1.5 请问伪元素与伪类有什么区别？

伪类：本质上是为了弥补常规CSS选择器的不足，存在DOM文档中(无标签，找不到，只有符合触发条件时才能看到 )，逻辑上存在但在文档树中却无须标识的“幽灵”分类。

伪元素：本质上是创建了一个有内容的虚拟容器，不实际存在于DOM文档树中，仅在逻辑上存在，是虚拟的元素，代表某个元素的子元素

比如，有以下HTML代码：

```html
<div>
    <p>a</p>
    <p>b</p>
</div>

```

想要第一个p标签字体颜色变蓝色，使用伪类就很简单：

```css
p:first-child{
    color:blue;
}
```

不用伪类呢？ 就需要为第一个p标签添加一个类class，再通过类选择器添加颜色属性：

```html
<div>
    <p class="first-child">a</p>
    <p>b</p>
</div>
<style type="text/css">
.first-child{
    color:blue;
}
</style>
```

使用伪元素来实现该效果：

```css
p::first-child{
    color:blue;
}
```

不用伪元素呢？则需要在第一个p标签中创建一个span标签，再通过span标签选择器添加颜色属性

```html
<div>
    <p><span>a</span></p>
    <p>b</p>
</div>
<style type="text/css">
p span{
    color:blue;
}
</style>

```

- 伪类是通过添加“class类”来实现，伪元素是通过添加“元素”来实现，**二者本质区别：是否创造了新元素**
- **可同时使用多个伪类**，而只能同时使用一个伪元素，伪类可理解为添加类，所以可以多个，**而伪元素在一个选择器中只能出现一次，并且只能出现在末尾**
- 伪类和伪元素的语法不同：伪类单冒号，如：:link 、：hover ；伪元素双冒号，如：::after、::before

常见的伪类及功能分类如下图可见：

![img](E:\pogject\学习笔记\image\js\常见的伪类及功能分类)

常见的伪元素如下表可见：

| 伪元素                                   | 作用                                   |
| ---------------------------------------- | -------------------------------------- |
| ::before（CSS2中为 :before）             | 在选中元素之前添加内容                 |
| ::after（CSS2中为 :after）               | 在选中元素之后添加内容                 |
| ::first-letter（CSS1中为 :first-letter） | 向选取文字块的第一个字符添加特殊样式   |
| ::first-line（CSS1中为 :first-line）     | 向选取文字块的首行字符添加特殊样式     |
| ::placeholder                            | 选取字段的占位符文本(提示信息)         |
| ::selection                              | 选取文档中高亮(反白)的部分             |
| ::inactive-selection                     | 选取非活动状态时文档中高亮(反白)的部分 |
| ::marker                                 | 选取列表自动生成的项目标记符号         |

---

## 1.6 请问什么是DOM结构？

浏览器渲染页面都是从解析HTML文档开始的，HTML文档中定义了该页面所有组成元素以及分布结构，解析时，将元素转换为一个个DOM节点，再根据各元素间的所属关系，转换为DOM树，如下图示例所示，每个页面都有对应的DOM树

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632984775830/DAD918C8A9ED0031746ADC00AD5450C8)

----

## 1.7 请问你了解哪些CSS常用单位？

可将单位分为绝对单位与相对单位，绝对单位即固定长度的单位，不会变化，主要有：pt：Points 磅、in：Inches 英寸、mm：Millimeter 毫米、cm：Centimeter 厘米、q：Quarter millimeters 1/4毫米。

相对单位会随着参考值得变化而变化，在开发中使用频率更高，主要有：

- **px：**Pixel CSS像素，是web页面图像显示的基本单元，区别于物理像素，不是一个确定的物理量，也不是一个点或者小方块，而是CSS中的一个抽象概念，是一个相对单位，受上下文影响，默认情况（zoom100%）下1个CSS像素等于1个物理像素，若手动将页面放大或缩小，1个CSS像素就不等于1个物理像素。

在一些高PPI（每英寸像素数）的设备上，1个CSS像素默认相当于多个物理像素。比如iPhone的屏幕对比一般的手机屏幕会看起来更精细清晰一些，iPhone6、7、8都是两倍屏手机，1个CSS像素等于2个物理像素，对比一般的手机屏幕会看起来更清晰一些。

- **rem：**Root element meter 通过根文档（ body/html ）内文本的字体尺寸计算尺寸，如下代码示例，若未指定字体大小则为浏览器默认字体大小（浏览器默认字体大小为16px)。

```html
<body>     
<div class="element"></div> 
</body>  
<style type="text/css">  
body {     
    font-size: 14px; 
} 
.element {     
    font-size: 16px;     
    width: 2rem;     /* 2rem === 28px */ 
} 
</style>

```

- **em：**Element meter 通过当前对象内文本的字体尺寸计算尺寸，若未指定字体大小则继承自上级元素，直至 body，若body未指定则为浏览器的默认字体尺寸。

```html
<body>     
<div class="element"></div> 
</body>  
<style type="text/css"> 
body {     
    font-size: 14px; 
} 
.element {     
    font-size: 16px;     
    width: 2em;     /* 2em === 32px */ } 
</style>

```

- **%：**百分比，笼统的说是相对于父元素的百分比，不同CSS属性，百分比的表现有所不同。常见使用场景：

- - width、height：width相对于父元素的宽；height相对于父元素的高进行百分比计算
  - 定位relative：top、bottom相对父元素的高;left 、right相对于父元素的宽进行计算
  - border-radius：相对自身标签的宽高设置每个边角的垂直和水平半径
  - margin: left、right、top、bottom相当于父元素的宽度进行计算
  - 定位absolute：top、bottom相对定位元素的高；left 、right相对于定位元素的宽进行计算，同时位于absolute中的其他属性如width heiht margin等都相当于定位元素进行计算
  - line-hight设置内联元素垂直居中时，%相对于文本的行高进行计算，非父元素

- **vh vw：**view height/view width，相对于视口的高度和宽度，视口指屏幕可见范围，1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。假设浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px

---

1. **物理像素与CSS像素有什么换算关系呢？**

CSS像素*DPR = 物理像素

像素比（DPR）：一个CSS像素占用几个物理像素

---

## 2.1 请问有哪些CSS浏览器兼容问题以及解决方案？

目前，浏览器厂商众多，Chrome，Frirefox，Safari，Edge，IE6……对于同一段CSS代码，不同厂商、甚至同一厂商不同版本的解析效果极大可能不一致，其根本原因是浏览器内核不同，这就导致了页面显示效果不统一，产生了CSS兼容性问题

目前对兼容问题的解决方案：

- **浏览器CSS样式初始化**

在所有CSS开始前，对某些属性初始化，以防不同浏览器的显示效果不一样，通常不推荐一味地使用通配符统一初始化样式

```css
*{
 margin: 0;
 padding: 0;
}
```

- **浏览器私有属性**

可直接在某个属性中额外添加浏览器私有写法，确保浏览器能识别该属性值，有两种开发思路，分别是渐近增强和优雅降级

**渐进增强：**先写某些特殊浏览器能识别的私有属性，再写通用写法确保大部分浏览器能正常显示

```html
<style type="text/css">
.test {
  -webkit-transform:rotate(-3deg); /*Chrome/Safari*/
  -moz-transform:rotate(-3deg); /*Firefox*/
  -ms-transform:rotate(-3deg); /*IE*/
  -o-transform:rotate(-3deg); /*Opera*/
   transform:rotate(-3deg);
  background-color: #fe3388;
  width: 300px;
  height: 300px;
}
</style>
<body>
<div class="test"></div>
</body>
```

**优雅降级：**先确保大部分浏览器能正常显示，再写某些特殊浏览器能识别的私有属性

```html
<style type="text/css">
.test {
  width: 300px;
  height: 300px;
  background-color: #fe3388;
  transform:rotate(-3deg);
  -webkit-transform:rotate(-3deg); /*Chrome/Safari*/
  -moz-transform:rotate(-3deg); /*Firefox*/
  -ms-transform:rotate(-3deg); /*IE*/
  -o-transform:rotate(-3deg); /*Opera*/
}
</style>
<body>
<div class="test"></div>
```

- **CSS hack语法（**一般情况下，尽量避免使用CSS hack，过多滥用会造成html文档混乱，不易管理与维护）

1. 条件hack，IE浏览器专有的hack方式，微软官方推荐

```css
<!--[if IE]> 	
这段文字只在IE浏览器显示 	
<![endif]-->
<!--[if gte IE 6]> 	
这段文字只在IE6以上(包括)版本IE浏览器显示 	
<![endif]-->
```

  **2.** **属性级hack** CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果

```css
.test {
  color: red; /* All browsers */
  *color: blue;  /* IE7，IE6 */
  _color: skyblue;  /* IE6 */
}
```

  **3.** **选择符级hack，**在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀

```css
*html /* *前缀只对IE6生效*/
*+html /* *+前缀只对IE7生效*/
@media screen\9{...} /*只对IE6/7生效*/
@media \0screen {body { background: red; }} /*只对IE8有效*/
@media \0screen\,screen\9{body { background: blue; }} /*只对IE6/7/8有效*/
@media screen\0 {body { background: green; }} /*只对IE8/9/10有效*/
@media screen and (min-width:0\0) {body { background: gray; }} /*只对IE9/10有效*/ 
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} /*只对IE10有效*/
```

- **自动化插件**

在解析CSS文件时，插件会自动添加浏览器前缀至CSS代码中，如Autoprefixer

---

## 2.2 请问Flex的常见写法：flex:1表达什么含义？

虽说Flex具有众多属性，但在实际开发常简写为：flex：1，再结合display：flex，就能轻松打造出自适应布局，这也是Flex布局最大的优势。实际上flex为：flex-grow flex-shrink flex-basic三者的缩写。

flex-grow：定义在分配多余空间时，盒子的放大比例，默认为0，即存在剩余空间，也不放大

flex-shrink：定义在分配多余空间时，盒子的缩小比例（多余空间可能是负值），默认为1，即空间不足将缩小

flex-basis：定义在分配多余空间之前，盒子占据的主轴空间（可理解为基准值），通常根据该属性计算多余空间，默认为auto，即盒子自身大小

flex取值不同，空间分配计算值不同，有以下几种常见情况：

|                | flex-grow | flex-shrink | flex-basis | 解释                                                         |
| -------------- | --------- | ----------- | ---------- | ------------------------------------------------------------ |
| flex: 2 3 23px | 2         | 3           | 23px       | 当flex有三个值时，则依次分配给flex-grow、flex-shrink、flex-basic |
| flex: none     | 0         | 0           | auto       | 当 flex 为none时，则计算值为0 0 auto                         |
| flex: auto     | 1         | 1           | auto       | 当 flex 为auto时，则计算值为1 1 auto                         |
| flex: 1        | 1         | 1           | 0%         | 当 flex 为一个非负数字，该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0% |
| flex: 0%       | 1         | 1           | 0%         | 当 flex 为一个长度或百分比，该数字为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1 |
| flex: 23px     | 1         | 1           | 23px       |                                                              |
| flex: 2 3      | 2         | 3           | 0%         | 当 flex 为两个非负数字，则分别为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% |
| flex: 2 23px   | 2         | 1           | 23px       | 当 flex 为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 |

关于 flex-basis 的取值情况：

- auto：盒子本身大小
- 百分比：根据其包含块（即伸缩父容器）的主尺寸计算
- 0：盒子本身大小，当盒子大小未定义时，按其内容来来计算
- 可以代替width属性定义盒子大小，同时声明width属性和flex-basic属性时，会以flex-basic的值来计算

针对以下Flex布局，算出三个盒子自适应后的最终宽度。

```html
<style type="text/css">
.parent {
    display: flex;
    width: 600px;
}
.item-1 {
    width: 140px;
    flex: 2 1 0%;
    background-color: red;
    height: 50px;
}
.item-2 {
    width: 100px;
    flex: 2 1 auto;
    background-color: green;
    height: 50px;
}
.item-3 {
    flex: 1 1 200px;
    background-color: blue;
    height: 50px;
}
</style>

<body>
<div class="parent">
    <div class="item-1"></div>
    <div class="item-2"></div>
    <div class="item-3"></div> 
</div>
</body>
```

```
主轴上父容器总尺寸： 600px

子元素总基准值（flex-basis）：0% + auto + 200px = 300px，其中

0% 即 600*0% = 0 宽度

auto 对应取盒子自身尺寸：100px

故剩余空间： 600px - 300px = 300px

剩余空间为正，需要扩大子元素，伸缩放大(flex-grow)系数之和为： 2 + 2 + 1 = 5

剩余空间分配如下：

item-1 和 item-2 各分配 2/5，各得 300*2/5 = 120px

item-3 分配 1/5，得 300*1/5 = 60px

各项目最终宽度为：

item-1 = 0% + 120px = 0 + 120px = 120px

item-2 = auto + 120px = 100px + 120px = 220px

item-3 = 200px + 60px = 260px
```

---

## 2.3 请问清除浮动有哪些常用方法？

