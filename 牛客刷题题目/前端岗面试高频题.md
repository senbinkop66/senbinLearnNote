----

# HTML/CSS部分

---

## 1.1 请问HTML5有哪些新特性？

首先，HTML 是一种标记语言，全称超文本标记语言，HTML5是第五个版本。对比传统HTML（HTML4、XHTML 各版本），有以下新特性：

1. **文档的类型声明不同**

HTML5的文档声明相比传统HTML来说更为简便，有利于程序员快速阅读和开发。具体写法：<!DOCTYPE html>

  **2. 新增语义化、结构化标签**

传统HTML没有语义化、结构化标签，不方便阅读，不清楚哪里是网页头部、尾部。HTML5新增的语义化、结构化标签主要有：

| <header>     | 网页或节的页眉/头部                |
| ------------ | ---------------------------------- |
| <footer>     | 网页或节的页脚/尾部                |
| <nav>        | 导航栏（一般集中放一些页面链接）   |
| <aside>      | 侧边栏                             |
| <article>    | 网页中一段独立的“文章”，可独立阅读 |
| <section>    | 节，有主题的内容组（一般含有标题） |
| <figcaption> | 图片标题                           |
| <figure>     | 图片与图片标题的组合               |
| <main>       | 主内容                             |
| <time>       | 时间                               |
| <video>      | 视频                               |
| <datalist>   | 选项列表                           |
| <summary>    | 包含 details 元素的标题            |

 **3. 增强型表单，**以便更好地控制与验证input

新增的input类型：color、date、datetime、datetime-local、email、month、number、range、search、tel、time、url、week

新增表单属性（输入限制）：placehoder、required、pattern、autofocus、multiple、step、min/max、height/wdith

  **4. 图像标签**

新增<canvas>、<svg>标签用于在网页绘制图形

  **5. 多媒体标签**

新增<audio>标签，以供引入音频

  **6. 新增的一些功能性API**

WebStorage本地存储，HTML5新增了两种客户端本地存储数据方法：

- localStorage：长期有效的数据存储，
- sessionStorage：只针对当前会话的数据存储。

地理定位，可使用getCurrentPosition()函数直接获取用户位置

WebSocket协议，能从客户端使用简单的语法推动消息到服务器，为客户端与服务端之间提供了一种全双工通信机制

requestAnimationFrame请求动画关键帧，把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般频率为每秒60帧

Drag 和 Drop拖放，抓取对象以后拖到另一个位置

---

### **1.什么是<!DOCTYPE>声明？**

对标记语言的文档类型声明，告知浏览器该页面使用的是哪个 HTML 版本，浏览器的解析器用什么文档标准解析页面文档，必须在 HTML 文档的第一行，且位于 <html> 标签之前，但不属于HTML标签

在 HTML5 中只有一种：<!DOCTYPE html>，HTML 4.01 中有三种模式：分别是：Strict、Transitional 和 Frameset

---

###  **2. 什么是语义化标签？**

能传达标签所包含内容类型的信息，开发者能直观地分辨标签和属性的用途

常见语义化标签：<hn>：h1~h6，分级标题；<header>：头部；<nav>：导航栏；<main>：主要内容；<footer>：尾部

常见非语义化标签：<div>、<span>

语义化标签的一些**优点**：

代码结构清晰，即使没有css的情况下，也能够呈现出清晰的内容结构

有利于SEO，爬虫依赖标签来确定关键字权重，可以和搜索引擎建立良好的沟通，帮助抓取更多的有效信息

提升用户体验，例如title、alt属性可以解释名称、图片信息

代码可读性强，便于团队开发和维护，让其他开发人员能快速理解HTML结构，减少差异化。

便于其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，网页渲染效率高

----

###   **3.** **cookie、localStorage、sessionStorage区别？**

cookie是服务器发给客户端的一种特殊认证信息，通常以文本的方式保存在客户端，始终在同源的http请求中携带（即使不需要），以供服务器验证当前浏览器用户身份，常见应用场景：验证用户身份、保存上次登录信息、统计浏览次数

sessionStorage和localStorage仅用于本地保存，不会自动把数据发给服务器

|                | 有期时间                                           | 作用域                                                       | 存储大小                           | 存储位置 |
| -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | -------- |
| cookie         | 在过期时间前一直有效（即使浏览窗口器关闭）         | domain本身以及domain下的所有子域名（跨域请求的 cookie在fetch时需要设置 withCredentials） | 不能超过4k                         | 浏览器端 |
| localStorage   | 长期存储，浏览器窗口关闭数据不丢失（除非主动删除） | 所有同源窗口共享                                             | 虽有存储大小限制，但可达到5M或更大 |          |
| sessionStorage | 临时存储，当前浏览器窗口关闭后自动删除             | 不同浏览器窗口不共享                                         |                                    |          |

----

### **4.** **WebSocket协议及实现原理？**

HTTP协议有一个局限：通信只能由客户端发起，服务器端不能实时发送最新数据给客户端（具有被动性）

数据交互有两种模式：Push（推模式）、Pull（拉模式）

Push：客户端与服务端建立好网络长连接，服务器有相关数据，直接通过长连接通道推送到客户端

Pull：客户端主动向服务端发出请求，拉取相关数据

那怎么获取最新数据呢？ 传统有两种方式：轮询、长轮询

轮询：开启一个定时器，每隔一段时间调用Ajax请求一次数据

长轮询：本质也是轮询，不过是阻塞型（一直打电话，没收到就不挂电话），客户端发起连接后，如果没消息，就一直不返回Response给客户端，直到有消 息才返回或超时。基于事件的触发，一个事件接一个事件。

而**WebSocket协议只需要发送一次请求**，只要服务器有最新数据就会自动发送给客户端，不用重复请求（类似天气预报，每当天气有变化则会自动更新最新天气状况）

**WebSocket协议没有同源限制，**客户端可与任意服务器通信，可用于解决跨域

实现原理：

WebSocket是一个应用层协议，必须依赖 HTTP 协议进行第一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 再无关联。WebSocket进行了**HTTP握手 + 双工的TCP数据传输**

协议以frame形式传输数据，会将一条消息分为几个frame，按照先后顺序传输。大数据可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况，可以边生成数据边传递消息，传输效率高

---

## 1.2 请问CSS3有哪些新特性？

CSS 为层叠样式表，用来定义页面中的HTML各标签如何显示，控制页面的整体布局与样式。

CSS3为W3C组织发布的最新版CSS，主要有以下新特性：

**1. 选择器**

CSS3增加了很多选择器，以供样式绑定使用，常用的主要有：

:nth-child(n)：匹配其父标签的第n个子元素，不论元素类型，n可以是数字、关键字、公式

:nth-of-type(n)：选择与之其匹配的父元素的第N个子元素

:frist-child：相对于父级做参考，“所有”子元素的第一个子元素，并且“位置”要对应

:empty：选择没有子元素的每个元素

[abc*="def"]：选择adc属性值中包含子串"def"的所有元素

  **2. 动画**

CSS3新增创建动画方法，通过@keyframes 规则创建动画，在规则中指定 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果，用百分比来规定变化发生的时间，或用"from" 和 "to"（等同于 0% 和 100%）

利用animation属性将动画绑定到指定选择器上，至少绑定动画名称与时长

  **3. 形状变换**

CSS3新增了transform属性实现元素的旋转、缩放、倾斜平移等形状变换。主要有一下新方法：

translate()：元素从当前位置在x 坐标、y 坐标上移动

rotate()：元素顺时针旋转给定的角度（负值则逆时针旋转）

scale()：通过向量形式定义的缩放值来放大或缩小元素尺寸

skew()：元素按照一定的角度进行倾斜转换

  **4. 文本**

CSS3新增text-shadow属性可实现文本阴影，text-overflow属性可规定当文本溢出盒子时呈现效果

  **5. 边框**

CSS3新增边框属性，可呈现更多的边框效果，有以下3个边框属性：

border-radius：创建圆角矩形

box-shadow：给盒子添加阴影效果

border-image：可利用图片创建边框

  **6. 过渡**

CSS3提供transition 属性呈现元素由A样式过渡至B样式，常用两个值定义过渡效果：transition-property：过渡的属性列表，transition-duration：过渡持续的时间

  **7.** **盒模型定义**

CSS3增加了新的用户界面属性来调整标签尺寸、盒尺寸以及外部轮廓等，常用属性有：

resize：指定一个标签可由用户调整大小

outline-offset：对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

box-sizing：允许以确切的方式定义适应某个区域的具体内容，可定义盒模型，有三个值：content-box：边框和padding不包含在元素的宽高之内、border-box：边框和padding包含在元素的宽高之内、inherit：从父标签继承 box-sizing 属性值

 **8.Flex布局**

弹性布局，使页面布局更加方便与灵活，舍弃传统上下排列页面元素，采用双轴排列方式，水平主轴与垂直交叉轴，并按照比例对元素进行放大与缩小，可利用简洁语法实现自适应布局

通过6个属性设置容器属性：flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content，设置容器的轴线方向、元素对齐方向、换行

通过6个属性设置元素属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self，设置元素的排列顺序、放大/缩小比例、多余空间分配方案、对齐方案

---

### 1.盒模型与宽高计算方式？

前端页面都由一个个盒子组成，每个盒子由content、padding、border、margin4部分组成。目前主要有两种盒模型：标准盒模型与IE盒模型（怪异盒模型），不同盒模型盒子的宽高值不同

标准盒模型：width 和 height 指content区域的宽度和高度，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸

IE盒模型（怪异盒模型）：width 和 height 指content+border+padding的宽度和高度

如何设置盒模型？

1、若定义了完整的<!DOCTYPE>声明，会直接触发标准盒模型，若<!DOCTYPE>声明缺失，则会由浏览器自己判定，IE浏览器中IE9以下（IE6.IE7.IE8）的版本触发IE盒模型，其他浏览器会默认为标准盒模型

2、可通过box-sizing属性来设置盒模型解析模式：content-box： 默认值，border和padding不算到width范围内，可以理解为标准盒模型，border-box：border和padding划到width范围内，可以理解为怪异盒模型

---

## 1.3 请问你了解行内元素、块级元素、空元素吗，它们如何互相转换？

- 行内元素、块级元素、空元素定义

行内元素（内联元素）：与其他元素水平方向依次排列，处于同一行，通常不会以新行开始，宽度就是内容的宽度，不可改变

块级元素：总在新一行开始，一个元素独占一行，宽度默认100%（继承父元素宽度）

两者区别总结如下表：

|                   | 行内元素                                                     | 块级元素                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 容纳内容          | 只能容纳文本或其他内联元素                                   | 容纳内联元素或其他块元素                                     |
| 设置宽度width     | 无效                                                         | 有效                                                         |
| 设置高度height    | 无效                                                         | 有效                                                         |
| 设置内边距padding | 左右有效，上下无效                                           | 有效                                                         |
| 设置外边距margin  | 左右有效，上下无效                                           | 有效                                                         |
| 常见元素          | <a>、<span>、<strong>、<i>、 <button>、<em>、<label>、<textarea>、<kbd>...... | <div>、<hn>、<p> 、<ul>、<ol>、<li>、<header>、<footer>、<form>、<nav>...... |

**空元素**：官方术语为**自闭合标签**，没有内容的 HTML 元素，没有闭合标签，在开始标签就关闭了，常见标签：<br>、<hr>、<img>、<input>、<link>、<meta>

----

### 1.行内元素和块级元素转换方式

**1、display属性**

display：inline-block 行内元素——>行内块元素

display：block 行内元素——>块级元素

display：inline 块级元素——>行内元素

**2、float**

设置行内元素float：left/right，则该行内元素隐式转换为块级元素 ，且有浮动特性

**3、position**

设置行内元素position：absolute/fixed 会把行内元素隐式转换为块级元素，且有定位特性

---

### 2.置换元素定义与特点？

置换元素：内容不受CSS视觉格式化模型控制，渲染模型不考虑对此内容渲染，拥有固定尺寸的元素（有且仅有置换元素有固定尺寸），浏览器依据元素的标签和属性来决定具体显示内容，又名**替换元素**

块级元素包含置换元素、非置换元素；行内元素同样包含置换元素、非置换元素；行内置换元素有可修改的宽高属性，其默认值即元素的固有宽高

常见置换元素有：视图元素<img>、<object>、<video>等

表单元素<textarea>、<input>、<select>等

某些元素只在一些特殊情况下表现为可替换元素，如 <audio>、<canvas>等

----

## 1.4 请问CSS选择器有哪些，应该如何计算优先级？

CSS选择器可将CSS样式表与HTML元素进行一一绑定，实现一对一，一对多、多对一的样式控制。CSS样式具有三大特性：继承、 优先级和层叠

继承：即子类元素继承父类的样式

优先级：指不同类别样式的权重比较

层叠：当数量相同时，后者覆盖前者

CSS选择器分类众多，主要可分为以下几类：

| 标签选择器                 | 如：body,div,p,ul,li                                   |
| -------------------------- | ------------------------------------------------------ |
| 类选择器                   | 如：class="head",class="head_logo"                     |
| ID选择器                   | 如：id="name",id="name_txt"                            |
| 全局选择器（通配符选择器） | 如：*号                                                |
| 组合选择器                 | 如：.head .head_logo（各选择器用空格键分开）           |
| 后代选择器                 | 如：#head .nav ul li 从父集到子孙集的选择器            |
| 群组选择器                 | div,span,img {color:Red} 即具有相同样式的标签分组显示  |
| 继承选择器                 | 如：div p（各选择器用空格键分开）                      |
| 伪类选择器                 | 如：a元素的伪类，4种状态：link、visited、active、hover |
| 字符串匹配属性选择器       | 如：^ $ *三种，分别对应开始、结尾、包含                |
| 子选择器                   | 如：div>p （大于号>分隔）                              |
| 相邻选择器                 | 如：h1+p（加号+分隔）                                  |

CSS优先级算法：

对于同一优先级选择器，后写的会覆盖先写的样式

当两个不同选择器都作用到同一个HTML元素时，如果定义的属性值有冲突，那么应该受哪个选择器控制？CSS有一套固定的优先级排序：属性后面使用!important > 作为style属性行内样式>ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器= 伪元素选择器 > 通配符选择器 > 继承选择器 > 浏览器默认属性

当有多个级别组合的选择器时，往往利用上述优先级排序无法得出优先级，故有以下优先级计算方式：

每个选择器对应一个初始"四位数"：0、0、0、0

若是 行内选择器，则加1、0、0、0

若是 ID选择器，则加0、1、0、0

若是 类选择器/属性选择器/伪类选择符，则分别加0、0、1、0

若是 标签选择器/伪元素选择器，则分别加0、0、0、1

最终优先级由级别权重与出现次数决定，统计元素对应的所有选择器的权重与次数，最终得到的”四位数“，从左到右进行比较，大的优先级越高。

需注意：

- !important的优先级是最高的，但出现冲突时则需比较“四位数”
- 通配符选择器、子选择器、相邻选择器、同胞选择器权重值为0
- 优先级相同时，则采用就近原则，选择最后出现的样式

---

## 1.5 请问伪元素与伪类有什么区别？

伪类：本质上是为了弥补常规CSS选择器的不足，存在DOM文档中(无标签，找不到，只有符合触发条件时才能看到 )，逻辑上存在但在文档树中却无须标识的“幽灵”分类。

伪元素：本质上是创建了一个有内容的虚拟容器，不实际存在于DOM文档树中，仅在逻辑上存在，是虚拟的元素，代表某个元素的子元素

比如，有以下HTML代码：

```html
<div>
    <p>a</p>
    <p>b</p>
</div>

```

想要第一个p标签字体颜色变蓝色，使用伪类就很简单：

```css
p:first-child{
    color:blue;
}
```

不用伪类呢？ 就需要为第一个p标签添加一个类class，再通过类选择器添加颜色属性：

```html
<div>
    <p class="first-child">a</p>
    <p>b</p>
</div>
<style type="text/css">
.first-child{
    color:blue;
}
</style>
```

使用伪元素来实现该效果：

```css
p::first-child{
    color:blue;
}
```

不用伪元素呢？则需要在第一个p标签中创建一个span标签，再通过span标签选择器添加颜色属性

```html
<div>
    <p><span>a</span></p>
    <p>b</p>
</div>
<style type="text/css">
p span{
    color:blue;
}
</style>

```

- 伪类是通过添加“class类”来实现，伪元素是通过添加“元素”来实现，**二者本质区别：是否创造了新元素**
- **可同时使用多个伪类**，而只能同时使用一个伪元素，伪类可理解为添加类，所以可以多个，**而伪元素在一个选择器中只能出现一次，并且只能出现在末尾**
- 伪类和伪元素的语法不同：伪类单冒号，如：:link 、：hover ；伪元素双冒号，如：::after、::before

常见的伪类及功能分类如下图可见：

![img](E:\pogject\学习笔记\image\js\常见的伪类及功能分类)

常见的伪元素如下表可见：

| 伪元素                                   | 作用                                   |
| ---------------------------------------- | -------------------------------------- |
| ::before（CSS2中为 :before）             | 在选中元素之前添加内容                 |
| ::after（CSS2中为 :after）               | 在选中元素之后添加内容                 |
| ::first-letter（CSS1中为 :first-letter） | 向选取文字块的第一个字符添加特殊样式   |
| ::first-line（CSS1中为 :first-line）     | 向选取文字块的首行字符添加特殊样式     |
| ::placeholder                            | 选取字段的占位符文本(提示信息)         |
| ::selection                              | 选取文档中高亮(反白)的部分             |
| ::inactive-selection                     | 选取非活动状态时文档中高亮(反白)的部分 |
| ::marker                                 | 选取列表自动生成的项目标记符号         |

---

## 1.6 请问什么是DOM结构？

浏览器渲染页面都是从解析HTML文档开始的，HTML文档中定义了该页面所有组成元素以及分布结构，解析时，将元素转换为一个个DOM节点，再根据各元素间的所属关系，转换为DOM树，如下图示例所示，每个页面都有对应的DOM树

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632984775830/DAD918C8A9ED0031746ADC00AD5450C8)

----

## 1.7 请问你了解哪些CSS常用单位？

可将单位分为绝对单位与相对单位，绝对单位即固定长度的单位，不会变化，主要有：pt：Points 磅、in：Inches 英寸、mm：Millimeter 毫米、cm：Centimeter 厘米、q：Quarter millimeters 1/4毫米。

相对单位会随着参考值得变化而变化，在开发中使用频率更高，主要有：

- **px：**Pixel CSS像素，是web页面图像显示的基本单元，区别于物理像素，不是一个确定的物理量，也不是一个点或者小方块，而是CSS中的一个抽象概念，是一个相对单位，受上下文影响，默认情况（zoom100%）下1个CSS像素等于1个物理像素，若手动将页面放大或缩小，1个CSS像素就不等于1个物理像素。

在一些高PPI（每英寸像素数）的设备上，1个CSS像素默认相当于多个物理像素。比如iPhone的屏幕对比一般的手机屏幕会看起来更精细清晰一些，iPhone6、7、8都是两倍屏手机，1个CSS像素等于2个物理像素，对比一般的手机屏幕会看起来更清晰一些。

- **rem：**Root element meter 通过根文档（ body/html ）内文本的字体尺寸计算尺寸，如下代码示例，若未指定字体大小则为浏览器默认字体大小（浏览器默认字体大小为16px)。

```html
<body>     
<div class="element"></div> 
</body>  
<style type="text/css">  
body {     
    font-size: 14px; 
} 
.element {     
    font-size: 16px;     
    width: 2rem;     /* 2rem === 28px */ 
} 
</style>

```

- **em：**Element meter 通过当前对象内文本的字体尺寸计算尺寸，若未指定字体大小则继承自上级元素，直至 body，若body未指定则为浏览器的默认字体尺寸。

```html
<body>     
<div class="element"></div> 
</body>  
<style type="text/css"> 
body {     
    font-size: 14px; 
} 
.element {     
    font-size: 16px;     
    width: 2em;     /* 2em === 32px */ } 
</style>

```

- **%：**百分比，笼统的说是相对于父元素的百分比，不同CSS属性，百分比的表现有所不同。常见使用场景：

- - width、height：width相对于父元素的宽；height相对于父元素的高进行百分比计算
  - 定位relative：top、bottom相对父元素的高;left 、right相对于父元素的宽进行计算
  - border-radius：相对自身标签的宽高设置每个边角的垂直和水平半径
  - margin: left、right、top、bottom相当于父元素的宽度进行计算
  - 定位absolute：top、bottom相对定位元素的高；left 、right相对于定位元素的宽进行计算，同时位于absolute中的其他属性如width heiht margin等都相当于定位元素进行计算
  - line-hight设置内联元素垂直居中时，%相对于文本的行高进行计算，非父元素

- **vh vw：**view height/view width，相对于视口的高度和宽度，视口指屏幕可见范围，1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。假设浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px

---

1. **物理像素与CSS像素有什么换算关系呢？**

CSS像素*DPR = 物理像素

像素比（DPR）：一个CSS像素占用几个物理像素

---

## 2.1 请问有哪些CSS浏览器兼容问题以及解决方案？

目前，浏览器厂商众多，Chrome，Frirefox，Safari，Edge，IE6……对于同一段CSS代码，不同厂商、甚至同一厂商不同版本的解析效果极大可能不一致，其根本原因是浏览器内核不同，这就导致了页面显示效果不统一，产生了CSS兼容性问题

目前对兼容问题的解决方案：

- **浏览器CSS样式初始化**

在所有CSS开始前，对某些属性初始化，以防不同浏览器的显示效果不一样，通常不推荐一味地使用通配符统一初始化样式

```css
*{
 margin: 0;
 padding: 0;
}
```

- **浏览器私有属性**

可直接在某个属性中额外添加浏览器私有写法，确保浏览器能识别该属性值，有两种开发思路，分别是渐近增强和优雅降级

**渐进增强：**先写某些特殊浏览器能识别的私有属性，再写通用写法确保大部分浏览器能正常显示

```html
<style type="text/css">
.test {
  -webkit-transform:rotate(-3deg); /*Chrome/Safari*/
  -moz-transform:rotate(-3deg); /*Firefox*/
  -ms-transform:rotate(-3deg); /*IE*/
  -o-transform:rotate(-3deg); /*Opera*/
   transform:rotate(-3deg);
  background-color: #fe3388;
  width: 300px;
  height: 300px;
}
</style>
<body>
<div class="test"></div>
</body>
```

**优雅降级：**先确保大部分浏览器能正常显示，再写某些特殊浏览器能识别的私有属性

```html
<style type="text/css">
.test {
  width: 300px;
  height: 300px;
  background-color: #fe3388;
  transform:rotate(-3deg);
  -webkit-transform:rotate(-3deg); /*Chrome/Safari*/
  -moz-transform:rotate(-3deg); /*Firefox*/
  -ms-transform:rotate(-3deg); /*IE*/
  -o-transform:rotate(-3deg); /*Opera*/
}
</style>
<body>
<div class="test"></div>
```

- **CSS hack语法（**一般情况下，尽量避免使用CSS hack，过多滥用会造成html文档混乱，不易管理与维护）

1. 条件hack，IE浏览器专有的hack方式，微软官方推荐

```css
<!--[if IE]> 	
这段文字只在IE浏览器显示 	
<![endif]-->
<!--[if gte IE 6]> 	
这段文字只在IE6以上(包括)版本IE浏览器显示 	
<![endif]-->
```

  **2.** **属性级hack** CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果

```css
.test {
  color: red; /* All browsers */
  *color: blue;  /* IE7，IE6 */
  _color: skyblue;  /* IE6 */
}
```

  **3.** **选择符级hack，**在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀

```css
*html /* *前缀只对IE6生效*/
*+html /* *+前缀只对IE7生效*/
@media screen\9{...} /*只对IE6/7生效*/
@media \0screen {body { background: red; }} /*只对IE8有效*/
@media \0screen\,screen\9{body { background: blue; }} /*只对IE6/7/8有效*/
@media screen\0 {body { background: green; }} /*只对IE8/9/10有效*/
@media screen and (min-width:0\0) {body { background: gray; }} /*只对IE9/10有效*/ 
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} /*只对IE10有效*/
```

- **自动化插件**

在解析CSS文件时，插件会自动添加浏览器前缀至CSS代码中，如Autoprefixer

---

## 2.2 请问Flex的常见写法：flex:1表达什么含义？

虽说Flex具有众多属性，但在实际开发常简写为：flex：1，再结合display：flex，就能轻松打造出自适应布局，这也是Flex布局最大的优势。实际上flex为：flex-grow flex-shrink flex-basic三者的缩写。

flex-grow：定义在分配多余空间时，盒子的放大比例，默认为0，即存在剩余空间，也不放大

flex-shrink：定义在分配多余空间时，盒子的缩小比例（多余空间可能是负值），默认为1，即空间不足将缩小

flex-basis：定义在分配多余空间之前，盒子占据的主轴空间（可理解为基准值），通常根据该属性计算多余空间，默认为auto，即盒子自身大小

flex取值不同，空间分配计算值不同，有以下几种常见情况：

|                | flex-grow | flex-shrink | flex-basis | 解释                                                         |
| -------------- | --------- | ----------- | ---------- | ------------------------------------------------------------ |
| flex: 2 3 23px | 2         | 3           | 23px       | 当flex有三个值时，则依次分配给flex-grow、flex-shrink、flex-basic |
| flex: none     | 0         | 0           | auto       | 当 flex 为none时，则计算值为0 0 auto                         |
| flex: auto     | 1         | 1           | auto       | 当 flex 为auto时，则计算值为1 1 auto                         |
| flex: 1        | 1         | 1           | 0%         | 当 flex 为一个非负数字，该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0% |
| flex: 0%       | 1         | 1           | 0%         | 当 flex 为一个长度或百分比，该数字为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1 |
| flex: 23px     | 1         | 1           | 23px       |                                                              |
| flex: 2 3      | 2         | 3           | 0%         | 当 flex 为两个非负数字，则分别为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% |
| flex: 2 23px   | 2         | 1           | 23px       | 当 flex 为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 |

关于 flex-basis 的取值情况：

- auto：盒子本身大小
- 百分比：根据其包含块（即伸缩父容器）的主尺寸计算
- 0：盒子本身大小，当盒子大小未定义时，按其内容来来计算
- 可以代替width属性定义盒子大小，同时声明width属性和flex-basic属性时，会以flex-basic的值来计算

针对以下Flex布局，算出三个盒子自适应后的最终宽度。

```html
<style type="text/css">
.parent {
    display: flex;
    width: 600px;
}
.item-1 {
    width: 140px;
    flex: 2 1 0%;
    background-color: red;
    height: 50px;
}
.item-2 {
    width: 100px;
    flex: 2 1 auto;
    background-color: green;
    height: 50px;
}
.item-3 {
    flex: 1 1 200px;
    background-color: blue;
    height: 50px;
}
</style>

<body>
<div class="parent">
    <div class="item-1"></div>
    <div class="item-2"></div>
    <div class="item-3"></div> 
</div>
</body>
```

```
主轴上父容器总尺寸： 600px

子元素总基准值（flex-basis）：0% + auto + 200px = 300px，其中

0% 即 600*0% = 0 宽度

auto 对应取盒子自身尺寸：100px

故剩余空间： 600px - 300px = 300px

剩余空间为正，需要扩大子元素，伸缩放大(flex-grow)系数之和为： 2 + 2 + 1 = 5

剩余空间分配如下：

item-1 和 item-2 各分配 2/5，各得 300*2/5 = 120px

item-3 分配 1/5，得 300*1/5 = 60px

各项目最终宽度为：

item-1 = 0% + 120px = 0 + 120px = 120px

item-2 = auto + 120px = 100px + 120px = 220px

item-3 = 200px + 60px = 260px
```

---

## 2.3 请问清除浮动有哪些常用方法？

目前常用清除浮动的方法主要有：

  **1.** **给父元素添加 overflow：hidden（BFC布局）**

overflow：hidden为隐藏溢出，当内容超过其父元素时，可以用该方式将溢出的部分裁剪掉，使页面更加美观

当子元素浮动，给父元素添加overflow：hidden，按照该属性特性，将子元素超出的部分截掉，但是子元素有浮动，无法裁剪，只能父元素增加高度去包裹住子元素，从而使得父元素拥有高度，且高度随子元素自适应变化，从而清除浮动效果

代码比较简洁，可以通过触发BFC方式，但是因为本身overflow的本质是溢出隐藏的效果，所以有的时候也会有一些问题存在，比如内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素。

```html
<style type="text/css">
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
    overflow: hidden;
    /* 加上这句话，就可以清除浮动   overflow = hidden|auto|scroll 都可以实现*/
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
  overflow: hidden;
}
</style>

<body>
<div class="wrap">
   <div class="float">浮动</div>
   <div class="nofloat">不想被浮动影响</div>
</div>
</body>
```

这里父容器是没有设置固定高度的，本来第一个子元素浮动之后，父元素的高度会塌陷到跟第二个子元素一样高，但由于这里分别给第二个子元素和父元素都设置了overflow:hidden ，所以它们都生成了一个新的BFC区域，根据上文提供的BFC布局规则可以得知：BFC区域不会与float box 重叠；计算BFC高度时浮动元素的高度也参与计算。所以就得到清除浮动的效果。说得比较绕，但其实清除浮动得根据自己开发中的实际情况合理使用。  

**2. 给需要清除浮动元素添加clear:both**

clear:both：元素的左侧和右侧均不允许出现浮动元素（摘自W3C），添加了 clear属性的元素只能通过调整自身来使自己不要和浮动元素排列在一起，不能移动别的元素。若一个元素同时设置了 float：left 和 clear：left，左边不能有浮动元素，那么这个元素就要调整自己，排到下一行，因设置了 float: left，这个元素会往左边靠拢，所以这个元素会跑到下一行，同时往左浮动

```css
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
  clear: both;
}
```

  **3. 给浮动元素下方添加空盒子**

给该空盒子清除浮动（一般用clear:both），把父元素撑开，需要注意：必须是块级元素，此方法早期比较常用，会给页面增加无意义标签，通常不建议页面中设置多个无意义标签。

```html
<style type="text/css">
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
}
.clear{
  clear: both;
}
</style>

<body>
<div class="wrap">
   <div class="float">浮动</div>
   <div class="clear"></div>
     <br class="clear" />    <!--也可以使用br等别的块级元素来清除浮动-->
   <div class="nofloat">不想被浮动影响</div>
</div>
</body>
```

  **4. 利用after伪元素清除浮动::after**

该种方式的原理和方法3一样，添加一个内容为空的伪类，同时清除浮动（一般用clear:both），这里用伪类代替了空盒子，避免增加无意义标签

```html
<style type="text/css">
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
}
.clearfix:after{
  content:".";  /*尽量不要为空，一般写一个点*/
  display: block;
  height: 0;
  clear: both;
  overflow: hidden;
  visibility: hidden;
}
   .clearfix {
    *zoom: 1;   /*  *只有IE6,7识别 */
}
</style>

<body>
<div class="wrap clearfix">
   <div class="float">浮动</div>
   <div class="nofloat">不想被浮动影响</div>
</div>
```

**5. 利用after伪元素空余字符法**

```css
.clearfix::after{
    content:"\200B";   /* content:'\0200'; 也可以 */
    display:block;
    height:0;
    clear:both;
}

.clearfix {
    *zoom: 1; 
}
```

  **6.** **让父元素也浮动**

以浮制浮，父元素与子元素一起脱离文档流浮动，这样父元素就能自适应子元素高度，此方法有较大弊端，一定会影响父元素之后的元素排列，影响页面整体布局

```css
.wrap {
    width: 520px;
    border: 1px solid black;
    margin: 0 auto;
    float: left;
}
.float{
  width: 200px;
  height: 200px;
  background-color: green;
  float: left;
}
.nofloat{
  width: 300px;
  height: 150px;
  background-color: gray;
}
```

  **7. 给父元素添加固定高度**

此方法仅适用于子元素高度已知并且固定情况

----

## 2.4 请问有哪些常见margin问题，有什么解决办法？

### **1. 父元素margin塌陷,父子边距重合**

边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。

只发生在垂直方向，父元素和第一个/最后一个子元素设置了同方向的margin值，两个属性之间没有其他内容进行隔离，导致父元素margin-top/margin-bottom塌陷

父子元素的边界重叠

```html
<style>
  .parent {
    background: #e7a1c5;
  }
  .parent .child {
    background: #c8cdf5;
    height: 100px;
    margin-top: 10px;
  }
</style>
<section class="parent">
  <article class="child"></article>
</section>
```

以为期待的效果：

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/1696b9ade2b71502.png)

而实际上效果如下:

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/1696b9aded524e48.png)

在这里父元素的高度不是 110px，而是 100px，在这里发生了高度坍塌。

**产生原因：**

 是如果块元素的 `margin-top` 与它的第一个子元素的 `margin-top` 之间没有 `border`、`padding`、`inline` `content`、 `clearance` 来分隔，或者块元素的 margin-bottom 与它的最后一个子元素的 margin-bottom 之间没有 `border`、`padding`、`inline` `content`、`height`、`min-height`、 `max-height` 分隔，那么外边距会塌陷。子元素多余的外边距会被父元素的外边距截断。

**解决办法**：

父子元素的边界重叠得解决方案： 在父元素上加上 overflow:hidden;使其成为 BFC。

```html
<style>
  .parent {
    background: #e7a1c5;
    overflow:hidden;
  }
  .parent .child {
    background: #c8cdf5;
    height: 100px;
    margin-top: 10px;
  }
</style>
<section class="parent">
  <article class="child"></article>
</section>
```



常见解决办法：

- 给父级元素设置边框或内边距
- **触发BFC布局**，改变父级元素渲染规则，将父级元素独立，可给父级盒子添加：position：absolute/fixed、display：inline-block、float：left/right、overflow：hidden等一些触发BFC的属性，但是使用的时候都会带来不同的问题，具体使用中还需根据具体情况选择
- 给子元素前面添加一个空的兄弟元素，其overflow设为hidden，起隔离作用

```html
    <style type="text/css">
      .parent{
        width: 500px;
        height: 500px;
        background-color: blue;
        margin: 20px;
      }
      .child{
        width: 200px;
        height: 200px;
        background-color: orange;
        margin: 50px;
      }
      .sub{
        overflow: hidden;
      }
    </style>
      </head>

<body>
<div class="parent">
  <div class="sub"></div>
  <div class="child"></div>
</div>
```

重叠意义：外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。

解决方法： 

外层元素padding代替
内层元素透明边框 border:1px solid transparent;
内层元素绝对定位 postion:absolute:
外层元素 overflow:hidden;
内层元素 加float:left;或display:inline-block;
内层元素padding:1px;

----

###  **2. 同级元素margin重叠**

只发生在垂直方向，在同一个BFC区域内，相邻的兄弟元素会出现margin重叠情况，通常是上一个盒子的margin-bottom和下一个盒子的margin-top，叠加后的间距通常是：**两者为正取大值**（如下图所示效果），**一正一负/两者为负取两者之和**

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632985623694/974EDA43625E4786A64431DC1560371A)

```html
    <style type="text/css">
      .parent{
        width: 500px;
        height: 800px;
        background-color: gray;
        margin: 20px;
        overflow: hidden;
      }
      .child1{
        width: 200px;
        height: 200px;
        background-color: blue;
        margin: 100px;
      }
      .child2{
        width: 200px;
        height: 200px;
        background-color: green;
        margin: 50px;
      }
    </style>
      </head>

<body>
<div class="parent">
  <div class="child1"></div>
  <div class="child2"></div>
</div>
```

**分析原因：**在于child1的margin-bottom的参照元素是child2，而child2的margin-top的参照元素恰好是child1，这就导致了它俩之间的间距就会以两值中最大的那个为实际效果。这个现象其实和我们生活中很多场景很像，仔细想想应该不难理解。

常见解决办法：

触发BFC布局，改变元素渲染规则，将其中一个元素独立出来

**解决方法**：只设置一个元素的margin-top或者margin-bottom，避免margin重叠。 

```

```

---

###  **3. 空元素自身margin重叠**

若一个无内容的空元素，同时设置了margin-top与margin-bottom，则会发生重叠，如下图所示效果

![img](https://uploadfiles.nowcoder.com/images/20210930/897353_1632985644955/FF6C2EB8F4D5CC20E8B3FCF9601FC281)

---

## 2.5 请问display:none、visibility:hidden、opacity:0有什么异同点？

相同点：都可以让网页中某个元素隐藏

不同点：

- **空间占据**

display:none：元素没有被渲染，不存在于Render Tree中，不保留元素位置，在页面上彻底消失，可理解为：看不见摸不到

visibility:hidden：存在于Render Tree中，元素在网页上不可见，但元素位置没有改变，可理解为：看不见但摸得到

opacity:0 ：会占据空间

- **子元素**

display:none：所有子元素都会被隐藏，占据的空间会消失，不可点击，也不可被访问

visibility:hidden：具有继承性，给父元素设置，子元素也会继承，但若重新给子元素设置visibility: visible，子元素又会显示

opacity:0 ：具有继承性，**不能**通过设置子元素的 opacity:1 使其显示

- **DOM结构**

display:none：影响DOM结构，会触发回流，计数器不会计数，浏览器渲染开销大

visibility:hidden：不影响DOM结构，计数器仍运行，只会触发重绘

opacity:0 ：只会触发重绘

- **事件绑定**

display:none和visibility:hidden：元素上绑定的事件无法触发

opacity:0 ：元素上绑定的事件可以触发

---

## 2.6 请问src和href有什么异同点？

相同点：都具有引用功能

不同点：

**href：**表示超文本引用，通常用于link、a等元素，**href是引用和页面关联**，在当前元素和引用资源之间建立联系

**src：**source的缩写，表示资源引用，通常用于img，script，iframe等元素，**指向外部资源的位置**，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，如js脚本，img图片等元素

---

# 页面布局

---

## 3.1 请问定位布局position属性有哪些取值？

定位布局：页面元素CSS样式采用position属性，可在top/bottom/right/left四个方向进行位置移动，从而达到定位效果，position属性可取以下7个值：

  **1. 相对定位 relative**

- 不会使元素脱离文档流（原本位置会被保留，即改变位置也不会占用新位置）
- 相对于自身原本位置移动（没有定位偏移量则对元素无影响）
- 不影响元素本身特性（无论块级元素或行内元素，保留其原本特性）
- 常用于提升层级，从而改变元素覆盖关系，若两个都为定位元素，后面的会覆盖前面

  **2. 绝对定位 absolute**

- 使元素完全脱离文档流（在文档流中不再占原来位置）
- 行内元素设置定位效果后，支持设置宽高
- 区块元素设置定位效果后，未设置宽度时由内容撑开宽度
- 相对于最近一个有定位的父元素进行偏移，如果不存在就逐级向上排查，直到相对于body元素，即相对于浏览器窗口（必须有参照物）
- 子绝父相，一般配合相对定位使用，（将父元素设置相对定位，子元素相对于父元素偏移）
- 可提升层级

  **3. 固定定位 fixed**

- 直接相对于浏览器窗口进行“绝对定位”
- 浮动在页面中，元素位置不会随浏览器窗口滚动条滚动而变化
- 不会受文档流动影响

  **4. 粘性定位 sticky**

- 基于用户的滚动来定位，在相对定位与绝对定位两者间切换。滚动前相当于position:relative，当页面滚动超出目标区域时，相当于position:fixed，会将元素固定在目标位置
- 相对于离它最近的具有滚动框的父级元素，如果父级元素都不可以滚动，那相对于浏览器窗口计算偏移量
- 如top: 50px，在sticky元素到达距离相对定位的元素顶部50px的位置时固定，无论怎么滚动，都不再向上移动
- 兼容性不好，如Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位，通常需要结合CSS3兼容方案

  **5. 静态定位 static**

- 默认定位，遵循正常的文档流
- 元素不会受到影响

  **6. 继承值 inherit**

- 从父元素继承 position 属性值

  **7. 初始值 initial**

- initial 关键字可用于任何 HTML 元素上任何 CSS 属性
- 可将所有CSS属性恢复到初始状态

---

###  **1. fixed定位会出现失效情况吗？有什么解决办法吗？**

存在常见3种fixed定位失效情况：

​     \1. 父元素的transform属性值不为none时，子元素的fixed失效（比较常见，仅在部分浏览器中失效）

​    失效原因：当元素祖先的 transform 属性非 none 时，定位容器由视口改为该祖先（摘自MDN）

​    解决办法：

​    经过实验发现，absolute定位在该情况下不会失效，可利用absolute定位模拟fixed效果，主要实现思路：将html的滚动条禁用，开启body滚动条，对该元素absolute定位，并不设置父级元素定位，会相对document定位，但其滚动条未开启，不会受body滚动影响

​    \2. perspective属性值不为none时（不常见）

​    浏览器都不支持 perspective 属性，Chrome 和 Safari 支持替代的 -webkit-perspective 属性，目前可行办法就是删掉perspective属性

​     \3. 元素的will-change中指定了任意 CSS 属性

​    目前可行办法就是尽量避免给fixed定位元素设置will-change

---

## 3.2 请问你了解浮动布局float属性吗？

浮动布局：为方便页面设计，给元素设置float属性，将元素脱离文档流，浮动框进行左右移动，直至外边缘遇到包含框或者另一个浮动框边缘，再通过margin属性调整位置，float属性可取3个值：left：左浮动、right：右浮动、none：不浮动（默认）

浮动的影响：

- 改变块级元素的排列方式，内容从上下排列显示变成水平排列显示
- 浮动元素会脱离文档流，不占位，盒子重叠，内容不重叠
- 浮动的块级元素的宽度由内容撑开，行内元素可设宽高、margin和padding均有效，**可理解为隐式转换为inline-block元素**

---

### 1. 浮动布局最常产生什么问题？

通常父级盒子不设置高度时，高度将由内容或子元素撑开，当子元素浮动脱离文档流后， 父盒子就会出现高度塌陷，边框变成一条线，通常需要清除浮动来解决该问题

---

## 3.3 请问BFC布局有哪些特点、触发条件以及实际应用？

BFC（Block Formatting Context）：格式化上下文，也称BFC布局，是Web页面中盒模型布局的CSS渲染模式，**指一个独立的渲染区域，与其他元素隔离，不受外部布局影响**

BFC布局特点：

- 在BFC区域内，内部盒子会在垂直方向上一个接一个地放置
- 在BFC区域内，内部盒子垂直方向上的距离由margin决定。（可理解为：属于同一个BFC的两个相邻盒子的上下margin会发生重叠）
- 同一个BFC区域内，设置了float属性的盒子不会重叠
- BFC就是页面上的一个隔离的独立容器，容器内外元素互不影响
- 计算BFC的高度时，区域内的浮动元素也参与计算

BFC布局触发条件（满足任意一个即可形成BFC）：

- 根元素<html>
- 浮动元素：float不为none
- 绝对定位元素：position（absolute、fixed）
- display为inline-block、table-cells、table-caption、flex、inline-flex
- overflow不为visible（hidden、auto、scroll）

BFC布局实际应用：

- 清除浮动，通过设置overflow:hidden解决父元素坍塌问题
- 垂直margin合并，BFC区域内两个相邻元素的垂直外边距会发生叠加，**叠加后的外边距为两者外边距的最大值。这样可保持各区域间上下间距一致**，比如多个段落之间与顶部底部的边距保持一致
- 防止垂直 margin 合并，**反之可以在元素外层包裹一层容器，并触发该容器生成一个新的BFC布局**，与相邻元素隔离开来
- 实现自适应双栏、三栏布局，利用浮动、定位、Flex布局原理可实现多种自适应布局

---

## 3.4 请问如何将一个<div>盒子在页面垂直水平居中？

### 元素宽高固定时（设元素宽高为100px）：

- **absolute + 负margin**

```html
<style type="text/css">
  .box{
    width: 100px;
    height: 100px;
    background-color: gray;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
</style>
<body>
  <div class="box"></div>
</body>
```

- **absolute + margin auto**

```css
  .box{
    width: 100px;
    height: 100px;
    background-color: gray;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: auto;
  }
```

- **absolute + calc()**

```css
  .box{
    width: 100px;
    height: 100px;
    background-color: gray;
    position: absolute;
    top: calc(50% - 50px);
    left: calc(50% - 50px);
  }
```

### 元素宽高未知时：

- absolute + transform

```html
<style type="text/css">
  .box{
    background-color: gray;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
  }
</style>
<body>
  <div class="box">元素宽高未知</div>
</body>
```

- table，需要先打造一个表格结构，再将盒子放入单元格中，表格单元格中的**内容本身就是垂直居中的**，此法弊端：增加了很多冗余代码

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    text-align: center;
  }
  .box{
    background-color: gray;
    display: inline-block;
  }
</style>
<body>
  <body>
  <table>
    <tbody>
      <tr>
        <td class="wrap">
          <div class="box">元素宽高未知</div>
        </td>
      </tr>
    </tbody>
  </table>
</body>
```

- css-table，CSS新增的table属性，直接把普通元素，变为table元素的现实效果，原理与用table一样，但没有那么多的冗余代码

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    display: table-cell;
    text-align: center;
    vertical-align: middle;
  }
  .box{
    background-color: gray;
    display: inline-block;
  }
</style>
<body>
  <div class="wrap">
      <div class="box">元素宽高未知</div>
  </div>
</body>
```

- flex布局

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .box{
    background-color: gray;
  }
</style>
<body>
  <div class="wrap">
      <div class="box">元素宽高未知</div>
  </div>
</body>
```

- grid布局，CSS新出的网格布局，代码量少，但兼容性不太好

```html
<style type="text/css">
  .wrap{
    width: 200px;
    height: 200px;
    border: 1px solid black;
    display: grid;
  }
  .box{
    background-color: gray;
    align-self: center;
    justify-self: center;
  }
</style>
<body>
  <div class="wrap">
      <div class="box">元素宽高未知</div>
  </div>
</body>
```

总结：宽高固定时，推荐absolute + 负margin；宽高不固定，推荐flex

---

## 3.5 请问实现自适应两栏布局（左定宽，右宽度自适应）有哪些方法？

```html
<style type="text/css">
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;
  }
</style>
<body>
  <div class="wrap">
    <div class="left">左侧固定内容</div>
    <div class="right">右侧内容自适应</div>
  </div>
</body>
```

- **float**

```css
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;
      
    float: left;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;
      
    margin-left: 200px;
  }
```

- **absolute**

```css
  .wrap{
    position: relative;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    position: absolute;
    top: 0;
    left: 0;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    margin-left: 200px;
  }
```

- **table**

```css
  .wrap{
    display: table;
    width: 100%;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    display: table-cell;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    display: table-cell;
  }
```

- **calc()**

```css
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    float: left;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    float: left;
    width: calc(100% - 200px);
  }
```

- **inline-block+calc()**

```css
  .wrap{
    width: 100%;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    display: inline-block;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    display: inline-block;
    width: calc(100% - 200px);  /* 谷歌和火狐都不能达到目的*/
  }
```

- **flex布局**

```css
  .wrap{
    display: flex;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    flex: 0 0 auto;
  }
  .right{
    height: 200px;
    background-color: #c0c0c0;

    flex: 1;
  }
```

---

## 3.6 请问实现自适应三栏布局（左右定宽，中间宽度自适应）有哪些方法？

- 左边左浮动，右边右浮动，中间自适应，需注意：**中间盒子必须放在DOM结构的最后**，若放在第一个，会占据第一行文档流位置，左右两边的盒子只能在第二行浮动

```html
<style type="text/css">
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    float: left;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    float: right;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    margin: 0 400px 0 200px; /*为左右两盒子留出位置*/
  }
</style>
<body>
  <div class="wrap">
    <div class="left">左侧固定内容</div>
    
    <div class="right">右侧宽度固定</div>
    
    <div class="center">中间宽度自适应</div>
  </div>
```

- 左右两盒子绝对定位，中间自适应，三个盒子的先后顺序无要求

```html
<style type="text/css">
  .wrap{
    position: relative;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    position: absolute;
    top: 0;
    left: 0;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    position: absolute;
    top: 0;
    right: 0;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    margin: 0 400px 0 200px; /*为左右两盒子留出位置*/
  }
</style>
<body>
  <div class="wrap">
    <div class="left">左侧固定内容</div>
    <div class="center">中间宽度自适应</div>
    <div class="right">右侧宽度固定</div>
  </div>
</body>
```

- flex布局，左右两盒子定宽，中间盒子flex：1，flex-grow：1、flex-shrink：1、flex-basic：0%，中间盒子的宽度：自动分配父元素除去左右盒子后的宽度，其次，弹性布局中盒子默认水平方向排列，需注意：必须最外层加一个大盒子，且中间盒子必须放在中间，按左中右顺序排列

```css
  .wrap{
    display: flex;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    flex: 1;  /*等同于flex-grow：1、flex-shrink：1、flex-basic：0%*/
  }
```

- 圣杯布局法，浮动+负margin，此方法逻辑上稍复杂，建议大家一步步理解后再实践一下，**center盒子必须放在DOM结构第一个**

```html
<div class="container">
    <div class="center"></div>
    <div class="left"></div>
    <div class="right"></div>
</div>
```

**步骤1：center盒子**宽度100%，左右两边盒子定宽

**步骤2：三个盒子**先设置相对定位，再左浮动，脱离文档流

为什么用relative 而不用 absolute呢？因为**设置absolute会让float失效**，而relative就不存在这个问题

**步骤3：left盒子** margin-left：-100%（直接将left盒子拉到center盒子左边），这里效果不等同取left盒子宽度（left盒子会跑到center盒子右边），margin设置-100%就等价于把left盒子向左移动视窗宽度的距离，等价于left盒子直接放置到最左边

**步骤4：left盒子**会覆盖center盒子左边部分内容，要把center盒子内容拉出来，在外围container加上左右padding，值分别为左右两盒子宽度，此时left盒子也会跟过来，left盒子设置left：-自身盒子宽度

**步骤5：right盒子** margin-left：-自身盒子宽度，移动到center盒子右边，不需要盒子处于最左端，所以不需要-100%，仅让它回到第一行即可

**步骤6：right盒子** right -自身盒子宽度，就可以让它不覆盖center盒子右边部分内容

完整的CSS代码如下：

```html
<style type="text/css">
  .wrap{
    padding: 0 400px 0 200px;
  }
  .center,.left,.right{
    position: relative;
    float: left;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    margin-left: -100%;
    left: -200px;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    margin-left: -400px;
    right: -400px;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    width: 100%;
  }
</style>
<body>
  <div class="wrap">
    <div class="center">中间宽度自适应</div>
    <div class="left">左侧固定内容</div>
    <div class="right">右侧宽度固定</div>
  </div>
</body>
```

- 双飞翼布局法，前半部分与圣杯布局基本一致，三栏全部float浮动，但左右两盒子加上负margin让其跟中间盒子并排，以形成三栏布局。

**不同处：**对于中间盒子被覆盖问题的解决思路：直接在center盒子内部创建子盒子用于放置内容，对该子盒子设置margin-left和margin-right为左右两盒子留出位置

简单地说，对比圣杯布局，双飞翼布局比圣杯布局多创建了一个div，但不用相对布局

```html
<style type="text/css">
  .center,.left,.right{
    position: relative;
    float: left;
  }
  .left{
    width: 200px;
    height: 200px;
    background-color: #389777;

    margin-left: -100%;
  }
  .right{
    width: 400px;
    height: 200px;
    background-color: #9899ff;

    margin-left: -400px;
  }
  .center{
    height: 200px;
    background-color: #c0c0c0;

    width: 100%;
  }
  .main{
    margin: 0 400px 0 200px;
  }
</style>
<body>
  <div class="wrap">
    <div class="center">
      <div class="main">中间宽度自适应</div>
    </div>
    <div class="left">左侧固定内容</div>
    <div class="right">右侧宽度固定</div>
  </div>
</body>
```

---

# js部分

---

## 1.1 请问在JS中有哪些数据类型？

JS数据类型一共有7种，分为基本数据类型和引用数据类型

- **基本数据类型**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol、BigInt

Symbol：ES6引入了一种新的原始数据类型，表示独一无二的值，**主要用于解决属性名冲突的问题**，做为标记

BigInt：新增数据类型，是ES2020新增加的，精度大于 2^53 - 1， 是比Number类型支持的范围更大的整数值，在对大整数执行数***算时，使用BigInt，会减少整数溢出问题

创建方式：BigInt(value)、在一个整数字面量后面加 n 

```js
let a = 10n; 
let b = BigInt(10);  
console.log(a === b);     // true
```

注意：由于在Number 与 BigInt 之间进行转换会损失精度，**建议仅在值可能大于2^53 时使用 BigInt类型**，并且不在两种类型之间进行相互转换。

与Number不同点：

（1）不能用于 Math 对象中的方法；

（2）不能和任何 Number 实例混合运算，两者必须转换成同一种类型（ BigInt 变量在转换成 Number 变量时可能会丢失精度）



- **引用数据类型**：对象(Object)，其中包含了日期（Date）、函数（Function)、数组（Array）、正则（RegExp）等

两者总结区别：

（1）声明变量时不同的内存分配：

基本：存储在栈中的简单数据段，它们的值直接存储在变量访问的位置

原因：**基本类型数据占据的空间是固定的**，所以将他们存储在较小的内存区域——栈，便于迅速查寻变量的值

引用：存储在堆中的对象，存储在变量处的值是一个指针，指向存储对象的内存地址

 原因：**引用类型数据的大小会改变**，不能把它放在栈中，否则会降低变量查寻速度，相反，地址的大小是固定的，可以存在栈中

（2）不同的内存分配机制也带来了不同的访问机制

引用：js中不允许直接访问保存在堆内存中的对象，在访问一个对象时，**首先得到对象在堆内存中的地址**，按照这个地址去获得对象中的值（引用访问）

基本：可直接访问

（3）复制变量时的不同

基本：变量复制时，会将原始值的副本赋值给新变量，此后两变量是完全独立的，他们只是拥有相同的值而已（深拷贝）

引用：变量复制时，会把内存地址赋值给新变量，新旧变量都指向了堆内存中的同一个对象，任何一个作出的改变都会影响另一个（浅拷贝）（深拷贝浅拷贝对比详见下3.3）

（4）参数传递的不同（把实参复制给形参的过程）

由于内存分配的差别，两者在传参时也有区别

基本：只是把变量里的值传递给参数，之后参数和这个变量互不影响

引用：传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部，因为它们都指向同一个对象

----

## 1.2 请问Undefined与Null有何异同点？

共同点：都是基本类型，保存在栈中

不同点：

Undefined表示"缺少值"，**就是此处应该有一个值，但是还没有定义**，转为数值时为NaN。典型用法：

- 变量被声明了，但没有赋值时，就等于undefined
- 调用函数时，应该提供的参数没有提供，该参数等于undefined
- 对象没有赋值的属性，该属性的值为undefined
- 函数没有返回值时，默认返回undefined

Null：

表示"没有对象"，**即该处不应该有值**，转为数值时为0。典型用法是：

- 作为函数的参数，表示该函数的参数不是对象
- 作为对象原型链的终点

注意：

```js
undefined == null; //true
undefined === null; //false
```

ECMAScript 规范： null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性，故他们相等。

全等操作 === 在比较相等性的时候，两者不是同一类型值，会发生类型转换，故两者不全等。

```js
Number(undefined); // NaN
Number(null); // 0

```

---

## 1.3 请问如何判断js变量的数据类型？

常见判断方法有以下四种：

- **typeof xx**

返回一个字符串（小写），用来判断：Undefined、String、Number、Boolean、Symbol、Object、Function，无法检测引用类型里的Array

```bash
> typeof(undefined)
'undefined'
> typeof("abc")
'string'
> typeof(100)
'number'
> typeof(false)
'boolean'
> typeof(Symbol(2))
'symbol'

> typeof(BigInt(200))
'bigint'
```

优点：可区分Object与Function

缺点：

（1）对于 Null ，返回 object 类型

```js
> typeof(null)
'object'
```

原因：Null类型只有一个null值，该值表示一个空对象指针（出自JavaScript高级程序设计）

**typeof的检测原理**：不同的对象在底层都表示为二进制，在js中二进制前**（低）三位存储其类型信息**为：000: Object、100：String、110： Boolean、1： Number。**null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回"object"。**

  （2） 对于Array、Date、RegExp都会返回object，不能更详细的区分

```js
var fn=function(){};
let obj={a:1};
let arr=[1,2,3];
let now=new Date();
let reg=/abc/;

console.log(typeof(fn));  //function
console.log(typeof(obj));  //object
console.log(typeof(arr));  //object
console.log(typeof(now));  //object
console.log(typeof(reg));  //object
```

- **xx instanceof xx**

返回true/false，**只能判断引用类型** ，无法检测基本类型

判断原理：判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上。简单来说：能验证new构造函数创建出来的实例，左边的对象是否是右边的类的实例，**属于验证式判断类型**

缺点：**只能用来判断两个对象是否属于实例关系**， 而不能判断一个对象实例具体属于哪种类型（原型链上的都会返回true）

```js
console.log('abc' instanceof String);// false 
console.log( String('abc') instanceof String);// true 

console.log(12 instanceof Number);// false 
console.log(new Number(12) instanceof Number);// true 

console.log(true instanceof Boolean);// false 
console.log(new Boolean(true) instanceof Boolean);// true 

console.log({name:'yy'} instanceof Object);// true 
console.log(new Object({name:'yy'}) instanceof Object);// true 

console.log(['12','123'] instanceof Object);// true 
console.log(['12','123'] instanceof Array);// true 
console.log(new Array('12',32) instanceof Object);// true 
console.log(new Array('12',32) instanceof Array);// true 

console.log(function(){} instanceof Object);// true 
console.log(function(){} instanceof Function);// true 
console.log(new Function() instanceof Function);// true 

console.log(new Date() instanceof Object);// true 
console.log(new RegExp instanceof Object);// true 

console.log(new String('abc') instanceof Object);// true 
console.log(new Number(12) instanceof Object);// true

console.log(null instanceof Object);  //false
console.log(undefined instanceof Object);  //false
console.log(Symbol(2) instanceof Object);  //false
console.log(BigInt(2) instanceof Object);  //false
```



- **xx.constructor === xx**

返回true/false，判断原理：

当一个函数F被定义时，JS引擎会为F添加prototype原型，然后再在prototype上添加一个constructor属性，并让其指向F的引用

具体来说：当 var f = new F() 时，F被当成了构造函数，f是F的实例对象，**此时F原型上的constructor传递到了f上，因此f.constructor === F**

缺点：不可判断Null、Undefined是无效的对象，**没有constructor存在**

constructor 是不稳定的，如创建的对象更改了原型，无法检测到最初的类型

```js
console.log("abc".constructor===String);  //true
console.log(new Number(2).constructor===Number);  //true
console.log([1,2,3].constructor===Array);  //true
console.log(false.constructor===Boolean);  //true
console.log(new Function().constructor===Function);  //true
console.log(new Date().constructor===Date);  //true
console.log(/abc/.constructor===RegExp);  //true

console.log(document.constructor===HTMLDocument);  //true
```

- **Object.prototype.toString.call(xx)**

返回“[object type]”（字符串），能判断所有类型，万金油方法

判断原理：JS中的所有对象都是继承自Object对象的，通过call方法（显式绑定）改变this指向，利用Object.prototype上的原生toString()方法判断数据类型

```js
console.log(Object.prototype.toString.call(123));  // [object Number]
console.log(Object.prototype.toString.call("abc"));  //[object String]
console.log(Object.prototype.toString.call(undefined));  //[object Undefined]
console.log(Object.prototype.toString.call(null));  //[object Null]
console.log(Object.prototype.toString.call(false));  //[object Boolean]

console.log(Object.prototype.toString.call(Symbol(2)));  //[object Symbol]
console.log(Object.prototype.toString.call(100n));  //[object BigInt]

console.log(Object.prototype.toString.call({}));  //[object Object]
console.log(Object.prototype.toString.call([]));  //[object Array]

console.log(Object.prototype.toString.call(new Date()));  //[object Date]
console.log(Object.prototype.toString.call(new RegExp("abc","g")));  //[object RegExp]

console.log(Object.prototype.toString.call(function(){}));  //[object Function]
```

-----

## 1.4 请问===与==有何区别？相等与全等的区别

==：相等(值)

**先转换再比较**（强制转换）

- 有布尔值，把false->0， true->1， 调用Number()方法
- 字符串 和 数值，字符串转数值 ；调用Number()方法
- 对象 和 非对象，调用对象的valueOf()和toString()方法把对象转换成基础类型的值再比较，除Date对象外，会优先尝试使用valueOf()方法
- 有一个是NaN， 则返回false。 即使两个都是NaN，也返回false，因为按照规则，NaN不等于NaN
- 两个操作数都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象，则返回ture 因为对象存的是地址值
- 比较相等性之前， 不能将 null和 undefined转换成其他任何值

```bash
> 1==true
true
> 2==false
false
> 2===true
false
> 1=="1"
true
> []==""
true
> []==false
true
> []=={}
false
> []==[]
false
> {}=={}
false
> null==undefined
true
> 1==NaN
false
> 0==undefined
false
> 0==null
false

> false==0
true
> false==null
false
> false==undefined
false


```

**=== ： 全等(类型和值）**

**先判断类型再比较**， 类型不同直接不等，不转换类型

```bash
> 0===0
true
> []===[]
false
> 2===2
true
```

---

## 1.5 请问你了解js作用域吗？

**1，js作用域**

作用域：在运行时代码中的某些特定部分中变量、函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。**作用域最大作用**：隔离变量，不同作用域下同名变量不会有冲突

作用域是分层的，内层作用域可以访问外层作用域的变量，反之不行

**2， JavaScript 没有块级作用域（ES6之前）**，只有全局作用域和函数作用域，ES6引入块级作用域（相关知识会在第5章中分析）

全局作用域（浏览器）：window

最外层函数 和在最外层函数外面定义的变量拥有全局作用域

所有末定义直接赋值的变量自动声明为拥有全局作用域

所有window对象的属性拥有全局作用域，如window.name、window.location、window.top等

nodejs 的全局对象：global，**声明全局变量的方式为: global.变量名**

在各个模块下都可以直接访问 global 对象

一个文件就是一个模块，通过 require 引入模块

函数作用域：

声明在函数内部的变量

**3，作用域链**

当我们需要某个变量的值时，先去它最近的作用域去找，如果找不到，就找它的上级作用域，依次类推，直到找到全局，如全都未定义，那就抛出一个错误，如下代码所示

```js
var a = 1
function A(){
    function B(){
        console.log(a);
    }
    return B();
}
A();//1

```

常见面试题：

```js
var a=10;
function A(){
    alert(a);
};
function B(){
    var a=20;
    A();
}
B();//10

```

为什么输出10，而不是20？**js中变量的作用域链与定义时的环境有关，与执行时无关**。调用函数B，B中调用了函数A，函数A里面没定义变量a，函数A只是被B调用且不传参，因此函数A无权使用函数B的局部变量a，而在上方还有一个全局变量a，因此这里输出10

---

## 1.6 请问什么是变量提升？什么是函数提升？

js区别于C、C++、Java语言，在ES6之前，JavaScript没有块级作用域，只有**全局作用域**和**函数作用域**。

这题在面试时尽量用具体代码举例说明

先看下面代码：

```js
console.log(a);

var a=2;  //undefined
```

变量 a 在使用前没有先进行声明，会抛出 ReferenceError异常?还是输出 2 ？事实上都不对，正确答案是输出 undefined（已声明未定义值）

这就是一个典型的 **变量提升** 现象

js 实际上会将 var a = 2 看成两个声明： var a和 a = 2。第一个定义声明在**编译阶段**进行，**第二个赋值声明被留在原地等待执行阶段**

因此上面代码会以如下形式进行处理：

```js
var a; 
console.log(a); 
a = 2;
```

所有的声明（变量和函数）都会被“移动”到各自作用域的最前端，这个过程被称为 **变量（函数）提升**

再看一个高频考题：

```js
var a=true;

foo();  //undefined

function foo(){   //函数声明
	if (a) {
		var a=10;
	}
	console.log(a);
}
```

最终的答案是 undefined，代码实际js执行情况如下：

```js
function foo() { 	
    var a; 	
    if(a) { 		
    	a = 10; 	
    } 	
    console.log(a); 
} 
var a;  
a = true;  
foo();

```

首先， foo(...) {} 的位置被移到了 foo();的前面，**这是函数发生了提升**，在 foo(...) {} 中，为什么会输出 undefined，而不是10？

原因：**JavaScript 中没有块级作用域，**所以 var a = 10会被 JavaScript 分为两步：var a; 会被提升到函数作用域中的最顶端，声明了一个局部变量 a，在 foo(...) {} 的函数作用域中，**这个重名局部变量 a 会屏蔽全局变量 a**，换句话说，在对 a 的赋值声明之前，在 foo(...) {}中，a 的值都是 undefined，无法进入 if(a) {...} 中，所以最后打印出来 undefined

注意：在 JavaScript 中，函数有两种方式进行声明，函数声明会被提升，**但函数表达式却不会被提升**

```js
var a = true; 
foo();  //TypeError: foo is not a function

var foo = function() { 	//函数表达式
    if(a) { 		
    	var a = 10; 	
	} 	
	console.log(a); 
}

```

```js
var a; 
var foo；  
a = true; 
foo();  
foo = function() { 
    if(a) {      
    	var a = 10;    
    } 
    console.log(a); 
}
```

当执行到foo()时，foo 还没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo()对 undefined 值进行函数调用而导致非法操作，因此会抛出 TypeError 异常

函数优先：函数声明和变量声明都会被提升。**但函数会首先被提升，然后才是变量提升**

```js
foo();  // 1

function foo(){  //函数声明
	console.log("1");
}

foo();  // 1

var foo = function() { 	//函数表达式
	console.log("2"); 
}


foo();  //2
```

输出 1 而不是 2！这段代码片段会被引擎理解为：

```js
function foo() { 	
    console.log('1'); 
}  
var foo;
foo();  
foo = function() {
 	console.log('2'); 
 }
```

---

## 1.7 请问js有哪些常见报错类型？它们有什么区别？

在js中常有6种错误类型：TypeError、ReferenceError、SyntaxError、RangeError、EvalError、URIError。其中 TypeError 和 ReferenceError 日常开发会经常碰到。

**TypeError：**类型错误(调用不存在的方法)，变量或参数不是预期类型时发生的错误

```js
var a;

console.log(a.b); //TypeError: Cannot read properties of undefined (reading 'b')
```

变量 a 存在，但a的b属性不存在

**ReferenceError：**引用错误(要用的变量没找到)

```js
console.log(b)  //ReferenceError: b is not defined
```

对 b 进行 RHS查询，在所有嵌套作用域中遍寻不到变量

**SyntaxError：**语法错误（给关键字赋值、变量名不符合规范）

```js
//var 1;  //SyntaxError: Unexpected number

function=1;  //SyntaxError: Unexpected token '='
```

**RangeError：**范围错误(参数超范围)，主要有：数组长度为负数、Number对象的方法参数超出范围、函数堆栈超过最大值

```js
// 1、数组长度为负数
[].length = -5      // Uncaught RangeError: Invalid array length

// 2、Number对象的方法参数超出范围
var num = new Number(12.34)
console.log(num.toFixed(-1))   //RangeError: toFixed() digits argument must be between 0 and 100    at Number.toFixed (<anonymous>)

```

**EvalError：**非法调用 eval()，eval()函数没有被正确执行

```js
var myEval = eval;
myEval("alert('call eval')");
// 需要注意的是：ES5以上的JavaScript中已经不再抛出该错误，但依然可以通过new关键字来自定义该类型的错误提示。

new Error([message[fileName[lineNumber]]])
// 第一个参数是错误提示信息，第二个是文件名，第三个是行号。

```

**URIError：**URI不合法，相关函数的参数不正确。

```js
decodeURI("%")     // URIError: URI malformed
```

---

### **1、什么是LHS和RHS查询？**

如上所说，对于var a = 2， js引擎会将它分为两步完成：var a 和 a = 2

变量的赋值操作会执行两个动作：首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在引用域中查找该变量，如果能够找到就会对它赋值

LHS和RHS就是js对变量的两种查找操作， 查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行

LHS（Left-hand Side）和RHS（Right-hand Side）通常是指等号（赋值运算）的**左右边的查询**，但并不一定意味就是"="的左侧和右侧，赋值操作还有其他几种形式，因此在概念上最好将其理解为：“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”

可以参考下面代码加以理解：

```js
function foo(a) { 	
    var b = a; 	
    return a + b; 
}  
var c = foo(2);
```

代码中一共有3个LHS查询和4个RHS查询

LHS：

```
第2、5行中的b = ...、c = ...，变量在赋值操作的左边，对 b、c 需要 LHS 查询

第5行调用 foo(2) 时，需要将实参2赋值给形参a，所以对 a 需要 LHS 查询
```

RHS：

```
第2行 b = a， a 在赋值操作的右边，需要知道 a的值，对 a 需要 RHS 查询

第3行 reutrn a + b， 需要知道 a 和 b 的值， 分别对 a 和 b 都进行 RHS 查询

第6行 c = foo(2)，foo(2) 在赋值操作的右边，需要知道 foo(2)的值，对 foo(2) 需要 RHS 查询
```

当**RHS****查询不成功**时：会抛出 ReferenceError异常

当**LHS查询不成功**时：会自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS查询的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）

---

## 2.1 请问你了解js中的闭包吗？

