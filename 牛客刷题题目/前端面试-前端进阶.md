------

## 浏览器

---

#### 1.1 cookie sessionStorage localStorage 区别

**参考答案**：

共同点：都是保存在浏览器端、且同源的

区别：

1. cookie数据始终在**同源**的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
2. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、**所以cookie只适合保存很小的数据，如会话标识**。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：**只在设置的cookie过期时间之前有效**，即使窗口关闭或浏览器关闭
4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的
5. web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6. web Storage的api接口使用更方便

---

#### 1.2 如何写一个会过期的localStorage，说说想法

**参考答案**：

**两种方案：惰性删除 和 定时删除**

**惰性删除**

惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。我们先来简单实现一下：

```js
    var lsc=(function(self){
      var prefix="one_more_lsc_";
      /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
      self.set=function(key,val,expires){
        key=prefix+key;
        val=JSON.stringify({'val':val,'expires':new Date().getTime()+expires*1000});
        localStorage.setItem(key,val);
      };
      /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
      self.get=function(key){
        key=prefix+key;
        var val=localStorage.getItem(key);
        if (!val) {
          return null;
        }
        val=JSON.parse(val);
          //检查是否过期
        if (val.expires<new Date().getTime()) {
          localStorage.removeItem(key);
          return null;
        }
        return val.val;
      };
      return self;
    }(lsc || {}));

//测试
    lsc.set("kop","66",10);
    console.log(lsc.get("kop"));
    setTimeout(()=>{
      console.log(lsc.get("kop"));
    },12000);
```

上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。

**定时删除**

定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。

每隔一秒执行一次定时删除，操作如下：

1. 随机测试20个设置了过期时间的key。
2. 删除所有发现的已过期的key。
3. 若删除的key超过5个则重复**步骤1**，直至重复500次。

具体实现如下：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>测试</title>
<style type="text/css">
  
</style>
</head>
<body>
<div>
    <button onclick="openLink()">打开</button>
</div>
<script type="text/javascript">
    var lsc=(function(self){
      var list=[];
      var prefix="one_more_lsc_";

      //初始化list
      self.init=function(){
        var keys=Object.keys(localStorage);
        var reg=new RegExp("^"+prefix);
        var temp=[];
        //遍历所有localStorage中的所有key
        for(let i=0;i<keys.length;i++){
          //找出可过期缓存的key
          if (reg.test(keys[i])) {
            temp.push(keys[i]);
          }
        }
        list=temp;
      };

      self.init();
      
      /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
      self.set=function(key,val,expires){
        key=prefix+key;
        val=JSON.stringify({'val':val,'expires':new Date().getTime()+expires*1000});
        localStorage.setItem(key,val);
      };
      /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
      self.get=function(key){
        key=prefix+key;
        var val=localStorage.getItem(key);
        if (!val) {
          return null;
        }
        val=JSON.parse(val);
        if (val.expires<new Date().getTime()) {
          localStorage.removeItem(key);
          return null;
        }
        return val.val;
      };

      self.check=function(){
        if (!list || list.length===0) {
          return;
        }
        let checkCount=0;
        while(checkCount<500){
          let expireCount=0;
          //随机测试20个设置了过期时间的key
          for(let i=0;i<20;i++){
            if (list.length===0) {
              break;
            }
            let index=Math.floor(Math.random()*list.length);
            let key=list[index];
            let val=localStorage.getItem(key);
            //从list中删除被惰性删除的key
            if (!val) {
              list.splice(index,1);
              expireCount++;
              continue;
            }
            val=JSON.parse(val);
            ///删除所有发现的已过期的key
            if (val.expires<new Date().getTime()) {
              list.splice(index,1);
              localStorage.removeItem(key);
              expireCount++;
            }
          }
          //若删除的key不超过5个则跳出循环
          if (expireCount<=5 || list.length===0) {
            break;
          }
          checkCount++;
        }
      }
      //每隔一秒执行一次定时删除
      window.setInterval(self.check,1000);
      return self;
    }(lsc || {}));
    /*
    for (let i=1;i<200;i++){
      lsc.set("key"+i,i.toString(),Math.random()*10);
    }
    */
    for (let i=1;i<200;i++){
      console.log(lsc.get("key"+i));
    }
    
</script>

</body>
</html>

```

-----

#### 1.4 localStorage 能跨域吗

**参考答案**：

不能

解决方案：

- 通过postMessage来实现跨源通信
- 可以实现一个公共的iframe部署在某个域名中，作为共享域
- 将需要实现localStorage跨域通信的页面嵌入这个iframe
- 接入对应的SDK操作共享域，从而实现localStorage的跨域存储

![localStorage跨域](E:\pogject\学习笔记\image\js\localStorage跨域.png)

----

#### 1.5 memory cache 如何开启

**参考答案**：

memory cache 如何开启是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，也不会生效。

---

#### 1.6 localstorage的限制

**参考答案**：

1. 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性
2. 目前**所有的浏览器中都会把localStorage的值类型限定为string类型**，这个在对我们日常比较常见的JSON对象类型需要一些转换
3. localStorage在浏览器的隐私模式下面是不可读取的
4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
5. localStorage不能被爬虫抓取到

---

#### 1.7 浏览器输入URL发生了什么

**参考答案**：

1. URL 解析
2. DNS 查询
3. TCP 连接
4. 处理请求
5. 接受响应
6. 渲染页面

-----

#### 1.8 浏览器如何渲染页面的？

**参考答案**：

**可以分析出基本过程：**

1. HTML 被 HTML 解析器解析成 DOM 树；

2. CSS 被 CSS 解析器解析成 CSSOM 树；

- 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
- 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
- 将布局绘制(paint)在屏幕上，显示出整个页面。
- 不同的浏览器内核不同，所以渲染过程不太一样。

WebKit 主流程

![WebKit 主流程](E:\pogject\学习笔记\image\js\WebKit 主流程.png)

Mozilla 的 Gecko 呈现引擎主流程

![Mozilla 的 Gecko 呈现引擎主流程](E:\pogject\学习笔记\image\js\Mozilla引擎主流程.png)

Mozilla 的 Gecko 呈现引擎主流程

由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。
Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它 由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。

---

#### 1.9 重绘、重排区别如何避免

**参考答案**：

1. 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

2. 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等

3. 区别：**重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）**

4. 引发重排

   4.1 添加、删除可见的dom

   4.2 元素的位置改变

   4.3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)

   4.4 页面渲染初始化

   4.5 浏览器窗口尺寸改变

   4.6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。

5. 优化：

   **浏览器自己的优化**：

   浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘

   **减少 reflow/repaint**：
   （1）不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。

   （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
   （3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
   （4）**千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局**。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)

   （5）不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）

------

#### 1.10 事件循环Event loop

**参考答案**：

主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为**事件循环**。此机制具体如下: 主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。

**详细步骤**：

1.  选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。
2. 事件循环的当前运行宏任务设置为已选择的宏任务。
3. 运行宏任务。
4. 将事件循环的当前运行任务设置为null。
5. 将运行完的宏任务从宏任务队列中移除。
6. microtasks步骤：进入microtask检查点。
7. 更新界面渲染。
8. 返回第一步。

**执行进入microtask检查的的具体步骤如下:**

1. 设置进入microtask检查点的标志为true。
2. 当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。
3. 对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。
4. 清理indexedDB的事务。
5. 设置进入microtask检查点的标志为false。

需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。**同一次事件循环中, 微任务永远在宏任务之前执行。**

![事件循环Eventloop](E:\pogject\学习笔记\image\js\事件循环Eventloop.png)



----

#### 1.11 let a = "sssssss"，存在哪儿？

**参考答案**：

使用let声明的全局变量不是挂在window对象下的，**声明的全局变量存在于一个块级作用域中**。

具体查看，我们可以通过打印一个全局函数，在let声明的全局变量在全局函数的scope下，我们平时使用时直接 用变量名称就能访问到

具体位置如下图：

![let变量存储](E:\pogject\学习笔记\image\js\let变量存储.png)

---

#### 1.12 浏览器垃圾回收机制

**参考答案：**

**1. 介绍**

浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以**垃圾回收器会按照固定的时间间隔周期性的执行**。

不再使用的变量也就是生命周期结束的变量，**当然只可能是局部变量**，全局变量的生命周期直至浏览器卸载页面才会结束。**局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值**，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

还是上代码说明吧：

```js
function fn1() {
    var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
    var obj = {name:'hanzichi', age: 10};
    return obj;
}

var a = fn1();
var b = fn2();
```

我们来看代码是如何执行的。首先定义了两个function，分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: 'hanzichi', age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量是没有用的？**所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存**。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。引用计数不太常用，标记清除较为常用。

**2. 标记清除**

js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

```js
function test(){
	var a = 10 ;             //被标记 ，进入环境 
	var b = 20 ;             //被标记 ，进入环境
}
test();                     //执行完毕 之后 a、b又被标离开环境，被回收。
```

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（**闭包**）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

**3. 引用计数**

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

```js
function test(){
    var a = {} ;         //a的引用次数为0 
    var b = a ;         //a的引用次数加1，为1 
    var c =a;           //a的引用次数再加1，为2
    var b ={};          //a的引用次数减1，为1
}
```

Netscape Navigator3是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

```js
function fn() {
    var a = {};
    var b = {};
    a.pro = b;
    b.pro = a;
}
fn();
```

以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，**如果fn函数被大量调用，就会造成内存泄露**。在IE7与IE8上，内存直线上升。

我们知道，IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的**COM对象依然是基于引用计数策略**的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.e = element;
element.o = myObject;
```

这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。

举个栗子：

```js
window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
};

```

这段代码看起来没什么问题，但是obj引用了document.getElementById('element')，而document.getElementById('element')的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug)

**解决办法：**

最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样

```js
myObject.element = null;
element.o = null;

window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
    obj=null;
};

```

**将变量设置为null意味着切断变量与它此前引用的值之间的连接。**当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。

要注意的是，**IE9+并不存在循环引用导致Dom内存泄露问题**，可能是微软做了优化，或者Dom的回收方式已经改变



**4. 内存管理**

**4.1 什么时候触发垃圾回收？**

垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。

微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，**如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍**，如果回收的内存高于85%，说明大部分内存早就该清理了，**这时候把触发条件置回。这样就使垃圾回收工作职能了很多**

**4.2 合理的GC方案**

**1. 基础方案**

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：

1. 遍历所有可访问的对象。
2. 回收已不可访问的对象。

**2. GC的缺陷**

和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

**3. GC优化策略**

David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了：

1. **分代回收**（Generation GC） 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：

​	![分代回收](E:\pogject\学习笔记\image\js\分代回收.png)

这里需要补充的是：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。

2. **增量GC** 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：

![增量GC](E:\pogject\学习笔记\image\js\增量GC.png)

这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。

比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。

------

#### 1.13 顺序存储结构和链式存储结构的比较

**参考答案**：

**优缺点**

1. 顺序存储时，相邻数据元素的存放地址也相邻（逻辑与物理统一）；要求内存中可用存储单元的地址必须是连续的。
   - 优点：存储密度大（＝1），存储空间利用率高。
   - 缺点：插入或删除元素时不方便。
2. 链式存储时，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针
   - 优点：插入或删除元素时很方便，使用灵活。
   - 缺点：存储密度小（<1），存储空间利用率低。

**使用情况**

- 顺序表适宜于做查找这样的静态操作；
- 链表宜于做插入、删除这样的动态操作。
- 若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；
- 若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表

**顺序表与链表的比较**

- 基于空间的比较
  - 存储分配的方式
    - 顺序表的存储空间是静态分配的
    - 链表的存储空间是动态分配的
  - 存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量
    - 顺序表的存储密度 = 1
    - 链表的存储密度 < 1
- 基于时间的比较
  - 存取方式
    - 顺序表可以随机存取，也可以顺序存取
    - 链表是顺序存取的
  - 插入/删除时移动元素个数
    - 顺序表平均需要移动近一半元素
    - 链表不需要移动元素，只需要修改指针

------

#### 1.14 token 能放在cookie中吗

**参考答案**：

能

**解析**：

- token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。
- **「简单 token 的组成」**:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）

**token认证流程**

![token认证流程](E:\pogject\学习笔记\image\js\token认证流程.png)

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端签发一个 token ，并把它发送给客户端
4. 客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. 客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）
6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据

------

#### 1.15 js如何获取/禁用cookie

**参考答案**：

**js如何获取cookie**

假设cookie中存储的内容为：name=jack;password=123

则在B页面中获取变量username的值的JS代码如下：

```html
<script type="text/javascript">
    //arusername=document.cookie.split(";")[0].split("=")[1];

    //JS操作cookies方法!
    //写cookies
    function setCookie(name,value){
      let days=30;
      let expires=new Date();
      expires.setTime(expires.getTime()+days*24*60*60*1000);
      document.cookie=name+"="+escape(value)+";"+"expires="+expires.toGMTString();
    }
    
    //读取cookies
    function getCookie(name){
      let arr;
      let reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)");
      if (arr=document.cookie.match(reg)) {
        return unescape(arr[2]);
      }else{
        return null;
      }
    }

    //setCookie("kop",66);
    console.log(getCookie("kop"));
</script>
```

https://www.nowcoder.com/tutorial/96/122b5108175b46f3a8eaaebbd5e9e18a
