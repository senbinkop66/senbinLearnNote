   

----

## 2.1 树 找到某节点的路径

查找某个节点的路径的方法通常有两种，一种是递归算法,另一种是非递归算法

### 1.定义树节点和构建树

```js
//定义树结点
function TreeNode(val,left,right){
	this.val = (val === undefined ? 0 : val);
	this.left = (left === undefined ? null : left);
	this.right = (right === undefined ? null : right);
}

//构建树
let root=new TreeNode(1);
root.left=new TreeNode(2);
root.right=new TreeNode(3);
root.left.left=new TreeNode(4);
root.right.right=new TreeNode(5);

//console.log(root);
```

### **2.递归算法**

```js
// 递归中序遍历二叉树
function midOrder(root){
	if (!root || !(root instanceof TreeNode)) {
		return;
	}
	//递归访问左子树
	midOrder(root.left);
	console.log(root.val);
	//递归访问右子树
	midOrder(root.right);
}

midOrder(root);
```

### **3非递归算法**

```js
//非递归中序遍历二叉树
function midOrder(root){
	if (!root || !(root instanceof TreeNode)) {
		return;
	}
	let arr=[];  //arr作为栈
	let p=root;  //p为当前遍历的节点， 初始为根
	while(p || arr.length!==0){
		if (p) {
			//遍历左子树
			arr.push(p);
			p=p.left;   //每遇到非空二叉树先向左走
		}else{
			// p为空，出栈
			let node=arr.pop();
			console.log(node.val);  //访问该结点
			p=node.right;  // 访问该结点的右子树
		}
	}
}

midOrder(root);
```

### **4.迭代方法**

```js
//迭代中序遍历二叉树
function midOrderTraversal(root){
	if (!root || !(root instanceof TreeNode)) {
		return;
	}
	let ans=[];
	let arr=[root];
	while(arr.length!==0){
		let node=arr[arr.length-1];
		if (!node.left || (node.left && node.left.isOk)) {
			//左子树访问了
			arr.pop();
			node.isOk=true;
			console.log(node.val);
			if (node.right) {
				arr.push(node.right);
			}
		}else if(node.left && !node.left.isOk){
			//左子树没有访问
			arr.push(node.left);
		}
	}

}

midOrderTraversal(root);
```



----

## 2.2 洗完牌抽5张判断是否为同花顺

题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2-10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成任意数字。

思路一:

我们需要把扑克牌的背景抽象成计算机语言。不难想象，我们可以把5张牌看成由5个数字组成的数组。大小王是特殊的数字，我们不妨把它们都当成0，这样和其他扑克牌代表的数字就不重复了。接下来我们来分析怎样判断5个数字是不是连续的。最直观的是，我们把数组排序。但值得注意的是，由于0可以当成任意数字，我们可以用0去补满数组中的空缺。也就是排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但如果我们有足够的0可以补满这两个数字的空缺，这个数组实际上还是连续的。举个例子，数组排序之后为{0，1，3，4，5}。在1和3之间空缺了一个2，刚好我们有一个0，也就是我们可以它当成2去填补这个空缺。

于是我们需要做三件事情：把数组排序，统计数组中0的个数，统计排序之后的数组相邻数字之间的空缺总数。如果空缺的总数小于或者等于0的个数，那么这个数组就是连续的；反之则不连续。最后，我们还需要注意的是，如果数组中的非0数字重复出现，则该数组不是连续的。换成扑克牌的描述方式，就是如果一副牌里含有对子，则不可能是顺子。

```

```

思路二:

1）确认5张牌中除了0，其余数字没有重复的（可以用表统计的方法）;

2）满足这样的逻辑：（max，min分别代表5张牌中的除0以外的最大值最小值）

 如果没有0，则max-min=4，则为顺子，否则不是

 如果有一个0，则max-min=4或者3，则为顺子，否则不是

 如果有两个0，则max-min=4或者3或者2，则为顺子，否则不是最大值和最小值在1）中就可以获得，这样就 不用排序了

```

```

---

## 2.3 爬楼梯 编代码

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意**：**给定 *n* 是一个正整数。

方法分析：

这道题主要是要明白该爬楼梯的规律其实就是符合斐波那契数列（Fibonacci Sequence） 规律的，问题就迎刃而解了。为什么说它是斐波那契数列呢？我们可以这样来思考：当我们从第 n-1 阶楼梯爬到第 n 阶楼梯时，需要1步；当我们从第 n-2 阶楼梯爬到第 n 阶楼梯时，需要2步.也就是说 到达第 n 阶楼梯的方法数等于到达第 n-1 阶楼梯的方法数加上到达第 n-2 阶楼梯的方法数，其正好符合斐波那契通项。

### **1.采用递归实现**

递归是求解斐波那契数列最经典和最直接的方式，其简洁易懂；但是递归特别费时，在该题中使用会出现[超出时间限制]的错误提示。

```js
function climbStairs(n){
	if (n===1) {
		return 1;
	}
	if (n===2) {
		return 2;
	}
	return climbStairs(n-1)+climbStairs(n-2);
}

let n=10;
console.log(climbStairs(n));  //89
```

### **2.数组方式**

数组方式大大的减少了运行时间，我们先预设好前两项，再得到结果，返回数组最后一项即可。

```js
function climbStairs(n){
	const result=[1,2];
	for (let i=2; i<n; i++){
		result.push(result[i-1]+result[i-2]);
	}
	return result[n-1];
}

let n=10;
console.log(climbStairs(n));  //89
```

### **3.ES6的方式**

```js
function climbStairs(n){
	let a=b=1;
	for (let i=0; i<n; i++){
		[a,b]=[b,a+b];
	}
	return a;
}

let n=10;
console.log(climbStairs(n));  //89
```

其中 [a, b] = [b, a + b] 表示解构赋值，其等价于

```js
temp = a;
a = b;
b = temp + b;
```

---

## 2.4 怎么识别100枚硬币中的假币

**问题描述：**
在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，但不知道假币与真币相比较轻还是较重。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币(**以下提供两种方法**)。

**解题思路1 (本例为真币重量大于假币)：**
使用减治法的解题思路，将硬币分为3堆，则每堆的硬币数量为 n/3 ，但是这是在 n%3==0 的情况下才能成立，所以我们将 n 枚硬币分为 3 堆加 1 堆 余数堆(余数堆可能为0)，则可分为如下(n-n%3)/3, (n-n%3)/3, (n-n%3)/3, n%3。
**如下分组：**
a堆： (n-n%3)/3
b堆： (n-n%3)/3
c堆： (n-n%3)/3
d(余数堆): n%3
**逻辑流程：**

1. 判断n中的硬币数量，如果n>2则执行2，否则执行5.
2. 将n分为上图的四堆，拿 a 和 b 比较，如果 a == b ,则 假币在 c 或 d 中。否则假币在 a 或 b 中。
3. 如果 a == b，则拿 a 和 c 比较。如果 a == c,则假币在d(余数堆)中。将 d 再次 执行流程1，并且n=n%3。如果不等，则假币在 c 中，将 c 再次 执行流程1，并且n=(n-n%3)/3。
4. 如果 a != b，则拿 a 和 c 比较。如果 a == c,则假币在b中，将 b 再次 执行流程1，并且n=(n-n%3)/3。如果不等，则假币在 a 中，将 a 再次 执行流程 1，并且n=(n-n%3)/3。
5. 如果n==2，则将两枚硬币进行比较找出假币。
6. 如果n==1，则该硬币就是假币，输出结果结束。

**解题思路2（以12枚硬币为例，且假币未知轻重）：**

1. 将硬币编号：1，2，3，4，5，6，7，8，9，10，11，12。三次称重如下安排：
2. 称重：
   第一次称重：左盘：1，2，3，4 右盘：5，6，7，8 其他：9，10，11，12
   第二次称重：左盘：1，6，7，8 右盘：5，10，11，12 其他：9，2，3，4
   第三次称重：左盘：5，6，10，2 右盘：9，7，11，3 其他：1，8，12，4
   称重结果：平衡取0，左倾取1，右倾取-1。
   3次称重安排可表示成矩阵形式：

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/1605692726(1).png)
其中，矩阵第一行是硬币序号，下面每一行都是一次称重结果，1表示该硬币放左盘，-1表示放右盘，0表示不放。矩阵每一列为检测结果，检测结果对应的硬币序号为假币。如果结果与上边的符合，则对应重量为重，如果结果不包含在上述表中，则进行1 -1互换，得到的重量为轻。例如：若称重结果是110，则1号为假币，且重量较重：若称重结果为1-10，1与-1进行交换后为-110，则8号为假币，且重量较轻。

---

## 2.5 快排算法

思想：

1. 在数据集之中，选择一个元素作为"基准"（pivot）。
2. 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
3. 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

实现：

```js
function quickSort(nums){
	if (nums.length<=1){
		return nums;
	}
	let pivotIndex = Math.floor(nums.length / 2);
	let pivot = nums.splice(pivotIndex,1)[0];  //基准值
	const left = [];
	const right = [];
	for (let i = 0; i < nums.length; i++){
		if (nums[i] < pivot) {
			left.push(nums[i]);
		}else{
			right.push(nums[i]);
		}
	}
	return quickSort(left).concat([pivot],quickSort(right));
}

let test=[1,3,4,5,6,2,3,1,5,8];
console.log(quickSort(test));  //
```

----

## 2.6 常见的排序算法和它们的时间复杂度是多少？

**参考答案**：

|          稳定的排序          |            时间复杂度            | 空间复杂度 |
| :--------------------------: | :------------------------------: | :--------: |
|    冒泡排序(bubble sort)     | 最差、平均都是O(n^2)，最好是O(n) |     1      |
|   插入排序(insertion sort)   | 最差、平均都是O(n^2)，最好是O(n) |     1      |
|     归并排序(merge sort)     |  最差、平均、最好都是O(n log n)  |    O(n)    |
|     桶排序(bucket sort)      |               O(n)               |    O(k)    |
|     基数排序(Radix sort)     |         O(nk)（k是常数）         |    O(n)    |
| 二叉树排序(Binary tree sort) |            O(n log n)            |    O(n)    |

|       不稳定的排序       |           时间复杂度           | 空间复杂度 |
| :----------------------: | :----------------------------: | :--------: |
| 选择排序(selection sort) |      最差、平均都是O(n^2)      |     1      |
|   希尔排序(shell sort)   |           O(n log n)           |     1      |
|     堆排序(heapsort)     | 最差、平均、最好都是O(n log n) |     1      |
|   快速排序(quicksort)    | 平均是O(n log n)，最差是O(n^2) |  O(log n)  |



---

## 2.7 说一下归并排序思想怎么实现的

“归并”的意思是将两个或两个以上的有序表组合成一个新的有序表。假如初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（向上取整）个长度为2或1的有序子序列；再两两归并，……，如此重复，直到得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。

步骤解析：

1、把长度为n的输入序列分成两个长度为n/2的子序列；

2、对这两个子序列继续分为m/2的子序列，一直分下去，直为1个元素；

3、将两个排序好的子序列合并成一个最终的排序序列。

特点：

速度仅次于快速排序，为稳定排序算法，一般用于总体无序，但是各子项相对有序的数列，属于分治思想，递归归并。

动图演示：

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/20180502102359525.png)

**JavsScript代码实现：**

```javascript
//归并排序
function mergeSort(arr){
  var len = arr.length;
  if(len < 2){
    return arr;
  }

  //首先将无序数组划分为两个数组
  var mid = Math.floor(len / 2);
  var left = arr.slice(0,mid);
  var right = arr.slice(mid,len);
  return merge(mergeSort(left),mergeSort(right));//递归分别对左右两部分数组进行排序合并
}
//合并
function merge(left,right){
  var result = [];
  while(left.length>0 && right.length>0){
    if(left[0]<=right[0]){
      //如果左边的数据小于右边的数据，将左边数据取出，放在新数组中
      result.push(left.shift());
    }else{
       result.push(right.shift());
     }
  }

  while(left.length){
     result.push(left.shift());
  }
  while(right.length){
     result.push(right.shift());
  }
  return result;
}

var arr = [3,44,38,5,47,15,36,26];
console.log(mergeSort(arr));//3,5,15,26,36,38,44,47
```

----

## 2.8 算法：3数之和

题目描述：

给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，\*使得 \*a + b + c =* 0 ？找出所有满足条件且不重复的三元组。

```js
function threeNumberSum(nums){
	nums=nums.sort((a,b)=>a-b);  //排序
	let n=nums.length;
	const ans=[];
	let sum=0;
	//枚举第一个数字
	for (let first=0; first<n; first++){
		// 需要和上一次枚举的数不相同
		if (nums[first]>0) {
			//first元素大于0后，后面sum不可能等于0
			break;
		}
		if (first>0 && nums[first]===nums[first-1]){
			continue;
		}
		//第三个数对应的指针初始指向数组的最右端
		let third=n-1;
		let target=-nums[first];
		for (let second=first+1; second<n; second++){
			if (nums[second] > target) {
				//前两个元素和已经大于0，则再加第三个一定大于0;
				break;
			}
			// 需要和上一次枚举的数不相同
			if (second>first+1 && nums[second]===nums[second-1]) {
				continue;
			}
			// 需要保证 second 的指针在 third 的指针的左侧
			while(second<third && nums[second]+nums[third]>target){
				third--;
			}
			// 如果指针重合，随着 second 后续的增加
			// 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
			if (second===third) {
				break;
			}
			if (nums[second]+nums[third]===target) {
				ans.push([nums[first],nums[second],nums[third]]);
			}
		}
	}
	return ans;
}

let test=[-1, 0, 1, 2, -1, -4];
console.log(threeNumberSum(test));  // [ [ -1, -1, 2 ], [ -1, 0, 1 ] ]
```

---

## 2.9 算法：连续最大乘积

题目描述

给一个浮点数序列，取最大乘积连续子串的值，例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。也就是说，上述数组中，3 0.5 8这3个数的乘积3*0.5*8=12是最大的，而且是连续的。

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/maximum-product-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

分析与解法

此最大乘积连续子串与最大乘积子序列不同，请勿混淆，前者子串要求连续，后者子序列不要求连续。也就是说，最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence，LCS）是：

- 子串（Substring）是串的一个连续的部分，
- 子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；

更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串“ acdfg ”同“ akdfc ”的最长公共子串为“ df ”，而它们的最长公共子序列LCS是“ adf ”，LCS可以使用动态规划法解决。

![最大子数组乘积](E:\pogject\学习笔记\image\leetcode\最大子数组乘积.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let n=nums.length;
    const maxF=[...nums];
    const minF=[...nums];
    let ans=maxF[0];
    for (let i=1;i<n;i++){
        maxF[i]=Math.max(maxF[i-1]*nums[i], Math.max(nums[i],minF[i-1]*nums[i]));
        ans = ans > maxF[i] ? ans : maxF[i];
        minF[i]=Math.min(minF[i-1]*nums[i], Math.min(nums[i],maxF[i-1]*nums[i]));
    }
    return ans;
};

let nums=[2,3,-2,4];
let result=maxProduct(nums);
console.log(result);
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let n=nums.length;
    let maxF=nums[0];
    let minF=nums[0];
    let ans=nums[0];
    for (let i=1;i<n;i++){
        let mx=maxF,mn=minF;
        maxF=Math.max(mx*nums[i], Math.max(nums[i],mn*nums[i]));
        ans = Math.max(maxF,ans);
        minF=Math.min(mn*nums[i], Math.min(nums[i],mx*nums[i]));
    }
    return ans;
};

let nums=[2,3,-2,4];
let result=maxProduct(nums);
console.log(result);
```

动态规划求解的方法一个for循环搞定，所以时间复杂度为O(n)。

---

## 2.10 第K大的数

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

三种方案：

- 排序，取第 `k` 个
- 构造前 `k` 个最大元素小顶堆，取堆顶
- 计数排序或桶排序，但它们都要求输入的数据必须是有确定范围的整数，所以本题不可用

那么除了这两种方案还有没有其它的方式可解决本题喃？其实还有两种：

- 快速选择（quickselect）算法
- 中位数的中位数（bfprt）算法

解法一：数组排序，取第 k 个数

最简单

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
	nums.sort((a,b)=>b-a);
	return nums[k-1];
};

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```

**复杂度分析：**

- 时间复杂度：O(nlogn)
- 空间复杂度：O(logn)

解法二：构造前 `k` 个最大元素小顶堆，取堆顶

我们也可以通过构造一个前 `k` 个最大元素小顶堆来解决，小顶堆上的任意节点值都必须小于等于其左右子节点值，即堆顶是最小值。

所以我们可以从数组中取出 `k` 个元素构造一个小顶堆，然后将其余元素与小顶堆对比，如果大于堆顶则替换堆顶，然后堆化，所有元素遍历完成后，堆中的堆顶即为第 `k` 个最大值

具体步骤如下：

- 从数组中取前 `k` 个数（ `0` 到 `k-1` 位），构造一个小顶堆
- 从 `k` 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。
- 遍历完成后，堆顶的数据就是第 K 大的数据

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
*/
var findKthLargest = function(nums, k) {
	//从nums中取出前k个数，构建一个小顶锥
	const heap=[,];
	let i=0;
	while(i<k){
		heap.push(nums[i++]);
	}
	bulidHeap(heap,k);

	// 从 k 位开始遍历数组
	for (let i=k; i < nums.length; i++){
		if (heap[1] < nums[i]) {
			//替换并堆化
			heap[1]=nums[i];
			heapify(heap,k,1);
		}
	}
	//返回堆顶元素
	return heap[1];
};

// 原地建堆，从后往前，自上而下式建小顶堆
var bulidHeap=(arr,k)=>{
	if (k===1) {
		return;
	}
	// 从最后一个非叶子节点开始，自上而下式堆化
	for (let i=Math.floor(k/2);i>=1;i--){
		heapify(arr,k,i);
	}
}

//堆化
var heapify=(arr,k,i)=>{
	// 自上而下式堆化
	while(true){
		let minIndex=i;
		if(2*i<=k && arr[2*i] < arr[i]){
			minIndex=2*i;
		}
		if (2*i+1 <= k && arr[2*i+1] < arr[minIndex]) {
			minIndex=2*i+1;
		}
		if (minIndex !== i) {
			swap(arr,i,minIndex);
			i=minIndex;
		}else{
			break;
		}
	}
}

//交换元素
var swap=(arr,i,j)=>{
	let temp=arr[i];
	arr[i]=arr[j];
	arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```

**复杂度分析：**

- 时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)
- 空间复杂度：O(k)

解法三：快速选择（quickselect）算法

无论是排序算法还是构造堆求解 Top k问题，我们都经过的一定量的不必要操作：

- 如果使用排序算法，我们仅仅想要的是第 k 个最大值，但对其余不需要的数也进行了排序
- 如果使用堆排序，需要维护一个大小为 `k` 的堆(大顶堆，小顶堆)，时间复杂度也为 `O(nlogk)`

快速选择（quickselect）算法与快排思路上相似，我们先看看快排是如何实现的？

快排

快排使用了分治策略的思想，所谓分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。

快排的过程简单的说只有三步：

- 首先从序列中选取一个数作为基准数
- 将比这个数大的数全部放到它的右边，把小于或者等于它的数全部放到它的左边 （一次快排 `partition`）
- 然后分别对基准的左右两边重复以上的操作，直到数组完全排序

具体按以下步骤实现：

- 创建两个指针分别指向数组的最左端以及最右端
- 在数组中任意取出一个元素作为基准
- 左指针开始向右移动，遇到比基准大的停止
- 右指针开始向左移动，遇到比基准小的元素停止，交换左右指针所指向的元素
- 重复3，4，直到左指针超过右指针，此时，比基准小的值就都会放在基准的左边，比基准大的值会出现在基准的右边
- 然后分别对基准的左右两边重复以上的操作，直到数组完全排序

注意这里的基准该如何选择喃？最简单的一种做法是每次都是选择最左边的元素作为基准，但这对几乎已经有序的序列来说，并不是最好的选择，它将会导致算法的最坏表现。还有一种做法，就是选择中间的数或通过 `Math.random()` 来随机选取一个数作为基准，下面的代码实现就是以随机数作为基准。

```js
var quickSort=(arr)=>{
    quick(arr, 0, arr.length - 1);
}

var quick=(arr,left,right)=>{
    let index;
    if (left < right) {
        //划分数组
        index=partition(arr, left, right);
        if (left < index - 1) {
            quick(arr, left, index - 1);
        }
        if (index < right) {
            quick(arr, index, right);
        }
    }
}

// 一次快排
var partition=(arr,left,right)=>{
    //取中间项为基准
    let datum=arr[Math.floor(Math.random() * (right - left + 1)) + left];
    let i=left;
    let j=right;
    // 开始调整
    while (i <= j){
        //左指针右移
        while(arr[i] < datum){
            i++;
        }
        // 右指针左移
        while(arr[j] > datum){
            j--;
        }
        //交换
        if (i <= j) {
            swap(arr, i, j);
            i += 1;
            j -= 1;
        }
    }
    return i;
}

//交换元素
var swap=(arr,i,j)=>{
    let temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6];
quickSort(test);
console.log(test);  //
```

快排是从小到大排序，所以第 `k` 个最大值在 `n-k` 位置上

**复杂度分析**

- 时间复杂度：O(nlog~~2~~n)
- 空间复杂度：O(nlog~~2~~n)

快速选择（quickselect）算法

上面我们实现了快速排序来取第 k 个最大值，其实没必要那么麻烦，我们仅仅需要在每执行一次快排的时候，比较基准值位置是否在 `n-k` 位置上，如果小于 `n-k` ，则第 k 个最大值在基准值的右边，我们只需递归快排基准值右边的子序列即可；如果大于 `n-k` ，则第 k 个最大值在基准值的做边，我们只需递归快排基准值左边的子序列即可；如果等于 `n-k` ，则第 k 个最大值就是基准值

```js
let findKthLargest = function(nums, k) {
    return quickSelect(nums, nums.length - k)
};

let quickSelect = (arr, k) => {
  return quick(arr, 0 , arr.length - 1, k)
}

let quick = (arr, left, right, k) => {
  let index
  if(left < right) {
    // 划分数组
    index = partition(arr, left, right)
    // Top k
    if(k === index) {
        return arr[index]
    } else if(k < index) {
        // Top k 在左边
        return quick(arr, left, index-1, k)
    } else {
        // Top k 在右边
        return quick(arr, index+1, right, k)
    }
  }
  return arr[left]
}

let partition = (arr, left, right) => {
  // 取中间项为基准
  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],
      i = left,
      j = right
  // 开始调整
  while(i < j) {

    // 左指针右移
    while(arr[i] < datum) {
      i++
    }

    // 右指针左移
    while(arr[j] > datum) {
      j--
    }

    // 交换
    if(i < j) swap(arr, i, j)

    // 当数组中存在重复数据时，即都为datum，但位置不同
    // 继续递增i，防止死循环
    if(arr[i] === arr[j] && i !== j) {
        i++
    }
  }
  return i
}

// 交换
let swap = (arr, i , j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

**复杂度分析：**

- 时间复杂度：平均时间复杂度O(n)，最坏情况时间复杂度为O(n2)
- 空间复杂度：O(1)

解法四：中位数的中位数（BFPRT）算法

又称为**中位数的中位数算法**，它的最坏时间复杂度为 O(n) ，它是由**Blum、Floyd、Pratt、Rivest、Tarjan**提出。该算法的思想是修改快速选择算法的主元选取方法，提高算法在最坏情况下的时间复杂度。

在BFPTR算法中，仅仅是改变了快速选择（quickselect）算法中 `Partion` 中的基准值的选取，在快速选择（quickselect）算法中，我们可以选择第一个元素或者最后一个元素作为基准元，优化的可以选择随机一个元素作为基准元，而在 BFPTR 算法中，每次选择五分中位数的中位数作为基准元（也称为主元**pivot**），这样做的目的就是使得划分比较合理，从而避免了最坏情况的发生。

BFPRT 算法步骤如下：

- 选取主元
  - 将 n 个元素按顺序分为 `n/5` 个组，每组 5 个元素，若有剩余，舍去
  - 对于这 `n/5` 个组中的每一组使用插入排序找到它们各自的中位数
  - 对于上一步中找到的所有中位数，调用 BFPRT 算法求出它们的中位数，作为主元；
- 以主元为分界点，把小于主元的放在左边，大于主元的放在右边；
- 判断主元的位置与 k 的大小，有选择的对左边或右边递归

**代码实现：**

```js
let findKthLargest = function(nums, k) {
    return nums[bfprt(nums, 0, nums.length - 1, nums.length - k)]
}

let bfprt = (arr, left , right, k) => {
  let index
  if(left < right) {
    // 划分数组
    index = partition(arr, left, right)
    // Top k
    if(k === index) {
        return index
    } else if(k < index) {
        // Top k 在左边
        return bfprt(arr, left, index-1, k)
    } else {
        // Top k 在右边
        return bfprt(arr, index+1, right, k)
    }
  }
  return left
}

let partition = (arr, left, right) => {
  // 基准
  var datum = arr[findMid(arr, left, right)],
      i = left,
      j = right
  // 开始调整
  while(i < j) {
    // 左指针右移
    while(arr[i] < datum) {
      i++
    }

    // 右指针左移
    while(arr[j] > datum) {
      j--
    }

    // 交换
    if(i < j) swap(arr, i, j)

    // 当数组中存在重复数据时，即都为datum，但位置不同
    // 继续递增i，防止死循环
    if(arr[i] === arr[j] && i !== j) {
        i++
    }
  }
  return i
}

/**
 * 数组 arr[left, right] 每五个元素作为一组，并计算每组的中位数，
 * 最后返回这些中位数的中位数下标（即主元下标）。
 *
 * @attention 末尾返回语句最后一个参数多加一个 1 的作用其实就是向上取整的意思，
 * 这样可以始终保持 k 大于 0。
 */
let findMid = (arr, left, right) => {
    if (right - left < 5)
        return insertSort(arr, left, right);

    let n = left - 1;

    // 每五个作为一组，求出中位数，并把这些中位数全部依次移动到数组左边
    for (let i = left; i + 4 <= right; i += 5)
    {
        let index = insertSort(arr, i, i + 4);
        swap(arr[++n], arr[index]);
    }

    // 利用 bfprt 得到这些中位数的中位数下标（即主元下标）
    return findMid(arr, left, n);
}

/**
 * 对数组 arr[left, right] 进行插入排序，并返回 [left, right]
 * 的中位数。
 */
let insertSort = (arr, left, right) => {
    let temp, j
    for (let i = left + 1; i <= right; i++) {
        temp = arr[i];
        j = i - 1;
        while (j >= left && arr[j] > temp)
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
    return ((right - left) >> 1) + left;
}

// 交换
let swap = (arr, i , j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
```

**为什么是5？**

在BFPRT算法中，为什么是选5个作为分组？

首先，偶数排除，因为对于奇数来说，中位数更容易计算。

如果选用3，有 ![图片说明](https://uploadfiles.nowcoder.com/images/20210301/59_1614587226282/7A310A449D4D97D485E7E6FFD81C3BAA) ，其操作元素个数还是 `n` 。

如果选取7，9或者更大，在插入排序时耗时增加，常数 `c` 会很大，有些得不偿失。

总结

所以，这里我们总结一下，求topk问题其实并不难，主要有以下几个思路：

- 整体排序：O(nlogn)
- 局部排序：只冒泡排序前k个最大值，O(nk)
- 堆：O(nlogk)
- 计数或桶排序：计数排序用于前k个最值，时间复杂度为O(n + m)，其中 m 表示数据范围；桶排序用于最高频k个，时间复杂度为O(n)； **但这两者都要求输入数据必须是有确定范围的整数**
- 快速选择（quickselect）算法：平均O(n)，最坏O(n2)
- 中位数的中位数（bfprt）算法：最坏O(n)

----

## 2.11 验证有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。

第一种：用repace方法，闭合才有效，也就是最里边的也要闭合，那就把最里边的括号取代为空

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
	while(s.length){
		let temp=s;
		s=s.replace("()", "");
		s=s.replace("[]", "");
		s=s.replace("{}", "");
		if (s===temp) {
			return false;
		}
	}
	return true;
};

let s = "()[]{}";
console.log(isValid(s));
```

第二种：栈思想 括号都是要闭合的，也就是说遇到第一个右括号时，必定左边就是对应的左括号，也就是说把遇到的左括号都放进栈里，然后遇到右括号时取出栈顶的元素匹配 如"{[()]}"遇到{[(放入栈内，然后遇到）与栈顶匹配，栈顶也就是最后一个进栈的元素（，然后把栈的最后一个元素删掉

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
	let stack = [];
	let leftBracketSet = new Set(['(', '[', '{']);
	let bracketMap = new Map([[')','('],[']','['],['}','{']]);
	console.log(bracketMap)
	for (let i = 0; i < s.length; i++){
		if (leftBracketSet.has(s[i])) {
			stack.push(s[i]);
		}else{
			if (stack.length > 0 && stack[stack.length - 1] === bracketMap.get(s[i])) {
				stack.pop();
			}else{
				return false;
			}
		}
	}
	return stack.length===0;
};

let s = "()[]{}";
console.log(isValid(s));
```

比起第一个方法快了不少但是还是慢

第三种：使用map数据结构

循环s字符串，ch in map 的意思是循环map的键值，也就是遇到左括号时，放进数组，当开始遇到右括号时，用pop（）弹出栈顶的元素与与之比对，若是不相等，就ruturn false （leftArr.pop()为左括号，map[key]=value,也就是右括号），当程序走完时，left的length长度应该为0，若不为0则没闭合(当length=0 时，!leftArr.length为ture，当length>0 时，!leftArr.length为false)

```js
var isValid = function(s) {
    let map = {
        "{":"}",
        "[":"]",
        "(":")",
    }
    let leftArr = [];
    for(let ch of s){
        if(ch in map){
            leftArr.push(ch)
        }else{
            if(ch!=map[leftArr.pop()]){
                return false
            }
        }
    }
     return !leftArr.length
};
```

---

## 2.12 算法题，反转单链表

