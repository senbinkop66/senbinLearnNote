

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum =function(nums,target){
    len_nums=nums.length;
    for (let i=0; i<len_nums-1; i++){
        for (let j=i+1; j<len_nums; j++){
            if (nums[i]+nums[j]==target) {
                return [i,j];
            }
        }
    }
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=twoSum(str1,6);
//console.log(typeof result);
console.log(result);
```



## 2.两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let temp=0;
    let head=l1;

    while (l1.next){
        if (l2.next) {
            temp+=l1.val+l2.val;
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
            l2=l2.next;
        }else{
            temp+=l1.val+l2.val;
            l2.val=0;  //
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
        }
    }

    while(l2.next){
        temp+=l1.val+l2.val;
        l1.val=temp%10;
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=0;
        temp=Math.floor(temp/10);
        l2=l2.next;
    }
    temp+=l1.val+l2.val;
    l1.val=temp%10;
    temp=Math.floor(temp/10);
    if (temp===1) {
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=1;
    }
    return head;

};
```

链表连接可以优化代码



## 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**提示：**

- `0 <= s.length <= 5 * 104`

- `s` 由英文字母、数字、符号和空格组成

- **例 1:**

  ```
  输入: s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s==="") {return 0;}
    let maxLen=1;
    let flag;
    let count=1;
    let newArr=[];  //存储子串数组
    for (let i=0;i<s.length;i++){
        newArr.push(s[i]);
        flag=true;
        for (let j=i+1;j<s.length;j++){
            if (newArr.includes(s[j])) {
                //当子串数组中已有时
                maxLen=count>maxLen ? count : maxLen;
                flag=false;
                count=1;
                newArr=[];
                break;
            }else{
                newArr.push(s[j]);
                count++;
            }
        }
        if (flag) {
            maxLen=count>maxLen ? count : maxLen;
            break;
        }
    }
    return maxLen;
};


let str1 = "heflfdddswertllo";
let result=lengthOfLongestSubstring(str1);
console.log(result);
```



## 4. 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    let newArr=new Array();
    //双指针
    let i=0;
    let j=0;
    while(i<nums1.length && j<nums2.length){
        if (nums1[i]<=nums2[j]) {
            newArr.push(nums1[i]);
            i++;
        }
        if (nums2[j]<=nums1[i]) {
            console.log(nums2[j]);
            newArr.push(nums2[j]);
            j++;
        }
    }

    while (i<nums1.length){
        newArr.push(nums1[i]);
        i++;
    }
    while(j<nums2.length){
        newArr.push(nums2[j]);
        j++;
    }
    //return newArr;
    let n=nums1.length+nums2.length;
    if (n%2===0) {
        return parseFloat((newArr[n/2]+newArr[n/2-1])/2);
    }else{
        return parseFloat(newArr[Math.floor(n/2)]);
    }
    console.log(newArr);
};


let str1 = [1,2];
let str2=[3,4];
let result=findMedianSortedArrays(str1,str2);
console.log(result);
```

## 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if (s.length===1) {return 1;}
    let maxLen=s.length;
    let flag1=false;
    let flag2=false;
    let newArr=[];  //
    //从最长到最短判断
    for (let i=0;i<s.length;i++){
        for (let j=i;j<s.length;i++){
            if (s[j]!===s[s.length-1-j]) {

                flag1=true;
                break;
            }
        }
        for (let j=i;j<s.length;i++){
            if (s[i]!===s[s.length-1-i]) {
                flag1=true;
                break;
            }
        }
    }
    return maxLen;
};


let str1 = "babad";
let str2=[3,4];
let result=longestPalindrome(str1);
console.log(result);
```

## 6.Z 字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P    A    H   N
A P L S I  I G
Y    I     R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`

```
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows===1) {return s;}
    
    return newStr;
};

let str1 = "basanaadsfenafdrrgeana";
let result=convert(str1);
console.log(result);
```

## 7. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

```java
import java.util.*;

class Solution {
	public int reverse(int x) {
		if (x>-10 && x<10) return x;
		long result=0;
		while(x!=0){
			result=result*10+x%10;
			x=x/10;
		}
		//检测是否溢出，溢出则返回0
		return (int) result==result ? (int) result :0;
	}
}


public class TestOperateString{
	public static void main(String[] args) {

		//int[] testnums={1,2,3,4,5,6,7,8,9,10};
		//char[] testStr={'h','e','l','l','o','b'};

		int n=-136469;

		Solution mysolution=new Solution();
		//mysolution.reverseString(testStr);
		int result=mysolution.reverse(n);
		System.out.println(result);
		//System.out.println(Arrays.toString(testStr));
	}
}
```

注意检查是否溢出

## 8. 字符串转换整数 (atoi)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

```js
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    s=s.trim();
    let patt=/[^0-9+-]/
    if (patt.test(s[0])) {
        return 0;
    }
    let nums=new Array();
    nums.push(s[0]);
    for (let i=1;i<s.length;i++){
        if (/\D/.test(s[i])) {
            //查找到非数字停止
            break;
        }else{
            nums.push(s[i]);
        }
    }

    let num=nums.join("");
    if (num==="+" || num==="-") {return 0;}
    num=parseInt(num);
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "+-12";
let result=myAtoi(str1);
console.log(result);

```

直接调用内置函数

```js
var myAtoi = function(s) {
    s=s.trim();
    let num=parseInt(s);
    if (isNaN(num)) {
        return 0;
    }
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "words and 987";
let result=myAtoi(str1);
console.log(result);
```

### 

## 9.回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

提示：
-231 <= x <= 231 - 1

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x<0) {
        return false;
    }
    x=x.toString();

    for (let i=0;i<x.length/2;i++){
        if (x[i]!==x[x.length-1-i]) {
            return false;
        }
    }
    return true;
};

let str1 = -121;
let result=isPalindrome(str1);
console.log(result);

```

## 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符

直接调用正则方法

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    return new RegExp("^"+p+"$").test(s);
};
```

动态规划

```
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    //动态规划 dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
    let lenS=s.length;
    let lenP=p.length;

    let dp=new Array(lenS+1);

    for (let i=0;i<dp.length;i++){
        //先构造dp[][]数组，将其每一项初始化为false
        dp[i]=new Array(lenP+1).fill(false);

    }
    //base case
    dp[0][0] = true; // s为空、p为空 两者都是空串的时候 可匹配

    //s不为空 p为空，必为false(dp数组默认值为false，无需处理)

    /*//s为空，p不为空(dp[0][]) 由于*可以匹配0个字符，所以有可能为true 
    要进行处理（看看有无*来挽救） 注意 dp[0][j] 当j=1时，表示p的前1个字符
    自然是p[j-1]呢，p的下标是从0开始*/
    for (let j=1;j<lenP;j++){
        if (p[j-1]==="*") {
            dp[0][j]=dp[0][j-2];
        }
    }

    // 迭代 状态转移
    for (let i=1;i<=lenS;i++){
        for (let j=1;j<lenP;j++){
            if (s[i-1]===p[j-1] || p[j-1]===".") {
                //最好简单情况 到这里 s、p 可以直接匹配
                dp[i][j]=dp[i-1][j-1];
            }else if(p[j-1]==="*"){
                //不满足直接对应相等，但 p这个字符是 ‘*’ 的话 仔细考虑
                if (s[i-1]===p[j-2] || p[j-2]===".") {
                    //s当前字符 可匹配上 p前一个字符
                    ////*匹配0次的情况 ｜｜ *匹配1次或多次的情况 
                    dp[i][j]=dp[i][j-2]  || dp[i-1][j];
                }else if(s[i-1]!==p[j-2]){
                    //s当前字符 无法匹配上 p前一个字符，只能是 *匹配0次的情况
                    dp[i][j]=dp[i][j-2];
                }
            }
        }
    }

    return dp[lenS][lenP];
};

let str1 = "mississippi";
let str2="mis*is*p*.";
let result=isMatch(str1,str2);
console.log(result);

```

## 13. 罗马数字转整数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 IV (4) 和 IX  (9)。
X 可以放在 L (50) 和 C (100) 的左边，来表示 XL 40 和 XC90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 CD 400 和 CM 900。
给定一个罗马数字，将其转换成整数。

提示：

1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {

	let romanObj={I:1,V:5,X:10,L:50,C:100,D:500,M:1000};
	let sum=0;

	let i=0;
	while(s.length>0){
		if (s.length===1) {
			sum+=romanObj[s[0]];
			break;
		}
		if (s[0]=="I") {
			if (s[1]==="V") {
				sum+=4;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="X") {
				sum+=9;
				s=s.slice(2);
				continue;
			}
			sum+=1;
			s=s.slice(1);
			continue;
		}else if(s[0]=="X") {
			if (s[1]==="L") {
				sum+=40;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="C") {
				sum+=90;
				s=s.slice(2);
				continue;
			}
			sum+=10;
			s=s.slice(1);
			continue;
		}else if(s[0]=="C") {
			if (s[1]==="D") {
				sum+=400;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="M") {
				sum+=900;
				s=s.slice(2);
				continue;
			}
			sum+=100;
			s=s.slice(1);
			continue;
		}
		sum+=romanObj[s[0]];
		s=s.slice(1);
	}
	return sum;
};

let str1="MCMXCIV";
let result=romanToInt(str1);
console.log(result);
```

## 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length===1) {return strs[0];}
    let minLen=strs[0].length;
    for (let i=0;i<strs.length;i++){
        if (strs[i].length===0) {
            return "";
        }
        if (strs[i].length<minLen) {
            minLen=strs[i].length;
        }
    }
    let alphas=new Array("");
    for (let i=0;i<minLen;i++){
        for (let j=1;j<strs.length;j++){
            if (strs[j][i]!=strs[0][i]) {
                return alphas.join("");
            }
        }
        alphas.push(strs[0][i]);
    }
    return alphas.join("");
};


let str1 = ["flower","flow","flight"];
let result=longestCommonPrefix(str1);
//console.log(typeof result);
console.log(result);

```

利用数组的 Reduce 方法实现的最简洁代码

取第一个字符串为公共前缀
逐个对比，返回两两元素的公共前缀
将 2 中的公共前缀和下一个元素对比，得到新的公共前缀

## 15. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
提示：

0 <= nums.length <= 3000
-105 <= nums[i] <= 105

繁琐的思路，需要简化代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
	if (nums.length<3) {
		return [];
	}

	if (nums.length===3) {
		if (nums[0]+nums[1]+nums[2]===0) {
			return [[...nums]];
		}else{
			return[]
		}
	}

	let newArr=[];

	const positiveInterger=[];
	const negativeInterger=[];
	const zeros=[];

	nums.sort((a,b)=>a-b);
	let count=0;
	let temp=nums[0];
	//非零相同值最多需要留两个就可
	for (let i=0;i<nums.length;i++){
		//这里可用indexOf与lastIndexOf处理
		if (nums[i]!==temp) {
			temp=nums[i];
			count=1;
			if (nums[i]<0) {
				negativeInterger.push(nums[i]);
			}else if(nums[i]>0){
				positiveInterger.push(nums[i]);
			}else{
				zeros.push(0);
			}
		}else{
			if (nums[i]!==0) {
				if (count<2) {
					count+=1
					if (nums[i]<0) {
						negativeInterger.push(nums[i]);
					}else{
						positiveInterger.push(nums[i]);
					}
				}
			}else{
				zeros.push(0);
			}
		}
	}
	if (zeros.length!==0) {
		//有0时把0作为负数处理
		negativeInterger.push(0);
		//正数则为
		//positiveInterger.unshift(0);
	}
	if (zeros.length>2) {
		newArr.push([0,0,0]);
	}

	//console.log(positiveInterger);
	//console.log(negativeInterger);

	//需要匹配最大正数索引边界，动态变化
	let maxPositiveIndex=positiveInterger.length-1;
	//最大负数和
	let maxSum1;
	for (let i=0;i<negativeInterger.length-1;i++){
		//两负一正时
		if (maxPositiveIndex===-1) {
			//当正整数遍历完时，退出
			break;
		}
		if (i>0) {
			if (negativeInterger[i]===negativeInterger[i-1]) {
				continue;
			}
		}
		maxSum1=-(negativeInterger[i]+negativeInterger[i+1]);
		if (positiveInterger[maxPositiveIndex]>maxSum1) {
			maxPositiveIndex--;
		}
		for (let j=i+1;j<negativeInterger.length;j++){
			//计算两个负数和后取绝对值
			if (maxPositiveIndex===-1) {
				//当正整数遍历完时，退出
				break;
			}
			if (negativeInterger[j]===negativeInterger[j+1]) {
				continue;
			}
			let NegativeSum=-(negativeInterger[i]+negativeInterger[j]);
			//去找是否有相等的值
			for (let k=maxPositiveIndex;k>=0;k--){
				//因为是排好序的
				if (positiveInterger[k]<NegativeSum) {
					//如果小于则不存在，退出
					break;
				}
				if(positiveInterger[k]===NegativeSum) {
					//如果相等
					newArr.push([negativeInterger[i],negativeInterger[j],positiveInterger[k]]);
					break;
				}
				//如果大于就往前找
			}
		}
		if (positiveInterger[maxPositiveIndex]===maxSum1) {
			maxPositiveIndex--;
		}
	}

    //需要匹配最大负数索引边界，动态变化
    let maxNegativeIndex=negativeInterger.length-1;
    //最小正数和
	let maxSum2;
    for (let i=0;i<positiveInterger.length-1;i++){
        //两正一负时
        if (maxNegativeIndex===-1) {
            //当正整数遍历完时，退出
            break;
        }
        if (i>0) {
        	if (positiveInterger[i]===positiveInterger[i-1]) {
        		continue;
        	}
        }
        maxSum2=-(positiveInterger[i]+positiveInterger[i+1]);
        if (negativeInterger>maxSum2) {
        	maxNegativeIndex--;
        }

        for (let j=i+1;j<positiveInterger.length;j++){
            //计算两个负数和后取绝对值
            if (maxNegativeIndex===-1) {
                //当正整数遍历完时，退出
                break;
            }
            if (positiveInterger[j]===positiveInterger[j+1]) {
            	continue;
            }
            let PositiveSum=-(positiveInterger[i]+positiveInterger[j]);
            //去找是否有相等的值
            for (let k=maxNegativeIndex;k>=0;k--){
                //因为是排好序的
                if (negativeInterger[k]<PositiveSum) {
                    //如果小于则不存在，退出
                    break;
                }
                if(negativeInterger[k]===PositiveSum){
                    //如果相等
                    newArr.push([positiveInterger[i],positiveInterger[j],negativeInterger[k]]);
                    break;
                }
                //如果大于，则往前查找，最大正数索引边界减一
            }
        }
        if (negativeInterger===maxSum2) {
        	//移动最大位，可以避免重复
        	maxNegativeIndex--;
        }
    }

	return newArr;
};

let str1=[-1,0,1,2,-1,-4,-2,-3,3,0,4];
let result=threeSum(str1);
console.log(result);
```

简化，直接使用双指针

```

```

## 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

栈实现

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if (s.length%2!==0) {
        return false;
    }
    let leftBrackets=["(","[","{"];
    let rightBrackets=[")","]","}"];

    let stack=[];
    for (let i=0;i<s.length;i++){
        //是否是右括号
        let index=rightBrackets.indexOf(s[i]);
        if (index!==-1) {
            //是右括号
            if (stack.length===0) {
                //如果栈为空，则不合法
                return false;
            }
            //则去看栈顶是否相匹配
            if (stack[stack.length-1]===leftBrackets[index]){
                //如果匹配，则出栈
                stack.pop();
            }else{
                //不匹配，则进栈
                stack.push(s[i]);
            }
        }else{
            //是左括号则直接进栈
            stack.push(s[i]);
        }
        //console.log(stack);
    }
    if (stack.length===0) {
        return true;
    }else{
        return false;
    }
};

let str1 = "{[{{[{}]}[({[]})]}]}";
let result=isValid(str1);
console.log(result);
```

## 21.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列

方法一：递归
思路

我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：

list1[0]+merge(list1[1:],list2)    ,list1[0]<list2[0]
list2[0]+merge(list1,list2[1:])    ,otherwise

也就是说，**两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并**。

算法

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```js
var mergeTwoLists = function(list1, list2) {
    //如果一个为空，则直接返回另一个
    if (list1===null) {
        return list2
    }else if (list2===null) {
        return list1;
    }else if(list1.val<list2.val){
        list1.next=mergeTwoLists(list1.next,list2);
        return list1;
    }else{
        list2.next=mergeTwoLists(list1,list2.next);
        return list2;
    }
};
```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。
- 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。

方法二：迭代
思路

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

算法

首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

**在循环终止的时候， l1 和 l2 至多有一个是非空的**。由于输入的两个链表都是有序的，**所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大**。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

var mergeTwoLists = function(list1, list2) {
    const head=new ListNode();
    let list3=head;
    while(list1!=null && list2!=null){
        if (list1.val<list2.val) {
            list3.next=list1;
            list1=list1.next;
        }else{
            list3.next=list2;
            list2=list2.next;
        }
        list3=list3.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    list3.next=list1===null ? list2:list1;
    //注意返回的是什么
    return head.next;
};

let str1 = [-9,3];
let str2=[5,7];
let list1=new ListNode();
let list2=new ListNode();
let head1=list1;
let head2=list2;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
for (let i=0;i<str2.length;i++){
    list2.val=str2[i];
    list2.next=new ListNode();
    list2=list2.next;
}
//console.log(head2);

let result=mergeTwoLists(head1,head2);
console.log(result);


```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

- 空间复杂度：O(1)。我们只需要常数的空间存放若干变量。

```

```

## 26.删除有序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

提示：

0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let start=0;
    while(start<nums.length){
        if (nums[start]===nums[start+1]) {
            //删除重复中的后一个
            nums.splice(start+1,1);
        }else{
            start++;
        }
    }
    console.log(nums);
    return nums.length;
};


let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeDuplicates(test);
console.log(result);
```

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\双指针删除排序数组中的重复项.png)

```js
var removeDuplicates = function(nums) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let fast = 1, slow = 1;
    while (fast < n) {
        if (nums[fast] !== nums[fast - 1]) {
            //如果不同，则赋值给前面的重复位或当前位
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
};
```

**把不相同的用来覆盖前面相同的，不涉及删除消耗相对较小**

复杂度分析

- 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。


- 空间复杂度：O(1)。只需要使用常数的额外空间。


## 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let flag=0;
    let count=0;
    while (flag < n-count) {
        if (nums[flag]===val) {
            //如果匹配则把后面的值赋值到这里判断
            //只需移动元素匹配次数
            nums[flag]=nums[n-1-count];
            count++;
        }else{
            flag++;
        }
    }
    console.log(nums);
    return flag;
};

let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeElement(test,2);
console.log(result);
```

![移除元素双指针](E:\pogject\学习笔记\image\leetcode\移除元素双指针.png)

## 28. 实现 strStr()

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

![方法一：暴力匹配strStr](E:\pogject\学习笔记\image\leetcode\方法一：暴力匹配strStr.png)

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (haystack.length<needle.length) {return -1;}
    if (needle==="") {return 0;}
    if (haystack.length===needle.length && haystack===needle) {return 0;}
    if (haystack.length===needle.length && haystack!==needle) {return -1;}
    for (let i=0;i<haystack.length-needle.length+1;i++){
        if (haystack[i]===needle[0]) {
            let flag=true;
            for (let j=1;j<needle.length;j++){
                if (haystack[i+j]!==needle[j]){
                    flag=false;
                    break;
                }
            }
            if (flag) {
                return i;
            }

        }
    }
    return -1;
};


let str1 = "heffdddllo";
let str2 = "ell";
let result=strStr(str1,str2);
console.log(result);

```

调用内置方法

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle);
};
```

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr.png)

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr2.png)

```js
var strStr=function(haystack,needle){
    const n=haystack.length,m=needle.length;
    if (m===0) {
        return 0;
    }

    const pi=new Array(m).fill(0);

    //needle部分的前缀函数
    for (let i=1,j=0;i<m;i++){
        while (j>0 && needle[i]!=needle[j]){
            j=pi[j-1];
        }
        if (needle[i]===needle[j]) {
            j++;
        }
        pi[i]=j;
    }

    //求 haystack 部分的前缀函数
    for (let i=0,j=0;i<n;i++){
        while(j>0 && haystack[i]!=needle[j]){
            j=pi[j-1];
        }
        if (haystack[i]==needle[j]) {
            j++;
        }
        if (j===m) {
            return i-m+1;
        }
    }
    return -1;
};

```

## 29.两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

提示：

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。

暴力解法，连减计数,会超时

```

```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除二分查找.png)



```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //二分查找
    let left=1;
    let right=MAX_VALUE;
    let ans=0;
    while(left<=right){
        //注意溢出，并且不能使用除法
        const mid=left+((right-left)>>1);
        const check=quickAdd(divisor,mid,dividend);
        if (check) {
            ans=mid;
            // 注意溢出
            if (mid===MAX_VALUE) {
                break;
            }
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return rev ? -ans : ans;
};

// 快速乘
const quickAdd=(y,z,x)=>{
    // x 和 y 是负数，z 是正数
    // 需要判断 z * y >= x 是否成立
    let result=0;
    let add=y;
    while(z!==0){
        if ((z&1)!==0) {
            //需要保证 result + add >= x
            if (result<x-add) {
                return false;
            }
            result+=add;
        }
        if (z!==1) {
            //需要保证 add + add >= x
            if (add<x-add) {
                return false;
            }
            add+=add;
        }
        // 不能使用除法
        z>>=1;
    }
    return true;
};

let str1 = 10;
let str2 = 3;
let result=divide(str1,str2);
console.log(result);
```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除类二分查找.png)

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用类二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //类二分查找
    const candidates=[divisor];
    let index=0;
    //注意溢出
    while(candidates[index]>=dividend-candidates[index]){
        //处理的都是负数
        candidates.push(candidates[index]+candidates[index]);
        index++;
    }
    //console.log(candidates);
    let ans=0;
    console.log(ans,dividend);
    for (let i=candidates.length-1;i>=0;--i){
        if (candidates[i]>=dividend) {
            ans+=1<<i;
            dividend-=candidates[i];
            console.log(ans,dividend);
        }
    }
    return rev ? -ans : ans;
};


let str1 = 10000;
let str2 = 33;
let result=divide(str1,str2);
console.log(result);
```

## 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。
提示:

1 <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4
nums 为无重复元素的升序排列数组
-10^4 <= target <= 10^4

二分查找

因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=Math.floor((right+left)/2);
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=Math.floor((right+left)/2);
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=Math.floor((right+left)/2);
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=(right+left)>>1;
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=(right+left)>>1;
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=(right+left)>>1;
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};


let test = [1,2,3,5,6,7,20,100,289,328];
let result=searchInsert(test,1);
console.log(result);
```

## 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

![最大子数组和动态规划](E:\pogject\学习笔记\image\leetcode\最大子数组和动态规划.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    //只有一个元素直接返回
    if (nums.length===1) { return nums[0]; }

    //动态规划
    let pre=0;
    let maxSum=nums[0];
    nums.forEach((x)=>{
        pre=Math.max(pre+x,x);
        maxSum=Math.max(maxSum,pre);
    });
    //console.log(nums);
    return maxSum;
};

let test = [-2,1,-3,4,-1,2,1,-5,4];
let result=maxSubArray(test,1);
console.log(result);
```

**方法二：分治**



## 58. 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

提示：

1 <= s.length <= 104
s 仅有英文字母和空格 ' ' 组成
s 中至少存在一个单词

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        //反向遍历
        if(s[i]!==" "){
            count++;
        }else{
            //如果前面是字母，则这里单词就结束
            if (count>0) {
                return count;
            }
        }
    }
    return count;
};

let test = "   fly me   to   the moon  ";
let result=lengthOfLastWord(test);
console.log(result);
```

## 66. 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    digits[digits.length-1]+=1;
    for (let i=digits.length-1;i>0;i--){
        if (digits[i]<10){
            break;
        }else{
             digits[i]=0;
             digits[i-1]+=1;
        }
    }
    if (digits[0]===10) {
        digits[0]=1;
        digits[digits.length]=0;
    }
    return digits;
};
```

## 67. 二进制求和

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。
示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"


提示：

每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    if (a.length<b.length) {
        //交换变量的值,解构赋值
        [a,b]=[b,a];
    }
    let result=[];
    let temp=0;
    for(let i=0;i<b.length;i++){
        //先遍历短的一个
        temp+=Number(a[a.length-1-i])+Number(b[b.length-1-i])
        result.unshift((temp%2).toString());
        temp=temp>1 ? 1 : 0;
    }

    for(let j=a.length-b.length-1;j>=0;j--){
        //继续遍历长的一个剩余的位
        if (temp===1) {
            temp+=Number(a[j]);
            result.unshift((temp%2).toString());
            temp=temp>1 ? 1 : 0;
        }else{
            result.unshift(a[j]);
        }
    }
    if (temp===1) {
        //最后是否需要进位
        result.unshift("1")
    }
    return result.join("");
};

let test = "100";
let result=addBinary(test,"110010");
console.log(result);
```

考虑一个最朴素的方法：先将 a和 b转化成十进制数，求和后再转化为二进制数。

方法二：位运算

## 69. Sqrt(x)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
提示：

0 <= x <= 2^31 - 1

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    if (x<2) {
        return x;
    }
    //因为只需要整数部分，所以只需要找到平方小于等于x的的最接近的一个整数
    let left=1;
    let right=x>>1;
    let middle=(left+right)>>1;
    //二分查找
    while(left<=right){
        //注意溢出
        if (middle*middle>x) {
            right=middle-1;
        }else if (middle*middle<x) {
            left=middle+1;
        }else{
            return middle;
        }
        middle=(left+right)>>1;
    }
    return middle;
};

let test = 3;
let result=mySqrt(test);
console.log(result);
```

牛顿迭代法，或其他函数代替

## 70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

递归

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<3){
        return n;
    }else{
        //找到规律
        return climbStairs(n-1)+climbStairs(n-2);
    }

};

let test = 5;
let result=climbStairs(test);
console.log(result);
for (let i=1;i<20;i++){
    console.log(climbStairs(i));
}
/*
1
2
3
5
8
13
21
34
55
*/
```

```js
//动态规划
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```

方法一：动态规划

方法二：**矩阵快速幂**

方法三：通项公式

## 71. 简化路径

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。

1 <= path.length <= 3000
path 由英文字母，数字，'.'，'/' 或 '_' 组成。
path 是一个有效的 Unix 风格绝对路径。

```js
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    path=path.split("/")
    let result=[];
    path.forEach((item)=>{
        if (item!=="" && item!==".") {
            //对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理
            if (item==="..") {
                //当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录
                result.pop();
            }else{
                //当我们遇到「目录名」时，就把它放入栈。
                result.push(item);
            }
        }
    });
    //console.log(path);
    return "/"+result.join("/");
};

//let test = "/a/./b/../../c/";
let test = "/../";
let result=simplifyPath(test);
console.log(result);

```



## 83.删除排序链表中的重复元素

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。

返回同样按升序排列的结果链表。
提示：

链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列

方法一：一次遍历
当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。

```js
var deleteDuplicates = function(head) {
    if (!head) {
        return head;
    }

    let cur = head;
    while (cur.next) {
        if (cur.val === cur.next.val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return head;
};

```



```js
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if (head===null) {
        //如果为空
        return head;
    }
    let pre=head;
    let temp=head.val;
    while (head.next){
        if (head.next.val===temp) {
            //如果与前一个结点相同,跳过相同的那个
            head.next=head.next.next;
            //head=head.next;
        }else{
            //不同在移动到下一个
            head=head.next;
            temp=head.val;
        }
    }
    return pre;
};

let str1 = [1,1,2,3,3];
let list1=new ListNode();
let head1=list1;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
let result=deleteDuplicates(head1)
console.log(result);
```

## 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

提示：

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-10^9 <= nums1[i], nums2[j] <= 10^9

**进阶：**你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？

方法二：双指针,直接放会出现覆盖

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    const sorted = new Array(m + n).fill(0);
    var cur;
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            cur = nums2[p2++];
        } else if (p2 === n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (let i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
};
```

方法三：逆向双指针,不会产生覆盖现象

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    var cur;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 === -1) {
            cur = nums2[p2--];
        } else if (p2 === -1) {
            cur = nums1[p1--];
        } else if (nums1[p1] > nums2[p2]) {
            cur = nums1[p1--];
        } else {
            cur = nums2[p2--];
        }
        nums1[tail--] = cur;
    }
};
```



```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let len=m+n-1;
    while(m>=1 && n>=1){
        if (nums1[m-1]>=nums2[n-1]) {
            //如果访问到num1元素大于等于比nums2的
            nums1[len--]=nums1[--m];
        }else{
            //如果访问到num1元素小于比nums2的
            nums1[len--]=nums2[--n];
        }
    }
    while(m>=1){
        //n=0时候
        nums1[len--]=nums1[--m];
    }
    while(n>=1){
        //m=0时
        nums1[len--]=nums2[--n];
    }
};

let test =[1,2,3,0,0,0];
let test2=[2,5,6];
//let result=merge(test);
//console.log(result);
merge(test,3,test2,3);
console.log(test);
```

方法一：直接合并后排序

```js
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m, ...nums2);
    nums1.sort((a, b) => a - b);
};
```

## 89.格雷编码

n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：

- 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
- 第一个整数是 0
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同

给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

1 <= n <= 16

方法一：对称生成

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let result=[0];
    for (let i=1;i<=n;i++){
        let len=result.length;
        while(len>0){
            //对此生成
            result.push(result[--len] | (1<<(i-1)));
            //console.log(result[j] | (1<<(i-1)));
        }
    }
    return result;
};
```

```
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let maxValue=Math.pow(2,n)-1;
    let maxValueHex=maxValue.toString(2);
    let maxLen=maxValueHex.length;
    let arr=new Array(maxLen).fill("0");
    let hexs=[];
    for (let i=0;i<Math.pow(2,n);i++){
        let hex=(arr.join("")+i.toString(2)).slice(-maxLen);
        hexs.push(hex);
        //console.log(hex);
    }
    let newArr=[];
    for (let i=0;i<Math.pow(2,n);i++){
        
    }
    return 0;
};

let test=5;
let result=grayCode(test);
console.log(result);
```

方法二：二进制数转格雷码

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let result=[];
    for (let i=0;i<1<<n;i++){
        result.push((i>>1)^i);
    }
    return result;
};

let test=5;
let result=grayCode(test);
console.log(result);
```



## 94.二叉树的中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。
提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    
    if (root===null) {
        return [];
    }
    let result=[];

    result=result.concat(inorderTraversal(root.left));
    result.push(root.val);
    result=result.concat(inorderTraversal(root.right));
    return result;
};

let test =[1,null,2,3];

let root=new TreeNode(test[0]);
let result=inorderTraversal(test);
console.log(result);


```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

方法二：迭代

方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。

```js
var inorderTraversal = function(root) {
    let result=[];
    let stack=[];

    while(root || stack.length){
        while(root){
            stack.push(root);
            root=root.left;
        }
        root=stack.pop();
        result.push(root.val);
        root=root.right;
    }
    return result;
};
```

方法三：Morris 中序遍历

![Morris 中序遍历二叉树](E:\pogject\学习笔记\image\leetcode\Morris 中序遍历二叉树.png)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result=[];
    let predecessor=null;

    while(root){
        if (root.left) {
            //predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
            predecessor=root.left;
            while(predecessor.right && predecessor.right!==root){
                predecessor=predecessor.right;
            }
            // 让 predecessor 的右指针指向 root，继续遍历左子树
            if (!predecessor.right) {
                predecessor.right=root;
                root=root.left;
            }else{
                //说明左子树已经访问完了，我们需要断开链接
                result.push(root.val);
                predecessor.right=null;
                root=root.right;
            }
        }else{
            //如果没有左孩子，则直接访问右孩子
            result.push(root.val);
            root=root.right;
        }

    }
    return result;
};
```

## 100.相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
提示：

两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104

方法一：深度优先搜索

如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。

如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if (p===null && q===null) {
        return true;
    }else if (p===null || q===null) {
        return false;
    }else{
        if (p.val===q.val) {
            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
        }else{
            return false;
        }
    }
};
```

方法二：广度优先搜索

也可以通过广度优先搜索判断两个二叉树是否相同。同样首先判断两个二叉树是否为空，如果两个二叉树都不为空，则从两个二叉树的根节点开始广度优先搜索。

使用**两个队列**分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。

1. 比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；
2. 如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；
3. 如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。

**如果搜索结束时两个队列同时为空，则两个二叉树相同**。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。

```js
var isSameTree = function(p, q) {
    if (p===null && q===null) {
        return true;
    }
    if(p===null || q===null) {
        return false;
    }
    let arr1=[p];
    let arr2=[q];

    while(arr1.length>0 && arr2.length>0){
        let node1=arr1.shift();
        let node2=arr2.shift();
        if (node1.val!==node2.val) {
            return false;
        }
        let left1=node1.left,right1=node1.right;
        let left2=node2.left,right2=node2.right;

        if ((!left1)^(!left2) || (!right1)^(!right2)) {
            return false;
        }
        if (left1) {
            arr1.push(left1);
        }
        if (right1) {
            arr1.push(right1);
        }
        if (left2) {
            arr2.push(left2);
        }
        if (right2) {
            arr2.push(right2);
        }
    }
    if (arr1.length===0 && arr2.length===0) {
        return true;
    }else{
        return false;
    }

};
```

## 101.对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

方法一：递归

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值

- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，**通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q左移，p 左移时，q 右移**。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

function check(p,q){
    if (p===null && q===null) {
        return true;
    }
    if (p===null || q===null) {
        return false;
    }
    return p.val===q.val && check(p.left,q.right) && check(p.right,q.left);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root,root);
};

```

方法二：迭代

方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？**首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法**。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```js
function check(p,q){
    let arr=[p,q];
    while(arr.length>0){
        node1=arr.shift();
        node2=arr.shift();
        if (!node1 && !node2) {
            //都为空,跳过，检查后面的
            continue;
        }
        if ((!node1 || !node2) || node1.val!==node2.val) {
            //值不等或一个为空，一个不为空
            return false;
        }
        arr.push(node1.left);
        arr.push(node2.right);
        arr.push(node1.right);
        arr.push(node2.left);
    }
    return true;
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root,root);
};
```

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

```

```

## 104.二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

方法一：深度优先搜索

如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1

而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
};
```

方法二：广度优先搜索

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的**队列里存放的是「当前层的所有节点」**。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们**需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展**，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。

```js
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }
    let arr=[root];
    let count=0;
    while(arr.length>0){
        let len=arr.length;
        while(len>0){
            //需要将队列里的所有节点都拿出来进行拓展
            node=arr.shift();
            if (node.left!==null) {
                //加入的这层在下一次外循环拿出判断
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        count++;
    }
    return count;
};
```

## 108. 将有序数组转换为二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「**每个节点的左右两个子树的高度差的绝对值不超过 1** 」的二叉树。

提示：

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 按 严格递增 顺序排列

二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。

给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。

如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。

直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 11，可以使得树保持平衡。**如果数组长度是奇数，则根节点的选择是唯一的**，**如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点**，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。

当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考「1382. 将二叉搜索树变平衡」，这两道题的构造方法完全相同，这种方法是正确的，1382 题解中给出了这个方法的正确性证明：1382 官方题解，感兴趣的同学可以戳进去参考。

递归的基准情形是平衡二叉搜索树不包含任何数字，此时平衡二叉搜索树为空。

在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为[left,right]。对于整个中序遍历序列，下标范围从left=0 到 right=nums.length−1。当 left>right 时，平衡二叉搜索树为空。

以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。

方法一：中序遍历，总是选择中间位置左边的数字作为根节点

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置左边的数字作为根节点
    let mid=(left+right)>>1;  //左边
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}

let test =[-10,-3,0,5,9];
let result=sortedArrayToBST(test);
console.log(result);
```

方法二：中序遍历，总是选择中间位置右边的数字作为根节点

```js
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置右边的数字作为根节点
    let mid=(left+right+1)>>1;  //右边
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}
```

方法三：中序遍历，**选择任意一个中间位置数字作为根节点**

```js
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置右边的数字作为根节点
    let mid=(left+right+Math.round(Math.random()))>>1;  //左右随机一个
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}
```

## 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

方法一：自顶向下的递归

有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    if (root===null) {
        return true;
    }
    let leftDeep=maxDepth(root.left);
    let rightDeep=maxDepth(root.right);
    if (Math.abs(leftDeep-rightDeep)>1) {
        //左右子树高度差的绝对值不超过 1
        return false;
    }
    
    let leftIsBalance=isBalanced(root.left);
    let rightIsBalance=isBalanced(root.right);
    
    if (leftIsBalance && rightIsBalance) {
    	//左右子树也必需是平衡二叉树
        return true;
    }else{
        return false;
    }
};

var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
};
```

方法二：自底向上的递归

方法一由于是自顶向下递归，**因此对于同一个节点，函数 height 会被重复调用**，导致时间复杂度较高。**如果使用自底向上的做法，则对于每个节点，函数height 只会被调用一次。**

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    return getHeight(root)>=0;
};

function getHeight(root){
    if (root===null) {
        return 0;
    }
    let leftHeight=getHeight(root.left);
    let rightHeight=getHeight(root.right);
    if (leftHeight===-1  || rightHeight===-1 || Math.abs(leftHeight-rightHeight)>1) {
        //只要遇到不平衡时就返回-1，整棵树也是不平衡的
        return -1;
    }else{
        //平衡时
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```

## 111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

方法一：深度优先搜索

首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。

对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。

```js

/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (root===null){
        //如果结点为空
        return 0;
    }else if (root.left===null && root.right===null){
        //如果没有子树，则深度为1
        return 1;
    }else if (root.left===null && root.right!==null) {
        //如果只存在右子树
        return 1+minDepth(root.right);
    }else if (root.left!==null && root.right===null) {
        //如果只存在左子树
        return 1+minDepth(root.left);
    }else{
        //左右子树都存在
        return 1+Math.min(minDepth(root.left),minDepth(root.right));
    }
};
```

方法二：广度优先搜索

同样，我们可以想到使用广度优先搜索的方法，遍历整棵树。

当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。

```js
var minDepth = function(root) {
    if (root===null) {
        return 0;
    }
    let count=0;
    let arr=[root];
    let flag=true;
    while(flag){
        let len=arr.length;
        while(len>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                //当在一层遇到叶子结点，则退出循环
                flag=false;
            }
            if (node.left!==null) {
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        //如果这层没有叶子结点
        count++;
    }
    return count;
};

var minDepth = function(root) {
    if (root===null) {
        return 0;
    }
    let count=0;
    let arr=[root];

    while(true){
        let len=arr.length;
        count++;
        while(len>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                //当在一层遇到叶子结点，则退出循环,返回深度
                return count;
            }
            if (node.left!==null) {
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
    }
};
```

## 112.路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

方法一：广度优先搜索

首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。

这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (root===null) {
        return false;
    }
    let result=[root];
    while(result.length>0){
        let len=result.length;
        while(len>0){
            let node=result.shift();
            if (node.left!==null) {
                node.left.val+=node.val;
                result.push(node.left);
            }
            if (node.right!==null) {
                node.right.val+=node.val;
                result.push(node.right);
            }
            if (node.left===null && node.right===null) {
                if (node.val===targetSum) {
                    return true;
                }
            }
            len--;
        }
    }
    return false;
};
```

方法二：递归

观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```js
var hasPathSum = function(root, targetSum) {
    if (root===null) {
        return false;
    }
    if (root.left===null && root.right===null) {
        return targetSum===root.val;
    }
    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);
};
```

## 118.杨辉三角

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
提示:

1 <= numRows <= 30

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    let result=[[1]];
    for(n=2;n<=numRows;n++){
        let arr=new Array(n);
        arr[0]=1;
        arr[n-1]=1;
        for(i=1;i<n-1;i++){
            arr[i]=result[n-2][i-1]+result[n-2][i];
        }
        result.push(arr);
    }
    return result;
};

let test=5;
let result=generate(test);
console.log(result);
```

## 119.杨辉三角 II

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
提示:

0 <= rowIndex <= 33

```js
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let result=[1];
    for(n=2;n<=rowIndex+1;n++){
        let arr=new Array(n);
        arr[0]=1;
        arr[n-1]=1;
        for(i=1;i<n-1;i++){
            arr[i]=result[i-1]+result[i];
        }
        result=arr;
    }
    return result;
};

let test=3;
let result=getRow(test);
console.log(result);
```

## 121.买卖股票的最佳时机 

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

方法一：暴力法, 会超时

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let max=0;
    for (let i=1;i<prices.length;i++){
        for (let j=0;j<i;j++){
            let profit=prices[i]-prices[j]
            max=profit>max ? profit : max;
        }
    }
    return max;
};
let test=[7,1,5,3,6,4];
let result=maxProfit(test);
console.log(result);
```

方法二：一次遍历

我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```js
var maxProfit = function(prices) {
    let max=0;
    let minPrice=Number.MAX_VALUE;
    for (let i=0;i<prices.length;i++){
        if (prices[i]<minPrice) {
            minPrice=prices[i];
        }else{
            let profit=prices[i]-minPrice;
            max=profit>max ? profit : max;
        }
    }
    return max;
};
```

## 125.  验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s=s.toLowerCase();
    s=s.replace(/[^a-z0-9]/g,"")
    console.log(s);
    for (let i=0;i<s.length/2;i++){
        if (s[i]!==s[s.length-1-i]) {
            return false;
        }
    }
    return true;
};


let str1 = "A man, a plan, a canal: Panama";
let result=isPalindrome(str1);
console.log(result);

```

## 136. 只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

![只出现一次的数字位运算](E:\pogject\学习笔记\image\leetcode\只出现一次的数字位运算.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let single=0;
    for (let i=0;i<nums.length;i++){
        single^=nums[i];
    }
    return single;
};

let test=[4,1,2,1,2];
let result=singleNumber(test);
console.log(result);
```

## 141.环形链表

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

提示：

链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？

方法一：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if (head===null) {
        return false;
    }
    let set=new Set();
    while(head.next!==null){
        if (set.has(head)) {
            return true;
        }else{
            set.add(head);
            head=head.next;
        }
    }
    return false;
};
```

方法二：快慢指针

![环形链表快慢指针](E:\pogject\学习笔记\image\leetcode\环形链表快慢指针.png)

```js
var hasCycle = function(head) {
    if (head===null || head.next===null) {
        return false;
    }
    let slow=head;
    let fast=head.next;
    while(slow!==fast){
        if (fast===null || fast.next===null) {
            return false;
        }else{
            slow=slow.next;  //慢指针
            fast=fast.next.next;  //快指针
        }
    }
    return true;
};
```

## 144.二叉树的前序遍历

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[root.val];
    //递归
    result=result.concat(preorderTraversal(root.left));
    result=result.concat(preorderTraversal(root.right));
    return result;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //迭代
        let node=arr.pop();
        result.push(node.val);  //出栈
        if (node.right!==null) {
            //右子树先入栈确保后访问右子树
            arr.push(node.right);
        }
        if (node.left!==null) {
            arr.push(node.left);
        }

    }
    return result;
};
```

方法三：Morris 遍历
思路与算法

有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。

**Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减**。其前序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：

- 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
- 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。

重复步骤 2 和步骤 3，直到遍历结束。

这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let p=root;
    let q;

    let result=[];
    while(p!==null){
        let q=p.left;
        if (q!==null) {
            //如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点
            while(q.right!==null && q.right!==p){
                q=q.right;
            }
            if (q.right===null) {
                //如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。
                result.push(p.val);  //然后将当前节点加入答案
                q.right=p;  //并将前驱节点的右子节点更新为当前节点
                p=p.left;  //当前节点更新为当前节点的左子节点。
                continue;
            }else{
                //q.right!==null && q.right===p
                //如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
                q.right=null;
            }
        }else{
            //如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
            result.push(p.val);
        }
        p=p.right;
    }
    return result;
};
```

## 145.二叉树的后序遍历

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[];
    //递归
    result=result.concat(postorderTraversal(root.left));
    result=result.concat(postorderTraversal(root.right));
    result.push(root.val);
    return result;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //反向迭代
        let node=arr.pop();  //出栈
        result.unshift(node.val);  //从数组前面进入队列
        if (node.left!==null) {
            //左子树先入栈确保先访问右子树
            arr.push(node.left);
        }
        if (node.right!==null) {
            //后入栈，先访问
            arr.push(node.right);
        }
        
    }
    return result;
};
```

## 155.最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。

- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。

```js
var MinStack = function() {
    this.data=new Array();
    this.minValue=new Array();  //存储每一个栈顶对应的最小值
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    if (this.data.length===0) {
        this.minValue.push(val)
    }else{
        this.minValue.push(Math.min(this.minValue[this.minValue.length-1],val));
    }
    //顺序不能反
    this.data.push(val);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.data.pop();
    this.minValue.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.data[this.data.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.minValue[this.minValue.length-1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

## 160.相交链表

给你两个单链表的头节点 headA 和 headB ，**请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。**
题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。
自定义评测：

评测系统 的输入如下（你设计的程序 不适用 此输入）：

- intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
- listA - 第一个链表
- listB - 第二个链表
- skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
- skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

提示：

- listA 中节点数目为 m

- listB 中节点数目为 n
- 1 <= m, n <= 3 * 104
- 1 <= Node.val <= 105
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    //方法一：哈希集合
    //首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中*/
    const visited=new Set();
    let p=headA;
    while(p!==null){
        visited.add(p);
        p=p.next;
    }
    p=headB;
    while(p!==null){
        if (visited.has(p)) {
            return p;
        }
        p=p.next;
    }
    return null;
};
```

![相交链表(双指针)](E:\pogject\学习笔记\image\leetcode\相交链表(双指针).png)

```js
var getIntersectionNode = function(headA, headB) {
    
    if (headA===null || headB===null) {
        return null;
    }
    let p=headA;
    let q=headB;

    while(p!==q){
        p=p===null ? headB : p.next;
        q=q===null ? headA : q.next;
    }
    return p;
};
```



## 208. 实现 Trie (前缀树)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次

```js
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @return {boolean}
 */
 //搜索
Trie.prototype.search = function(word) {
    let node=this.startsWith(word);
    //若搜索到了前缀的末尾，就说明字典树中存在该前缀。
    //此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。
    return node!==undefined && node.isEnd!==undefined;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
//查找前缀
Trie.prototype.startsWith = function(prefix) {
    let node=this.children;
    for (let ch of prefix){
        //子节点不存在。说明字典树中不包含该前缀，返回空指针
        if (!node[ch]) {
            return false;
        }
        //子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
        node=node[ch];
    }
    return node;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

let test=new Trie();

test.insert("apple");
result=test.search("apple");
console.log(result);  //true

result=test.search("app");
console.log(result);  //false

result=test.startsWith("app");
console.log(result);  //

test.insert("app");
result=test.search("app");
console.log(result);  //
```

## 306.累加数

累加数 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。

说明：累加序列里的数 不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。

提示：

1 <= num.length <= 35
num 仅由数字（0 - 9）组成

进阶：你计划如何处理由过大的整数输入导致的溢出?

```
/**
 * @param {string} num
 * @return {boolean}
 */
var isAdditiveNumber = function(num) {
    if (num.length<3) {
        //累加数至少3位才行
        return false;
    }
    let len=num.length;
    let i=0,j=1,k=2;
    let a,b;
    let sumab;
    while(i<len){
        a=Number(num.slice(0,i));
        while(j<len-Math.max(j-i,i)){
            b=Number(num.slice(i,j));
            while(k<len-Math.max(j-i,i)){
                c=(a+b).toString();
                if (num.indexOf(c)!==k) {

                }
            }
            
            
        }
    }
    return false;
};

let test= "199100199";
let result=isAdditiveNumber(test);
console.log(result);
```

## 334.递增的三元子序列

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

提示：

1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1

**进阶：**你能实现时间复杂度为 `O(n)` ，空间复杂度为 `O(1)` 的解决方案吗？

暴力解法，超时

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    if (nums.length<3) {
        return false;
    }
    let flag=0;
    let i;
    for (let i=0;i<nums.length-2;){
        for (let j=i+1;j<nums.length-1;j++){
            if (nums[i]<nums[j]) {
                for (let k=j+1;k<nums.length;k++){
                    if (nums[j]<nums[k]) {
                        return true;
                    }
                }
            }
            
        }
    }
    return false;
};

let test=[2,1,5,0,4,6];
let result=increasingTriplet(test);
console.log(result);
```

找到局部最小最大值

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    if (nums.length<3) {
        return false;
    }
    let min=nums[0]<nums[1] ? nums[0] : nums[1];  //局部最小在第一个与第二个开始计算
    let max=nums[1];  //局部最大值从第二个值开始计算
    for (let i=2;i<nums.length;i++){
        if (min<max) {
            //如果已经找到max>min
            if (nums[i]>max) {
                //如果当前值大于max,则满足题意条件
                return true;
            }else{
                //如果不满足
                if (nums[i]<=min) {
                    //如果当前值比min小，就把min设为当前值
                    min=nums[i];
                }else{
                    //如果当前值比min大，把max设为当前值，
                    max=nums[i];
                }
            }
        }else{
            //当min>max时，从第二个开始值都不大于前面的时候
            if (nums[i]<=min) {
                //如果当前值比min小，就把min,max都设为当前值
                max=nums[i];
                min=nums[i];
            }else{
                //如果当前值比min大，把max设为当前值，后面就会满足max>min了
                max=nums[i];
            }
        }
    }
    return false;
};

let test=[1,0,0,0,0,-1,0,0,0,1000];  //[1,1,-2,6]
let result=increasingTriplet(test);
console.log(result);
```

![递增的三元子序列（双向遍历）](E:\pogject\学习笔记\image\leetcode\递增的三元子序列（双向遍历）.png)

![递增的三元子序列（贪心）](E:\pogject\学习笔记\image\leetcode\递增的三元子序列（贪心）.png)



## 390. 消除游戏

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

- 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。

- 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。

- 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。

给你整数 n ，返回 arr 最后剩下的数字。

提示：

1 <= n <= 10^9

直接遍历数组删除会超时

**方法一：等差数列模拟**

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\消除游戏等差数列模拟.png)

```js
/**
 * @param {number} n
 * @return {number}
 */
var lastRemaining = function(n) {
    let a1=1;
    //删除次数k,元素数目为cnt,首元素a1,末尾元素an,公差step
    let k=0,cnt=n,step=1;
    while(cnt>1){
        if (k%2===0) {
            // 正向
            a1=a1+step;
        }else{
            //反向，得考虑奇数个或偶数个
            a1=(cnt%2===0) ? a1 : a1+step;
        }
        k++;
        //有符号右移由两个大于号（>>）表示
        cnt=cnt>>1;
        //左移操作符用两个小于号（<<）表示
        step=step<<1;
    }
    
    return a1;
};


console.log(lastRemaining(50));

```

复杂度分析

- 时间复杂度：O(log n)，其中 n 为初始整数列表的元素数目。每次删除都会将元素数目减半，所以时间复杂度为 O(logn)。


- 空间复杂度：O(1)。只需要使用常数的额外空间。


## 472. 连接词

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

提示：

1 <= words.length <= 104
0 <= words[i].length <= 1000
words[i] 仅由小写字母组成
0 <= sum(words[i].length) <= 105

方法一：字典树 + 深度优先搜索
判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。

1. 为了方便处理，首先将数组 words 按照字符串的长度递增的顺序排序，排序后可以确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。
2. 在将数组 words 排序之后，遍历数组，跳过空字符串，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入结果数组，如果不是连接词则将该单词加入字典树。
3. 判断一个单词是不是连接词的做法是在字典树中深度优先搜索。从该单词的第一个字符（即下标 00处的字符）开始，在字典树中依次搜索每个字符对应的结点，可能有以下几种情况：

- 如果一个字符对应的结点是单词的结尾，则找到了一个更短的单词，从该字符的后一个字符开始搜索下一个更短的单词；
- **如果一个字符对应的结点在字典树中不存在，则当前的搜索结果失败，回到上一个单词的结尾继续搜索。**

如果找到一个更短的单词且这个更短的单词的最后一个字符是当前单词的最后一个字符，则当前单词是连接词。由于数组 words 中没有重复的单词，因此在判断一个单词是不是连接词时，该单词一定没有加入字典树，由此可以确保判断连接词的条件成立。

由于一个连接词由多个更短的非空单词组成，如果存在一个较长的连接词的组成部分之一是一个较短的连接词，则一定可以将这个较短的连接词换成多个更短的非空单词，因此不需要将连接词加入字典树。

```
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @param {start} int 单词开始索引位置
 * @return {boolean}
 */
 //查找一个词从索引开始后的连续部分是否已存在
Trie.prototype.dfs = function(word,start) {
    let node=this.children;
    for (let i=start;i<word.length;i++){
        node=node[word[i]];
        //深度优先遍历
        if (node!==undefined) {
            if (node.isEnd!==undefined) {
                return i+1;
            }else{
                continue;
            }
        }
        node=node[word[i]];
        if (!node) {
            //得考虑这个单词不行可能那个单词行,carbat比如cat与car
            return false;
        }
        
        if (node && i===word.length-1){
            return i+1;
        }
    }
};



/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const trie=new Trie();

    trie.insert(words[0]);
    trie.insert(words[1]);
    //console.log(trie);
   
    for (let i=2;i<words.length;i++){
        let word=words[i];
        let start;
        let count=0;
        for(start=0;start<word.length;){
            let index=trie.dfs(word,start);
            if (index===false) {
                trie.insert(word);
                break;
            }else{
                if (index<word.length) {
                    start=index;
                    count++;
                }else{
                    if (count>1) {
                        result.push(word);
                    }
                }
            }
        }

    }
    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```

```

//插入字符串
function insertWord(dictTree,word) {
    let node=dictTree;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

//检查单词是否是连接词
function checkWord(dictTree,word,start){
    
    let node=dictTree;
    let count=0;  //计数找到多少个更短的单词
    let i; //i为要检查单词开始的索引
    let tempNode=[];  //记录一个路径上是单词的尾结点
    let tempIndex=[];  //记录一个路径上尾结点对应的索引
    for(i=0;i<word.length;){
        if (node[word[i]]===undefined && count<1) {
            //如果一个短的单词都没有找到，则不是连接词
            return false;
        }
        if (node[word[i]]===undefined){
            //当已经找到一个更短的单词时，字母在该路径不存在
            if (count>0) {
                //当尾结点数大于终末尾结点数时,则可以退回到上一次尾结点
                if (tempNode.length>count){
                    
                }
            }
        }else{
            //当一个字母在该路径存在
            node=node[word[i]];
            if (node.isEnd!==undefined) {
                //node是一个单词的尾结点
                tempNode.push(node);  //记录索引和结点指针
                tempIndex.push(i);
                //如果路径上还有结点,继续深度搜索
                if (node[word[i+1]]===undefined) {
                    //当是尾结点且后面不匹配
                    count+=1;
                    //从当前位置开始匹配下一份更短单词
                    node=dictTree;
                }
            }
            i++;
        }

    }
    return true;
}

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const dictTree={};

    insertWord(dictTree,words[0]);
    insertWord(dictTree,words[1]);
    //console.log(dictTree);
   
   for (let i=2;i<words.length;i++){
        let word=words[i];
        if (dictTree[word[0]]===undefined) {
            //因为单词是从短到长排序的
            //如果单词的第一个字母不在字典树的开始，则一定不是连接词，插入
            insertWord(dictTree,word);
            continue;  //跳过余下检查
        }

        let isConcatWord=checkWord(dictTree,word)
        if (isConcatWord) {
            //如果是连接词
            result.push(word);
        }else{
            //不是则插入
            insertWord(dictTree,word)
        }
    }

    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```



## 507. 完美数

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function(num) {
	if (num===1) {return false;}
	let sum=1;
	for (let i=2;i<=Math.sqrt(num);i++){
		if (i===Math.sqrt(num)) {
			sum+=Math.sqrt(num)
		}else{
			if (num%i===0) {
				sum+=i+num/i;
			}
		}
	}
	if (num===sum) {
		return true;
	}else{
		return false;
	}
}

let str1=121;
let result=checkPerfectNumber(str1);
console.log(result);
```



## 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

示例 1：

输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var repeatedStringMatch = function(a, b) {
    //首先只要b中有字母不在a中,则不可能b为a的子串
    let len_a=a.length;
    let len_b=b.length;

    let set=new Set();
    for (let i=0;i<len_a;i++){
        set.add(a[i]);
    }
    for (let i=0;i<len_b;i++){
        if (!set.has(b[i])) {
            return -1;
        }
    }
    let newStr=a;
    //判断b与a的长度，a当重复后长度最多超过b长度的2倍，如果2倍长度没有找到则返回-1
    let n=len_b%len_a===0 ? len_b/len_a : Math.floor(len_b/len_a)+1;
    if (len_a>=len_b) {
        //当a长时，返回值最多为2
        if (newStr.indexOf(b)!==-1) {
            return 1;
        }else{
            newStr+=a;
            if (newStr.indexOf(b)!==-1) {
                return 2;
            }else{
                return -1;
            }
        }
    }else{
        //当b长时，a长度最多增加到b的2倍
        for (let i=0;i<n-1;i++){
            newStr+=a;
        }
        while (newStr.length<2*len_b){
            if (newStr.indexOf(b)!==-1) {
                return n;
            }else{
                newStr+=a;
                n++;
            }
        }
        if (newStr.indexOf(b)!==-1) {
            return n;
        }else{
            return -1;
        }
        
    }
    return 0;
};


let str1 = "abc";
let str2="cabcabca";

let result=repeatedStringMatch(str1,str2);
console.log(result);
```

## 747.至少是其他数字两倍的最大数

给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。

请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。

提示：

1 <= nums.length <= 50
0 <= nums[i] <= 100
nums 中的最大元素是唯一的

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var dominantIndex = function(nums) {
    if (nums.length===1) {
        return 0;
    }
    //找到最大值与次大比较即可
    let maxValue=nums[0]>nums[1] ? nums[0] : nums[1];
    let secondMaxValue=nums[0]>nums[1] ? nums[1] : nums[0];
    let MaxValueIndex=nums[0]>nums[1] ? 0 : 1;
    for (let i=2;i<nums.length;i++){
        if (nums[i]>maxValue) {
            secondMaxValue=maxValue;
            maxValue=nums[i];
            MaxValueIndex=i;
        }else{
            if (nums[i]>secondMaxValue) {
                secondMaxValue=nums[i];
            }
        }
    }
    if (maxValue>=2*secondMaxValue) {
        return MaxValueIndex;
    }else{
        return -1;
    }
};

let str1 = [3,6,1,0];
let result=dominantIndex(str1);
console.log(result);

```



## 825. 适龄的朋友

在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：

age[y] <= 0.5 * age[x] + 7
age[y] > age[x]
age[y] > 100 && age[x] < 100
否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

- `n == ages.length`
- `1 <= n <= 2 * 104`
- `1 <= ages[i] <= 120`

```js
/**
 * @param {number[]} ages
 * @return {number}
 */
var numFriendRequests = function(ages) {
    if (ages.length===1) {return 0;}
    let count=0;
    ages.sort((a,b)=>b-a);  //从大到小排序
    let flag=0;  //移动指针
    for (let i=0;i<ages.length;i++){
        for (let j=flag;j<ages.length;j++){
            if (i!==j) {
                if (ages[j]>ages[i]*0.5+7) {
                    count++;
                    //console.log(ages[i]+"->"+ages[j]);
                }else{
                    break;
                }
            }
        }
        //age变化则移动指针
        if (ages[i]>ages[i+1]) {
            //console.log(ages[flag]);
            flag=i+1;
        }
    }
    return count;
};

let str1 = [30,100,110,120,20];
let result=numFriendRequests(str1);
console.log(result);

```



## 846. 一手顺子

Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。

给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。

提示：

1 <= hand.length <= 104
0 <= hand[i] <= 109
1 <= groupSize <= hand.length

示例 1：

输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
示例 2：

输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。

```js
/**
 * @param {number[]} hand
 * @param {number} groupSize
 * @return {boolean}
 */
var isNStraightHand = function(hand, groupSize) {
    if (hand.length%groupSize!==0) {
        //当不能整除则不能排列为相同size的
        return false;
    }
    if (groupSize===1) {
        //当size为1则可以
        return true;
    }
    //从小到大排序
    hand.sort((a,b)=>a-b);
    //console.log(hand.length/groupSize);
    //console.log(hand);
    let len=hand.length;  //记录初始长度

    for (let i=0;i<len/groupSize;i++){
        let temp=hand[0];  //每一次排列一定是从最小的开始
        //console.log(temp);
        hand.shift();  //删除第一张牌

        for (let j=1;j<groupSize;j++){
            //从第二张开始找就行
            let index=hand.indexOf(temp+j);
            if (index===-1) {
                //如果不存在比上一张大1的牌
                return false;
            }
            //存在则删除
            //console.log(hand[index]);
            hand.splice(index,1);

        }
        //console.log("---")
    }

    return true;
};

let hand = [9,13,15,23,22,25,16,21,18,21,24,23,10,21,16,18,16,18,5,20,19,20,10,14,26,2,9,19,12,28,17,5,7,25,22,16,17,21,11];
let groupSize = 10;

console.log(isNStraightHand(hand,groupSize));
```

## 913. 猫和老鼠

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

**老鼠从节点 1 开始**，第一个出发；**猫从节点 2 开始**，第二个出发。**在节点 0 处有一个洞**。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，**猫无法移动到洞中（节点 0**）。

然后，游戏在出现以下三种情形之一时结束：

- 如果猫和老鼠出现在同一个节点，猫获胜。
- 如果老鼠到达洞中，老鼠获胜。
- 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。

给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：

- 如果老鼠获胜，则返回 1；

- 如果猫获胜，则返回 2；
- 如果平局，则返回 0 。

提示：

3 <= graph.length <= 50
1 <= graph[i].length < graph.length
0 <= graph[i][j] < graph.length
graph[i][j] != i
graph[i] 互不相同
猫和老鼠在游戏中总是移动

![猫和老鼠动态规划1](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划1.png)

![猫和老鼠动态规划2](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划2.png)

```js
const MOUSE_WIN=1;
const CAT_WIN=2;
const DRAW=0;

/**
 * @param {number[][]} graph
 * @return {number}
 */
var catMouseGame = function(graph) {
    this.n=graph.length;
    this.graph=graph;
    this.dp=new Array(n).fill(0).map(()=>new Array(n).fill(0).map(()=>new Array(n*2).fill(-1)));
    //console.log(this.dp);
    return getResult(1,2,0);
};

const getResult=(mouse,cat,turns)=>{
    if (turns===n*2) {
        return DRAW;
    }
    if (dp[mouse][cat][turns]<0) {
        if (mouse===0) {
            dp[mouse][cat][turns]=MOUSE_WIN;
        }else if(cat===mouse){
            dp[mouse][cat][turns]=CAT_WIN;
        }else{
            getNextResult(mouse,cat,turns);
        }
    }
    return dp[mouse][cat][turns];
}

const getNextResult=(mouse,cat,turns)=>{
    const curMove=turns%2===0 ? mouse : cat;
    const defaultResult=curMove===mouse ? CAT_WIN : MOUSE_WIN;
    let result=defaultResult;
    const nextNodes=graph[curMove];
    for (let next of nextNodes){
        if (curMove===cat  && next===0) {
            continue;
        }
        const nextMouse=curMove===mouse ? next : mouse;
        const nextCat=curMove===cat ? next : cat;
        const nextResult=getResult(nextMouse,nextCat,turns+1);
        if (nextResult!==defaultResult) {
            result=nextResult;
            if (result!==DRAW) {
                break;
            }
        }
    }
    dp[mouse][cat][turns]=result;
}


let test = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]];
let result=catMouseGame(test);
console.log(result);
```



## 1044.最长重复子串

给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。

提示：

2 <= s.length <= 3 * 104
s 由小写英文字母组成

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    let strA;
    for (let k=s.length-1;k>0;k--){
        for (let i=0;i+k<s.length;i++){
            strA=s.slice(i,i+k);
            if (i!==s.lastIndexOf(strA)){
                return strA;
            }
        }
        
    }
    return "";
};

let str1 = "basanaadsfenafdrrgeana";
let result=longestDupSubstring(str1);
console.log(result);
```

超时

## 1154.  一年中的第几天

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

提示：

date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

```js
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    let y=Number(date.split("-")[0]);
    let m=Number(date.split("-")[1]);
    let d=Number(date.split("-")[2]);
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];

    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }

    let total=0;
    for (let i=0;i<m-1;i++){
        total+=monthOfDays[i]
    }
    total+=d;
    if (m>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }

    return total;
};

let str1 = "2022-01-01";

let result=dayOfYear(str1);
console.log(result);
```

**普通闰年:公历年份是4的倍数的，一般是闰年。（如2004年就是闰年）；
世纪闰年:公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是世纪闰年，2000年是世纪闰年）；**

## 1185. 一周中的第几天

给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

输入：day = 31, month = 8, year = 2019
输出："Saturday"

题目规定输入的日期一定是在 1971 到 2100 年之间的有效日期，即在 1971 年 1 月 1日，到 2100 年 12 月 31 日之间。通过查询日历可知，1970 年 12 月 31 日是星期四，我们只需要算出输入的日期距离 1970 年 12 月 31 日有几天，再加上 3 后对 7求余，即可得到输入日期是一周中的第几天。

求输入的日期距离 1970 年 12 月 31 日的天数，可以分为三部分分别计算后求和：

（1）输入年份之前的年份的天数贡献；
（2）输入年份中，输入月份之前的月份的天数贡献；
（3）输入月份中的天数贡献。

```js
var isLeap=function(y){
    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }
    return is_leap;
}

/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(year,month,day) {
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];
    let is_leap=isLeap(year);

    let total=0;
    for (let i=0;i<month-1;i++){
        total+=monthOfDays[i]
    }
    total+=day;
    if (month>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }
    return total;
};

/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    let totalDays=0;
    for(let y=1971;y<year;y++){
        totalDays+=365;
        if (isLeap(y)){
            console.log(y);
            totalDays+=1
        }
    }
    totalDays+=dayOfYear(year,month,day)+3;
    return weekdays[totalDays%7];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```

直接使用API

```js
/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    let weekDay=date.getDay();  //从 Date 对象返回一周中的某一天 (0 ~ 6)。
    return weekdays[weekDay];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```

## 1576.替换所有的问号

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你 不能 修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

提示：

1 <= s.length <= 100

s 仅包含小写英文字母和 '?' 字符

在替换时，实际不需要遍历所有的小写字母，只需要遍历三个互不相同的字母，就能保证一定找到一个与前后字符均不相同的字母，在此我们可以限定三个不同的字母为 (‘a’,‘b’,‘c’)。



```js
/**
 * @param {string} s
 * @return {string}
 */
var modifyString = function(s) {
    s=s.split("");
    for (let i=0;i<s.length;i++){
        if (s[i]==="?") {
            if (s[i-1]!=="a" && s[i+1]!=="a") {
                //前后都不为a则设为a
                s[i]="a";
            }else if (s[i-1]==="b" || s[i+1]==="b"){
                //有一个a和一个b，则设为c
                s[i]="c";
            }else{
                //前后都是a时,设为b
                s[i]="b";
            }
        }
    }
    return s.join("");
};

let test = "aza??byw?ipkj?";
let result=modifyString(test)
console.log(result);

//使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定
//fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
/*
console.log("az".charCodeAt(0));  //97
console.log("az".charCodeAt(1));  //122
console.log(String.fromCharCode(97));  //a
console.log(String.fromCharCode(122));  //z
*/
```

```

```

## 1614.括号的最大嵌套深度

如果字符串满足以下条件之一，则可以称之为 **有效括号字符串**（valid parentheses string，可以简写为 VPS）：

- 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。

- 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。

- 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。

类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：

- depth("") = 0

- depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
- depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
- depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串

例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。

**给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。**

提示：

1 <= s.length <= 100
s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
题目数据保证括号表达式 s 是 有效的括号表达式

栈处理

```js
/**
 * @param {string} s
 * @return {number}
 */
var maxDepth = function(s) {
    let arr=[];
    let maxDeep=0;
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        if (s[i]===")") {
            //右括号就入栈
            if (arr.length!==0) {
                if (count>0) {
                    //如果前面已经出栈，但栈不为空，局部值减1
                    count--;
                }
            }
            arr.unshift(s[i]);
            //console.log(arr,count);
        }
        if (s[i]==="(") {
            //是左括号则弹出一个右括号,局部计数加一
            arr.shift();
            count++;
            if (arr.length===0) {
                //当出栈后栈为空，则一个区域匹配完，判断最大值
                maxDeep=count>maxDeep ? count : maxDeep;
                count=0;
            }
            //console.log(arr,count);
        }
    }
    return maxDeep;
};

let test = "(1)+((2))+(((((4)((()))))((3))))";
let result=maxDepth(test)
console.log(result);
```

方法一：遍历

对于括号计算类题目，我们往往可以用栈来思考。

遍历字符串 s，如果遇到了一个左括号，那么就将其入栈；如果遇到了一个右括号，那么就弹出栈顶的左括号，与该右括号匹配。这一过程中的栈的大小的最大值，即为 s 的嵌套深度。

代码实现时，由于我们只需要考虑栈的大小，我们可以用一个变量 size 表示栈的大小，当遇到左括号时就将其加一，遇到右括号时就将其减一，从而表示栈中元素的变化。这一过程中 size 的最大值即为 s 的嵌套深度。

```js
/**
 * @param {string} s
 * @return {number}
 */
//不用栈空间是一样的
var maxDepth = function(s) {
    let maxDeep=0;
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        if (s[i]===")") {
            count++;
            maxDeep=count>maxDeep ? count : maxDeep;
        }
        if (s[i]==="(") {
            count--;
        }
    }
    return maxDeep;
};
```

## 1629.按键持续时间最长的键

LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。

给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。

测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。

注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。

请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。

提示：

releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed 仅由小写英文字母组成

```js
/**
 * @param {number[]} releaseTimes
 * @param {string} keysPressed
 * @return {character}
 */
var slowestKey = function(releaseTimes, keysPressed) {
    let maxTime=releaseTimes[0];
    let char=keysPressed[0];
    for (let i=1;i<releaseTimes.length;i++){
        let duration=releaseTimes[i]-releaseTimes[i-1]
        if (duration>maxTime) {
            maxTime=duration;
            char=keysPressed[i];
        }
        if (duration===maxTime) {
            if (keysPressed[i].codePointAt(0)>char.codePointAt(0)) {
                char=keysPressed[i];
            }
        }
    }
    return char;
};

let test= [9,29,49,50];
let result=slowestKey(test,"cbcd");
console.log(result);
```



## 1705. 吃苹果的最大数目

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

提示：

apples.length == n
days.length == n
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立

核心思路就是每次都吃最快腐烂的苹果 按照苹果的腐烂时间给苹果排序 需要用到优先队列
首先用实现一个优先队列的插入方法 核心思想二分法就可以
然后将苹果按照过期时间排序 并记录苹果的数量
苹果吃完了 就将队列第一项删除 或者腐烂了也需要删除
直到所有的苹果都遍历完了并且优先队列也空了

```
/**
 * @param {number[]} apples
 * @param {number[]} days
 * @return {number}
 */
var eatenApples = function(apples, days) {
    let count=0;
    let rest=0;
    let temp=0;  //每天长出后有效个苹果
    let max_day=0;

    for (let i=0;i<apples.length;i++){
        if (apples[i]>0) {
            temp=apples[i]>days[i] ? days[i]+1 : apples[i];  //
            apples[i]=temp;
        }
    }
    return apples;
    //return count;
};

let str1 = [1,2,3,5,2];
let str2=[3,2,1,4,2];
let result=eatenApples(str1,str2);
console.log(result);

```

## 1995. 统计特殊四元组

给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：

nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d

提示：
4 <= nums.length <= 50
1 <= nums[i] <= 100

直接枚举

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var countQuadruplets = function(nums) {
    let count=0;
    if (nums[0]+nums[1]+nums[2]===nums[3]) {count+=1;}
    for(let d=4;d<nums.length;d++){
        //1 <= nums[i] <= 100
        for(let a=0;a<=d-3;a++){
            if (nums[a]>=nums[d]) {
                continue
            }
            for(let b=a+1;b<=d-2;b++){
                if (nums[a]+nums[b]>=nums[d]) {
                    continue
                }
                for(let c=b+1;c<=d-1;c++){
                    if (nums[a]+nums[b]+nums[c]===nums[d]) {
                        console.log(a,b,c,d);
                        count+=1;
                    }
                }
            }
        }
    }
    return count;
};


let str1= [56,50,33,1,86,80,85,42,90];
let result=countQuadruplets(str1);
console.log(result);

```

使用哈希表存储 nums[d]

```

```



## 2022. 将一维数组转变成二维数组

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

提示：

1 <= original.length <= 5 * 104
1 <= original[i] <= 105
1 <= m, n <= 4 * 104

```js
/**
 * @param {number[]} original
 * @param {number} m
 * @param {number} n
 * @return {number[][]}
 */
var construct2DArray = function(original, m, n) {
	if (original.length!==m*n) {
		return [];
	}
	let newArr=[];
	for (let i=0;i<m;i++){
		newArr.push(original.slice(i*n,(i+1)*n));
	}
	return newArr;
};

let str1=[1,2,3,4];
let result=construct2DArray(str1,2,2);
console.log(result);
```

