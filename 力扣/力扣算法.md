

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum =function(nums,target){
    len_nums=nums.length;
    for (let i=0; i<len_nums-1; i++){
        for (let j=i+1; j<len_nums; j++){
            if (nums[i]+nums[j]==target) {
                return [i,j];
            }
        }
    }
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=twoSum(str1,6);
//console.log(typeof result);
console.log(result);
```



## 2.两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let temp=0;
    let head=l1;

    while (l1.next){
        if (l2.next) {
            temp+=l1.val+l2.val;
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
            l2=l2.next;
        }else{
            temp+=l1.val+l2.val;
            l2.val=0;  //
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
        }
    }

    while(l2.next){
        temp+=l1.val+l2.val;
        l1.val=temp%10;
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=0;
        temp=Math.floor(temp/10);
        l2=l2.next;
    }
    temp+=l1.val+l2.val;
    l1.val=temp%10;
    temp=Math.floor(temp/10);
    if (temp===1) {
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=1;
    }
    return head;

};
```

链表连接可以优化代码



## 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**提示：**

- `0 <= s.length <= 5 * 104`

- `s` 由英文字母、数字、符号和空格组成

- **例 1:**

  ```
  输入: s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s==="") {return 0;}
    let maxLen=1;
    let flag;
    let count=1;
    let newArr=[];  //存储子串数组
    for (let i=0;i<s.length;i++){
        newArr.push(s[i]);
        flag=true;
        for (let j=i+1;j<s.length;j++){
            if (newArr.includes(s[j])) {
                //当子串数组中已有时
                maxLen=count>maxLen ? count : maxLen;
                flag=false;
                count=1;
                newArr=[];
                break;
            }else{
                newArr.push(s[j]);
                count++;
            }
        }
        if (flag) {
            maxLen=count>maxLen ? count : maxLen;
            break;
        }
    }
    return maxLen;
};


let str1 = "heflfdddswertllo";
let result=lengthOfLongestSubstring(str1);
console.log(result);
```



## 4. 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    let newArr=new Array();
    //双指针
    let i=0;
    let j=0;
    while(i<nums1.length && j<nums2.length){
        if (nums1[i]<=nums2[j]) {
            newArr.push(nums1[i]);
            i++;
        }
        if (nums2[j]<=nums1[i]) {
            console.log(nums2[j]);
            newArr.push(nums2[j]);
            j++;
        }
    }

    while (i<nums1.length){
        newArr.push(nums1[i]);
        i++;
    }
    while(j<nums2.length){
        newArr.push(nums2[j]);
        j++;
    }
    //return newArr;
    let n=nums1.length+nums2.length;
    if (n%2===0) {
        return parseFloat((newArr[n/2]+newArr[n/2-1])/2);
    }else{
        return parseFloat(newArr[Math.floor(n/2)]);
    }
    console.log(newArr);
};


let str1 = [1,2];
let str2=[3,4];
let result=findMedianSortedArrays(str1,str2);
console.log(result);
```

## 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if (s.length===1) {return 1;}
    let maxLen=s.length;
    let flag1=false;
    let flag2=false;
    let newArr=[];  //
    //从最长到最短判断
    for (let i=0;i<s.length;i++){
        for (let j=i;j<s.length;i++){
            if (s[j]!===s[s.length-1-j]) {

                flag1=true;
                break;
            }
        }
        for (let j=i;j<s.length;i++){
            if (s[i]!===s[s.length-1-i]) {
                flag1=true;
                break;
            }
        }
    }
    return maxLen;
};


let str1 = "babad";
let str2=[3,4];
let result=longestPalindrome(str1);
console.log(result);
```

## 6.Z 字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P    A    H   N
A P L S I  I G
Y    I     R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`

```
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows===1) {return s;}
    
    return newStr;
};

let str1 = "basanaadsfenafdrrgeana";
let result=convert(str1);
console.log(result);
```

## 7. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

```java
import java.util.*;

class Solution {
	public int reverse(int x) {
		if (x>-10 && x<10) return x;
		long result=0;
		while(x!=0){
			result=result*10+x%10;
			x=x/10;
		}
		//检测是否溢出，溢出则返回0
		return (int) result==result ? (int) result :0;
	}
}


public class TestOperateString{
	public static void main(String[] args) {

		//int[] testnums={1,2,3,4,5,6,7,8,9,10};
		//char[] testStr={'h','e','l','l','o','b'};

		int n=-136469;

		Solution mysolution=new Solution();
		//mysolution.reverseString(testStr);
		int result=mysolution.reverse(n);
		System.out.println(result);
		//System.out.println(Arrays.toString(testStr));
	}
}
```

注意检查是否溢出

## 8. 字符串转换整数 (atoi)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

```js
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    s=s.trim();
    let patt=/[^0-9+-]/
    if (patt.test(s[0])) {
        return 0;
    }
    let nums=new Array();
    nums.push(s[0]);
    for (let i=1;i<s.length;i++){
        if (/\D/.test(s[i])) {
            //查找到非数字停止
            break;
        }else{
            nums.push(s[i]);
        }
    }

    let num=nums.join("");
    if (num==="+" || num==="-") {return 0;}
    num=parseInt(num);
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "+-12";
let result=myAtoi(str1);
console.log(result);

```

直接调用内置函数

```js
var myAtoi = function(s) {
    s=s.trim();
    let num=parseInt(s);
    if (isNaN(num)) {
        return 0;
    }
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "words and 987";
let result=myAtoi(str1);
console.log(result);
```

### 

## 9.回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

提示：
-231 <= x <= 231 - 1

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x<0) {
        return false;
    }
    x=x.toString();

    for (let i=0;i<x.length/2;i++){
        if (x[i]!==x[x.length-1-i]) {
            return false;
        }
    }
    return true;
};

let str1 = -121;
let result=isPalindrome(str1);
console.log(result);

```

## 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符

直接调用正则方法

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    return new RegExp("^"+p+"$").test(s);
};
```

动态规划

```
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    //动态规划 dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
    let lenS=s.length;
    let lenP=p.length;

    let dp=new Array(lenS+1);

    for (let i=0;i<dp.length;i++){
        //先构造dp[][]数组，将其每一项初始化为false
        dp[i]=new Array(lenP+1).fill(false);

    }
    //base case
    dp[0][0] = true; // s为空、p为空 两者都是空串的时候 可匹配

    //s不为空 p为空，必为false(dp数组默认值为false，无需处理)

    /*//s为空，p不为空(dp[0][]) 由于*可以匹配0个字符，所以有可能为true 
    要进行处理（看看有无*来挽救） 注意 dp[0][j] 当j=1时，表示p的前1个字符
    自然是p[j-1]呢，p的下标是从0开始*/
    for (let j=1;j<lenP;j++){
        if (p[j-1]==="*") {
            dp[0][j]=dp[0][j-2];
        }
    }

    // 迭代 状态转移
    for (let i=1;i<=lenS;i++){
        for (let j=1;j<lenP;j++){
            if (s[i-1]===p[j-1] || p[j-1]===".") {
                //最好简单情况 到这里 s、p 可以直接匹配
                dp[i][j]=dp[i-1][j-1];
            }else if(p[j-1]==="*"){
                //不满足直接对应相等，但 p这个字符是 ‘*’ 的话 仔细考虑
                if (s[i-1]===p[j-2] || p[j-2]===".") {
                    //s当前字符 可匹配上 p前一个字符
                    ////*匹配0次的情况 ｜｜ *匹配1次或多次的情况 
                    dp[i][j]=dp[i][j-2]  || dp[i-1][j];
                }else if(s[i-1]!==p[j-2]){
                    //s当前字符 无法匹配上 p前一个字符，只能是 *匹配0次的情况
                    dp[i][j]=dp[i][j-2];
                }
            }
        }
    }

    return dp[lenS][lenP];
};

let str1 = "mississippi";
let str2="mis*is*p*.";
let result=isMatch(str1,str2);
console.log(result);

```

## 13. 罗马数字转整数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 IV (4) 和 IX  (9)。
X 可以放在 L (50) 和 C (100) 的左边，来表示 XL 40 和 XC90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 CD 400 和 CM 900。
给定一个罗马数字，将其转换成整数。

提示：

1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {

	let romanObj={I:1,V:5,X:10,L:50,C:100,D:500,M:1000};
	let sum=0;

	let i=0;
	while(s.length>0){
		if (s.length===1) {
			sum+=romanObj[s[0]];
			break;
		}
		if (s[0]=="I") {
			if (s[1]==="V") {
				sum+=4;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="X") {
				sum+=9;
				s=s.slice(2);
				continue;
			}
			sum+=1;
			s=s.slice(1);
			continue;
		}else if(s[0]=="X") {
			if (s[1]==="L") {
				sum+=40;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="C") {
				sum+=90;
				s=s.slice(2);
				continue;
			}
			sum+=10;
			s=s.slice(1);
			continue;
		}else if(s[0]=="C") {
			if (s[1]==="D") {
				sum+=400;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="M") {
				sum+=900;
				s=s.slice(2);
				continue;
			}
			sum+=100;
			s=s.slice(1);
			continue;
		}
		sum+=romanObj[s[0]];
		s=s.slice(1);
	}
	return sum;
};

let str1="MCMXCIV";
let result=romanToInt(str1);
console.log(result);
```

## 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length===1) {return strs[0];}
    let minLen=strs[0].length;
    for (let i=0;i<strs.length;i++){
        if (strs[i].length===0) {
            return "";
        }
        if (strs[i].length<minLen) {
            minLen=strs[i].length;
        }
    }
    let alphas=new Array("");
    for (let i=0;i<minLen;i++){
        for (let j=1;j<strs.length;j++){
            if (strs[j][i]!=strs[0][i]) {
                return alphas.join("");
            }
        }
        alphas.push(strs[0][i]);
    }
    return alphas.join("");
};


let str1 = ["flower","flow","flight"];
let result=longestCommonPrefix(str1);
//console.log(typeof result);
console.log(result);

```

利用数组的 Reduce 方法实现的最简洁代码

取第一个字符串为公共前缀
逐个对比，返回两两元素的公共前缀
将 2 中的公共前缀和下一个元素对比，得到新的公共前缀

## 15. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
提示：

0 <= nums.length <= 3000
-105 <= nums[i] <= 105

繁琐的思路，需要简化代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
	if (nums.length<3) {
		return [];
	}

	if (nums.length===3) {
		if (nums[0]+nums[1]+nums[2]===0) {
			return [[...nums]];
		}else{
			return[]
		}
	}

	let newArr=[];

	const positiveInterger=[];
	const negativeInterger=[];
	const zeros=[];

	nums.sort((a,b)=>a-b);
	let count=0;
	let temp=nums[0];
	//非零相同值最多需要留两个就可
	for (let i=0;i<nums.length;i++){
		//这里可用indexOf与lastIndexOf处理
		if (nums[i]!==temp) {
			temp=nums[i];
			count=1;
			if (nums[i]<0) {
				negativeInterger.push(nums[i]);
			}else if(nums[i]>0){
				positiveInterger.push(nums[i]);
			}else{
				zeros.push(0);
			}
		}else{
			if (nums[i]!==0) {
				if (count<2) {
					count+=1
					if (nums[i]<0) {
						negativeInterger.push(nums[i]);
					}else{
						positiveInterger.push(nums[i]);
					}
				}
			}else{
				zeros.push(0);
			}
		}
	}
	if (zeros.length!==0) {
		//有0时把0作为负数处理
		negativeInterger.push(0);
		//正数则为
		//positiveInterger.unshift(0);
	}
	if (zeros.length>2) {
		newArr.push([0,0,0]);
	}

	//console.log(positiveInterger);
	//console.log(negativeInterger);

	//需要匹配最大正数索引边界，动态变化
	let maxPositiveIndex=positiveInterger.length-1;
	//最大负数和
	let maxSum1;
	for (let i=0;i<negativeInterger.length-1;i++){
		//两负一正时
		if (maxPositiveIndex===-1) {
			//当正整数遍历完时，退出
			break;
		}
		if (i>0) {
			if (negativeInterger[i]===negativeInterger[i-1]) {
				continue;
			}
		}
		maxSum1=-(negativeInterger[i]+negativeInterger[i+1]);
		if (positiveInterger[maxPositiveIndex]>maxSum1) {
			maxPositiveIndex--;
		}
		for (let j=i+1;j<negativeInterger.length;j++){
			//计算两个负数和后取绝对值
			if (maxPositiveIndex===-1) {
				//当正整数遍历完时，退出
				break;
			}
			if (negativeInterger[j]===negativeInterger[j+1]) {
				continue;
			}
			let NegativeSum=-(negativeInterger[i]+negativeInterger[j]);
			//去找是否有相等的值
			for (let k=maxPositiveIndex;k>=0;k--){
				//因为是排好序的
				if (positiveInterger[k]<NegativeSum) {
					//如果小于则不存在，退出
					break;
				}
				if(positiveInterger[k]===NegativeSum) {
					//如果相等
					newArr.push([negativeInterger[i],negativeInterger[j],positiveInterger[k]]);
					break;
				}
				//如果大于就往前找
			}
		}
		if (positiveInterger[maxPositiveIndex]===maxSum1) {
			maxPositiveIndex--;
		}
	}

    //需要匹配最大负数索引边界，动态变化
    let maxNegativeIndex=negativeInterger.length-1;
    //最小正数和
	let maxSum2;
    for (let i=0;i<positiveInterger.length-1;i++){
        //两正一负时
        if (maxNegativeIndex===-1) {
            //当正整数遍历完时，退出
            break;
        }
        if (i>0) {
        	if (positiveInterger[i]===positiveInterger[i-1]) {
        		continue;
        	}
        }
        maxSum2=-(positiveInterger[i]+positiveInterger[i+1]);
        if (negativeInterger>maxSum2) {
        	maxNegativeIndex--;
        }

        for (let j=i+1;j<positiveInterger.length;j++){
            //计算两个负数和后取绝对值
            if (maxNegativeIndex===-1) {
                //当正整数遍历完时，退出
                break;
            }
            if (positiveInterger[j]===positiveInterger[j+1]) {
            	continue;
            }
            let PositiveSum=-(positiveInterger[i]+positiveInterger[j]);
            //去找是否有相等的值
            for (let k=maxNegativeIndex;k>=0;k--){
                //因为是排好序的
                if (negativeInterger[k]<PositiveSum) {
                    //如果小于则不存在，退出
                    break;
                }
                if(negativeInterger[k]===PositiveSum){
                    //如果相等
                    newArr.push([positiveInterger[i],positiveInterger[j],negativeInterger[k]]);
                    break;
                }
                //如果大于，则往前查找，最大正数索引边界减一
            }
        }
        if (negativeInterger===maxSum2) {
        	//移动最大位，可以避免重复
        	maxNegativeIndex--;
        }
    }

	return newArr;
};

let str1=[-1,0,1,2,-1,-4,-2,-3,3,0,4];
let result=threeSum(str1);
console.log(result);
```

简化，直接使用双指针

```

```

## 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

栈实现

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if (s.length%2!==0) {
        return false;
    }
    let leftBrackets=["(","[","{"];
    let rightBrackets=[")","]","}"];

    let stack=[];
    for (let i=0;i<s.length;i++){
        //是否是右括号
        let index=rightBrackets.indexOf(s[i]);
        if (index!==-1) {
            //是右括号
            if (stack.length===0) {
                //如果栈为空，则不合法
                return false;
            }
            //则去看栈顶是否相匹配
            if (stack[stack.length-1]===leftBrackets[index]){
                //如果匹配，则出栈
                stack.pop();
            }else{
                //不匹配，则进栈
                stack.push(s[i]);
            }
        }else{
            //是左括号则直接进栈
            stack.push(s[i]);
        }
        //console.log(stack);
    }
    if (stack.length===0) {
        return true;
    }else{
        return false;
    }
};

let str1 = "{[{{[{}]}[({[]})]}]}";
let result=isValid(str1);
console.log(result);
```

## 21.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列

方法一：递归
思路

我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：

list1[0]+merge(list1[1:],list2)    ,list1[0]<list2[0]
list2[0]+merge(list1,list2[1:])    ,otherwise

也就是说，**两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并**。

算法

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```js
var mergeTwoLists = function(list1, list2) {
    //如果一个为空，则直接返回另一个
    if (list1===null) {
        return list2
    }else if (list2===null) {
        return list1;
    }else if(list1.val<list2.val){
        list1.next=mergeTwoLists(list1.next,list2);
        return list1;
    }else{
        list2.next=mergeTwoLists(list1,list2.next);
        return list2;
    }
};
```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。
- 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。

方法二：迭代
思路

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

算法

首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

**在循环终止的时候， l1 和 l2 至多有一个是非空的**。由于输入的两个链表都是有序的，**所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大**。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

var mergeTwoLists = function(list1, list2) {
    const head=new ListNode();
    let list3=head;
    while(list1!=null && list2!=null){
        if (list1.val<list2.val) {
            list3.next=list1;
            list1=list1.next;
        }else{
            list3.next=list2;
            list2=list2.next;
        }
        list3=list3.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    list3.next=list1===null ? list2:list1;
    //注意返回的是什么
    return head.next;
};

let str1 = [-9,3];
let str2=[5,7];
let list1=new ListNode();
let list2=new ListNode();
let head1=list1;
let head2=list2;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
for (let i=0;i<str2.length;i++){
    list2.val=str2[i];
    list2.next=new ListNode();
    list2=list2.next;
}
//console.log(head2);

let result=mergeTwoLists(head1,head2);
console.log(result);


```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

- 空间复杂度：O(1)。我们只需要常数的空间存放若干变量。

```

```

## 26.删除有序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

提示：

0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let start=0;
    while(start<nums.length){
        if (nums[start]===nums[start+1]) {
            //删除重复中的后一个
            nums.splice(start+1,1);
        }else{
            start++;
        }
    }
    console.log(nums);
    return nums.length;
};


let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeDuplicates(test);
console.log(result);
```

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\双指针删除排序数组中的重复项.png)

```js
var removeDuplicates = function(nums) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let fast = 1, slow = 1;
    while (fast < n) {
        if (nums[fast] !== nums[fast - 1]) {
            //如果不同，则赋值给前面的重复位或当前位
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
};
```

**把不相同的用来覆盖前面相同的，不涉及删除消耗相对较小**

复杂度分析

- 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。


- 空间复杂度：O(1)。只需要使用常数的额外空间。


## 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let flag=0;
    let count=0;
    while (flag < n-count) {
        if (nums[flag]===val) {
            //如果匹配则把后面的值赋值到这里判断
            //只需移动元素匹配次数
            nums[flag]=nums[n-1-count];
            count++;
        }else{
            flag++;
        }
    }
    console.log(nums);
    return flag;
};

let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeElement(test,2);
console.log(result);
```

![移除元素双指针](E:\pogject\学习笔记\image\leetcode\移除元素双指针.png)

## 28. 实现 strStr()

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

![方法一：暴力匹配strStr](E:\pogject\学习笔记\image\leetcode\方法一：暴力匹配strStr.png)

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (haystack.length<needle.length) {return -1;}
    if (needle==="") {return 0;}
    if (haystack.length===needle.length && haystack===needle) {return 0;}
    if (haystack.length===needle.length && haystack!==needle) {return -1;}
    for (let i=0;i<haystack.length-needle.length+1;i++){
        if (haystack[i]===needle[0]) {
            let flag=true;
            for (let j=1;j<needle.length;j++){
                if (haystack[i+j]!==needle[j]){
                    flag=false;
                    break;
                }
            }
            if (flag) {
                return i;
            }

        }
    }
    return -1;
};


let str1 = "heffdddllo";
let str2 = "ell";
let result=strStr(str1,str2);
console.log(result);

```

调用内置方法

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle);
};
```

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr.png)

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr2.png)

```js
var strStr=function(haystack,needle){
    const n=haystack.length,m=needle.length;
    if (m===0) {
        return 0;
    }

    const pi=new Array(m).fill(0);

    //needle部分的前缀函数
    for (let i=1,j=0;i<m;i++){
        while (j>0 && needle[i]!=needle[j]){
            j=pi[j-1];
        }
        if (needle[i]===needle[j]) {
            j++;
        }
        pi[i]=j;
    }

    //求 haystack 部分的前缀函数
    for (let i=0,j=0;i<n;i++){
        while(j>0 && haystack[i]!=needle[j]){
            j=pi[j-1];
        }
        if (haystack[i]==needle[j]) {
            j++;
        }
        if (j===m) {
            return i-m+1;
        }
    }
    return -1;
};

```

## 29.两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

提示：

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。

暴力解法，连减计数,会超时

```

```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除二分查找.png)



```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //二分查找
    let left=1;
    let right=MAX_VALUE;
    let ans=0;
    while(left<=right){
        //注意溢出，并且不能使用除法
        const mid=left+((right-left)>>1);
        const check=quickAdd(divisor,mid,dividend);
        if (check) {
            ans=mid;
            // 注意溢出
            if (mid===MAX_VALUE) {
                break;
            }
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return rev ? -ans : ans;
};

// 快速乘
const quickAdd=(y,z,x)=>{
    // x 和 y 是负数，z 是正数
    // 需要判断 z * y >= x 是否成立
    let result=0;
    let add=y;
    while(z!==0){
        if ((z&1)!==0) {
            //需要保证 result + add >= x
            if (result<x-add) {
                return false;
            }
            result+=add;
        }
        if (z!==1) {
            //需要保证 add + add >= x
            if (add<x-add) {
                return false;
            }
            add+=add;
        }
        // 不能使用除法
        z>>=1;
    }
    return true;
};

let str1 = 10;
let str2 = 3;
let result=divide(str1,str2);
console.log(result);
```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除类二分查找.png)

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用类二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //类二分查找
    const candidates=[divisor];
    let index=0;
    //注意溢出
    while(candidates[index]>=dividend-candidates[index]){
        //处理的都是负数
        candidates.push(candidates[index]+candidates[index]);
        index++;
    }
    //console.log(candidates);
    let ans=0;
    console.log(ans,dividend);
    for (let i=candidates.length-1;i>=0;--i){
        if (candidates[i]>=dividend) {
            ans+=1<<i;
            dividend-=candidates[i];
            console.log(ans,dividend);
        }
    }
    return rev ? -ans : ans;
};


let str1 = 10000;
let str2 = 33;
let result=divide(str1,str2);
console.log(result);
```

## 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。
提示:

1 <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4
nums 为无重复元素的升序排列数组
-10^4 <= target <= 10^4

二分查找

因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=Math.floor((right+left)/2);
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=Math.floor((right+left)/2);
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=Math.floor((right+left)/2);
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=(right+left)>>1;
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=(right+left)>>1;
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=(right+left)>>1;
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};


let test = [1,2,3,5,6,7,20,100,289,328];
let result=searchInsert(test,1);
console.log(result);
```

## 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

![最大子数组和动态规划](E:\pogject\学习笔记\image\leetcode\最大子数组和动态规划.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    //只有一个元素直接返回
    if (nums.length===1) { return nums[0]; }

    //动态规划
    let pre=0;
    let maxSum=nums[0];
    nums.forEach((x)=>{
        pre=Math.max(pre+x,x);
        maxSum=Math.max(maxSum,pre);
    });
    //console.log(nums);
    return maxSum;
};

let test = [-2,1,-3,4,-1,2,1,-5,4];
let result=maxSubArray(test,1);
console.log(result);
```

**方法二：分治**



## 58. 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

提示：

1 <= s.length <= 104
s 仅有英文字母和空格 ' ' 组成
s 中至少存在一个单词

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        //反向遍历
        if(s[i]!==" "){
            count++;
        }else{
            //如果前面是字母，则这里单词就结束
            if (count>0) {
                return count;
            }
        }
    }
    return count;
};

let test = "   fly me   to   the moon  ";
let result=lengthOfLastWord(test);
console.log(result);
```

## 66. 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    digits[digits.length-1]+=1;
    for (let i=digits.length-1;i>0;i--){
        if (digits[i]<10){
            break;
        }else{
             digits[i]=0;
             digits[i-1]+=1;
        }
    }
    if (digits[0]===10) {
        digits[0]=1;
        digits[digits.length]=0;
    }
    return digits;
};
```

## 67. 二进制求和

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。
示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"


提示：

每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    if (a.length<b.length) {
        //交换变量的值,解构赋值
        [a,b]=[b,a];
    }
    let result=[];
    let temp=0;
    for(let i=0;i<b.length;i++){
        //先遍历短的一个
        temp+=Number(a[a.length-1-i])+Number(b[b.length-1-i])
        result.unshift((temp%2).toString());
        temp=temp>1 ? 1 : 0;
    }

    for(let j=a.length-b.length-1;j>=0;j--){
        //继续遍历长的一个剩余的位
        if (temp===1) {
            temp+=Number(a[j]);
            result.unshift((temp%2).toString());
            temp=temp>1 ? 1 : 0;
        }else{
            result.unshift(a[j]);
        }
    }
    if (temp===1) {
        //最后是否需要进位
        result.unshift("1")
    }
    return result.join("");
};

let test = "100";
let result=addBinary(test,"110010");
console.log(result);
```

考虑一个最朴素的方法：先将 a和 b转化成十进制数，求和后再转化为二进制数。

方法二：位运算

## 69. Sqrt(x)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
提示：

0 <= x <= 2^31 - 1

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    if (x<2) {
        return x;
    }
    //因为只需要整数部分，所以只需要找到平方小于等于x的的最接近的一个整数
    let left=1;
    let right=x>>1;
    let middle=(left+right)>>1;
    //二分查找
    while(left<=right){
        //注意溢出
        if (middle*middle>x) {
            right=middle-1;
        }else if (middle*middle<x) {
            left=middle+1;
        }else{
            return middle;
        }
        middle=(left+right)>>1;
    }
    return middle;
};

let test = 3;
let result=mySqrt(test);
console.log(result);
```



## 208. 实现 Trie (前缀树)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次

```js
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @return {boolean}
 */
 //搜索
Trie.prototype.search = function(word) {
    let node=this.startsWith(word);
    //若搜索到了前缀的末尾，就说明字典树中存在该前缀。
    //此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。
    return node!==undefined && node.isEnd!==undefined;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
//查找前缀
Trie.prototype.startsWith = function(prefix) {
    let node=this.children;
    for (let ch of prefix){
        //子节点不存在。说明字典树中不包含该前缀，返回空指针
        if (!node[ch]) {
            return false;
        }
        //子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
        node=node[ch];
    }
    return node;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

let test=new Trie();

test.insert("apple");
result=test.search("apple");
console.log(result);  //true

result=test.search("app");
console.log(result);  //false

result=test.startsWith("app");
console.log(result);  //

test.insert("app");
result=test.search("app");
console.log(result);  //
```

## 390. 消除游戏

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

- 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。

- 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。

- 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。

给你整数 n ，返回 arr 最后剩下的数字。

提示：

1 <= n <= 10^9

直接遍历数组删除会超时

**方法一：等差数列模拟**

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\消除游戏等差数列模拟.png)

```js
/**
 * @param {number} n
 * @return {number}
 */
var lastRemaining = function(n) {
    let a1=1;
    //删除次数k,元素数目为cnt,首元素a1,末尾元素an,公差step
    let k=0,cnt=n,step=1;
    while(cnt>1){
        if (k%2===0) {
            // 正向
            a1=a1+step;
        }else{
            //反向，得考虑奇数个或偶数个
            a1=(cnt%2===0) ? a1 : a1+step;
        }
        k++;
        //有符号右移由两个大于号（>>）表示
        cnt=cnt>>1;
        //左移操作符用两个小于号（<<）表示
        step=step<<1;
    }
    
    return a1;
};


console.log(lastRemaining(50));

```

复杂度分析

- 时间复杂度：O(log n)，其中 n 为初始整数列表的元素数目。每次删除都会将元素数目减半，所以时间复杂度为 O(logn)。


- 空间复杂度：O(1)。只需要使用常数的额外空间。


## 472. 连接词

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

提示：

1 <= words.length <= 104
0 <= words[i].length <= 1000
words[i] 仅由小写字母组成
0 <= sum(words[i].length) <= 105

方法一：字典树 + 深度优先搜索
判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。

1. 为了方便处理，首先将数组 words 按照字符串的长度递增的顺序排序，排序后可以确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。
2. 在将数组 words 排序之后，遍历数组，跳过空字符串，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入结果数组，如果不是连接词则将该单词加入字典树。
3. 判断一个单词是不是连接词的做法是在字典树中深度优先搜索。从该单词的第一个字符（即下标 00处的字符）开始，在字典树中依次搜索每个字符对应的结点，可能有以下几种情况：

- 如果一个字符对应的结点是单词的结尾，则找到了一个更短的单词，从该字符的后一个字符开始搜索下一个更短的单词；
- **如果一个字符对应的结点在字典树中不存在，则当前的搜索结果失败，回到上一个单词的结尾继续搜索。**

如果找到一个更短的单词且这个更短的单词的最后一个字符是当前单词的最后一个字符，则当前单词是连接词。由于数组 words 中没有重复的单词，因此在判断一个单词是不是连接词时，该单词一定没有加入字典树，由此可以确保判断连接词的条件成立。

由于一个连接词由多个更短的非空单词组成，如果存在一个较长的连接词的组成部分之一是一个较短的连接词，则一定可以将这个较短的连接词换成多个更短的非空单词，因此不需要将连接词加入字典树。

```
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @param {start} int 单词开始索引位置
 * @return {boolean}
 */
 //查找一个词从索引开始后的连续部分是否已存在
Trie.prototype.dfs = function(word,start) {
    let node=this.children;
    for (let i=start;i<word.length;i++){
        node=node[word[i]];
        //深度优先遍历
        if (node!==undefined) {
            if (node.isEnd!==undefined) {
                return i+1;
            }else{
                continue;
            }
        }
        node=node[word[i]];
        if (!node) {
            //得考虑这个单词不行可能那个单词行,carbat比如cat与car
            return false;
        }
        
        if (node && i===word.length-1){
            return i+1;
        }
    }
};



/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const trie=new Trie();

    trie.insert(words[0]);
    trie.insert(words[1]);
    //console.log(trie);
   
    for (let i=2;i<words.length;i++){
        let word=words[i];
        let start;
        let count=0;
        for(start=0;start<word.length;){
            let index=trie.dfs(word,start);
            if (index===false) {
                trie.insert(word);
                break;
            }else{
                if (index<word.length) {
                    start=index;
                    count++;
                }else{
                    if (count>1) {
                        result.push(word);
                    }
                }
            }
        }

    }
    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```

```

//插入字符串
function insertWord(dictTree,word) {
    let node=dictTree;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

//检查单词是否是连接词
function checkWord(dictTree,word,start){
    
    let node=dictTree;
    let count=0;  //计数找到多少个更短的单词
    let i; //i为要检查单词开始的索引
    let tempNode=[];  //记录一个路径上是单词的尾结点
    let tempIndex=[];  //记录一个路径上尾结点对应的索引
    for(i=0;i<word.length;){
        if (node[word[i]]===undefined && count<1) {
            //如果一个短的单词都没有找到，则不是连接词
            return false;
        }
        if (node[word[i]]===undefined){
            //当已经找到一个更短的单词时，字母在该路径不存在
            if (count>0) {
                //当尾结点数大于终末尾结点数时,则可以退回到上一次尾结点
                if (tempNode.length>count){
                    
                }
            }
        }else{
            //当一个字母在该路径存在
            node=node[word[i]];
            if (node.isEnd!==undefined) {
                //node是一个单词的尾结点
                tempNode.push(node);  //记录索引和结点指针
                tempIndex.push(i);
                //如果路径上还有结点,继续深度搜索
                if (node[word[i+1]]===undefined) {
                    //当是尾结点且后面不匹配
                    count+=1;
                    //从当前位置开始匹配下一份更短单词
                    node=dictTree;
                }
            }
            i++;
        }

    }
    return true;
}

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const dictTree={};

    insertWord(dictTree,words[0]);
    insertWord(dictTree,words[1]);
    //console.log(dictTree);
   
   for (let i=2;i<words.length;i++){
        let word=words[i];
        if (dictTree[word[0]]===undefined) {
            //因为单词是从短到长排序的
            //如果单词的第一个字母不在字典树的开始，则一定不是连接词，插入
            insertWord(dictTree,word);
            continue;  //跳过余下检查
        }

        let isConcatWord=checkWord(dictTree,word)
        if (isConcatWord) {
            //如果是连接词
            result.push(word);
        }else{
            //不是则插入
            insertWord(dictTree,word)
        }
    }

    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```



## 507. 完美数

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function(num) {
	if (num===1) {return false;}
	let sum=1;
	for (let i=2;i<=Math.sqrt(num);i++){
		if (i===Math.sqrt(num)) {
			sum+=Math.sqrt(num)
		}else{
			if (num%i===0) {
				sum+=i+num/i;
			}
		}
	}
	if (num===sum) {
		return true;
	}else{
		return false;
	}
}

let str1=121;
let result=checkPerfectNumber(str1);
console.log(result);
```



## 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

示例 1：

输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var repeatedStringMatch = function(a, b) {
    //首先只要b中有字母不在a中,则不可能b为a的子串
    let len_a=a.length;
    let len_b=b.length;

    let set=new Set();
    for (let i=0;i<len_a;i++){
        set.add(a[i]);
    }
    for (let i=0;i<len_b;i++){
        if (!set.has(b[i])) {
            return -1;
        }
    }
    let newStr=a;
    //判断b与a的长度，a当重复后长度最多超过b长度的2倍，如果2倍长度没有找到则返回-1
    let n=len_b%len_a===0 ? len_b/len_a : Math.floor(len_b/len_a)+1;
    if (len_a>=len_b) {
        //当a长时，返回值最多为2
        if (newStr.indexOf(b)!==-1) {
            return 1;
        }else{
            newStr+=a;
            if (newStr.indexOf(b)!==-1) {
                return 2;
            }else{
                return -1;
            }
        }
    }else{
        //当b长时，a长度最多增加到b的2倍
        for (let i=0;i<n-1;i++){
            newStr+=a;
        }
        while (newStr.length<2*len_b){
            if (newStr.indexOf(b)!==-1) {
                return n;
            }else{
                newStr+=a;
                n++;
            }
        }
        if (newStr.indexOf(b)!==-1) {
            return n;
        }else{
            return -1;
        }
        
    }
    return 0;
};


let str1 = "abc";
let str2="cabcabca";

let result=repeatedStringMatch(str1,str2);
console.log(result);
```

## 825. 适龄的朋友

在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：

age[y] <= 0.5 * age[x] + 7
age[y] > age[x]
age[y] > 100 && age[x] < 100
否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

- `n == ages.length`
- `1 <= n <= 2 * 104`
- `1 <= ages[i] <= 120`

```js
/**
 * @param {number[]} ages
 * @return {number}
 */
var numFriendRequests = function(ages) {
    if (ages.length===1) {return 0;}
    let count=0;
    ages.sort((a,b)=>b-a);  //从大到小排序
    let flag=0;  //移动指针
    for (let i=0;i<ages.length;i++){
        for (let j=flag;j<ages.length;j++){
            if (i!==j) {
                if (ages[j]>ages[i]*0.5+7) {
                    count++;
                    //console.log(ages[i]+"->"+ages[j]);
                }else{
                    break;
                }
            }
        }
        //age变化则移动指针
        if (ages[i]>ages[i+1]) {
            //console.log(ages[flag]);
            flag=i+1;
        }
    }
    return count;
};

let str1 = [30,100,110,120,20];
let result=numFriendRequests(str1);
console.log(result);

```



## 846. 一手顺子

Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。

给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。

提示：

1 <= hand.length <= 104
0 <= hand[i] <= 109
1 <= groupSize <= hand.length

示例 1：

输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
示例 2：

输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。

```js
/**
 * @param {number[]} hand
 * @param {number} groupSize
 * @return {boolean}
 */
var isNStraightHand = function(hand, groupSize) {
    if (hand.length%groupSize!==0) {
        //当不能整除则不能排列为相同size的
        return false;
    }
    if (groupSize===1) {
        //当size为1则可以
        return true;
    }
    //从小到大排序
    hand.sort((a,b)=>a-b);
    //console.log(hand.length/groupSize);
    //console.log(hand);
    let len=hand.length;  //记录初始长度

    for (let i=0;i<len/groupSize;i++){
        let temp=hand[0];  //每一次排列一定是从最小的开始
        //console.log(temp);
        hand.shift();  //删除第一张牌

        for (let j=1;j<groupSize;j++){
            //从第二张开始找就行
            let index=hand.indexOf(temp+j);
            if (index===-1) {
                //如果不存在比上一张大1的牌
                return false;
            }
            //存在则删除
            //console.log(hand[index]);
            hand.splice(index,1);

        }
        //console.log("---")
    }

    return true;
};

let hand = [9,13,15,23,22,25,16,21,18,21,24,23,10,21,16,18,16,18,5,20,19,20,10,14,26,2,9,19,12,28,17,5,7,25,22,16,17,21,11];
let groupSize = 10;

console.log(isNStraightHand(hand,groupSize));
```

## 913. 猫和老鼠

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

**老鼠从节点 1 开始**，第一个出发；**猫从节点 2 开始**，第二个出发。**在节点 0 处有一个洞**。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，**猫无法移动到洞中（节点 0**）。

然后，游戏在出现以下三种情形之一时结束：

- 如果猫和老鼠出现在同一个节点，猫获胜。
- 如果老鼠到达洞中，老鼠获胜。
- 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。

给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：

- 如果老鼠获胜，则返回 1；

- 如果猫获胜，则返回 2；
- 如果平局，则返回 0 。

提示：

3 <= graph.length <= 50
1 <= graph[i].length < graph.length
0 <= graph[i][j] < graph.length
graph[i][j] != i
graph[i] 互不相同
猫和老鼠在游戏中总是移动

![猫和老鼠动态规划1](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划1.png)

![猫和老鼠动态规划2](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划2.png)

```js
const MOUSE_WIN=1;
const CAT_WIN=2;
const DRAW=0;

/**
 * @param {number[][]} graph
 * @return {number}
 */
var catMouseGame = function(graph) {
    this.n=graph.length;
    this.graph=graph;
    this.dp=new Array(n).fill(0).map(()=>new Array(n).fill(0).map(()=>new Array(n*2).fill(-1)));
    //console.log(this.dp);
    return getResult(1,2,0);
};

const getResult=(mouse,cat,turns)=>{
    if (turns===n*2) {
        return DRAW;
    }
    if (dp[mouse][cat][turns]<0) {
        if (mouse===0) {
            dp[mouse][cat][turns]=MOUSE_WIN;
        }else if(cat===mouse){
            dp[mouse][cat][turns]=CAT_WIN;
        }else{
            getNextResult(mouse,cat,turns);
        }
    }
    return dp[mouse][cat][turns];
}

const getNextResult=(mouse,cat,turns)=>{
    const curMove=turns%2===0 ? mouse : cat;
    const defaultResult=curMove===mouse ? CAT_WIN : MOUSE_WIN;
    let result=defaultResult;
    const nextNodes=graph[curMove];
    for (let next of nextNodes){
        if (curMove===cat  && next===0) {
            continue;
        }
        const nextMouse=curMove===mouse ? next : mouse;
        const nextCat=curMove===cat ? next : cat;
        const nextResult=getResult(nextMouse,nextCat,turns+1);
        if (nextResult!==defaultResult) {
            result=nextResult;
            if (result!==DRAW) {
                break;
            }
        }
    }
    dp[mouse][cat][turns]=result;
}


let test = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]];
let result=catMouseGame(test);
console.log(result);
```



## 1044.最长重复子串

给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。

提示：

2 <= s.length <= 3 * 104
s 由小写英文字母组成

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    let strA;
    for (let k=s.length-1;k>0;k--){
        for (let i=0;i+k<s.length;i++){
            strA=s.slice(i,i+k);
            if (i!==s.lastIndexOf(strA)){
                return strA;
            }
        }
        
    }
    return "";
};

let str1 = "basanaadsfenafdrrgeana";
let result=longestDupSubstring(str1);
console.log(result);
```

超时

## 1154.  一年中的第几天

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

提示：

date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

```js
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    let y=Number(date.split("-")[0]);
    let m=Number(date.split("-")[1]);
    let d=Number(date.split("-")[2]);
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];

    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }

    let total=0;
    for (let i=0;i<m-1;i++){
        total+=monthOfDays[i]
    }
    total+=d;
    if (m>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }

    return total;
};

let str1 = "2022-01-01";

let result=dayOfYear(str1);
console.log(result);
```

**普通闰年:公历年份是4的倍数的，一般是闰年。（如2004年就是闰年）；
世纪闰年:公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是世纪闰年，2000年是世纪闰年）；**

## 1185. 一周中的第几天

给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

输入：day = 31, month = 8, year = 2019
输出："Saturday"

题目规定输入的日期一定是在 1971 到 2100 年之间的有效日期，即在 1971 年 1 月 1日，到 2100 年 12 月 31 日之间。通过查询日历可知，1970 年 12 月 31 日是星期四，我们只需要算出输入的日期距离 1970 年 12 月 31 日有几天，再加上 3 后对 7求余，即可得到输入日期是一周中的第几天。

求输入的日期距离 1970 年 12 月 31 日的天数，可以分为三部分分别计算后求和：

（1）输入年份之前的年份的天数贡献；
（2）输入年份中，输入月份之前的月份的天数贡献；
（3）输入月份中的天数贡献。

```js
var isLeap=function(y){
    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }
    return is_leap;
}

/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(year,month,day) {
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];
    let is_leap=isLeap(year);

    let total=0;
    for (let i=0;i<month-1;i++){
        total+=monthOfDays[i]
    }
    total+=day;
    if (month>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }
    return total;
};

/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    let totalDays=0;
    for(let y=1971;y<year;y++){
        totalDays+=365;
        if (isLeap(y)){
            console.log(y);
            totalDays+=1
        }
    }
    totalDays+=dayOfYear(year,month,day)+3;
    return weekdays[totalDays%7];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```

直接使用API

```js
/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    let weekDay=date.getDay();  //从 Date 对象返回一周中的某一天 (0 ~ 6)。
    return weekdays[weekDay];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```



## 1705. 吃苹果的最大数目

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

提示：

apples.length == n
days.length == n
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立

核心思路就是每次都吃最快腐烂的苹果 按照苹果的腐烂时间给苹果排序 需要用到优先队列
首先用实现一个优先队列的插入方法 核心思想二分法就可以
然后将苹果按照过期时间排序 并记录苹果的数量
苹果吃完了 就将队列第一项删除 或者腐烂了也需要删除
直到所有的苹果都遍历完了并且优先队列也空了

```
/**
 * @param {number[]} apples
 * @param {number[]} days
 * @return {number}
 */
var eatenApples = function(apples, days) {
    let count=0;
    let rest=0;
    let temp=0;  //每天长出后有效个苹果
    let max_day=0;

    for (let i=0;i<apples.length;i++){
        if (apples[i]>0) {
            temp=apples[i]>days[i] ? days[i]+1 : apples[i];  //
            apples[i]=temp;
        }
    }
    return apples;
    //return count;
};

let str1 = [1,2,3,5,2];
let str2=[3,2,1,4,2];
let result=eatenApples(str1,str2);
console.log(result);

```

## 1995. 统计特殊四元组

给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：

nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d

提示：
4 <= nums.length <= 50
1 <= nums[i] <= 100

直接枚举

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var countQuadruplets = function(nums) {
    let count=0;
    if (nums[0]+nums[1]+nums[2]===nums[3]) {count+=1;}
    for(let d=4;d<nums.length;d++){
        //1 <= nums[i] <= 100
        for(let a=0;a<=d-3;a++){
            if (nums[a]>=nums[d]) {
                continue
            }
            for(let b=a+1;b<=d-2;b++){
                if (nums[a]+nums[b]>=nums[d]) {
                    continue
                }
                for(let c=b+1;c<=d-1;c++){
                    if (nums[a]+nums[b]+nums[c]===nums[d]) {
                        console.log(a,b,c,d);
                        count+=1;
                    }
                }
            }
        }
    }
    return count;
};


let str1= [56,50,33,1,86,80,85,42,90];
let result=countQuadruplets(str1);
console.log(result);

```

使用哈希表存储 nums[d]

```

```



## 2022. 将一维数组转变成二维数组

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

提示：

1 <= original.length <= 5 * 104
1 <= original[i] <= 105
1 <= m, n <= 4 * 104

```js
/**
 * @param {number[]} original
 * @param {number} m
 * @param {number} n
 * @return {number[][]}
 */
var construct2DArray = function(original, m, n) {
	if (original.length!==m*n) {
		return [];
	}
	let newArr=[];
	for (let i=0;i<m;i++){
		newArr.push(original.slice(i*n,(i+1)*n));
	}
	return newArr;
};

let str1=[1,2,3,4];
let result=construct2DArray(str1,2,2);
console.log(result);
```

