


---
## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum =function(nums,target){
    len_nums=nums.length;
    for (let i=0; i<len_nums-1; i++){
        for (let j=i+1; j<len_nums; j++){
            if (nums[i]+nums[j]==target) {
                return [i,j];
            }
        }
    }
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=twoSum(str1,6);
//console.log(typeof result);
console.log(result);
```




---
## 2.两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let temp=0;
    let head=l1;

    while (l1.next){
        if (l2.next) {
            temp+=l1.val+l2.val;
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
            l2=l2.next;
        }else{
            temp+=l1.val+l2.val;
            l2.val=0;  //
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
        }
    }

    while(l2.next){
        temp+=l1.val+l2.val;
        l1.val=temp%10;
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=0;
        temp=Math.floor(temp/10);
        l2=l2.next;
    }
    temp+=l1.val+l2.val;
    l1.val=temp%10;
    temp=Math.floor(temp/10);
    if (temp===1) {
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=1;
    }
    return head;

};
```

链表连接可以优化代码




---
## 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**提示：**

- `0 <= s.length <= 5 * 104`

- `s` 由英文字母、数字、符号和空格组成

- **例 1:**

  ```
  输入: s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s==="") {return 0;}
    let maxLen=1;
    let flag;
    let count=1;
    let newArr=[];  //存储子串数组
    for (let i=0;i<s.length;i++){
        newArr.push(s[i]);
        flag=true;
        for (let j=i+1;j<s.length;j++){
            if (newArr.includes(s[j])) {
                //当子串数组中已有时
                maxLen=count>maxLen ? count : maxLen;
                flag=false;
                count=1;
                newArr=[];
                break;
            }else{
                newArr.push(s[j]);
                count++;
            }
        }
        if (flag) {
            maxLen=count>maxLen ? count : maxLen;
            break;
        }
    }
    return maxLen;
};


let str1 = "heflfdddswertllo";
let result=lengthOfLongestSubstring(str1);
console.log(result);
```




---
## 4. 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    let newArr=new Array();
    //双指针
    let i=0;
    let j=0;
    while(i<nums1.length && j<nums2.length){
        if (nums1[i]<=nums2[j]) {
            newArr.push(nums1[i]);
            i++;
        }
        if (nums2[j]<=nums1[i]) {
            console.log(nums2[j]);
            newArr.push(nums2[j]);
            j++;
        }
    }

    while (i<nums1.length){
        newArr.push(nums1[i]);
        i++;
    }
    while(j<nums2.length){
        newArr.push(nums2[j]);
        j++;
    }
    //return newArr;
    let n=nums1.length+nums2.length;
    if (n%2===0) {
        return parseFloat((newArr[n/2]+newArr[n/2-1])/2);
    }else{
        return parseFloat(newArr[Math.floor(n/2)]);
    }
    console.log(newArr);
};


let str1 = [1,2];
let str2=[3,4];
let result=findMedianSortedArrays(str1,str2);
console.log(result);
```


---
## 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

方法一：动态规划

![最长回文子串(动态规划)](E:\pogject\学习笔记\image\leetcode\最长回文子串(动态规划).png)

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let n=s.length;
    if (n<2) {
        return s;
    }

    let maxLen=1;
    let begin=0;
    const dp=new Array(n);
    //dp[i][j] 表示 s[i..j] 是否是回文串
    for (let i=0;i<n;i++){
        /// 初始化：所有长度为 1 的子串都是回文串
        dp[i]=new Array(n).fill(false);
        dp[i][i]=true;
    }

    // 递推开始, 先枚举子串长度
    for(let L=2;L<=n;L++){
        // 枚举左边界，左边界的上限设置可以宽松一些
        for(let i=0;i<n;i++){
            // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
            let j=L+i-1;
            if (j>=n) {
                // 如果右边界越界，就可以退出当前循环
                break;
            }
            if (s[i]!==s[j]) {
                dp[i][j]=false;
            }else{
                if (j-i<3) {
                    dp[i][j]=true;
                }else{
                    dp[i][j]=dp[i+1][j-1];
                }
            }
            // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
            if (dp[i][j] && j-i+1>maxLen) {
                maxLen=j-i+1;
                begin=i;
            }
        }
    }

    return s.slice(begin,begin+maxLen);
};


let str1 = "babad";
let result=longestPalindrome(str1);
console.log(result);
```

![最长回文子串(中心扩展算法)](E:\pogject\学习笔记\image\leetcode\最长回文子串(中心扩展算法).png)

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let n=s.length;
    if (n<2) {
        return s;
    }

    let start=0,end=0;
    let len1,len2,len;
    for (let i=0;i<n;i++){
        len1=expandAroundCenter(s,i,i);
        len2=expandAroundCenter(s,i,i+1);
        len=Math.max(len1,len2);
        console.log(start,end);
        if (len>end-start) {
            start=i-Math.floor((len-1)/2);
            end=i+Math.floor(len/2);
        }
    }
    return s.slice(start,end+1);
};

var expandAroundCenter=function(s,left,right){
    while(left>=0 && right<s.length && s[left]===s[right]){
        left--;
        right++;
    }
    return right-left-1;
}


let str1 = "cbbd";
let result=longestPalindrome(str1);
console.log(result);
```








---
## 6.Z 字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P    A    H   N
A P L S I  I G
Y    I     R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`

```js
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows===1) {return s;}
    let n=s.length;
    //每一个周期需要2n-2个
    let cycles=2*numRows-2;
    let ans=[];
    //第一行
    for(let i=0;i<n;i+=cycles){
      ans.push(s[i]);
    }
    //中间部分
    for(let j=1;j<numRows-1;j++){
      for(let i=0;i<n;i+=cycles){
         if (i+j<n) {
            ans.push(s[i+j]);
         }
         if (i+cycles-j<n) {
            ans.push(s[i+cycles-j])
         }
         
      }
    }
    //最后一行
    for(let i=numRows-1;i<n;i+=cycles){
      ans.push(s[i]);
    }
    return ans.join("");
};

let str1 = "basanaadsfenafdrrgeana";
let result=convert(str1,3);
console.log(result);
```

```js
var convert = function(s, numRows) {
    const n = s.length, r = numRows;
    if (r === 1 || r >= n) {
        return s;
    }
    const t = r * 2 - 2;
    const ans = [];
    for (let i = 0; i < r; i++) { // 枚举矩阵的行
        for (let j = 0; j < n - i; j += t) { // 枚举每个周期的起始下标
            ans.push(s[j + i]); // 当前周期的第一个字符
            if (0 < i && i < r - 1 & j + t - i < n) {
                ans.push(s[j + t - i]); // 当前周期的第二个字符
            }
        }
    }
    return ans.join('');
};
```




---
## 7. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

```java
import java.util.*;

class Solution {
	public int reverse(int x) {
		if (x>-10 && x<10) return x;
		long result=0;
		while(x!=0){
			result=result*10+x%10;
			x=x/10;
		}
		//检测是否溢出，溢出则返回0
		return (int) result==result ? (int) result :0;
	}
}


public class TestOperateString{
	public static void main(String[] args) {

		//int[] testnums={1,2,3,4,5,6,7,8,9,10};
		//char[] testStr={'h','e','l','l','o','b'};

		int n=-136469;

		Solution mysolution=new Solution();
		//mysolution.reverseString(testStr);
		int result=mysolution.reverse(n);
		System.out.println(result);
		//System.out.println(Arrays.toString(testStr));
	}
}
```

注意检查是否溢出


---
## 8. 字符串转换整数 (atoi)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

```js
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    s=s.trim();
    let patt=/[^0-9+-]/
    if (patt.test(s[0])) {
        return 0;
    }
    let nums=new Array();
    nums.push(s[0]);
    for (let i=1;i<s.length;i++){
        if (/\D/.test(s[i])) {
            //查找到非数字停止
            break;
        }else{
            nums.push(s[i]);
        }
    }

    let num=nums.join("");
    if (num==="+" || num==="-") {return 0;}
    num=parseInt(num);
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "+-12";
let result=myAtoi(str1);
console.log(result);

```

直接调用内置函数

```js
var myAtoi = function(s) {
    s=s.trim();
    let num=parseInt(s);
    if (isNaN(num)) {
        return 0;
    }
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "words and 987";
let result=myAtoi(str1);
console.log(result);
```


---
### 


---
## 9.回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

提示：
-231 <= x <= 231 - 1

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x<0) {
        return false;
    }
    x=x.toString();

    for (let i=0;i<x.length/2;i++){
        if (x[i]!==x[x.length-1-i]) {
            return false;
        }
    }
    return true;
};

let str1 = -121;
let result=isPalindrome(str1);
console.log(result);

```


---
## 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符

直接调用正则方法

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    return new RegExp("^"+p+"$").test(s);
};
```

动态规划

```
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    //动态规划 dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
    let lenS=s.length;
    let lenP=p.length;

    let dp=new Array(lenS+1);

    for (let i=0;i<dp.length;i++){
        //先构造dp[][]数组，将其每一项初始化为false
        dp[i]=new Array(lenP+1).fill(false);

    }
    //base case
    dp[0][0] = true; // s为空、p为空 两者都是空串的时候 可匹配

    //s不为空 p为空，必为false(dp数组默认值为false，无需处理)

    /*//s为空，p不为空(dp[0][]) 由于*可以匹配0个字符，所以有可能为true 
    要进行处理（看看有无*来挽救） 注意 dp[0][j] 当j=1时，表示p的前1个字符
    自然是p[j-1]呢，p的下标是从0开始*/
    for (let j=1;j<lenP;j++){
        if (p[j-1]==="*") {
            dp[0][j]=dp[0][j-2];
        }
    }

    // 迭代 状态转移
    for (let i=1;i<=lenS;i++){
        for (let j=1;j<lenP;j++){
            if (s[i-1]===p[j-1] || p[j-1]===".") {
                //最好简单情况 到这里 s、p 可以直接匹配
                dp[i][j]=dp[i-1][j-1];
            }else if(p[j-1]==="*"){
                //不满足直接对应相等，但 p这个字符是 ‘*’ 的话 仔细考虑
                if (s[i-1]===p[j-2] || p[j-2]===".") {
                    //s当前字符 可匹配上 p前一个字符
                    ////*匹配0次的情况 ｜｜ *匹配1次或多次的情况 
                    dp[i][j]=dp[i][j-2]  || dp[i-1][j];
                }else if(s[i-1]!==p[j-2]){
                    //s当前字符 无法匹配上 p前一个字符，只能是 *匹配0次的情况
                    dp[i][j]=dp[i][j-2];
                }
            }
        }
    }

    return dp[lenS][lenP];
};

let str1 = "mississippi";
let str2="mis*is*p*.";
let result=isMatch(str1,str2);
console.log(result);

```


---
## 11.盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

提示：

n == height.length
2 <= n <= 105
0 <= height[i] <= 104

**双指针**

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let ans = 0;
    let area=0;
    //在初始时，左右指针分别指向数组的左右两端
    for (let i = 0, j = height.length - 1; i < j;){
        area = Math.min(height[i], height[j]) * (j - i);
        ans = Math.max(ans,area);
        if (height[i] <= height[j]) {
            //移动对应数字较小的那个指针
            i++;
        }else{
            j--;
        }
    }
    return ans;
};

let test = [1,8,6,2,5,4,8,3,7];
let result = maxArea(test);
console.log(result);  //
```

---

## 12. 整数转罗马数字

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。

**提示：**

- `1 <= num <= 3999`

**模拟**

```js
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
    let valueSymbols = [
        [1000,"M"],
        [900,"CM"],
        [500,"D"],
        [400,"CD"],
        [100,"C"],
        [90,"XC"],
        [50,"L"],
        [40,"XL"],
        [10,"X"],
        [9,"IX"],
        [5,"V"],
        [4,"IV"],
        [1,"I"]
    ];
    let roman = "";
    for (let [value, symbol] of valueSymbols){
        while (num >= value) {
            roman += symbol;
            num -= value;
        }
        if (num === 0) {
            break;
        }
    }
    return roman;
};

let num = 58;
let result = intToRoman(num);
console.log(result);  //
```

**硬编码数字**

这恰好把这 13个符号分为四组，且组与组之间没有公共的符号。因此，整数num* 的十进制表示中的每一个数字都是可以单独处理的。

进一步地，我们可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 0 对应的是空字符串。

![fig4](https://assets.leetcode-cn.com/solution-static/12/3.png)

```js
var intToRoman = function(num) {
    const thousands = ["", "M", "MM", "MMM"];
    const hundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
    const tens = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
    const ones = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

    let roman = "";
    roman += thousands[Math.floor(num / 1000)];
    roman += hundreds[Math.floor(num % 1000 / 100)];
    roman += tens[Math.floor(num % 100 / 10)];
    roman += ones[num % 10];
    return roman;
};

```




---
## 13. 罗马数字转整数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 IV (4) 和 IX  (9)。
X 可以放在 L (50) 和 C (100) 的左边，来表示 XL 40 和 XC90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 CD 400 和 CM 900。
给定一个罗马数字，将其转换成整数。

提示：

1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {

	let romanObj={I:1,V:5,X:10,L:50,C:100,D:500,M:1000};
	let sum=0;

	let i=0;
	while(s.length>0){
		if (s.length===1) {
			sum+=romanObj[s[0]];
			break;
		}
		if (s[0]=="I") {
			if (s[1]==="V") {
				sum+=4;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="X") {
				sum+=9;
				s=s.slice(2);
				continue;
			}
			sum+=1;
			s=s.slice(1);
			continue;
		}else if(s[0]=="X") {
			if (s[1]==="L") {
				sum+=40;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="C") {
				sum+=90;
				s=s.slice(2);
				continue;
			}
			sum+=10;
			s=s.slice(1);
			continue;
		}else if(s[0]=="C") {
			if (s[1]==="D") {
				sum+=400;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="M") {
				sum+=900;
				s=s.slice(2);
				continue;
			}
			sum+=100;
			s=s.slice(1);
			continue;
		}
		sum+=romanObj[s[0]];
		s=s.slice(1);
	}
	return sum;
};

let str1="MCMXCIV";
let result=romanToInt(str1);
console.log(result);
```


---
## 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length===1) {return strs[0];}
    let minLen=strs[0].length;
    for (let i=0;i<strs.length;i++){
        if (strs[i].length===0) {
            return "";
        }
        if (strs[i].length<minLen) {
            minLen=strs[i].length;
        }
    }
    let alphas=new Array("");
    for (let i=0;i<minLen;i++){
        for (let j=1;j<strs.length;j++){
            if (strs[j][i]!=strs[0][i]) {
                return alphas.join("");
            }
        }
        alphas.push(strs[0][i]);
    }
    return alphas.join("");
};


let str1 = ["flower","flow","flight"];
let result=longestCommonPrefix(str1);
//console.log(typeof result);
console.log(result);

```

利用数组的 Reduce 方法实现的最简洁代码

取第一个字符串为公共前缀
逐个对比，返回两两元素的公共前缀
将 2 中的公共前缀和下一个元素对比，得到新的公共前缀


---
## 15. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
提示：

0 <= nums.length <= 3000
-105 <= nums[i] <= 105

繁琐的思路，需要简化代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
	if (nums.length<3) {
		return [];
	}

	if (nums.length===3) {
		if (nums[0]+nums[1]+nums[2]===0) {
			return [[...nums]];
		}else{
			return[]
		}
	}

	let newArr=[];

	const positiveInterger=[];
	const negativeInterger=[];
	const zeros=[];

	nums.sort((a,b)=>a-b);
	let count=0;
	let temp=nums[0];
	//非零相同值最多需要留两个就可
	for (let i=0;i<nums.length;i++){
		//这里可用indexOf与lastIndexOf处理
		if (nums[i]!==temp) {
			temp=nums[i];
			count=1;
			if (nums[i]<0) {
				negativeInterger.push(nums[i]);
			}else if(nums[i]>0){
				positiveInterger.push(nums[i]);
			}else{
				zeros.push(0);
			}
		}else{
			if (nums[i]!==0) {
				if (count<2) {
					count+=1
					if (nums[i]<0) {
						negativeInterger.push(nums[i]);
					}else{
						positiveInterger.push(nums[i]);
					}
				}
			}else{
				zeros.push(0);
			}
		}
	}
	if (zeros.length!==0) {
		//有0时把0作为负数处理
		negativeInterger.push(0);
		//正数则为
		//positiveInterger.unshift(0);
	}
	if (zeros.length>2) {
		newArr.push([0,0,0]);
	}

	//console.log(positiveInterger);
	//console.log(negativeInterger);

	//需要匹配最大正数索引边界，动态变化
	let maxPositiveIndex=positiveInterger.length-1;
	//最大负数和
	let maxSum1;
	for (let i=0;i<negativeInterger.length-1;i++){
		//两负一正时
		if (maxPositiveIndex===-1) {
			//当正整数遍历完时，退出
			break;
		}
		if (i>0) {
			if (negativeInterger[i]===negativeInterger[i-1]) {
				continue;
			}
		}
		maxSum1=-(negativeInterger[i]+negativeInterger[i+1]);
		if (positiveInterger[maxPositiveIndex]>maxSum1) {
			maxPositiveIndex--;
		}
		for (let j=i+1;j<negativeInterger.length;j++){
			//计算两个负数和后取绝对值
			if (maxPositiveIndex===-1) {
				//当正整数遍历完时，退出
				break;
			}
			if (negativeInterger[j]===negativeInterger[j+1]) {
				continue;
			}
			let NegativeSum=-(negativeInterger[i]+negativeInterger[j]);
			//去找是否有相等的值
			for (let k=maxPositiveIndex;k>=0;k--){
				//因为是排好序的
				if (positiveInterger[k]<NegativeSum) {
					//如果小于则不存在，退出
					break;
				}
				if(positiveInterger[k]===NegativeSum) {
					//如果相等
					newArr.push([negativeInterger[i],negativeInterger[j],positiveInterger[k]]);
					break;
				}
				//如果大于就往前找
			}
		}
		if (positiveInterger[maxPositiveIndex]===maxSum1) {
			maxPositiveIndex--;
		}
	}

    //需要匹配最大负数索引边界，动态变化
    let maxNegativeIndex=negativeInterger.length-1;
    //最小正数和
	let maxSum2;
    for (let i=0;i<positiveInterger.length-1;i++){
        //两正一负时
        if (maxNegativeIndex===-1) {
            //当正整数遍历完时，退出
            break;
        }
        if (i>0) {
        	if (positiveInterger[i]===positiveInterger[i-1]) {
        		continue;
        	}
        }
        maxSum2=-(positiveInterger[i]+positiveInterger[i+1]);
        if (negativeInterger>maxSum2) {
        	maxNegativeIndex--;
        }

        for (let j=i+1;j<positiveInterger.length;j++){
            //计算两个负数和后取绝对值
            if (maxNegativeIndex===-1) {
                //当正整数遍历完时，退出
                break;
            }
            if (positiveInterger[j]===positiveInterger[j+1]) {
            	continue;
            }
            let PositiveSum=-(positiveInterger[i]+positiveInterger[j]);
            //去找是否有相等的值
            for (let k=maxNegativeIndex;k>=0;k--){
                //因为是排好序的
                if (negativeInterger[k]<PositiveSum) {
                    //如果小于则不存在，退出
                    break;
                }
                if(negativeInterger[k]===PositiveSum){
                    //如果相等
                    newArr.push([positiveInterger[i],positiveInterger[j],negativeInterger[k]]);
                    break;
                }
                //如果大于，则往前查找，最大正数索引边界减一
            }
        }
        if (negativeInterger===maxSum2) {
        	//移动最大位，可以避免重复
        	maxNegativeIndex--;
        }
    }

	return newArr;
};

let str1=[-1,0,1,2,-1,-4,-2,-3,3,0,4];
let result=threeSum(str1);
console.log(result);
```

简化，直接使用双指针

```js
function threeNumberSum(nums){
	nums=nums.sort((a,b)=>a-b);  //排序
	let n=nums.length;
	const ans=[];
	let sum=0;
	//枚举第一个数字
	for (let first=0; first<n; first++){
		// 需要和上一次枚举的数不相同
		if (nums[first]>0) {
			//first元素大于0后，后面sum不可能等于0
			break;
		}
		if (first>0 && nums[first]===nums[first-1]){
			continue;
		}
		//第三个数对应的指针初始指向数组的最右端
		let third=n-1;
		let target=-nums[first];
		for (let second=first+1; second<n; second++){
			if (nums[second] > target) {
				//前两个元素和已经大于0，则再加第三个一定大于0;
				break;
			}
			// 需要和上一次枚举的数不相同
			if (second>first+1 && nums[second]===nums[second-1]) {
				continue;
			}
			// 需要保证 second 的指针在 third 的指针的左侧
			while(second<third && nums[second]+nums[third]>target){
				third--;
			}
			// 如果指针重合，随着 second 后续的增加
			// 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
			if (second===third) {
				break;
			}
			if (nums[second]+nums[third]===target) {
				ans.push([nums[first],nums[second],nums[third]]);
			}
		}
	}
	return ans;
}

let test=[-1, 0, 1, 2, -1, -4];
console.log(threeNumberSum(test));  // [ [ -1, -1, 2 ], [ -1, 0, 1 ] ]
```


---
## 16. 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

提示：

3 <= nums.length <= 1000
-1000 <= nums[i] <= 1000
-104 <= target <= 104

**排序** + **双指针**

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {

    nums.sort((a, b) => a - b);
    let n = nums.length;
    let sum = 0;
    let closestValue = Number.MAX_SAFE_INTEGER;

    var updateClosestValue = (value) =>{
        // 根据差值的绝对值来更新答案
        if (Math.abs(value - target) < Math.abs(closestValue - target)) {
            closestValue = value;
        }
    }

    for (let i = 0; i < n; i++){
        if (i > 0 && nums[i] === nums[i-1]){
            continue;
        }
        let j = i + 1;
        let k = n - 1;
        let a = nums[i];
        while (j < k){
            let b = nums[j], c = nums[k];
            sum = a + b + c;
            if (sum === target) {
                return target;
            }
            updateClosestValue(sum);
            if (sum > target) {
                //如果和大于 target，移动 c 对应的指针
                k--;
                //移动到下一个不相等的元素
                while (j < k && nums[k] === c){
                    k--;
                }
            }else{
                // 如果和小于 target，移动 b 对应的指针
                j++;
                //移动到下一个不相等的元素
                while (j < k && nums[j] === b){
                    j++;
                }
            }
        }
    }

    return closestValue;
};

let nums = [-1,2,1,-4], target = 1;
let result = threeSumClosest(nums, target);
console.log(result);
```

---

## 17. 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

提示：

0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。

```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    let ans = [];
    if (digits.length === 0) {
        return ans;
    }
    const aCode = "a".charCodeAt();
    for (let num of digits){
        num=Number(num) -2;
        let n = 3;
        if (num === 7 || num === 5) {
            n = 4;
        }
        let temp = [...ans];
        ans = [];
        
        for (let i = 0; i < n; i++){
            let code = aCode + 3 * num + i;
            if (num === 6 || num === 7) {
                code += 1;
            }
            let s = String.fromCharCode(code);
            if (temp.length ===0){
                ans.push(s)
            }else{
                for (let j = 0; j< temp.length; j++){
                    ans.push(temp[j] + s);
                }
            }
        }
    }
    return ans;
};

let digits = "23";
let result = letterCombinations(digits);
console.log(result);
```

---

## 18. 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

提示：

1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    if (nums.length < 4) {
        return [];
    }
    nums = nums.sort((a, b) => a - b);

    let n = nums.length;
    const ans = [];
    let sum = 0;
    //枚举第一个数字
    for (let first = 0; first < n - 3; first++){
        // 需要和上一次枚举的数不相同
        if (first > 0 && nums[first] === nums[first-1]){
            continue;
        }
        if (nums[first] + nums[first + 1] +nums[first + 2] + nums[first + 3] > target) {
            //sum大于target后，后面sum不可能小于
            break;
        }
        if (nums[first] + nums[n - 1] +nums[n - 2] + nums[n - 3] < target) {
            //sum小于target后，前面sum不可能大于
            continue;
        }
        //第二个数在第一个数的右端
        for (let second = first + 1; second < n-2; second++){
            // 需要和上一次枚举的数不相同
            if (second > first+1 && nums[second] === nums[second-1]) {
                continue;
            }
            if (nums[first] + nums[second] + nums[second + 1] + nums[second + 2] > target) {
                //前面元素和已经大于target，则后面一定大于
                break;
            }
            if (nums[first] + nums[second] +nums[n - 1] + nums[n - 2] < target) {
                //sum小于target后，前面sum不可能大于
                continue;
            }
            //第三个数位于second的右端
            //第四个数对应的指针初始指向数组的最右端
            let third = second + 1;
            let fourth = n - 1;
            while (third < fourth) {
                sum = nums[first] + nums[second] + nums[third] + nums[fourth];
                if (sum === target) {
                    ans.push([nums[first], nums[second], nums[third], nums[fourth]]);
                    // 需要保证 third 的指针在 fourth 的指针的左侧, 需要和上一次枚举的数不相同
                    while (third < fourth && nums[third] === nums[third + 1]) {
                        third++;
                    }
                    third++;
                    while (third < fourth && nums[fourth] === nums[fourth - 1]) {
                        fourth--;
                    }
                    fourth--;
                }else if (sum < target) {
                    third++;
                }else{
                    fourth--;
                }
            }
        }
    }
    return ans;
}

let nums = [1,0,-1,0,-2,2], target = 0;
let result = fourSum(nums, target);
console.log(result);
```

---

## 19. 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
提示：

链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz

**进阶：**你能尝试使用一趟扫描实现吗？

**计算链表长度**

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    
    let dummy = new ListNode(0, head);  //哑节点
    let len = 0;
    let p = head;
    //我们首先从头节点开始对链表进行一次遍历，得到链表的长度
    while (p !== null){
        p = p.next;
        len++;
    }
    
    len -= n;
    p = dummy;
    //随后我们再从头节点开始对链表进行一次遍历
    while (len > 0){
        p = p.next;
        len--;
    }
    当遍历到第L−n+1 个节点时，它就是我们需要删除的节点。
    p.next = p.next.next;
    return dummy.next;
};
```

栈

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        Deque<ListNode> stack = new LinkedList<ListNode>();
        ListNode cur = dummy;
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        for (int i = 0; i < n; ++i) {
            stack.pop();
        }
        ListNode prev = stack.peek();
        prev.next = prev.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}

```

**双指针**

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    
    let dummy = new ListNode(0, head);  //哑节点
    let first = head;
    let second = dummy;  //first 与second相隔 n-1个结点
    for (let i=0; i < n; i++){
        first = first.next;
    }
    while (first){
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;

    return dummy.next;
};
```



---

## 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

栈实现

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if (s.length%2!==0) {
        return false;
    }
    let leftBrackets=["(","[","{"];
    let rightBrackets=[")","]","}"];

    let stack=[];
    for (let i=0;i<s.length;i++){
        //是否是右括号
        let index=rightBrackets.indexOf(s[i]);
        if (index!==-1) {
            //是右括号
            if (stack.length===0) {
                //如果栈为空，则不合法
                return false;
            }
            //则去看栈顶是否相匹配
            if (stack[stack.length-1]===leftBrackets[index]){
                //如果匹配，则出栈
                stack.pop();
            }else{
                //不匹配，则进栈
                stack.push(s[i]);
            }
        }else{
            //是左括号则直接进栈
            stack.push(s[i]);
        }
        //console.log(stack);
    }
    if (stack.length===0) {
        return true;
    }else{
        return false;
    }
};

let str1 = "{[{{[{}]}[({[]})]}]}";
let result=isValid(str1);
console.log(result);
```


---
## 21.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列

方法一：递归
思路

我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：

list1[0]+merge(list1[1:],list2)    ,list1[0]<list2[0]
list2[0]+merge(list1,list2[1:])    ,otherwise

也就是说，**两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并**。

算法

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```js
var mergeTwoLists = function(list1, list2) {
    //如果一个为空，则直接返回另一个
    if (list1===null) {
        return list2
    }else if (list2===null) {
        return list1;
    }else if(list1.val<list2.val){
        list1.next=mergeTwoLists(list1.next,list2);
        return list1;
    }else{
        list2.next=mergeTwoLists(list1,list2.next);
        return list2;
    }
};
```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。
- 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。

方法二：迭代
思路

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

算法

首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

**在循环终止的时候， l1 和 l2 至多有一个是非空的**。由于输入的两个链表都是有序的，**所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大**。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

var mergeTwoLists = function(list1, list2) {
    const head=new ListNode();
    let list3=head;
    while(list1!=null && list2!=null){
        if (list1.val<list2.val) {
            list3.next=list1;
            list1=list1.next;
        }else{
            list3.next=list2;
            list2=list2.next;
        }
        list3=list3.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    list3.next=list1===null ? list2:list1;
    //注意返回的是什么
    return head.next;
};

let str1 = [-9,3];
let str2=[5,7];
let list1=new ListNode();
let list2=new ListNode();
let head1=list1;
let head2=list2;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
for (let i=0;i<str2.length;i++){
    list2.val=str2[i];
    list2.next=new ListNode();
    list2=list2.next;
}
//console.log(head2);

let result=mergeTwoLists(head1,head2);
console.log(result);


```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

- 空间复杂度：O(1)。我们只需要常数的空间存放若干变量。

```

```

---

## 22. 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
提示：

1 <= n <= 8

![括号生成(按括号序列的长度递归)](E:\pogject\学习笔记\image\leetcode\括号生成(按括号序列的长度递归).png)

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    const cache = [];

    var generate = (n) =>{
        if (cache[n] !== undefined) {
            return cache[n];
        }
        const ans = [];
        if (n === 0) {
            ans.push("");
        }else{
            for (let i = 0; i < n; i++){
                for (let left of generate(i)){
                    for (let right of generate(n - 1 - i)){
                        ans.push("(" + left + ")" +right);
                    }
                }
            }
        }
        cache[n] = ans;
        return ans;
    };

    return generate(n);
};

let n = 3;
let result = generateParenthesis(n);
console.log(result);
```

---

## 23. 合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。
提示：

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4

**方法一：顺序合并**

用一个变量ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和 ans 合并，答案保存到ans 中。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    let ans = null;
    for (let i =0; i < lists.length; i++){
        ans = mergeTwoLists(ans, lists[i]);
    }
    return ans;
};

var mergeTwoLists = function(list1, list2){
    if ((!list1) || (!list2)) {
        return list1 ? list1 : list2;
    }
    let head = new ListNode();
    let tail = head;
    let p1 = list1;
    let p2 = list2;
    while (p1 && p2){
        if (p1.val < p2.val) {
            tail.next = p1;
            p1 = p1.next;
        }else{
            tail.next = p2;
            p2 = p2.next;
        }
        tail = tail.next;
    }
    tail.next = (p1 ? p1 : p2);
    return head.next;
}
```

**方法二：分治合并**

考虑优化方法一，用分治的方法进行合并。

- 将 k 个链表配对并将同一对中的链表合并；
- 重复这一过程，直到我们得到了最终的有序链表。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    return merge(lists, 0, lists.length - 1);
};

var merge = function(lists, left, right){
    if (left === right) {
        return lists[left];
    }
    if (left > right) {
        return null;
    }
    let mid = (left + right) >> 1;
    return mergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));
}

var mergeTwoLists = function(list1, list2){
    if ((!list1) || (!list2)) {
        return list1 ? list1 : list2;
    }
    let head = new ListNode();
    let tail = head;
    let p1 = list1;
    let p2 = list2;
    while (p1 && p2){
        if (p1.val < p2.val) {
            tail.next = p1;
            p1 = p1.next;
        }else{
            tail.next = p2;
            p2 = p2.next;
        }
        tail = tail.next;
    }
    tail.next = (p1 ? p1 : p2);
    return head.next;
}
```

**方法三：使用优先队列合并**

这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

```
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    const queue = [];

    for (let list of lists){
        if (node !== null){
            queue.push()
        }
    }
    let head = new ListNode(0);
    let tail = head;
    while (queue.length){
        let node = queue.pop();
        tail.next = node.
    }
    return merge(lists, 0, lists.length - 1);
};

```

---

## 24. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

**递归**

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    if (head === null || head.next === null) {
        return head;
    }
    let p = head.next;
    head.next = swapPairs(p.next);
    p.next = head;

    return p;
};
```

**迭代**

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    if (head === null || head.next === null) {
        return head;
    }
    let dummyHead = new ListNode(0);
    dummyHead.next = head;

    let temp = dummyHead;
    while (temp.next !== null && temp.next.next !== null){
        let node1 = temp.next;
        let node2 = temp.next.next;
        temp.next = node2;
        node1.next = node2.next;
        node2.next = node1;
        temp = node1;
    }
    return dummyHead.next;
};
```




---
## 26.删除有序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

提示：

0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let start=0;
    while(start<nums.length){
        if (nums[start]===nums[start+1]) {
            //删除重复中的后一个
            nums.splice(start+1,1);
        }else{
            start++;
        }
    }
    console.log(nums);
    return nums.length;
};


let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeDuplicates(test);
console.log(result);
```

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\双指针删除排序数组中的重复项.png)

```js
var removeDuplicates = function(nums) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let fast = 1, slow = 1;
    while (fast < n) {
        if (nums[fast] !== nums[fast - 1]) {
            //如果不同，则赋值给前面的重复位或当前位
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
};
```

**把不相同的用来覆盖前面相同的，不涉及删除消耗相对较小**

复杂度分析

- 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。


- 空间复杂度：O(1)。只需要使用常数的额外空间。



---
## 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let flag=0;
    let count=0;
    while (flag < n-count) {
        if (nums[flag]===val) {
            //如果匹配则把后面的值赋值到这里判断
            //只需移动元素匹配次数
            nums[flag]=nums[n-1-count];
            count++;
        }else{
            flag++;
        }
    }
    console.log(nums);
    return flag;
};

let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeElement(test,2);
console.log(result);
```

![移除元素双指针](E:\pogject\学习笔记\image\leetcode\移除元素双指针.png)


---
## 28. 实现 strStr()

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

![方法一：暴力匹配strStr](E:\pogject\学习笔记\image\leetcode\方法一：暴力匹配strStr.png)

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (haystack.length<needle.length) {return -1;}
    if (needle==="") {return 0;}
    if (haystack.length===needle.length && haystack===needle) {return 0;}
    if (haystack.length===needle.length && haystack!==needle) {return -1;}
    for (let i=0;i<haystack.length-needle.length+1;i++){
        if (haystack[i]===needle[0]) {
            let flag=true;
            for (let j=1;j<needle.length;j++){
                if (haystack[i+j]!==needle[j]){
                    flag=false;
                    break;
                }
            }
            if (flag) {
                return i;
            }

        }
    }
    return -1;
};


let str1 = "heffdddllo";
let str2 = "ell";
let result=strStr(str1,str2);
console.log(result);

```

调用内置方法

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle);
};
```

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr.png)

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr2.png)

```js
var strStr=function(haystack,needle){
    const n=haystack.length,m=needle.length;
    if (m===0) {
        return 0;
    }

    const pi=new Array(m).fill(0);

    //needle部分的前缀函数
    for (let i=1,j=0;i<m;i++){
        while (j>0 && needle[i]!=needle[j]){
            j=pi[j-1];
        }
        if (needle[i]===needle[j]) {
            j++;
        }
        pi[i]=j;
    }

    //求 haystack 部分的前缀函数
    for (let i=0,j=0;i<n;i++){
        while(j>0 && haystack[i]!=needle[j]){
            j=pi[j-1];
        }
        if (haystack[i]==needle[j]) {
            j++;
        }
        if (j===m) {
            return i-m+1;
        }
    }
    return -1;
};

```


---
## 29.两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

提示：

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。

暴力解法，连减计数,会超时

```

```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除二分查找.png)



```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //二分查找
    let left=1;
    let right=MAX_VALUE;
    let ans=0;
    while(left<=right){
        //注意溢出，并且不能使用除法
        const mid=left+((right-left)>>1);
        const check=quickAdd(divisor,mid,dividend);
        if (check) {
            ans=mid;
            // 注意溢出
            if (mid===MAX_VALUE) {
                break;
            }
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return rev ? -ans : ans;
};

// 快速乘
const quickAdd=(y,z,x)=>{
    // x 和 y 是负数，z 是正数
    // 需要判断 z * y >= x 是否成立
    let result=0;
    let add=y;
    while(z!==0){
        if ((z&1)!==0) {
            //需要保证 result + add >= x
            if (result<x-add) {
                return false;
            }
            result+=add;
        }
        if (z!==1) {
            //需要保证 add + add >= x
            if (add<x-add) {
                return false;
            }
            add+=add;
        }
        // 不能使用除法
        z>>=1;
    }
    return true;
};

let str1 = 10;
let str2 = 3;
let result=divide(str1,str2);
console.log(result);
```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除类二分查找.png)

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用类二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //类二分查找
    const candidates=[divisor];
    let index=0;
    //注意溢出
    while(candidates[index]>=dividend-candidates[index]){
        //处理的都是负数
        candidates.push(candidates[index]+candidates[index]);
        index++;
    }
    //console.log(candidates);
    let ans=0;
    console.log(ans,dividend);
    for (let i=candidates.length-1;i>=0;--i){
        if (candidates[i]>=dividend) {
            ans+=1<<i;
            dividend-=candidates[i];
            console.log(ans,dividend);
        }
    }
    return rev ? -ans : ans;
};


let str1 = 10000;
let str2 = 33;
let result=divide(str1,str2);
console.log(result);
```


---
## 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。
提示:

1 <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4
nums 为无重复元素的升序排列数组
-10^4 <= target <= 10^4

二分查找

因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=Math.floor((right+left)/2);
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=Math.floor((right+left)/2);
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=Math.floor((right+left)/2);
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=(right+left)>>1;
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=(right+left)>>1;
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=(right+left)>>1;
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};


let test = [1,2,3,5,6,7,20,100,289,328];
let result=searchInsert(test,1);
console.log(result);
```


---
## 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

![最大子数组和动态规划](E:\pogject\学习笔记\image\leetcode\最大子数组和动态规划.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    //只有一个元素直接返回
    if (nums.length===1) { return nums[0]; }

    //动态规划
    let pre=0;
    let maxSum=nums[0];
    nums.forEach((x)=>{
        pre=Math.max(pre+x,x);
        maxSum=Math.max(maxSum,pre);
    });
    //console.log(nums);
    return maxSum;
};

let test = [-2,1,-3,4,-1,2,1,-5,4];
let result=maxSubArray(test,1);
console.log(result);
```

**方法二：分治**




---
## 58. 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

提示：

1 <= s.length <= 104
s 仅有英文字母和空格 ' ' 组成
s 中至少存在一个单词

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        //反向遍历
        if(s[i]!==" "){
            count++;
        }else{
            //如果前面是字母，则这里单词就结束
            if (count>0) {
                return count;
            }
        }
    }
    return count;
};

let test = "   fly me   to   the moon  ";
let result=lengthOfLastWord(test);
console.log(result);
```


---
## 66. 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    digits[digits.length-1]+=1;
    for (let i=digits.length-1;i>0;i--){
        if (digits[i]<10){
            break;
        }else{
             digits[i]=0;
             digits[i-1]+=1;
        }
    }
    if (digits[0]===10) {
        digits[0]=1;
        digits[digits.length]=0;
    }
    return digits;
};
```


---
## 67. 二进制求和

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。
示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"


提示：

每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    if (a.length<b.length) {
        //交换变量的值,解构赋值
        [a,b]=[b,a];
    }
    let result=[];
    let temp=0;
    for(let i=0;i<b.length;i++){
        //先遍历短的一个
        temp+=Number(a[a.length-1-i])+Number(b[b.length-1-i])
        result.unshift((temp%2).toString());
        temp=temp>1 ? 1 : 0;
    }

    for(let j=a.length-b.length-1;j>=0;j--){
        //继续遍历长的一个剩余的位
        if (temp===1) {
            temp+=Number(a[j]);
            result.unshift((temp%2).toString());
            temp=temp>1 ? 1 : 0;
        }else{
            result.unshift(a[j]);
        }
    }
    if (temp===1) {
        //最后是否需要进位
        result.unshift("1")
    }
    return result.join("");
};

let test = "100";
let result=addBinary(test,"110010");
console.log(result);
```

考虑一个最朴素的方法：先将 a和 b转化成十进制数，求和后再转化为二进制数。

方法二：位运算


---
## 69. Sqrt(x)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
提示：

0 <= x <= 2^31 - 1

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    if (x<2) {
        return x;
    }
    //因为只需要整数部分，所以只需要找到平方小于等于x的的最接近的一个整数
    let left=1;
    let right=x>>1;
    let middle=(left+right)>>1;
    //二分查找
    while(left<=right){
        //注意溢出
        if (middle*middle>x) {
            right=middle-1;
        }else if (middle*middle<x) {
            left=middle+1;
        }else{
            return middle;
        }
        middle=(left+right)>>1;
    }
    return middle;
};

let test = 3;
let result=mySqrt(test);
console.log(result);
```

牛顿迭代法，或其他函数代替


---
## 70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

递归

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<3){
        return n;
    }else{
        //找到规律
        return climbStairs(n-1)+climbStairs(n-2);
    }

};

let test = 5;
let result=climbStairs(test);
console.log(result);
for (let i=1;i<20;i++){
    console.log(climbStairs(i));
}
/*
1
2
3
5
8
13
21
34
55
*/
```

```js
//动态规划
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```

方法一：动态规划

方法二：**矩阵快速幂**

方法三：通项公式


---
## 71. 简化路径

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。

1 <= path.length <= 3000
path 由英文字母，数字，'.'，'/' 或 '_' 组成。
path 是一个有效的 Unix 风格绝对路径。

```js
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    path=path.split("/")
    let result=[];
    path.forEach((item)=>{
        if (item!=="" && item!==".") {
            //对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理
            if (item==="..") {
                //当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录
                result.pop();
            }else{
                //当我们遇到「目录名」时，就把它放入栈。
                result.push(item);
            }
        }
    });
    //console.log(path);
    return "/"+result.join("/");
};

//let test = "/a/./b/../../c/";
let test = "/../";
let result=simplifyPath(test);
console.log(result);

```




---
## 83.删除排序链表中的重复元素

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。

返回同样按升序排列的结果链表。
提示：

链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列

方法一：一次遍历
当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。

```js
var deleteDuplicates = function(head) {
    if (!head) {
        return head;
    }

    let cur = head;
    while (cur.next) {
        if (cur.val === cur.next.val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return head;
};

```



```js
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if (head===null) {
        //如果为空
        return head;
    }
    let pre=head;
    let temp=head.val;
    while (head.next){
        if (head.next.val===temp) {
            //如果与前一个结点相同,跳过相同的那个
            head.next=head.next.next;
            //head=head.next;
        }else{
            //不同在移动到下一个
            head=head.next;
            temp=head.val;
        }
    }
    return pre;
};

let str1 = [1,1,2,3,3];
let list1=new ListNode();
let head1=list1;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
let result=deleteDuplicates(head1)
console.log(result);
```


---
## 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

提示：

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-10^9 <= nums1[i], nums2[j] <= 10^9

**进阶：**你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？

方法二：双指针,直接放会出现覆盖

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    const sorted = new Array(m + n).fill(0);
    var cur;
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            cur = nums2[p2++];
        } else if (p2 === n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (let i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
};
```

方法三：逆向双指针,不会产生覆盖现象

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    var cur;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 === -1) {
            cur = nums2[p2--];
        } else if (p2 === -1) {
            cur = nums1[p1--];
        } else if (nums1[p1] > nums2[p2]) {
            cur = nums1[p1--];
        } else {
            cur = nums2[p2--];
        }
        nums1[tail--] = cur;
    }
};
```



```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let len=m+n-1;
    while(m>=1 && n>=1){
        if (nums1[m-1]>=nums2[n-1]) {
            //如果访问到num1元素大于等于比nums2的
            nums1[len--]=nums1[--m];
        }else{
            //如果访问到num1元素小于比nums2的
            nums1[len--]=nums2[--n];
        }
    }
    while(m>=1){
        //n=0时候
        nums1[len--]=nums1[--m];
    }
    while(n>=1){
        //m=0时
        nums1[len--]=nums2[--n];
    }
};

let test =[1,2,3,0,0,0];
let test2=[2,5,6];
//let result=merge(test);
//console.log(result);
merge(test,3,test2,3);
console.log(test);
```

方法一：直接合并后排序

```js
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m, ...nums2);
    nums1.sort((a, b) => a - b);
};
```


---
## 89.格雷编码

n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：

- 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
- 第一个整数是 0
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同

给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

1 <= n <= 16

方法一：对称生成

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let result=[0];
    for (let i=1;i<=n;i++){
        let len=result.length;
        while(len>0){
            //对此生成
            result.push(result[--len] | (1<<(i-1)));
            //console.log(result[j] | (1<<(i-1)));
        }
    }
    return result;
};
```

```
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let maxValue=Math.pow(2,n)-1;
    let maxValueHex=maxValue.toString(2);
    let maxLen=maxValueHex.length;
    let arr=new Array(maxLen).fill("0");
    let hexs=[];
    for (let i=0;i<Math.pow(2,n);i++){
        let hex=(arr.join("")+i.toString(2)).slice(-maxLen);
        hexs.push(hex);
        //console.log(hex);
    }
    let newArr=[];
    for (let i=0;i<Math.pow(2,n);i++){
        
    }
    return 0;
};

let test=5;
let result=grayCode(test);
console.log(result);
```

方法二：二进制数转格雷码

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let result=[];
    for (let i=0;i<1<<n;i++){
        result.push((i>>1)^i);
    }
    return result;
};

let test=5;
let result=grayCode(test);
console.log(result);
```




---
## 94.二叉树的中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。
提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    
    if (root===null) {
        return [];
    }
    let result=[];

    result=result.concat(inorderTraversal(root.left));
    result.push(root.val);
    result=result.concat(inorderTraversal(root.right));
    return result;
};

let test =[1,null,2,3];

let root=new TreeNode(test[0]);
let result=inorderTraversal(test);
console.log(result);


```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

方法二：迭代

方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。

```js
var inorderTraversal = function(root) {
    let result=[];
    let stack=[];

    while(root || stack.length){
        while(root){
            stack.push(root);
            root=root.left;
        }
        root=stack.pop();
        result.push(root.val);
        root=root.right;
    }
    return result;
};
```

方法三：Morris 中序遍历

![Morris 中序遍历二叉树](E:\pogject\学习笔记\image\leetcode\Morris 中序遍历二叉树.png)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result=[];
    let predecessor=null;

    while(root){
        if (root.left) {
            //predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
            predecessor=root.left;
            while(predecessor.right && predecessor.right!==root){
                predecessor=predecessor.right;
            }
            // 让 predecessor 的右指针指向 root，继续遍历左子树
            if (!predecessor.right) {
                predecessor.right=root;
                root=root.left;
            }else{
                //说明左子树已经访问完了，我们需要断开链接
                result.push(root.val);
                predecessor.right=null;
                root=root.right;
            }
        }else{
            //如果没有左孩子，则直接访问右孩子
            result.push(root.val);
            root=root.right;
        }

    }
    return result;
};
```


---
## 100.相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
提示：

两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104

方法一：深度优先搜索

如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。

如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if (p===null && q===null) {
        return true;
    }else if (p===null || q===null) {
        return false;
    }else{
        if (p.val===q.val) {
            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
        }else{
            return false;
        }
    }
};
```

方法二：广度优先搜索

也可以通过广度优先搜索判断两个二叉树是否相同。同样首先判断两个二叉树是否为空，如果两个二叉树都不为空，则从两个二叉树的根节点开始广度优先搜索。

使用**两个队列**分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。

1. 比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；
2. 如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；
3. 如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。

**如果搜索结束时两个队列同时为空，则两个二叉树相同**。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。

```js
var isSameTree = function(p, q) {
    if (p===null && q===null) {
        return true;
    }
    if(p===null || q===null) {
        return false;
    }
    let arr1=[p];
    let arr2=[q];

    while(arr1.length>0 && arr2.length>0){
        let node1=arr1.shift();
        let node2=arr2.shift();
        if (node1.val!==node2.val) {
            return false;
        }
        let left1=node1.left,right1=node1.right;
        let left2=node2.left,right2=node2.right;

        if ((!left1)^(!left2) || (!right1)^(!right2)) {
            return false;
        }
        if (left1) {
            arr1.push(left1);
        }
        if (right1) {
            arr1.push(right1);
        }
        if (left2) {
            arr2.push(left2);
        }
        if (right2) {
            arr2.push(right2);
        }
    }
    if (arr1.length===0 && arr2.length===0) {
        return true;
    }else{
        return false;
    }

};
```


---
## 101.对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

方法一：递归

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值

- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，**通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q左移，p 左移时，q 右移**。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

function check(p,q){
    if (p===null && q===null) {
        return true;
    }
    if (p===null || q===null) {
        return false;
    }
    return p.val===q.val && check(p.left,q.right) && check(p.right,q.left);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root,root);
};

```

方法二：迭代

方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？**首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法**。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```js
function check(p,q){
    let arr=[p,q];
    while(arr.length>0){
        node1=arr.shift();
        node2=arr.shift();
        if (!node1 && !node2) {
            //都为空,跳过，检查后面的
            continue;
        }
        if ((!node1 || !node2) || node1.val!==node2.val) {
            //值不等或一个为空，一个不为空
            return false;
        }
        arr.push(node1.left);
        arr.push(node2.right);
        arr.push(node1.right);
        arr.push(node2.left);
    }
    return true;
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root,root);
};
```

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

```

```

----

## 102. 二叉树的层序遍历

给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

广度优先搜索

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (root === null) {
        return [];
    }
    const ans = [];

    let arr = [root];
    let node = null;
    let n = 0;  //每一层的结点数
    while (arr.length > 0){
        n=arr.length;
        let temp = [];
        while (n > 0){
            node = arr.shift();
            temp.push(node.val);
            if (node.left) {
                arr.push(node.left);
            }
            if (node.right) {
                arr.push(node.right);
            }
            n--;
        }
        ans.push(temp);
    }

    return ans;
};
```




---
## 104.二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

方法一：深度优先搜索

如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1

而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
};
```

方法二：广度优先搜索

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的**队列里存放的是「当前层的所有节点」**。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们**需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展**，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。

```js
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }
    let arr=[root];
    let count=0;
    while(arr.length>0){
        let len=arr.length;
        while(len>0){
            //需要将队列里的所有节点都拿出来进行拓展
            node=arr.shift();
            if (node.left!==null) {
                //加入的这层在下一次外循环拿出判断
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        count++;
    }
    return count;
};
```


---
## 108. 将有序数组转换为二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「**每个节点的左右两个子树的高度差的绝对值不超过 1** 」的二叉树。

提示：

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 按 严格递增 顺序排列

二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。

给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。

如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。

直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 11，可以使得树保持平衡。**如果数组长度是奇数，则根节点的选择是唯一的**，**如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点**，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。

当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考「1382. 将二叉搜索树变平衡」，这两道题的构造方法完全相同，这种方法是正确的，1382 题解中给出了这个方法的正确性证明：1382 官方题解，感兴趣的同学可以戳进去参考。

递归的基准情形是平衡二叉搜索树不包含任何数字，此时平衡二叉搜索树为空。

在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为[left,right]。对于整个中序遍历序列，下标范围从left=0 到 right=nums.length−1。当 left>right 时，平衡二叉搜索树为空。

以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。

方法一：中序遍历，总是选择中间位置左边的数字作为根节点

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置左边的数字作为根节点
    let mid=(left+right)>>1;  //左边
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}

let test =[-10,-3,0,5,9];
let result=sortedArrayToBST(test);
console.log(result);
```

方法二：中序遍历，总是选择中间位置右边的数字作为根节点

```js
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置右边的数字作为根节点
    let mid=(left+right+1)>>1;  //右边
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}
```

方法三：中序遍历，**选择任意一个中间位置数字作为根节点**

```js
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置右边的数字作为根节点
    let mid=(left+right+Math.round(Math.random()))>>1;  //左右随机一个
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}
```


---
## 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

方法一：自顶向下的递归

有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    if (root===null) {
        return true;
    }
    let leftDeep=maxDepth(root.left);
    let rightDeep=maxDepth(root.right);
    if (Math.abs(leftDeep-rightDeep)>1) {
        //左右子树高度差的绝对值不超过 1
        return false;
    }
    
    let leftIsBalance=isBalanced(root.left);
    let rightIsBalance=isBalanced(root.right);
    
    if (leftIsBalance && rightIsBalance) {
    	//左右子树也必需是平衡二叉树
        return true;
    }else{
        return false;
    }
};

var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
};
```

方法二：自底向上的递归

方法一由于是自顶向下递归，**因此对于同一个节点，函数 height 会被重复调用**，导致时间复杂度较高。**如果使用自底向上的做法，则对于每个节点，函数height 只会被调用一次。**

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    return getHeight(root)>=0;
};

function getHeight(root){
    if (root===null) {
        return 0;
    }
    let leftHeight=getHeight(root.left);
    let rightHeight=getHeight(root.right);
    if (leftHeight===-1  || rightHeight===-1 || Math.abs(leftHeight-rightHeight)>1) {
        //只要遇到不平衡时就返回-1，整棵树也是不平衡的
        return -1;
    }else{
        //平衡时
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```


---
## 111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

方法一：深度优先搜索

首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。

对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。

```js

/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (root===null){
        //如果结点为空
        return 0;
    }else if (root.left===null && root.right===null){
        //如果没有子树，则深度为1
        return 1;
    }else if (root.left===null && root.right!==null) {
        //如果只存在右子树
        return 1+minDepth(root.right);
    }else if (root.left!==null && root.right===null) {
        //如果只存在左子树
        return 1+minDepth(root.left);
    }else{
        //左右子树都存在
        return 1+Math.min(minDepth(root.left),minDepth(root.right));
    }
};
```

方法二：广度优先搜索

同样，我们可以想到使用广度优先搜索的方法，遍历整棵树。

当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。

```js
var minDepth = function(root) {
    if (root===null) {
        return 0;
    }
    let count=0;
    let arr=[root];
    let flag=true;
    while(flag){
        let len=arr.length;
        while(len>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                //当在一层遇到叶子结点，则退出循环
                flag=false;
            }
            if (node.left!==null) {
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        //如果这层没有叶子结点
        count++;
    }
    return count;
};

var minDepth = function(root) {
    if (root===null) {
        return 0;
    }
    let count=0;
    let arr=[root];

    while(true){
        let len=arr.length;
        count++;
        while(len>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                //当在一层遇到叶子结点，则退出循环,返回深度
                return count;
            }
            if (node.left!==null) {
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
    }
};
```


---
## 112.路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

方法一：广度优先搜索

首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。

这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (root===null) {
        return false;
    }
    let result=[root];
    while(result.length>0){
        let len=result.length;
        while(len>0){
            let node=result.shift();
            if (node.left!==null) {
                node.left.val+=node.val;
                result.push(node.left);
            }
            if (node.right!==null) {
                node.right.val+=node.val;
                result.push(node.right);
            }
            if (node.left===null && node.right===null) {
                if (node.val===targetSum) {
                    return true;
                }
            }
            len--;
        }
    }
    return false;
};
```

方法二：递归

观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```js
var hasPathSum = function(root, targetSum) {
    if (root===null) {
        return false;
    }
    if (root.left===null && root.right===null) {
        return targetSum===root.val;
    }
    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);
};
```


---
## 118.杨辉三角

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
提示:

1 <= numRows <= 30

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    let result=[[1]];
    for(n=2;n<=numRows;n++){
        let arr=new Array(n);
        arr[0]=1;
        arr[n-1]=1;
        for(i=1;i<n-1;i++){
            arr[i]=result[n-2][i-1]+result[n-2][i];
        }
        result.push(arr);
    }
    return result;
};

let test=5;
let result=generate(test);
console.log(result);
```


---
## 119.杨辉三角 II

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
提示:

0 <= rowIndex <= 33

```js
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let result=[1];
    for(n=2;n<=rowIndex+1;n++){
        let arr=new Array(n);
        arr[0]=1;
        arr[n-1]=1;
        for(i=1;i<n-1;i++){
            arr[i]=result[i-1]+result[i];
        }
        result=arr;
    }
    return result;
};

let test=3;
let result=getRow(test);
console.log(result);
```


---
## 121.买卖股票的最佳时机 

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

方法一：暴力法, 会超时

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let max=0;
    for (let i=1;i<prices.length;i++){
        for (let j=0;j<i;j++){
            let profit=prices[i]-prices[j]
            max=profit>max ? profit : max;
        }
    }
    return max;
};
let test=[7,1,5,3,6,4];
let result=maxProfit(test);
console.log(result);
```

方法二：一次遍历

我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```js
var maxProfit = function(prices) {
    let max=0;
    let minPrice=Number.MAX_VALUE;
    for (let i=0;i<prices.length;i++){
        if (prices[i]<minPrice) {
            minPrice=prices[i];
        }else{
            let profit=prices[i]-minPrice;
            max=profit>max ? profit : max;
        }
    }
    return max;
};
```


---
## 125.  验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s=s.toLowerCase();
    s=s.replace(/[^a-z0-9]/g,"")
    console.log(s);
    for (let i=0;i<s.length/2;i++){
        if (s[i]!==s[s.length-1-i]) {
            return false;
        }
    }
    return true;
};


let str1 = "A man, a plan, a canal: Panama";
let result=isPalindrome(str1);
console.log(result);

```


---
## 136. 只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

![只出现一次的数字位运算](E:\pogject\学习笔记\image\leetcode\只出现一次的数字位运算.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let single=0;
    for (let i=0;i<nums.length;i++){
        single^=nums[i];
    }
    return single;
};

let test=[4,1,2,1,2];
let result=singleNumber(test);
console.log(result);
```


---
## 141.环形链表

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

提示：

链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？

方法一：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if (head===null) {
        return false;
    }
    let set=new Set();
    while(head.next!==null){
        if (set.has(head)) {
            return true;
        }else{
            set.add(head);
            head=head.next;
        }
    }
    return false;
};
```

方法二：快慢指针

![环形链表快慢指针](E:\pogject\学习笔记\image\leetcode\环形链表快慢指针.png)

```js
var hasCycle = function(head) {
    if (head===null || head.next===null) {
        return false;
    }
    let slow=head;
    let fast=head.next;
    while(slow!==fast){
        if (fast===null || fast.next===null) {
            return false;
        }else{
            slow=slow.next;  //慢指针
            fast=fast.next.next;  //快指针
        }
    }
    return true;
};
```


---
## 144.二叉树的前序遍历

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[root.val];
    //递归
    result=result.concat(preorderTraversal(root.left));
    result=result.concat(preorderTraversal(root.right));
    return result;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //迭代
        let node=arr.pop();
        result.push(node.val);  //出栈
        if (node.right!==null) {
            //右子树先入栈确保后访问右子树
            arr.push(node.right);
        }
        if (node.left!==null) {
            arr.push(node.left);
        }

    }
    return result;
};
```

方法三：Morris 遍历
思路与算法

有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。

**Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减**。其前序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：

- 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
- 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。

重复步骤 2 和步骤 3，直到遍历结束。

这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let p=root;
    let q;

    let result=[];
    while(p!==null){
        let q=p.left;
        if (q!==null) {
            //如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点
            while(q.right!==null && q.right!==p){
                q=q.right;
            }
            if (q.right===null) {
                //如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。
                result.push(p.val);  //然后将当前节点加入答案
                q.right=p;  //并将前驱节点的右子节点更新为当前节点
                p=p.left;  //当前节点更新为当前节点的左子节点。
                continue;
            }else{
                //q.right!==null && q.right===p
                //如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
                q.right=null;
            }
        }else{
            //如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
            result.push(p.val);
        }
        p=p.right;
    }
    return result;
};
```


---
## 145.二叉树的后序遍历

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[];
    //递归
    result=result.concat(postorderTraversal(root.left));
    result=result.concat(postorderTraversal(root.right));
    result.push(root.val);
    return result;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //反向迭代
        let node=arr.pop();  //出栈
        result.unshift(node.val);  //从数组前面进入队列
        if (node.left!==null) {
            //左子树先入栈确保先访问右子树
            arr.push(node.left);
        }
        if (node.right!==null) {
            //后入栈，先访问
            arr.push(node.right);
        }
        
    }
    return result;
};
```




---
## 152. 乘积最大子数组

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

提示:

1 <= nums.length <= 2 * 104
-10 <= nums[i] <= 10
nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数

![最大子数组乘积](E:\pogject\学习笔记\image\leetcode\最大子数组乘积.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let n=nums.length;
    const maxF=[...nums];
    const minF=[...nums];
    let ans=maxF[0];
    for (let i=1;i<n;i++){
        maxF[i]=Math.max(maxF[i-1]*nums[i], Math.max(nums[i],minF[i-1]*nums[i]));
        ans = ans > maxF[i] ? ans : maxF[i];
        minF[i]=Math.min(minF[i-1]*nums[i], Math.min(nums[i],maxF[i-1]*nums[i]));
    }
    return ans;
};

let nums=[2,3,-2,4];
let result=maxProduct(nums);
console.log(result);
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let n=nums.length;
    let maxF=nums[0];
    let minF=nums[0];
    let ans=nums[0];
    for (let i=1;i<n;i++){
        let mx=maxF,mn=minF;
        maxF=Math.max(mx*nums[i], Math.max(nums[i],mn*nums[i]));
        ans = Math.max(maxF,ans);
        minF=Math.min(mn*nums[i], Math.min(nums[i],mx*nums[i]));
    }
    return ans;
};

let nums=[2,3,-2,4];
let result=maxProduct(nums);
console.log(result);
```




---
## 155.最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。

- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。

```js
var MinStack = function() {
    this.data=new Array();
    this.minValue=new Array();  //存储每一个栈顶对应的最小值
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    if (this.data.length===0) {
        this.minValue.push(val)
    }else{
        this.minValue.push(Math.min(this.minValue[this.minValue.length-1],val));
    }
    //顺序不能反
    this.data.push(val);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.data.pop();
    this.minValue.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.data[this.data.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.minValue[this.minValue.length-1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```


---
## 160.相交链表

给你两个单链表的头节点 headA 和 headB ，**请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。**
题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。
自定义评测：

评测系统 的输入如下（你设计的程序 不适用 此输入）：

- intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
- listA - 第一个链表
- listB - 第二个链表
- skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
- skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

提示：

- listA 中节点数目为 m

- listB 中节点数目为 n
- 1 <= m, n <= 3 * 104
- 1 <= Node.val <= 105
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    //方法一：哈希集合
    //首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中*/
    const visited=new Set();
    let p=headA;
    while(p!==null){
        visited.add(p);
        p=p.next;
    }
    p=headB;
    while(p!==null){
        if (visited.has(p)) {
            return p;
        }
        p=p.next;
    }
    return null;
};
```

![相交链表(双指针)](E:\pogject\学习笔记\image\leetcode\相交链表(双指针).png)

```js
var getIntersectionNode = function(headA, headB) {
    
    if (headA===null || headB===null) {
        return null;
    }
    let p=headA;
    let q=headB;

    while(p!==q){
        p=p===null ? headB : p.next;
        q=q===null ? headA : q.next;
    }
    return p;
};
```


---
## 168. Excel表列名称

给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

```js
/**
 * @param {number} columnNumber
 * @return {string}
 */
var convertToTitle = function(columnNumber) {

    let result=[];
    while(columnNumber>0){
        if (columnNumber===26) {
            //剩余为26的特殊处理
            result.unshift("Z");
            break;
        }
        let r=columnNumber%26;
        if (r>0) {
            let alpha=String.fromCharCode(0x60+r).toUpperCase();
            result.unshift(alpha);
            columnNumber=columnNumber-r;
        }else{
            result.unshift("Z");
            columnNumber=columnNumber-26;
        }
        //console.log(columnNumber,r);
        columnNumber=columnNumber/26;
    }
    
    return result.join("");
};

let test=52;
let result=convertToTitle(test);
console.log(result);
```

```
var convertToTitle = function(columnNumber) {
    let ans = [];
    while (columnNumber > 0) {
        const a0 = (columnNumber - 1) % 26 + 1;
        ans.push(String.fromCharCode(a0 - 1 + 'A'.charCodeAt()));
        columnNumber = Math.floor((columnNumber - a0) / 26);
    }
    ans.reverse();
    return ans.join('');
};
```


---
## 169. 多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

进阶：

尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    let n=nums.length>>1;
    //console.log(n);
    let obj={};
    for (let i=0;i<nums.length;i++){
        obj[nums[i]]===undefined ? obj[nums[i]]=1 : ++obj[nums[i]];
    }
    //console.log(obj);
    let result;
    Object.keys(obj).forEach((key)=>{
        if (obj[key]>n) {
            result=key;
        }
    });
    return result;

};

let test=[2,2,1,1,1,2,2];
let result=majorityElement(test);
console.log(result);
```

```

```


---
## 171. Excel 表列序号

给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。

```js
/**
 * @param {string} columnTitle
 * @return {number}
 */
var titleToNumber = function(columnTitle) {
    let result=0;
    let n=columnTitle.length
    for (let i=0; i<n; i++){
        let num=columnTitle.charCodeAt(n-1-i)-64;
        result+=num*Math.pow(26,i);
    }
    return result;
};


let test="FXSHRXW";
let result=titleToNumber(test);
console.log(result);
```


---
## 172. 阶乘后的零

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
提示：

0 <= n <= 104

进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？

![阶乘后的零](E:\pogject\学习笔记\image\leetcode\阶乘后的零.png)

```js
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
    let ans = 0;
    for (let i = 5; i <= n; i += 5) {
        for (let x = i; x % 5 == 0; x /= 5) {
            ++ans;
        }
    }
    return ans;
};
```

```js
var trailingZeroes = function(n) {
    let ans = 0;
    while (n !== 0) {
        n = Math.floor(n / 5);
        ans += n;
    }
    return ans;
};

```




---
## 175. 组合两个表

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：

```
FirstName, LastName, City, State
```

```mysql
select FirstName,LastName,City,State 
from Person left join Address 
on Person.PersonId=Address.PersonId;
```


---
## 181. 超过经理收入的员工

Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。
给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。

```mysql
select a.Name as 'Employee' 
from Employee as a,Employee as b 
where a.ManagerId=b.Id and a.Salary>b.Salary;
```

```mysql
select a.Name as 'Employee' 
from Employee as a join Employee as b 
on a.ManagerId=b.Id and a.Salary>b.Salary;
```


---
## 182. 查找重复的电子邮箱

编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。

```mysql
select Email from (
	select Email,count(Email) as num 
	from Person group by Email 
) as statistic where num>1;

```

```mysql
select Email from Person group by Email having count(Email) >1;
```


---
## 183. 从不订购的客户

某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

```mysql
select customers.name as 'Customers' from customers 
where customers.id not in (
	select customerid from orders
);
```


---
## 190. 颠倒二进制位

颠倒给定的 32 位无符号整数的二进制位。

提示：

输入是一个长度为 32 的二进制字符串

进阶: 如果多次调用这个函数，你将如何优化你的算法？

```js
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    let rev=0;
    for (let i=0;i<32 && n>0;++i){
        rev |=(n & 1) << (31-i);  //按位或操作符用管道符
        n >>>=1;  //无符号右移用 3 个大于号表示
    }
    return rev >>> 0;
};

```

```js
var reverseBits = function(n) {
    const M1 = 0x55555555; // 01010101010101010101010101010101
    const M2 = 0x33333333; // 00110011001100110011001100110011
    const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    const M8 = 0x00ff00ff; // 00000000111111110000000011111111

    n = n >>> 1 & M1 | (n & M1) << 1;
    n = n >>> 2 & M2 | (n & M2) << 2;
    n = n >>> 4 & M4 | (n & M4) << 4;
    n = n >>> 8 & M8 | (n & M8) << 8;
    return (n >>> 16 | n << 16) >>> 0;
};
```


---
## 191. 位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let ret=0;
    for (let i=0;i<32;i++){
        if ((n & (1 << i))!==0) {
            //当且仅当 n 的第 i 位为 1 时，运算结果不为 0。
            ret++;
        }
    }
    return ret;
};
```

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let ret=0;
    while(n){
        //因为每次运算会使得 nn 的最低位的 11 被翻转，因此运算次数就等于 nn 的二进制位中 11 的个数。
        n&=n-1;
        ret++;
    }
    return ret;
};
```


---
## 193. 有效电话号码

给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

```bash
grep -P '^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$' file.txt

awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt

gawk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt
```


---
## 195. 第十行

给定一个文本文件 file.txt，请只打印这个文件中的第十行。
说明:

如果文件少于十行，你应当输出什么？

至少有三种不同的解法，请尝试尽可能多的方法来解题。

```bash
awk 'NR=10' file.txt
sed -n 10p file.txt
tail -n +10 file.txt|head -1
```


---
## 196. 删除重复的电子邮箱

编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。
提示：

执行 SQL 之后，输出是整个 Person 表。
使用 delete 语句。

```mysql
delete p1 from Person p1,Person p2 
where p1.Email=p2.Email and p1.Id>p2.Id;
```


---
## 197. 上升的温度

编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。

返回结果 不要求顺序 。

```mysql
select weather.id as 'Id' 
from weather join weather w on DATEDIFF(weather.recordDate,w.recordDate)=1
 and weather.Temperature>w.Temperature;
```


---
198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 400

```js
/**
 * @param {number[]} nums
 * @return {number}
 */

var rob = function(nums){
    if (nums.length < 3) {
        return Math.max(...nums);
    }
    const dp = new Array(nums.length);
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0],nums[1]);
    let i = 2;
    while(i < nums.length){
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        i++;
    }
    return dp[dp.length - 1];
}

let nums=[2,7,9,3,1];
let result=rob(nums);
console.log(result);
```

```js
var rob = function(nums){
    if (nums.length < 3) {
        return Math.max(...nums);
    }

    let first = nums[0];
    let second = Math.max(nums[0],nums[1]);
    let i = 2;
    while(i < nums.length){
        let temp = second;
        second = Math.max(second, first + nums[i]);
        first = temp;
        i++;
    }
    return second;
}

```



-----

## 202. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let set=new Set();
    while(true){
        console.log(n);
        let str=n.toString();
        if (set.has(n)) {
            //如果该数已经计算过，则不是快乐数
            return false;
        }else{
            set.add(n);
        }
        n=0;
        for(let i=0;i<str.length;i++){
            n+=str[i]*str[i];
        }
        if (n===1) {
            return true;
        }
    }
};

let test=19;
let result=isHappy(test);
console.log(result);
```


---
## 203. 移除链表元素

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

方法一：递归

```js
var removeElements = function(head, val) {
    if (head===null) {
        return head;
    }
    head.next=removeElements(head.next,val);
    //相等则返回后继
    return head.val===val ? head.next : head;
};
```

方法二：迭代

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
    const pre=new ListNode(0);
    pre.next=head;
    let temp=pre;
    while(temp.next!==null){
        if (temp.next.val===val) {
            temp.next=temp.next.next;
        }else{
            temp=temp.next;
        }
    }
    return pre.next;
};
```


---
## 205. 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

提示：

1 <= s.length <= 5 * 104
t.length == s.length
s 和 t 由任意有效的 ASCII 字符组成

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
    let m1=new Map();
    let m2=new Map();
    for (let i=0;i<s.length;i++){
        if (m1.has(s[i])) {
            //当映射存在
            if (m1.get(s[i])!==t[i]) {
                return false;
            }
        }else{
            m1.set(s[i],t[i]);
        }
        if (m2.has(t[i])) {
            if (m2.get(t[i])!==s[i]) {
                return false;
            }
        }else{
            m2.set(t[i],s[i]);
        }
    }
    return true;
};

let test="paper";
let result=isIsomorphic(test,"title");
console.log(result);
```


---
## 206. 反转链表

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

方法一：迭代

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev=null;
    let curr=head;
    while(curr){
        const next=curr.next;  //当前结点的后继
        curr.next=prev;  //将当前节点的 next 指针改为指向前一个节点
        prev=curr;  //先存储其前一个节点
        curr=next;  //存储后一个节点
    }
    return prev;
};
```

方法二：递归

```js
var reverseList = function(head) {
    if (head===null || head.next===null) {
        return head;
    }
    const newHead=reverseList(head.next);
    head.next.next=head;
    head.next=null;
    return newHead;
};
```




---
## 208. 实现 Trie (前缀树)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次

```js
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @return {boolean}
 */
 //搜索
Trie.prototype.search = function(word) {
    let node=this.startsWith(word);
    //若搜索到了前缀的末尾，就说明字典树中存在该前缀。
    //此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。
    return node!==undefined && node.isEnd!==undefined;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
//查找前缀
Trie.prototype.startsWith = function(prefix) {
    let node=this.children;
    for (let ch of prefix){
        //子节点不存在。说明字典树中不包含该前缀，返回空指针
        if (!node[ch]) {
            return false;
        }
        //子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
        node=node[ch];
    }
    return node;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

let test=new Trie();

test.insert("apple");
result=test.search("apple");
console.log(result);  //true

result=test.search("app");
console.log(result);  //false

result=test.startsWith("app");
console.log(result);  //

test.insert("app");
result=test.search("app");
console.log(result);  //
```


---
## 215. 数组中的第K个最大元素

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
提示：

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
	nums.sort((a,b)=>b-a);
	return nums[k-1];
};
```

**基于快速排序的选择方法**

![数组中的第K个最大元素_基于快速排序的选择方法](E:\pogject\学习笔记\image\leetcode\数组中的第K个最大元素_基于快速排序的选择方法.png)

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
*/
var findKthLargest = function(nums, k) {
    return quickSelect(nums, 0, nums.length - 1, nums.length - k);
};


var quickSelect=(arr, left, right, index)=>{
    let q = randomPartition(arr, left, right);  //基准
    if (q === index) {
        return arr[q];
    }else{
        if (q < index) {
            return quickSelect(arr, q + 1, right, index);
        }else{
            return quickSelect(arr, left, q - 1, index);
        }
    }
}

//
var randomPartition=(arr,left,right)=>{
    let i = Math.floor(Math.random() * (right - left + 1)) + left;
    swap(arr, i, right);
    return partition(arr, left, right);
}

var partition=(arr, left, right)=>{
    let datum = arr[right];
    let i = left - 1;
    for (let j = left; j < right; j++){
        if (arr[j] <= datum) {
            swap(arr ,++i, j);
        }
    }
    swap(arr, i+1, right);
    return i+1;
}

//交换元素
var swap=(arr,i,j)=>{
    let temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6];

console.log(findKthLargest(test,4));  //
```

**基于堆排序的选择方法**

我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k - 1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
*/
var findKthLargest = function(nums, k) {
	//从nums中取出前k个数，构建一个小顶锥
	let heapSize = nums.length;
	bulidMaxHeap(nums,heapSize);
	for (let i = nums.length - 1; i >= nums.length - k + 1; i--){
		swap(nums, 0, i);
		heapSize--;
		maxHeapify(nums,0,heapSize);
	}
	return nums[0];  //返回堆顶元素
};

// 原地建堆，从后往前，自上而下式建小顶堆
var bulidMaxHeap = (arr, heapSize)=>{
	for (let i=Math.floor(heapSize/2); i >= 0; i--){
		maxHeapify(arr,i,heapSize);
	}
}

//堆化
var maxHeapify = (arr, i, heapSize)=>{
	let left = i*2 + 1;
	let right = i*2 + 2;
	let largest = i;
	if (left < heapSize && arr[left] > arr[largest]) {
		largest = left;
	}
	if (right < heapSize && arr[right] > arr[largest]) {
		largest = right;
	}

	if (largest !== i) {
		swap(arr, i, largest);
		maxHeapify(arr, largest, heapSize);
	}
}

//交换元素
var swap=(arr,i,j)=>{
	let temp=arr[i];
	arr[i]=arr[j];
	arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```



---

## 217. 存在重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
    let set=new Set();
    for(let i=0;i<nums.length;i++){
        if (set.has(nums[i])) {
            return true;
        }else{
            set.add(nums[i]);
        }
    }
    return false;
};

let test=[1,1,1,3,3,4,3,2,4,2];
let result=containsDuplicate(test);
console.log(result);
```


---
## 219. 存在重复元素 II

给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。

方法一：哈希表

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    let m=new Map();
    for(let i=0;i<nums.length;i++){
        if (m.has(nums[i])) {
            if (Math.abs(m.get(nums[i])-i)<=k) {
                return true;
            }else{
                m.set(nums[i],i);
            }
        }else{
            m.set(nums[i],i);
        }
        //console.log(m);
    }
    return false;
};

let test=[1,0,1,1];
let result=containsNearbyDuplicate(test,1);
console.log(result);
```

方法二：滑动窗口

```js
var containsNearbyDuplicate = function(nums, k) {
    const set = new Set();
    const length = nums.length;
    for (let i = 0; i < length; i++) {
        if (i > k) {
            set.delete(nums[i - k - 1]);
        }
        if (set.has(nums[i])) {
            return true;
        }
        set.add(nums[i])
    }
    return false;
};

```


---
## 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

提示：

1 <= x <= 9
最多调用100 次 push、pop、top 和 empty
每次调用 pop 和 top 都保证栈不为空

进阶：你能否仅用一个队列来实现栈。

方法一：两个队列

```js
var MyStack = function() {
    this.queue1=[];
    this.queue2=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue2.push(x);
    while(this.queue1.length>0){
        this.queue2.push(this.queue1.shift());
    }
    let temp=this.queue1;
    this.queue1=this.queue2;
    this.queue2=temp;
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    return this.queue1.shift();
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue1[0];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue1.length===0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */

```

方法二：一个队列

```js
var MyStack = function() {
    this.queue=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    let n=this.queue.length;
    this.queue.push(x);
    for (let i=0;i<n;i++){
        this.queue.push(this.queue.shift());
    }
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    return this.queue.shift();
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue[0];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length===0;
};
```


---
## 226. 翻转二叉树

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (root===null) {
        return root;
    }
    if (root.left || root.right) {
        let temp=root.left;
        root.left=root.right;
        root.right=temp;
        invertTree(root.left);
        invertTree(root.right);
    }
    return root;
};
```

```js
var invertTree = function(root) {
    if (root === null) {
        return null;
    }
    const left = invertTree(root.left);
    const right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
};
```


---
## 228. 汇总区间

给定一个  无重复元素 的 有序 整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

"a->b" ，如果 a != b
"a" ，如果 a == b

提示：

0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
nums 中的所有值都 互不相同
nums 按升序排列

```js
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    if (nums.length===0) {
        return [];
    }
    let i=0;
    let j=1;
    let result=[];
    for(j;j<nums.length;j++){
        if (nums[j]-nums[j-1]!==1) {
            if (i===j-1) {
                result.push(nums[i].toString());
            }else{
                result.push(nums[i].toString()+"->"+nums[j-1].toString());
            }
            i=j;
        }
    }
    if (i===j-1) {
        result.push(nums[i].toString());
    }else{
        result.push(nums[i].toString()+"->"+nums[j-1].toString());
    }
    return result;
};

let test=[0,1,2,4,5,7];
let result=summaryRanges(test);
console.log(result);
```

```js
var summaryRanges = function(nums) {
    const ret = [];
    let i = 0;
    const n = nums.length;
    while (i < n) {
        const low = i;
        i++;
        while (i < n && nums[i] === nums[i - 1] + 1) {
            i++;
        }
        const high = i - 1;
        const temp = ['' + nums[low]];
        if (low < high) {
            temp.push('->');
            temp.push('' + nums[high]);
        }
        ret.push(temp.join(''));
    }
    return ret;
};
```


---
## 231. 2 的幂

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

进阶：你能够不使用循环/递归解决此问题吗？出处。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    if (n<=0) {
        //小于等于0的不满足
        return false;
    }
    while(n>=1){
        if (n===1) {
            return true;
        }
        if (n%2!==0) {
            //如果不能被2整除则不满足
            return false;
        }
        n=n/2;
    }
};

let test=5;
let result=isPowerOfTwo(test);
console.log(result);
```

![2 的幂（二进制表示）](E:\pogject\学习笔记\image\leetcode\2 的幂（二进制表示）.png)

判断是否为最大 2 的幂的约数

```js
var isPowerOfTwo = function(n) {
    const BIG = 1 << 30;
    return n > 0 && BIG % n === 0;
};
```


---
## 232. 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
进阶：

你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。

```js
var MyQueue = function() {
    this.stack1=[];  //用于存储
    this.stack2=[];  //用于反转元素的入队顺序
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    while(this.stack1.length>0){
        //把栈1的所有元素弹出到栈2
        this.stack2.push(this.stack1.pop());
    }
    this.stack1.push(x);  //进队列元素压到栈1底部
    while(this.stack2.length>0){
        //把栈2的所有元素弹出到栈1
        this.stack1.push(this.stack2.pop());
    }
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    return this.stack1.pop();
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    return this.stack1[this.stack1.length-1];
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.stack1.length===0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

```js
var MyQueue = function() {
    this.stack1=[];  //用于存储
    this.stack2=[];  //反转元素的入队顺序
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    while(this.stack1.length>0){
        //把栈1的所有元素弹出到栈2
        this.stack2.push(this.stack1.pop());
    }
    this.stack1.push(x);  //进队列元素压到栈1底部
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    while(this.stack2.length>0){
        //把栈2的所有元素弹出到栈1
        this.stack1.push(this.stack2.pop());
    }
    return this.stack1.pop();
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    while(this.stack2.length>0){
        //把栈2的所有元素弹出到栈1
        this.stack1.push(this.stack2.pop());
    }
    return this.stack1[this.stack1.length-1];
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.stack1.length===0 && this.stack2.length===0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```


---
## 234. 回文链表

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
提示：

链表中节点数目在范围[1, 105] 内
0 <= Node.val <= 9

进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    let nums=[];
    while(head!==null){
        nums.push(head.val);
        head=head.next;
    }
    let n=nums.length;
    let m=n>>1;
    for(let i=0;i<m;i++){
        if (nums[i]!==nums[n-1-i]) {
            return false;
        }
    }
    return true;

};
```

递归

```js
let frontPointer;

const recursivelyCheck = (currentNode) => {
    if (currentNode !== null) {
        if (!recursivelyCheck(currentNode.next)) {
            return false;
        }
        if (currentNode.val !== frontPointer.val) {
            return false;
        }
        frontPointer = frontPointer.next;
    }
    return true;
}

var isPalindrome = function(head) {
    frontPointer = head;
    return recursivelyCheck(head);
};
```


---
## 235. 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。

![二叉搜索树的最近公共祖先（两次遍历）](E:\pogject\学习笔记\image\leetcode\二叉搜索树的最近公共祖先（两次遍历）.png)

一次遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    //注意是二叉搜索
    if (root.val<p.val && root.val<q.val) {
        return lowestCommonAncestor(root.right,p,q);
    }else if(root.val>p.val && root.val>q.val) {
        return lowestCommonAncestor(root.left,p,q);
    }else{
        //返回的是结点
        return root;
    }
};
```


---
## 237. 删除链表中的节点

请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。

题目数据保证需要删除的节点 不是末尾节点 。

提示：

链表中节点的数目范围是 [2, 1000]
-1000 <= Node.val <= 1000
链表中每个节点的值都是唯一的
需要删除的节点 node 是 链表中的一个有效节点 ，且 不是末尾节点

删除链表中的节点的常见的方法是定位到待删除节点的上一个节点，修改上一个节点的 next 指针，使其指向待删除节点的下一个节点，即可完成删除操作。

这道题中，传入的参数 node 为要被删除的节点，无法定位到该节点的上一个节点。注意到要被删除的节点不是链表的末尾节点，因此 node.next 不为空，可以通过对 node 和 node.next 进行操作实现删除节点。

在给定节点 node 的情况下，可以通过修改 node 的 next 指针的指向，删除 node 的下一个节点。但是题目要求删除 node，为了达到删除 node 的效果，只要在删除节点之前，将 node 的节点值修改为 node.next 的节点值即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    node.val=node.next.val;
    node.next=node.next.next;
};
```


---
## 242.  有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

使用数组计数

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length!==t.length) {
        return false;
    }
    var alphas1=new Array();
    var alphas2=new Array();
    var counts1=new Array();
    var counts2=new Array();
    for (let i=0;i<s.length;i++){
        let index1=alphas1.indexOf(s[i]);
        let index2=alphas2.indexOf(t[i]);
        if (index1!==-1) {
            counts1[index1]+=1;
        }else{
            counts1.push(1);
            alphas1.push(s[i]);
        }
        if (index2!==-1) {
            counts2[index2]+=1;
        }else{
            counts2.push(1);
            alphas2.push(t[i]);
        }
    }
    if (alphas1.length!==alphas2.length) {return false;}
    for (let i=0;i<alphas1.length;i++){
        if (counts1[i]!==counts2[alphas2.indexOf(alphas1[i])]) {
            return false;
        }
    }
    return true;

};

let str1 = "anaagram";
let str2 = "naggaram";
let result=isAnagram(str1,str2);
console.log(result);
```

使用对象计数




---
## 257. 二叉树的所有路径

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。
提示：

树中节点的数目在范围 [1, 100] 内
-100 <= Node.val <= 100

迭代

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    root.val=[root.val];
    let arr=[root];
    let result=[];
    while(arr.length>0){
        let n=arr.length;
        while(n>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                result.push(node.val.join("->"));
            }
            if (node.left!==null) {
                node.left.val=node.val.concat([node.left.val])
                arr.push(node.left);
            }
            if (node.right!==null) {
                node.right.val=node.val.concat([node.right.val])
                arr.push(node.right);
            }
            n--;
        }
    }
    return result;
};
```

方法一：深度优先搜索    二：广度优先搜索

```

```


---
## 258. 各位相加

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。

提示：

0 <= num <= 231 - 1

进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

```js
/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {

    while(num>9){
        let arr=(""+num).split("");
        num=0;
        arr.forEach((item)=>{
            num+=Number(item);
        });
        console.log(num);
    }
    return num;
};

let test=236;
let result=addDigits(test);
console.log(result);
```

对于9的倍数来说，各位和肯定是9，81=8+1=9 729=7+2+9=18=1+8=9

任何数都可以表现为 9n+b b in [0,1,2,3,4,5,6,7,8]

已知9n各位和为9，最后结果即为9+b

最后对0做一下特殊处理

```js
/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
    if (num===0) {
        return 0;
    }
    if (num%9===0) {
        return 9;
    }else{
        return num%9;
    }
};

let test=236;
let result=addDigits(test);
console.log(result);
```


---
## 263. 丑数

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

![判断丑数](E:\pogject\学习笔记\image\leetcode\判断丑数.png)

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isUgly = function(n) {
    if (n<=0) {
        return false;
    }
    let factors=[2,3,5];
    for (let f of factors){
        //对n反复除以2,3,5
        while(n%f===0){
            n/=f;
        }
    }
    return n===1;
};

let test=100;
let result=isUgly(test);
console.log(result);
```


---
## 268. 丢失的数字

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
提示：

n == nums.length
1 <= n <= 104
0 <= nums[i] <= n
nums 中的所有数字都 独一无二

进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

数学方法

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let n=nums.length;
    let sum=n*(n+1)/2;
    for (let i=0;i<n;i++){
        sum-=nums[i];
    }
    return sum;
};

let test=[9,6,4,2,3,5,7,0,1];
let result=missingNumber(test);
console.log(result);
```

排序

将数组排序之后，即可根据数组中每个下标处的元素是否和下标相等，得到丢失的数字。

```js
var missingNumber = function(nums) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i) {
            return i;
        }
    }
    return n;
};

```

哈希集合

使用哈希集合，可以将时间复杂度降低到 O(n)*O*(*n*)。

```js
var missingNumber = function(nums) {
    const set = new Set();
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        set.add(nums[i]);
    }
    let missing = -1;
    for (let i = 0; i <= n; i++) {
        if (!set.has(i)) {
            missing = i;
            break;
        }
    }
    return missing;
};

```

位运算

```js
var missingNumber = function(nums) {
    let xor = 0;
    const n = nums.length;
    for (let i = 0; i < nums.length; i++) {
        xor ^= nums[i];
    }
    for (let i = 0; i <= n; i++) {
        xor ^= i;
    }
    return xor;
};

```


---
## 278. 第一个错误的版本

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

 

提示：

1 <= bad <= n <= 231 - 1

```js
/**
 * Definition for isBadVersion()
 * 
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n) {
        let left=1;
        let right=n;
        while(left<right){
             let mid = Math.floor(left + (right - left) / 2); // 防止计算时溢出
            if (isBadVersion(mid)) {
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    };
};

```




---
## 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

双指针

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

1. 左指针左边均为非零数；
2. 右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。



```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let flag1=nums.length-1;  //标识最后的最后一个非0的位置
    for (let i=nums.length-1;i>=0;i--) {
        if (nums[i]===0) {
            if (i!==flag1) {
                for (let j=i;j<flag1;j++){
                    nums[j]=nums[j+1];
                }
                nums[flag1]=0;
                flag1--;
            }else{
                flag1--;
            }
        }
    }
    return nums;
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let result=moveZeroes(str1);
//console.log(typeof result);
console.log(result);

```


---
## 290. 单词规律

给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

说明:
你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    

```js
/**
 * @param {string} pattern
 * @param {string} s
 * @return {boolean}
 */
var wordPattern = function(pattern, s) {
    s=s.split(" ");
    if (pattern.length!==s.length) {
        return false;
    }
    let m1=new Map();
    let m2=new Map();
    for(let i=0;i<pattern.length;i++){
        if(m1.has(pattern[i])){
            if (m1.get(pattern[i])!==s[i]) {
                return false;
            }
        }else{
            m1.set(pattern[i],s[i]);
        }
        if(m2.has(s[i])){
            if (m2.get(s[i])!==pattern[i]) {
                return false;
            }
        }else{
            m2.set(s[i],pattern[i]);
        }
    }
    return true;
};

let test="dog cat cat fish";
let result=wordPattern("abba",test);
console.log(result);
```


---
## 292. Nim 游戏

你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合， 你作为先手 。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

提示：

1 <= n <= 231 - 1

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    return n%4!==0;
};

let test=5;
let result=canWinNim(test);
console.log(result);
```


---
## 303. 区域和检索 - 数组不可变

给定一个整数数组  nums，处理以下类型的多个查询:

计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )

提示：

0 <= nums.length <= 104
-105 <= nums[i] <= 105
0 <= i <= j < nums.length
最多调用 104 次 sumRange 方法

```js
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.nums=nums;
};

/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    let sum=this.nums[right];
    for (let i=left;i<right;i++){
        sum+=this.nums[i];
    }
    return sum;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */

```

```js
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    let n=nums.length;
    this.sums=new Array(n+1).fill(0); //前n个数的和
    for (let i=0;i<n;i++){
        this.sums[i+1]=this.sums[i]+nums[i];
    }
};

/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    return this.sums[right+1]-this.sums[left];
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */

```


---
## 306.累加数

累加数 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。

说明：累加序列里的数 不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。

提示：

1 <= num.length <= 35
num 仅由数字（0 - 9）组成

进阶：你计划如何处理由过大的整数输入导致的溢出?

```
/**
 * @param {string} num
 * @return {boolean}
 */
var isAdditiveNumber = function(num) {
    if (num.length<3) {
        //累加数至少3位才行
        return false;
    }
    let len=num.length;
    let i=0,j=1,k=2;
    let a,b;
    let sumab;
    while(i<len){
        a=Number(num.slice(0,i));
        while(j<len-Math.max(j-i,i)){
            b=Number(num.slice(i,j));
            while(k<len-Math.max(j-i,i)){
                c=(a+b).toString();
                if (num.indexOf(c)!==k) {

                }
            }
            
            
        }
    }
    return false;
};

let test= "199100199";
let result=isAdditiveNumber(test);
console.log(result);
```


---
## 307.区域和检索 - 数组可修改

给你一个数组 nums ，请你完成两类查询。

其中一类查询要求 更新 数组 nums 下标对应的值
另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 用整数数组 nums 初始化对象
void update(int index, int val) 将 nums[index] 的值 更新 为 val
int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）

```js
var NumArray = function(nums) {
    this.nums = nums;
    const n = nums.length;
    size = Math.floor(Math.sqrt(n));
    this.sum = new Array(Math.floor((n + size - 1) / size)).fill(0); // n/size 向上取整
    for (let i = 0; i < n; i++) {
        this.sum[Math.floor(i / size)] += nums[i];
    }
};

NumArray.prototype.update = function(index, val) {
    this.sum[Math.floor(index / size)] += val - this.nums[index];
    this.nums[index] = val;
};

NumArray.prototype.sumRange = function(left, right) {
    const b1 = Math.floor(left / size), i1 = left % size, b2 = Math.floor(right / size), i2 = right % size;
    if (b1 === b2) { // 区间 [left, right] 在同一块中
        let sum = 0;
        for (let j = i1; j <= i2; j++) {
            sum += this.nums[b1 * size + j];
        }
        return sum;
    }
    let sum1 = 0;
    for (let j = i1; j < size; j++) {
        sum1 += this.nums[b1 * size + j];
    }
    let sum2 = 0;
    for (let j = 0; j <= i2; j++) {
        sum2 += this.nums[b2 * size + j];
    }
    let sum3 = 0;
    for (let j = b1 + 1; j < b2; j++) {
        sum3 += this.sum[j];
    }
    return sum1 + sum2 + sum3;
};
```


---
## 310. 最小高度树

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。

树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。

提示：

1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
所有 (ai, bi) 互不相同
给定的输入 保证 是一棵树，并且 不会有重复的边

```
var findMinHeightTrees = function(n, edges) {
    const ans = [];
    if (n === 1) {
        ans.push(0);
        return ans;
    }
    const adj = new Array(n).fill(0).map(() => new Array());
    for (const edge of edges) {
        adj[edge[0]].push(edge[1]);
        adj[edge[1]].push(edge[0]);
    }

    const parent = new Array(n).fill(-1);
    /* 找到与节点 0 最远的节点 x */
    const x = findLongestNode(0, parent, adj);
    /* 找到与节点 x 最远的节点 y */
    let y = findLongestNode(x, parent, adj);
    /* 求出节点 x 到节点 y 的路径 */
    const path = [];
    parent[x] = -1;
    while (y !== -1) {
        path.push(y);
        y = parent[y];
    }
    const m = path.length;
    if (m % 2 === 0) {
        ans.push(path[Math.floor(m / 2) - 1]);
    }
    ans.push(path[Math.floor(m / 2)]);
    return ans;
}

const findLongestNode = (u, parent, adj) => {
    const n = adj.length;
    const queue = [];
    const visit = new Array(n).fill(false);
    queue.push(u);
    visit[u] = true;
    let node = -1;

    while (queue.length) {
        const curr = queue.shift();
        node = curr;
        for (const v of adj[curr]) {
            if (!visit[v]) {
                visit[v] = true;
                parent[v] = curr;
                queue.push(v);
            }
        }
    }
    return node;
};

let n = 4, edges = [[1,0],[1,2],[1,3]];
let result=findMinHeightTrees(n,edges);
console.log(result);
```




---
## 326. 3 的幂

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x

进阶：你能不使用循环或者递归来完成本题吗？

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    if (n<=0) {
        return false;
    }
    if (n%3!==0 && n!==1) {
        return false;
    }
    while(n>1){
        n/=3;
    }
    return n===1;
};

let test=81;
let result=isPowerOfThree(test);
console.log(result);
```

```

```


---
## 334.递增的三元子序列

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

提示：

1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1

**进阶：**你能实现时间复杂度为 `O(n)` ，空间复杂度为 `O(1)` 的解决方案吗？

暴力解法，超时

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    if (nums.length<3) {
        return false;
    }
    let flag=0;
    let i;
    for (let i=0;i<nums.length-2;){
        for (let j=i+1;j<nums.length-1;j++){
            if (nums[i]<nums[j]) {
                for (let k=j+1;k<nums.length;k++){
                    if (nums[j]<nums[k]) {
                        return true;
                    }
                }
            }
            
        }
    }
    return false;
};

let test=[2,1,5,0,4,6];
let result=increasingTriplet(test);
console.log(result);
```

找到局部最小最大值

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    if (nums.length<3) {
        return false;
    }
    let min=nums[0]<nums[1] ? nums[0] : nums[1];  //局部最小在第一个与第二个开始计算
    let max=nums[1];  //局部最大值从第二个值开始计算
    for (let i=2;i<nums.length;i++){
        if (min<max) {
            //如果已经找到max>min
            if (nums[i]>max) {
                //如果当前值大于max,则满足题意条件
                return true;
            }else{
                //如果不满足
                if (nums[i]<=min) {
                    //如果当前值比min小，就把min设为当前值
                    min=nums[i];
                }else{
                    //如果当前值比min大，把max设为当前值，
                    max=nums[i];
                }
            }
        }else{
            //当min>max时，从第二个开始值都不大于前面的时候
            if (nums[i]<=min) {
                //如果当前值比min小，就把min,max都设为当前值
                max=nums[i];
                min=nums[i];
            }else{
                //如果当前值比min大，把max设为当前值，后面就会满足max>min了
                max=nums[i];
            }
        }
    }
    return false;
};

let test=[1,0,0,0,0,-1,0,0,0,1000];  //[1,1,-2,6]
let result=increasingTriplet(test);
console.log(result);
```

![递增的三元子序列（双向遍历）](E:\pogject\学习笔记\image\leetcode\递增的三元子序列（双向遍历）.png)

![递增的三元子序列（贪心）](E:\pogject\学习笔记\image\leetcode\递增的三元子序列（贪心）.png)


---
## 


---
## 338. 比特位计数

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。
提示：

0 <= n <= 105


进阶：

很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）

**提示：**

- `0 <= n <= 105`

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var countBits = function(n) {
    let result=[0];
    let len=1;
    while(n>0){
        len=result.length < n ? result.length : n;
        for(let i=0;i<len;i++){
            result.push(1+result[i])
        }
        n=n-len;
    }
    //console.log(result);
    return result;
};

for(let i=0;i<=64;i++){
    let result=countBits(i);
    console.log(i,result[i]);
}

```

Brian Kernighan 算法

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 0; i <= n; i++) {
        bits[i] = countOnes(i);
    }
    return bits
};

const countOnes = (x) => {
    let ones = 0;
    while (x > 0) {
        x &= (x - 1);
        ones++;
    }
    return ones;
}

```

动态规划——最高有效位

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    let highBit = 0;
    for (let i = 1; i <= n; i++) {
        if ((i & (i - 1)) == 0) {
            highBit = i;
        }
        bits[i] = bits[i - highBit] + 1;
    }
    return bits;
};

```

动态规划——最低有效位

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        bits[i] = bits[i >> 1] + (i & 1);
    }
    return bits;
};
```

动态规划——最低设置位

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        bits[i] = bits[i & (i - 1)] + 1;
    }
    return bits;
};
```




---
## 342. 4的幂

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

**进阶：**你能不使用循环或者递归来完成本题吗？

二进制表示中 11 的位置

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfFour = function(n) {
    return n>0 && (n&(n-1))===0 && (n&0xaaaaaaaa)===0;
};
```

如果 n 是 4的幂，那么它可以表示成 4^x的形式，我们可以发现它除以 3 的余数一定为 1，

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfFour = function(n) {
     return n > 0 && (n & (n - 1)) === 0 && n % 3 === 1;
};
```


---
## 344. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    let n=s.length-1;
    let m=n>>1;
    for(let i=0;i<=m;i++){
        let temp=s[i];
        s[i]=s[n-i];
        s[n-i]=temp;
    }
    return s;
};

let test= ["A"," ","m","a","n",","," ","a"," ","p","l","a","n",","," ","a"," ","c","a","n","a","l",":"," ","P","a","n","a","m","a"];
let result=reverseString(test);
console.log(result);
```

```js
var reverseString = function(s) {
    const n = s.length;
    for (let left = 0, right = n - 1; left < right; ++left, --right) {
        [s[left], s[right]] = [s[right], s[left]];
    }
};

```


---
## 345. 反转字符串中的元音字母

给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
    s=s.split("");
    let right=s.length-1;
    let left=0;
    let temp="";
    let set=new Set(["a","e","i","o","u","A","E","I","O","U"]);
    //console.log(set);
    while(left<right){
        if (set.has(s[left])) {
            temp=s[left];
            if (set.has(s[right])) {
                s[left]=s[right];
                s[right]=temp;
                left++;
                right--;
            }else{
                right--;
            }
        }else{
            left++;
        }
    }
    return s.join("");
};

let test="leetcode";
let result=reverseVowels(test);
console.log(result);
```


---
## 349. 两个数组的交集

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
提示：

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    let result=[];
    let set=new Set();
    for(let i=0;i<nums1.length;i++){
        set.add(nums1[i]);
    }
    for(let i=0;i<nums2.length;i++){
        if (set.has(nums2[i])) {
            result.push(nums2[i]);
            set.delete(nums2[i]);
        }
    }
    return result;
};

let test=[1,2,4,2,1,4,6];
let result=intersection(test,[9,4,9,8,4]);
console.log(result);
```

```js
const set_intersection = (set1, set2) => {
    if (set1.size > set2.size) {
        return set_intersection(set2, set1);
    }
    const intersection = new Set();
    for (const num of set1) {
        if (set2.has(num)) {
            intersection.add(num);
        }
    }
    return [...intersection];
}

var intersection = function(nums1, nums2) {
    const set1 = new Set(nums1);
    const set2 = new Set(nums2);
    return set_intersection(set1, set2);
};

```


---
## 350. 两个数组的交集 II

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

```js

```

使用双指针

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
    nums1.sort((a,b)=>a-b);
    nums2.sort((a,b)=>a-b);

    let i=0,j=0;
    let results=new Array();
    let temp=nums1[0];
    for (i=0,j=0;i<nums1.length,j<nums2.length;){
        if (nums1[i]==nums2[j]) {
            results.push(nums1[i]);
            i++;
            j++;
        }else{
            if (nums1[i]<nums2[j]) {
                i++;
            }else{
                j++;
            }
        }
    }
    return results;
};
```


---
## 357. 统计各位数字都不同的数字个数

给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10n 。

提示：

0 <= n <= 8

暴力超时

```js
/**
 * @param {number} n
 * @return {number}
 */
var countNumbersWithUniqueDigits = function(n) {
    let maxValue=Math.pow(10,n);
    let ans=0;
    let s;
    for (let i=0;i<maxValue;i++){
        i=""+i;
        s=new Set([...i]);
        if (i.length===s.size) {
            ans++;
        }
    }
    return ans;
};

let n=5;
let result=countNumbersWithUniqueDigits(n);
console.log(result);
```

排列组合

```js
/**
 * @param {number} n
 * @return {number}
 */
var countNumbersWithUniqueDigits = function(n) {
    if (n===0) {
        return 1;
    }
    if (n===1) {
        return 10;
    }
    let ans=10,cur=9;
    for (let i=0;i<n-1;i++){
        cur*=9-i;
        ans+=cur;
    }

    
    return ans;
};
let n=5;
let result=countNumbersWithUniqueDigits(n);
console.log(result);
```




---
## 367. 有效的完全平方数

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

提示：

1 <= num <= 2^31 - 1

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
    let result=true;
    //2分法
    let left=0;
    let right=num;
    let mid;
    while(left<=right){
        mid=(left+right)>>1;
        if(mid*mid>num) {
            right=mid-1;
        }else if(mid*mid<num){
            left=mid+1;
        }else{
            return true;
        }
        //console.log(mid);
    }
    return false;
};

let test=100000000;
let result=isPerfectSquare(test);
console.log(result);

```




---
## 373.查找和最小的K对数字

给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

提示:

- 1 <= nums1.length, nums2.length <= 104
- -109 <= nums1[i], nums2[i] <= 109
- nums1, nums2 均为升序排列
- 1 <= k <= 1000

```
var kSmallestPairs = function(nums1, nums2, k) {
    m = nums1.length
    n = nums2.length
    /*二分查找第 k 小的数对和的大小*/
    let left = nums1[0] + nums2[0];
    let right = nums1[m - 1] + nums2[n - 1];
    let pairSum = right;
    while (left <= right) {
        const mid = left + ((right - left) >> 1);
        let cnt = 0;
        let start = 0;
        let end = n - 1;
        while (start < m && end >= 0) {
            if (nums1[start] + nums2[end] > mid) {
                end--;
            } else {
                cnt += end + 1;
                start++;
            }
        }
        if (cnt < k) {
            left = mid + 1;
        } else {
            pairSum = mid;
            right = mid - 1;
        }
    }

    const ans = [];
    let pos = n - 1;
    /*找到小于目标值 pairSum 的数对*/
    for (let i = 0; i < m; i++) {
        while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {
            pos--;
        }
        for (let j = 0; j <= pos && k > 0; j++, k--) {
            const list = [];
            list.push(nums1[i]);
            list.push(nums2[j]);
            ans.push(list);
        }
    }

    /*找到等于目标值 pairSum 的数对*/
    pos = n - 1;
    for (let i = 0; i < m && k > 0; i++) {
        while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {
            pos--;
        }
        for (let j = i; k > 0 && j >= 0 && nums1[j] + nums2[pos] == pairSum; j--, k--) {
            const list = [];
            list.push(nums1[i]);
            list.push(nums2[pos]);
            ans.push(list);
        }
    }
    return ans;
}

let str1=[0,1,3,6];
let str2=[2,3,4,5];
let result=kSmallestPairs(str1,str2,3);
console.log(result);

```


---
## 374. 猜数字大小

猜数字游戏的规则如下：

每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

-1：我选出的数字比你猜的数字小 pick < num
1：我选出的数字比你猜的数字大 pick > num
0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。

提示：

1 <= n <= 231 - 1
1 <= pick <= n

```js
/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return              -1 if num is lower than the guess number
 *                       1 if num is higher than the guess number
 *                       otherwise return 0
 */
var guess = function(num) {
    if (num>1702766719) {
        return -1;
    }else if(num<1702766719){
        return 1;
    }else{
        return 0;
    }
}


/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    let left=1;
    let right=n;
    let mid;
    while(left<right){
        mid= Math.floor(left + (right - left) / 2);  // 防止计算时溢出;
        if(guess(mid)===-1) {
            right=mid-1;
        }else if(guess(mid)===1){
            left=mid+1;
        }else{
            return mid;
        }
        //console.log(mid);
    }
    return left;
};

let test=2126753390;
let result=guessNumber(test);
console.log(result);
```

380. O(1) 时间插入、删除和获取随机元素

实现RandomizedSet 类：

RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。

```js
var RandomizedSet = function() {
    this.nums = [];
    this.indices = new Map();
};

RandomizedSet.prototype.insert = function(val) {
    if (this.indices.has(val)) {
        return false;
    }
    let index = this.nums.length;
    this.nums.push(val);
    this.indices.set(val, index);
    return true;
};

RandomizedSet.prototype.remove = function(val) {
    if (!this.indices.has(val)) {
        return false;
    }
    let id = this.indices.get(val);
    this.nums[id] = this.nums[this.nums.length - 1];
    this.indices.set(this.nums[id], id);
    this.nums.pop();
    this.indices.delete(val);
    return true;
};

RandomizedSet.prototype.getRandom = function() {
    const randomIndex = Math.floor(Math.random() * this.nums.length);
    return this.nums[randomIndex];
};


```




---
## 383. 赎金信

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

提示：

1 <= ransomNote.length, magazine.length <= 105
ransomNote 和 magazine 由小写英文字母组成

```js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    let m=new Map();
    for(let i=0;i<magazine.length;i++){
        m.set(magazine[i],m.has(magazine[i]) ? m.get(magazine[i])+1 : 1);
    }
    for(let i=0;i<ransomNote.length;i++){
        if (m.has(ransomNote[i])) {
            if (m.get(ransomNote[i])===0) {
                return false;
            }else{
                m.set(ransomNote[i],m.get(ransomNote[i])-1);
            }
        }else{
            return false;
        }
    }
    return true;
};


let test="ab";
let result=canConstruct("aa",test);
console.log(result);

```


---
## 385.迷你语法分析器

给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。

列表中的每个元素只可能是整数或整数嵌套列表

提示：

1 <= s.length <= 5 * 104
s 由数字、方括号 "[]"、负号 '-' 、逗号 ','组成
用例保证 s 是可解析的 NestedInteger
输入中的所有值的范围是 [-106, 106]

```
var deserialize = function(s) {
    let index = 0;
    const dfs = (s) => {
        if (s[index] === '[') {
            index++;
            const ni = new NestedInteger();
            while (s[index] !== ']') {
                ni.add(dfs(s));
                if (s[index] === ',') {
                    index++;
                }
            }
            index++;
            return ni;
        } else {
            let negative = false;
            if (s[index] === '-') {
                negative = true;
                index++;
            }
            let num = 0;
            while (index < s.length && isDigit(s[index])) {
                num = num * 10 + s[index].charCodeAt() - '0'.charCodeAt();
                index++;
            }
            if (negative) {
                num *= -1;
            }
            return new NestedInteger(num);
        }
    }
    return dfs(s);
};

const isDigit = (ch) => {
    return parseFloat(ch).toString() === "NaN" ? false : true;
}


```

```
var deserialize = function(s) {
    if (s[0] !== '[') {
        return new NestedInteger(parseInt(s));
    }
    const stack = [];
    let num = 0;
    let negative = false;
    for (let i = 0; i < s.length; i++) {
        const c = s[i];
        if (c === '-') {
            negative = true;
        } else if (isDigit(c)) {
            num = num * 10 + c.charCodeAt() - '0'.charCodeAt();
        } else if (c === '[') {
            stack.push(new NestedInteger());
        } else if (c === ',' || c === ']') {
            if (isDigit(s[i - 1])) {
                if (negative) {
                    num *= -1;
                }
                stack[stack.length - 1].add(new NestedInteger(num));
            }
            num = 0;
            negative = false;
            if (c === ']' && stack.length > 1) {
                const ni = stack.pop();
                stack[stack.length - 1].add(ni);
            }
        }
    }
    return stack.pop();
};

const isDigit = (ch) => {
    return parseFloat(ch).toString() === "NaN" ? false : true;
}

```


---
## 386.字典序排数

给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var lexicalOrder = function(n) {
    let ans=[];
    let number=1;
    for(let i=0;i<n;i++){
        ans.push(number);
        if (number*10<=n) {
            number*=10;
        }else{
            while(number%10===9 || number+1>n){
                number=Math.floor(number/10);
            }
            number++;
        }
    }
    return ans;
};

let test=123;
let result=lexicalOrder(test);
console.log(result);

```

388. 文件的最长绝对路径
假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：
这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。

在文本格式中，如下所示(⟶表示制表符)：

```
dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
```

如果是代码表示，上面的文件系统可以写为 "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" 。'\n' 和 '\t' 分别是换行符和制表符。

文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 "dir/subdir2/subsubdir2/file2.ext" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成。

给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。

提示：

1 <= input.length <= 104
input 可能包含小写或大写的英文字母，一个换行符 '\n'，一个制表符 '\t'，一个点 '.'，一个空格 ' '，和数字。

```
/**
 * @param {string} input
 * @return {number}
 */
var lengthLongestPath = function(input) {
    let n=input.length;
    let pos=0;
    let ans=0;
    const stack=[];
    while(pos<n){
        /* 检测当前文件的深度 */
        let depth=1;
        while(pos<n && input[pos]==="\t"){
            pos++;
            depth++;
        }
        /* 统计当前文件名的长度 */
        let isFile=false;
        let len=0;
        while(pos<n && input[pos]!=="\n"){
            if (input[pos]===".") {
                isFile=true;
            }
            len++;
            pos++;
        }
        /* 跳过当前的换行符 */
        pos++;
        while(stack.length>=depth){
            stack.pop();
        }
        if (stack.length) {
            len+=stack[stack.length-1]+1;
        }
        if (isFile) {
            ans=Math.max(ans,len);
        }else{
            stack.push(len);
        }
    }
    
    return ans;
};

let input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext";
let result=lengthLongestPath(input);
console.log(result);
```



```
var lengthLongestPath = function(input) {
    const n = input.length;
    let pos = 0;
    let ans = 0;
    const level = new Array(n + 1).fill(0);

    while (pos < n) {
        /* 检测当前文件的深度 */
        let depth = 1;
        while (pos < n && input[pos] === '\t') {
            pos++;
            depth++;
        }
        /* 统计当前文件名的长度 */   
        let len = 0; 
        let isFile = false;     
        while (pos < n && input[pos] !== '\n') {
            if (input[pos] === '.') {
                isFile = true;
            }
            len++;
            pos++;
        }
        /* 跳过换行符 */
        pos++;

        if (depth > 1) {
            len += level[depth - 1] + 1;
        }
        if (isFile) {
            ans = Math.max(ans, len);
        } else {
            level[depth] = len;
        }
    }
    return ans;
}

```




---
## 389. 找不同

给定两个字符串 s 和 t ，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。
提示：

0 <= s.length <= 1000
t.length == s.length + 1
s 和 t 只包含小写字母

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function(s, t) {
    if (s.length===0) {
        return t;  //只有一个字母
    }
    let m=new Map();
    for(let i=0;i<s.length;i++){
        m.set(s[i],m.has(s[i]) ? m.get(s[i])+1 : 1);
    }
    for(let i=0;i<t.length;i++){
        if (m.has(t[i])) {
            if (m.get(t[i])===0) {
                return t[i];
            }else{
                m.set(t[i],m.get(t[i])-1);
            }
        }else{
            return t[i];
        }
    }
};


let test="ab";
let result=findTheDifference(test,"acb");
console.log(result);

```

求和

```js
var findTheDifference = function(s, t) {
    let as = 0, at = 0;
    for (let i = 0; i < s.length; i++) {
        as += s[i].charCodeAt();
    }
    for (let i = 0; i < t.length; i++) {
        at += t[i].charCodeAt();
    }
    return String.fromCharCode(at - as);
};

```

位运算

如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。使用位运算的技巧解决本题。

```js
var findTheDifference = function(s, t) {
    let ret = 0;
    for (const ch of s) {
        ret ^= ch.charCodeAt();
    }
    for (const ch of t) {
        ret ^= ch.charCodeAt();
    }
    return String.fromCharCode(ret);
};

```




---
## 390. 消除游戏

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

- 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。

- 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。

- 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。

给你整数 n ，返回 arr 最后剩下的数字。

提示：

1 <= n <= 10^9

直接遍历数组删除会超时

**方法一：等差数列模拟**

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\消除游戏等差数列模拟.png)

```js
/**
 * @param {number} n
 * @return {number}
 */
var lastRemaining = function(n) {
    let a1=1;
    //删除次数k,元素数目为cnt,首元素a1,末尾元素an,公差step
    let k=0,cnt=n,step=1;
    while(cnt>1){
        if (k%2===0) {
            // 正向
            a1=a1+step;
        }else{
            //反向，得考虑奇数个或偶数个
            a1=(cnt%2===0) ? a1 : a1+step;
        }
        k++;
        //有符号右移由两个大于号（>>）表示
        cnt=cnt>>1;
        //左移操作符用两个小于号（<<）表示
        step=step<<1;
    }
    
    return a1;
};


console.log(lastRemaining(50));

```

复杂度分析

- 时间复杂度：O(log n)，其中 n 为初始整数列表的元素数目。每次删除都会将元素数目减半，所以时间复杂度为 O(logn)。


- 空间复杂度：O(1)。只需要使用常数的额外空间。


---
## 392. 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

提示：

0 <= s.length <= 100
0 <= t.length <= 10^4
两个字符串都只由小写字符组成。

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    if (s.length===0) {
        //s为空时一定是
        return true;
    }
    if (s.length===t.length) {
        return s===t;
    }
    if(s.length>t.length){
        return false;
    }
    for (let i=0,j=0;i<s.length;j++){
        if (s.length-i>t.length-j) {
            return false;
        }
        /*
        if (j===t.length) {
            //遍历完t,但s没有遍历完
            return false;
        }
        */
        if (s[i]===t[j]) {
            i++;
        }
    }
    return true;
};


let test1="abec";
let test2="abcde";
let result=isSubsequence(test1,test2);
console.log(result);

```

动态规划

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    let m=t.length;
    let n=s.length;
    const f=new Array(m+1);
    for(let j=0;j<m+1;j++){
        f[j]=new Array(26).fill(m);
    }

    //预处理出对于 t 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。
    for(let i=m-1;i>=0;i--){
        for(let j=0;j<26;j++){
            if (t.charCodeAt(i)==="a".charCodeAt()+j) {
                f[i][j]=i;
            }else{
                f[i][j]=f[i+1][j];
            }
        }
    }
    //console.log(f);
    let add=0;
    for(let i=0;i<n;i++){
        if (f[add][s.charCodeAt(i)-"a".charCodeAt()]===m) {
            //m表示遍历完t了
            return false;
        }
        add=f[add][s.charCodeAt(i)-"a".charCodeAt()]+1;
    }
    return true;
};


let test1="abecd";
let test2="zxabdeccde";
let result=isSubsequence(test1,test2);
console.log(result);

```


---
## 393. UTF-8 编码验证

给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。

UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：

对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。
对于 n 字节 的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。

注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。

```js
/**
 * @param {number[]} data
 * @return {boolean}
 */
var validUtf8 = function(data) {
   let n=data.length;
   let m=0;  //1~4
   let flag=true;
   for(let i=0;i<n;i++){
      let binary=("00000000"+data[i].toString(2)).slice(-8);
      //console.log(binary);
      if (flag) {
         //每个字符的第一个字节
         for(let j=0;j<8;j++){
            if (binary[j]==="0") {
               break;
            }else{
               m++;
            }
         }
         if(m===1 || m>4){
            //开始字节不能一个1开头,不能超过4
            return false;
         }else if (m!==0) {
            flag=false;
            m--;  //再遍历m-1个
         }else{
            //为0时代表一个字节的字符
         }
      }else{
         //判断后续m-1个
         if (binary.indexOf("10")!==0) {
            return false;
         }
         m--;
         if (m==0) {
            flag=true;
         }
      }
   }
   if(m>0){
      //判断最后是否满足
      return false;
   }
   return true;
};

let data = [197,130,1];
let result=validUtf8(data);
console.log(result);
```


---
## 396. 旋转函数

给定一个长度为 n 的整数数组 nums 。

假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：

F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
返回 F(0), F(1), ..., F(n-1)中的最大值 。

生成的测试用例让答案符合 32 位 整数。

超时做法

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxRotateFunction = function(nums) {
    let n=nums.length;
    let maxSum=Number.NEGATIVE_INFINITY;
    let sum;
    for(let i=0;i<n;i++){
        sum=0;
        for(let j=0;j+i<n;j++){
            sum+=(j+i)*nums[j];
        }
        for(let k=0;k<i;k++){
            sum+=k*nums[n-i+k];
        }
        console.log(sum);
        maxSum=maxSum>sum ? maxSum : sum;
    }
    return maxSum;
};

let data = [4,3,2,6];
let result=maxRotateFunction(data);
console.log(result);
```

2

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxRotateFunction = function(nums) {
    let n=nums.length;
    let sum=0,numSum=0;
    for(let i=0;i<n;i++){
        sum+=i*nums[i];
        numSum+=nums[i];
        
    }
    let maxSum=sum;
    for (let i=n-1;i>0;i--){
        //找到迭代公式,f1,f2,f3...fn的关系
        sum+=numSum-n*nums[i];
        maxSum=maxSum>sum ? maxSum : sum;
    }
    return maxSum;
};
```


---
## 398. 随机数索引

给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。

实现 Solution 类：

Solution(int[] nums) 用数组 nums 初始化对象。
int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。

哈希表

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.pos = new Map();
    for (let i = 0; i < nums.length; ++i) {
        if (!this.pos.has(nums[i])) {
            this.pos.set(nums[i], []);
        }
        
        this.pos.get(nums[i]).push(i);
    }
};

/** 
 * @param {number} target
 * @return {number}
 */
Solution.prototype.pick = function(target) {
    const indices = this.pos.get(target);
    return indices[Math.floor(Math.random() * indices.length)];
};

/**
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(nums)
 * var param_1 = obj.pick(target)
 */
```

水塘抽样

```js
var Solution = function(nums) {
    this.nums = nums;
};

Solution.prototype.pick = function(target) {
    let ans = 0;
    for (let i = 0, cnt = 0; i < this.nums.length; ++i) {
        if (this.nums[i] == target) {
            ++cnt; // 第 cnt 次遇到 target
            if (Math.floor(Math.random() * cnt) === 0) {
                ans = i;
            }
        }
    }
    return ans;
};

```




---
## 401. 二进制手表

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。
给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。
分钟必须由两位数组成，可能会以零开头：

例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。

提示：

0 <= turnedOn <= 10

```js
/**
 * @param {number} turnedOn
 * @return {string[]}
 */
var readBinaryWatch = function(turnedOn) {
    if (turnedOn>8) {
        return [];
    }
    //const hours=[0,1,2,4,8];
    //const minutes=[0,1,2,4,8,16,32];
    const hourOfNums=new Array(4);  //亮几个灯时能代表的小时数,最多亮三盏灯
    for(let i=0;i<4;i++){
        hourOfNums[i]=new Array();
    }
    for(let i=0;i<12;i++){
        let numOfOne=countBitOfOne(i.toString(2));
        hourOfNums[numOfOne].push(i.toString());
    }

    const minuteOfNums=new Array(6);  //亮几个灯时能代表的分钟数,最多亮5盏灯
    for(let i=0;i<6;i++){
        minuteOfNums[i]=new Array();
    }
    for(let i=0;i<60;i++){
        let numOfOne=countBitOfOne(i.toString(2));
        minuteOfNums[numOfOne].push(("00"+i.toString()).slice(-2));
    }

    let result=[];
    for(let h=0;h<=turnedOn;h++){
        let m=turnedOn-h;
        if (h<=3 && m<=5) {
            for(let i=0;i<hourOfNums[h].length;i++){
                for(let j=0;j<minuteOfNums[m].length;j++){
                    result.push(hourOfNums[h][i]+":"+minuteOfNums[m][j]);
                }
            }
            
        }
    }
    return result;
};

var countBitOfOne=function(bits){
    let count=0;
    bits=bits.split("");
    for(let i=0;i<bits.length;i++){
        count+=Number(bits[i]);
    }
    return count;
}

let test=1;
let result=readBinaryWatch(test);
console.log(result);

```


---
## 404. 左叶子之和

给定二叉树的根节点 root ，返回所有左叶子之和。
提示:

节点数在 [1, 1000] 范围内
-1000 <= Node.val <= 1000

深度优先

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
   return root!==null ? dfs(root) : 0;
};

var dfs=function(root){
   let ans=0;
   if (root.left!==null) {
      ans+=isLeafNode(root.left) ? root.left.val : dfs(root.left);
   }
   if (root.right!==null && !isLeafNode(root.right)) {
      ans+=dfs(root.right);
   }
   return ans;
}

var isLeafNode=function(root){
   return root.left===null && root.right===null;
}
```

广度优先

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
   if (root===null) {
      return 0;
   }
   const arr=[root];
   let ans=0;
   while(arr.length!==0){
      let node=arr.shift();
      if(node.left!==null){
         if (isLeafNode(node.left)) {
            ans+=node.left.val;
         }else{
            arr.push(node.left);
         }
      }
      if (node.right!==null) {
         if (!isLeafNode(node.right)) {
            arr.push(node.right);
         }
      }
   }
   return ans;
};

var isLeafNode=function(root){
   return root.left===null && root.right===null;
}
```


---
## 405. 数字转换为十六进制数

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

![数字转换为十六进制数](E:\pogject\学习笔记\image\leetcode\数字转换为十六进制数.png)

```js
/**
 * @param {number} num
 * @return {string}
 */
var toHex = function(num) {
   if (num===0) {
      return "0";
   }
   const ans=[];
   for (let i=7;i>=0;i--){
      let val=(num>>(4*i)) & 0xf;
      if (ans.length>0 || val>0) {
         let digit=val<10 ? String.fromCharCode("0".charCodeAt()+val) : String.fromCharCode("a".charCodeAt()+val-10);
         ans.push(digit);
      }
   }
   return ans.join("");
};


let test=26;
let result=toHex(test);
console.log(result);
```


---
## 409. 最长回文串

给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。

在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
   let m=new Map();
   for(let i=0;i<s.length;i++){
      m.set(s[i],m.has(s[i]) ? m.get(s[i])+1 : 1);
   }
   let ans=0;
   let flag=false;  //是否存在奇数个，中间可以是奇数个
   for(let val of m.values()){
      if (val%2===0) {
         ans+=val;
      }else{
         ans+=val-1;
         flag=true;
      }
   }
   if (flag) {
      ans+=1;
   }
   return ans;
};

let test="abccccdd";
let result=longestPalindrome(test);
console.log(result);
```


---
## 412. Fizz Buzz

给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：

answer[i] == "FizzBuzz" 如果 i 同时是 3 和 5 的倍数。
answer[i] == "Fizz" 如果 i 是 3 的倍数。
answer[i] == "Buzz" 如果 i 是 5 的倍数。
answer[i] == i （以字符串形式）如果上述条件全不满足。

提示：

1 <= n <= 104

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
   const ans=["1"];
   let i=2;
   while(i<=n){
      if (i%3===0 && i%5===0) {
         ans.push("FizzBuzz");
      }else if(i%3===0){
         ans.push("Fizz");
      }else if(i%5===0){
         ans.push("Buzz");
      }else{
         ans.push(i+"");
      }
      i++;
   }
   return ans;
};

let n = 5;
let result=fizzBuzz(n);
console.log(result);
```


---
## 414. 第三大的数

给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。
提示：

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

用一个有序集合来维护数组中前三大的数

```python
from sortedcontainers import SortedList

class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        s = SortedList()
        for num in nums:
            if num not in s:
                s.add(num)
                if len(s) > 3:
                    s.pop(0)
        return s[0] if len(s) == 3 else s[-1]

```

进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？

```js
var thirdMax = function(nums) {
    let a = -Number.MAX_VALUE, b = -Number.MAX_VALUE, c = -Number.MAX_VALUE;
    for (const num of nums) {
        if (num > a) {
            c = b;
            b = a;
            a = num;
        } else if (a > num && num > b) {
            c = b;
            b = num;
        } else if (b > num && num > c) {
            c = num;
        }
    }
    return c === -Number.MAX_VALUE ? a : c;
};

let nums = [3, 2, 1,2,3,4,2,5];
let result=thirdMax(nums);
console.log(result);
```


---
## 415. 字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

提示：

1 <= num1.length, num2.length <= 104
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零

```js
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
   if (num2.length>num1.length) {
      [num1,num2]=[num2,num1];
   }
   let m=num1.length-1;
   let n=num2.length-1;
   num1=num1.split("");
   let e=0;
   while(n>=0){
      let plus=e+Number(num1[m])+Number(num2[n]);
      num1[m]=plus>9 ? plus-10 : plus;
      e=plus>9 ? 1 : 0;
      m--;
      n--;
   }
   while(m>=0 && e>0){
      let plus=e+Number(num1[m]);
      num1[m]=plus>9 ? plus-10 : plus;
      e=plus>9 ? 1 : 0;
      m--;
   }
   if (e>0) {
      num1.unshift(1);
   }
   return num1.join("");

};

let num1 = "456", num2 = "77000";
let result=addStrings(num1,num2);
console.log(result);
```

```js
var addStrings = function(num1, num2) {
    let i = num1.length - 1, j = num2.length - 1, add = 0;
    const ans = [];
    while (i >= 0 || j >= 0 || add != 0) {
        const x = i >= 0 ? num1.charAt(i) - '0' : 0;
        const y = j >= 0 ? num2.charAt(j) - '0' : 0;
        const result = x + y + add;
        ans.push(result % 10);
        add = Math.floor(result / 10);
        i -= 1;
        j -= 1;
    }
    return ans.reverse().join('');
};

```


---
## 417. 太平洋大西洋水流问题

有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。

岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。

提示：

m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 105

```js
/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];

var pacificAtlantic = function(heights) {
    let m=heights.length;
    let n=heights[0].length;
    const pacific=new Array(m).fill(0).map(()=>new Array(n).fill(0));
    const atlantic=new Array(m).fill(0).map(()=>new Array(n).fill(0));
    const dfs=(row,col,ocean)=>{
        if (ocean[row][col]) {
            return;
        }
        ocean[row][col]=true;
        for (let dir of dirs){
            let newRow=row+dir[0];
            let newCol=col+dir[1];
            if (newRow>=0 && newRow<m && newCol>=0 && newCol<n && heights[newRow][newCol]>=heights[row][col]) {
                dfs(newRow,newCol,ocean);
            }
        }
    }

    for (let i=0;i<m;i++){
        dfs(i,0,pacific);
    }
    for (let i=1;i<n;i++){
        dfs(0,i,pacific);
    }
    for (let i=0;i<m;i++){
        dfs(i,n-1,atlantic);
    }
    for (let i=0;i<n-1;i++){
        dfs(m-1,i,atlantic);
    }

    const result=[];
    for (let i=0;i<m;i++){
        for (let j=0;j<n;j++){
            if (pacific[i][j] && atlantic[i][j]) {
                let cell=[];
                cell.push(i);
                cell.push(j);
                result.push(cell);
            }
        }
    }
    return result;
};

let heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]];
let result=pacificAtlantic(heights);
console.log(result);
```

```js
const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
var pacificAtlantic = function(heights) {
    m = heights.length;
    n = heights[0].length;
    const pacific = new Array(m).fill(0).map(() => new Array(n).fill(0));
    const atlantic = new Array(m).fill(0).map(() => new Array(n).fill(0));

    const bfs = (row, col, ocean) => {
        if (ocean[row][col]) {
            return;
        }
        ocean[row][col] = true;
        const queue = [];
        queue.push([row, col]);
        while (queue.length) {
            const cell = queue.shift();
            for (const dir of dirs) {
                const newRow = cell[0] + dir[0], newCol = cell[1] + dir[1];
                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && heights[newRow][newCol] >= heights[cell[0]][cell[1]] && !ocean[newRow][newCol]) {
                    ocean[newRow][newCol] = true;
                    queue.push([newRow, newCol]);
                }
            }
        }
    };

    for (let i = 0; i < m; i++) {
        bfs(i, 0, pacific);
    }
    for (let j = 1; j < n; j++) {
        bfs(0, j, pacific);
    }
    for (let i = 0; i < m; i++) {
        bfs(i, n - 1, atlantic);
    }
    for (let j = 0; j < n - 1; j++) {
        bfs(m - 1, j, atlantic);
    }
    const result = [];
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (pacific[i][j] && atlantic[i][j]) {
                const cell = [];
                cell.push(i);
                cell.push(j);
                result.push(cell);
            }
        }
    }
    return result;
}

```




---
## 420. 强密码检验器

如果一个密码满足下述所有条件，则认为这个密码是强密码：
由至少 6 个，至多 20 个字符组成。
至少包含 一个小写 字母，一个大写 字母，和 一个数字 。
同一字符 不能 连续出现三次 (比如 "...aaa..." 是不允许的, 但是 "...aa...a..." 如果满足其他条件也可以算是强密码)。
给你一个字符串 password ，返回 将 password 修改到满足强密码条件需要的最少修改步数。如果 password 已经是强密码，则返回 0 。

在一步修改操作中，你可以：

插入一个字符到 password ，
从 password 中删除一个字符，或
用另一个字符来替换 password 中的某个字符。

提示：

1 <= password.length <= 50
password 由字母、数字、点 '.' 或者感叹号 '!'

```
var strongPasswordChecker = function(password) {
    const n = password.length;
    let hasLower = 0, hasUpper = 0, hasDigit = 0;
    for (let i = 0; i < n; ++i) {
        const ch = password[i];
        if (isLowerCase(ch)) {
            hasLower = 1;
        } else if (isUpperCase(ch)) {
            hasUpper = 1;
        } else if (isDigit(ch)) {
            hasDigit = 1;
        }
    }
    const categories = hasLower + hasUpper + hasDigit;

    if (n < 6) {
        return Math.max(6 - n, 3 - categories);
    } else if (n <= 20) {
        let replace = 0;
        let cnt = 0;
        let cur = '#';

        for (let i = 0; i < n; ++i) {
            const ch = password[i];
            if (ch === cur) {
                ++cnt;
            } else {
                replace += Math.floor(cnt / 3);
                cnt = 1;
                cur = ch;
            }
        }
        replace += Math.floor(cnt / 3);
        return Math.max(replace, 3 - categories);
    } else {
        // 替换次数和删除次数
        let replace = 0, remove = n - 20;
        // k mod 3 = 1 的组数，即删除 2 个字符可以减少 1 次替换操作
        let rm2 = 0;
        let cnt = 0;
        let cur = '#';

        for (let i = 0; i < n; ++i) {
            const ch = password[i];
            if (ch === cur) {
                ++cnt;
            } else {
                if (remove > 0 && cnt >= 3) {
                    if (cnt % 3 === 0) {
                        // 如果是 k % 3 = 0 的组，那么优先删除 1 个字符，减少 1 次替换操作
                        --remove;
                        --replace;
                    } else if (cnt % 3 === 1) {
                        // 如果是 k % 3 = 1 的组，那么存下来备用
                        ++rm2;
                    }
                    // k % 3 = 2 的组无需显式考虑
                }
                replace += Math.floor(cnt / 3);
                cnt = 1;
                cur = ch;
            }
        }
        if (remove > 0 && cnt >= 3) {
            if (cnt % 3 === 0) {
                --remove;
                --replace;
            } else if (cnt % 3 === 1) {
                ++rm2;
            }
        }
        replace += Math.floor(cnt / 3);

        // 使用 k % 3 = 1 的组的数量，由剩余的替换次数、组数和剩余的删除次数共同决定
        const use2 = Math.min(Math.min(replace, rm2), Math.floor(remove / 2));
        replace -= use2;
        remove -= use2 * 2;
        // 由于每有一次替换次数就一定有 3 个连续相同的字符（k / 3 决定），因此这里可以直接计算出使用 k % 3 = 2 的组的数量
        const use3 = Math.min(replace, Math.floor(remove / 3));
        replace -= use3;
        remove -= use3 * 3;
        return (n - 20) + Math.max(replace, 3 - categories);
    }
};

const isLowerCase = (ch) => {
    return 'a' <= ch && ch <= 'z';
}

const isUpperCase = (ch) => {
    return 'A' <= ch && ch <= 'Z';
}

const isDigit = (ch) => {
    return parseFloat(ch).toString() === "NaN" ? false : true;
}


```


---
## 427. 建立四叉树

给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。

你需要返回能表示矩阵的 四叉树 的根结点。

注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。

四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：

val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False；
isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。

```
/**
 * // Definition for a QuadTree node.
 * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {
 *    this.val = val;
 *    this.isLeaf = isLeaf;
 *    this.topLeft = topLeft;
 *    this.topRight = topRight;
 *    this.bottomLeft = bottomLeft;
 *    this.bottomRight = bottomRight;
 * };
 */
 
/**
 * @param {number[][]} grid
 * @return {Node}
 */
var construct = function(grid) {
    return dfs(grid,0,0,grid.length,grid.length);
};

const dfs=(grid,r0,c0,r1,c1)=>{
    let same=true;
    for(let i=r0;i<r1;++i){
        for(let j=c0;j<c1;++j){
            if (grid[i][j]!==grid[r0][c0]) {
                same=false;
                break;
            }
        }
        if(!same){
            break;
        }
    }
    if (same) {
        return new Node(grid[r0][c0]===1,true);
    }
    const ret=new Node(
        true,
        false,
        dfs(grid, r0, c0, Math.floor((r0 + r1) / 2), Math.floor((c0 + c1) / 2)),
        dfs(grid, r0, Math.floor((c0 + c1) / 2), Math.floor((r0 + r1) / 2), c1),
        dfs(grid, Math.floor((r0 + r1) / 2), c0, r1, Math.floor((c0 + c1) / 2)),
        dfs(grid, Math.floor((r0 + r1) / 2), Math.floor((c0 + c1) / 2), r1, c1)
    );
    return ret;
}

let grid = [[0,1],[1,0]];
let result=construct(grid);
console.log(result);
```




---
## 429.N 叉树的层序遍历

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

```js
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (root===null) {
        return [];
    }
    let ans=[[root.val]];
    let arr=root.children;
    let len;
    while(arr.length>0){
        len=arr.length;
        let temp=[];
        while(len>0){
            len--;
            let node=arr.shift();
            temp.push(node.val);
            if (node.children) {
                arr=arr.concat(node.children);
            }
        }
        ans.push(temp);
    }
    return ans;
};
```




---
## 432. 全 O(1) 的数据结构

请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。

实现 AllOne 类：

AllOne() 初始化数据结构的对象。
inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。
dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。测试用例保证：在减少计数前，key 存在于数据结构中。
getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 "" 。
getMinKey() 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 "" 。

提示：

1 <= key.length <= 10
key 由小写英文字母组成
测试用例保证：在每次调用 dec 时，数据结构中总存在 key
最多调用 inc、dec、getMaxKey 和 getMinKey 方法 5 * 104 次

```js
var AllOne = function() {
   this.root=new Node();
   this.root.prev=this.root;
   this.root.next=this.root;  // 初始化链表哨兵，下面判断节点的 next 若为 root，则表示 next 为空（prev 同理）
   this.nodes=new Map();


};

/** 
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.inc = function(key) {
   if (this.nodes.has(key)) {
      let cur=this.nodes.get(key);
      let nxt=cur.next;
      if (nxt===this.root || nxt.count>cur.count+1) {
         this.nodes.set(key,cur.insert(new Node(key,cur.count+1)));
      }else{
         nxt.keys.add(key);
         this.nodes.set(key,nxt);
      }
      cur.keys.delete(key);
      if (cur.keys.size===0) {
         cur.remove();
      }
   }else{  // key 不在链表中
      if (this.root.next===this.root || this.root.next.count>1) {
         this.nodes.set(key,this.root.insert(new Node(key,1)));
      }else{
         this.root.next.keys.add(key);
         this.nodes.set(key,this.root.next);
      }
   }
};

/** 
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.dec = function(key) {
   let cur=this.nodes.get(key);
   if (cur.count===1) {  // key 仅出现一次，将其移出 nodes
      this.nodes.delete(key);
   }else{
      let pre=cur.prev;
      if (pre===this.root || pre.count<cur.count-1) {
         this.nodes.set(key,cur.prev.insert(new Node(key,cur.count-1)));
      }else{
         pre.keys.add(key);
         this.nodes.set(key,pre);
      }
   }
   cur.keys.delete(key);
   if (cur.keys.size===0) {
      cur.remove();
   }
};

/**
 * @return {string}
 */
AllOne.prototype.getMaxKey = function() {
   if (!this.root.prev) {
      return "";
   }
   let maxKey="";
   for (let key of this.root.prev.keys){
      maxKey=key;
      break;
   }
   return maxKey;
};

/**
 * @return {string}
 */
AllOne.prototype.getMinKey = function() {
   if (!this.root.prev) {
      return "";
   }
   let minKey="";
   for (let key of this.root.next.keys){
      minKey=key;
      break;
   }
   return minKey;
};

/**
 * Your AllOne object will be instantiated and called as such:
 * var obj = new AllOne()
 * obj.inc(key)
 * obj.dec(key)
 * var param_3 = obj.getMaxKey()
 * var param_4 = obj.getMinKey()
 */

class Node {
    constructor(key, count) {
        count ? this.count = count : 0;
        this.keys = new Set();
        key ? this.keys.add(key) : this.keys.add("");
    }

    insert(node) {  // 在 this 后插入 node
        node.prev = this;
        node.next = this.next;
        node.prev.next = node;
        node.next.prev = node;
        return node;
    }

    remove() {
        this.prev.next = this.next;
        this.next.prev = this.prev;
    }
}

```


---
## 433. 最小基因变化

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。

假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

例如，"AACCGGTT" --> "AACCGGTA" 就是一次基因变化。
另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。

给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。

注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。

```js
/**
 * @param {string} start
 * @param {string} end
 * @param {string[]} bank
 * @return {number}
 */
var minMutation = function(start, end, bank) {
    if (start===end) {
        return 0;
    }
    const cnt=new Set();
    const visited=new Set();
    const keys=['A','G','C','T'];
    for (let s of bank){
        cnt.add(s);
    }
    if (!cnt.has(end)) {
        return -1;
    }
    const queue=[start];
    visited.add(start);
    let step=1;
    while(queue.length){
        let sz=queue.length;
        for(let i=0;i<sz;i++){
            let curr=queue.shift();
            for(let j=0;j<8;j++){
                for(let k=0;k<4;k++){
                    if (keys[k]!==curr[j]) {
                        let sb=[...curr];
                        sb[j]=keys[k];
                        let next=sb.join("");
                        if (!visited.has(next) && cnt.has(next)) {
                            if (next===end) {
                                return step;
                            }
                            queue.push(next);
                            visited.add(next);
                        }
                    }
                }
            }
        }
        step++;
    }
    return -1;
};

let start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"];
let result=minMutation(start,end,bank);
console.log(result);
```


---
## 434. 字符串中的单词数

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSegments = function(s) {
    let ans = 0;
    for (let i = 0; i< s.length; i++){
        if ((i ===0 || s[i - 1] ===" ") && s[i] !== " ") {
            ans++;
        }
    }
    return ans;
};
```

---

## 436. 寻找右区间

给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。

区间 i 的 右侧区间 可以记作区间 j ，并满足 startj >= endi ，且 startj 最小化 。

返回一个由每个区间 i 的 右侧区间 在 intervals 中对应下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。

提示：

1 <= intervals.length <= 2 * 104
intervals[i].length == 2
-106 <= starti <= endi <= 106
每个间隔的起点都 不相同

```js
/**
 * @param {number[][]} intervals
 * @return {number[]}
 */
var findRightInterval = function(intervals) {
    let n = intervals.length;
    if (n === 1) {
        return [-1];
    }
    const m = new Map();
    let maxStart = intervals[0][0];
    for (let i = 0; i < n; i++){
        m.set(intervals[i][0], i);
        maxStart = Math.max(maxStart, intervals[i][0]);
    }
    let ans = [];
    for (let i = 0; i < n; i++){
        let end = intervals[i][1];
        if (end > maxStart) {
            ans.push(-1);
        }else{
            while(!m.has(end)){
                end++;
            }
            ans.push(m.get(end));
        }
    }
    return ans;
};
```







----

## 441. 排列硬币

你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
提示：

1 <= n <= 231 - 1

二分法

```js
var arrangeCoins = function(n) {
    let left = 1, right = n;
    while (left < right) {
        const mid = Math.floor((right - left + 1) / 2) + left;
        if (mid * (mid + 1) <= 2 * n) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
    return left;
};
```

数学

```js
/**
 * @param {number} n
 * @return {number}
 */
var arrangeCoins = function(n) {
    let ans = Math.floor((Math.sqrt(8 * n + 1) - 1) / 2);
    return ans;
};

let n = 8;
let result = arrangeCoins(n);
console.log(result);
```



---

## 442. 数组中重复的数据

给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。

提示：

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
nums 中的每个元素出现 一次 或 两次

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDuplicates = function(nums) {
    let n=nums.length;
    let ans=new Set();
    let i=0;
    while(i<n){
        if(nums[i]!==i+1){
            if (nums[i]>i+1) {
                if (nums[nums[i]-1]==nums[i]) {
                    ans.add(nums[i]);
                    nums[i]=0
                    i++;
                }else{
                    let temp=nums[i];
                    nums[i]=nums[nums[i]-1];
                    nums[temp-1]=temp;
                }
            }else{
                if (nums[nums[i]-1]!==0) {
                    ans.add(nums[i]);
                    nums[i]=0;
                }else{
                    nums[nums[i]-1]=nums[i];
                    nums[i]=0;
                }
                i++;
            }
        }else{
            i++;
        }
    }
    return [...ans];
};

let nums = [4,3,2,7,8,2,3,1];
let result=findDuplicates(nums);
console.log(result);
```


---
## 448. 找到所有数组中消失的数字

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

提示：

n == nums.length
1 <= n <= 105
1 <= nums[i] <= n
进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    let ans = [];
    let n = nums.length;
    for (let num of nums){
        //当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值
        let x = (num - 1) % n;
        nums[x] += n;
    }
    for (let [i, num] of nums.entries()){
        if (num <= n) {
            ans.push(i + 1);
        }
    }
    return ans;
};

let nums = [4,3,2,7,8,2,3,1];
let result = findDisappearedNumbers(nums);
console.log(result);
```

---

## 449.序列化和反序列化二叉搜索树

序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。

设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。

编码的字符串应尽可能紧凑。

提示：

树中节点数范围是 [0, 104]
0 <= Node.val <= 104
题目数据 保证 输入的树是一棵二叉搜索树。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    const list=[];
    const postOrder=(root,list)=>{
        if (!root) {
            return;
        }
        postOrder(root.left,list);
        postOrder(root.right,list);
        list.push(root.val);
    }

    postOrder(root,list);

    const str=list.join(",");
    return str;
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    if (data.length===0) {
        return null;
    }
    let arr=data.split(",");
    let n=arr.length;
    const stack=[];
    for(let i=0;i<n;i++){
        stack.push(parseInt(arr[i]));
    }

    const constructTree=(lower,upper,stack)=>{
        if (stack.length===0 || stack[stack.length-1]<lower || stack[stack.length-1]>upper) {
            return null;
        }
        let val=stack.pop();
        const root=new TreeNode(val);
        root.right=constructTree(val,upper,stack);
        root.left=constructTree(lower,val,stack);
        return root;
    }

    return constructTree(-Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,stack);
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

---

## 453. 最小操作次数使数组元素相等

给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。
提示：

n == nums.length
1 <= nums.length <= 105
-109 <= nums[i] <= 109
答案保证符合 32-bit 整数

每次操作既可以理解为使 n-1个元素增加 1，也可以理解使 1 个元素减少 1。显然，后者更利于我们的计算。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
    let minNum = Math.min(...nums);
    let ans = 0;
    for (let i = 0; i < nums.length ; i++){
        ans += nums[i] - minNum;
    }
    return ans;;
};

let nums = [4,3,2,7,8,2,3,1];
let result = minMoves(nums);
console.log(result);
```

---

## 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

提示：

1 <= g.length <= 3 * 104
0 <= s.length <= 3 * 104
1 <= g[i], s[j] <= 231 - 1

排序 + 贪心

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);
    let ans = 0;
    for (let i  = 0, j = 0; i < g.length, j < s.length;){
        if (s[j] >= g[i]) {
            ans++;
            i++;
        }
        j++;
    }
    return ans;
};

let g = [1,2,3], s = [1,1];
let result = findContentChildren(g, s);
console.log(result);
```

---

## 459. 重复的子字符串

给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 提示：

1 <= s.length <= 104
s 由小写英文字母组成

**枚举**

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
    let n = s.length;
    //注意到一个小优化是，因为子串至少需要重复一次
    //不会大于 n 的一半
    for (let i = 1; i * 2 <= n; i++){
        if (n % i ===0) {
            let match = true;
            for (let j = i; j < n; j++){
                if (s[j] !== s[j - i]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                return true;
            }
        }
    }
    return false;
};

let s = "abcabcabcabc";
let result = repeatedSubstringPattern(s);
console.log(result);
```

**字符串匹配**

我们将两个 s 连在一起，并移除第一个和最后一个字符。如果 s 是该字符串的子串，那么 s 就满足题目要求。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
   return (s + s).indexOf(s, 1) !== s.length;
};

let s = "abcabcabcabc";
let result = repeatedSubstringPattern(s);
console.log(result);
```

**KMP** **算法**

```

```

---

## 461. 汉明距离

两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

根据以上定义，我们使用异或运算，记为 ⊕，当且仅当输入位不同时输出为 1。

```js
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
    x ^= y;
    x = x.toString(2);
    let ans = 0;
    for (let i = 0; i < x.length; i++){
        if (x[i] === "1") {
            ans++;
        }
    }
    return ans;
};

let  m = 1, n = 4;
let result = hammingDistance(m, n);
console.log(result);
```

移位实现位计数

```js
var hammingDistance = function(x, y) {
    let s = x ^ y, ret = 0;
    while (s != 0) {
        ret += s & 1;
        s >>= 1;
    }
    return ret;
};
```

Brian Kernighan 算法

```js
var hammingDistance = function(x, y) {
    let s = x ^ y, ret = 0;
    while (s != 0) {
        s &= s - 1;
        ret++;
    }
    return ret;
};
```

---

## 463.岛屿的周长

给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

提示：

row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] 为 0 或 1

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function(grid) {
    let perimeter = 0;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    for (let row = 0; row < grid.length; row++){
        for (let col = 0; col < grid[0].length; col++){
            if (grid[row][col] === 1) {
                dirs.forEach((dir) =>{
                    if (row + dir[0] < 0 || row + dir[0] > grid.length - 1 || col + dir[1] < 0 || col + dir[1] > grid[0].length - 1 || grid[row + dir[0]][col + dir[1]] === 0 ) {
                        perimeter++;
                    }
                });
            }
        }
    }
    return perimeter;
};

let grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]];
let result = islandPerimeter(grid);
console.log(result);
```

---

## 464. 我能赢吗

在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。


提示:

1 <= maxChoosableInteger <= 20
0 <= desiredTotal <= 300

记忆化搜索 + 状态压缩

```
var canIWin = function(maxChoosableInteger, desiredTotal) {
    const memo = new Map();
    const dfs = (maxChoosableInteger, usedNumbers, desiredTotal, currentTotal) => {
        if (!memo.has(usedNumbers)) {
            let res = false;
            for (let i = 0; i < maxChoosableInteger; i++) {
                if (((usedNumbers >> i) & 1) === 0) {
                    if (i + 1 + currentTotal >= desiredTotal) {
                        res = true;
                        break;
                    }
                    if (!dfs(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, currentTotal + i + 1)) {
                        res = true;
                        break;
                    }
                }
            }
            memo.set(usedNumbers, res);
        }
        return memo.get(usedNumbers);
    }
    if ((1 + maxChoosableInteger) * (maxChoosableInteger) / 2 < desiredTotal) {
        return false;
    }
    return dfs(maxChoosableInteger, 0, desiredTotal, 0);
};
```






---
## 472. 连接词

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

提示：

1 <= words.length <= 104
0 <= words[i].length <= 1000
words[i] 仅由小写字母组成
0 <= sum(words[i].length) <= 105

方法一：字典树 + 深度优先搜索
判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。

1. 为了方便处理，首先将数组 words 按照字符串的长度递增的顺序排序，排序后可以确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。
2. 在将数组 words 排序之后，遍历数组，跳过空字符串，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入结果数组，如果不是连接词则将该单词加入字典树。
3. 判断一个单词是不是连接词的做法是在字典树中深度优先搜索。从该单词的第一个字符（即下标 00处的字符）开始，在字典树中依次搜索每个字符对应的结点，可能有以下几种情况：

- 如果一个字符对应的结点是单词的结尾，则找到了一个更短的单词，从该字符的后一个字符开始搜索下一个更短的单词；
- **如果一个字符对应的结点在字典树中不存在，则当前的搜索结果失败，回到上一个单词的结尾继续搜索。**

如果找到一个更短的单词且这个更短的单词的最后一个字符是当前单词的最后一个字符，则当前单词是连接词。由于数组 words 中没有重复的单词，因此在判断一个单词是不是连接词时，该单词一定没有加入字典树，由此可以确保判断连接词的条件成立。

由于一个连接词由多个更短的非空单词组成，如果存在一个较长的连接词的组成部分之一是一个较短的连接词，则一定可以将这个较短的连接词换成多个更短的非空单词，因此不需要将连接词加入字典树。

```
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @param {start} int 单词开始索引位置
 * @return {boolean}
 */
 //查找一个词从索引开始后的连续部分是否已存在
Trie.prototype.dfs = function(word,start) {
    let node=this.children;
    for (let i=start;i<word.length;i++){
        node=node[word[i]];
        //深度优先遍历
        if (node!==undefined) {
            if (node.isEnd!==undefined) {
                return i+1;
            }else{
                continue;
            }
        }
        node=node[word[i]];
        if (!node) {
            //得考虑这个单词不行可能那个单词行,carbat比如cat与car
            return false;
        }
        
        if (node && i===word.length-1){
            return i+1;
        }
    }
};



/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const trie=new Trie();

    trie.insert(words[0]);
    trie.insert(words[1]);
    //console.log(trie);
   
    for (let i=2;i<words.length;i++){
        let word=words[i];
        let start;
        let count=0;
        for(start=0;start<word.length;){
            let index=trie.dfs(word,start);
            if (index===false) {
                trie.insert(word);
                break;
            }else{
                if (index<word.length) {
                    start=index;
                    count++;
                }else{
                    if (count>1) {
                        result.push(word);
                    }
                }
            }
        }

    }
    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```

```

//插入字符串
function insertWord(dictTree,word) {
    let node=dictTree;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

//检查单词是否是连接词
function checkWord(dictTree,word,start){
    
    let node=dictTree;
    let count=0;  //计数找到多少个更短的单词
    let i; //i为要检查单词开始的索引
    let tempNode=[];  //记录一个路径上是单词的尾结点
    let tempIndex=[];  //记录一个路径上尾结点对应的索引
    for(i=0;i<word.length;){
        if (node[word[i]]===undefined && count<1) {
            //如果一个短的单词都没有找到，则不是连接词
            return false;
        }
        if (node[word[i]]===undefined){
            //当已经找到一个更短的单词时，字母在该路径不存在
            if (count>0) {
                //当尾结点数大于终末尾结点数时,则可以退回到上一次尾结点
                if (tempNode.length>count){
                    
                }
            }
        }else{
            //当一个字母在该路径存在
            node=node[word[i]];
            if (node.isEnd!==undefined) {
                //node是一个单词的尾结点
                tempNode.push(node);  //记录索引和结点指针
                tempIndex.push(i);
                //如果路径上还有结点,继续深度搜索
                if (node[word[i+1]]===undefined) {
                    //当是尾结点且后面不匹配
                    count+=1;
                    //从当前位置开始匹配下一份更短单词
                    node=dictTree;
                }
            }
            i++;
        }

    }
    return true;
}

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const dictTree={};

    insertWord(dictTree,words[0]);
    insertWord(dictTree,words[1]);
    //console.log(dictTree);
   
   for (let i=2;i<words.length;i++){
        let word=words[i];
        if (dictTree[word[0]]===undefined) {
            //因为单词是从短到长排序的
            //如果单词的第一个字母不在字典树的开始，则一定不是连接词，插入
            insertWord(dictTree,word);
            continue;  //跳过余下检查
        }

        let isConcatWord=checkWord(dictTree,word)
        if (isConcatWord) {
            //如果是连接词
            result.push(word);
        }else{
            //不是则插入
            insertWord(dictTree,word)
        }
    }

    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```


---
## 476. 数字的补数

对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。

例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。
给你一个整数 num ，输出它的补数。

提示：

1 <= num < 2^31

```js
/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
    let highBit = 0;
    //我们需要首先找到 num 二进制表示最高位的那个 1，再将这个 1 以及更低的位进行取反。
    for (let i = 1; i <= 30; i++){
        if (num >= 1 << i){
            highBit = i;
        }else{
            break;
        }
    }
    let mask = highBit === 30 ? 0x7fffffff : (1 << (highBit + 1)) - 1;
    return num ^ mask;
};

let num = 5;
let result = findComplement(num);
console.log(result);
```

---

## 479.最大回文数乘积

给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。
1 <= n <= 8

 ```
     /**
  * @param {number} n
  * @return {number}
  */
 var largestPalindrome = function(n) {
     if (n===1) {
         return 9;
     }
     const upper=10**n-1;
     for(let left=upper;left>upper/10;left--){
         let right=String(left).split("").reverse().join("");
         let p=BigInt(String(left)+right);  //得到回文数
         let x=BigInt(upper);
         while(x*x>=p){
             if (p%x===BigInt(0)) {  //x 是 p 的因子
                 return p%BigInt(1337);
             }
             x--;
         }
 
     }
 };
 
 let n=2;
 let result=largestPalindrome(n);
 console.log(result);
 ```



---

## 482. 密钥格式化

给定一个许可密钥字符串 s，仅由字母、数字字符和破折号组成。字符串由 n 个破折号分成 n + 1 组。你也会得到一个整数 k 。

我们想要重新格式化字符串 s，使每一组包含 k 个字符，除了第一组，它可以比 k 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。

返回 重新格式化的许可密钥 。

提示:

1 <= s.length <= 105
s 只包含字母、数字和破折号 '-'.
1 <= k <= 104

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var licenseKeyFormatting = function(s, k) {
    s = s.replace(/-/g, "").toUpperCase();
    let newStr = "";
    let i;
    for (i = s.length; i - k > 0; i -= k){
        newStr = "-" + s.slice(i - k, i) + newStr;
    }
    newStr = s.slice(0, i) + newStr;
    return newStr;
};

let S = "5F3Z-2e-9-w", k = 4;
let result = licenseKeyFormatting(S, k);
console.log(result);
```

```js
var licenseKeyFormatting = function(s, k) {
    const ans = [];
    let cnt = 0;

    for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== '-') {
            cnt++;
            ans.push(s[i].toUpperCase());
            if (cnt % k === 0) {
                ans.push("-");
            }
        }
    }
    if (ans.length > 0 && ans[ans.length - 1] === '-') {
        ans.pop();
    }
    return ans.reverse().join('');
};

```

---

## 485. 最大连续 1 的个数

给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    let ans = 0;
    let count = 0;
    for (let i = 0; i < nums.length; i++){
        if (nums[i] === 1) {
            count++;
        }else{
            ans = Math.max(ans, count);
            count = 0;
        }
    }
    ans = Math.max(ans, count);
    return ans;
};

let nums = [1,1,0,1,1,1];
let result = findMaxConsecutiveOnes(nums);
console.log(result);
```

---

## 492. 构造矩形

作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

你设计的矩形页面必须等于给定的目标面积。
宽度 W 不应大于长度 L ，换言之，要求 L >= W 。
长度 L 和宽度 W 之间的差距应当尽可能小。
返回一个 数组 [L, W]，其中 L 和 W 是你按照顺序设计的网页的长度和宽度。

提示:

1 <= area <= 107

```js
/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
    let W = Math.floor(Math.sqrt(area));
    while (area % W !== 0){
        W--;
    }
    return [area / W, W];
};

let area = 102;
let result = constructRectangle(area);
console.log(result);
```


---
## 495. 提莫攻击

在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。

当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。

正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。

给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。

返回艾希处于中毒状态的 总 秒数。

提示：

1 <= timeSeries.length <= 104
0 <= timeSeries[i], duration <= 107
timeSeries 按 非递减 顺序排列

```js
/**
 * @param {number[]} timeSeries
 * @param {number} duration
 * @return {number}
 */
var findPoisonedDuration = function(timeSeries, duration) {
    let ans = duration;
    if (duration === 0 || timeSeries.length < 2) {
        return ans;
    }
    for (let i = 1; i < timeSeries.length; i++){
        ans += Math.min(duration, timeSeries[i] - timeSeries[i - 1]);
    }
    return ans;
};

let timeSeries = [1,4], duration = 2;
let result = findPoisonedDuration(timeSeries, duration);
console.log(result);
```

---

## 496. 下一个更大元素 I

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
提示：

1 <= nums1.length <= nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 104
nums1和nums2中所有整数 互不相同
nums1 中的所有整数同样出现在 nums2 中

**进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？

**单调栈 + 哈希表**

倒序遍历nums2  ，并用单调栈中维护当前位置右边的更大的元素列表，从栈底到栈顶的元素是单调递减的。具体地，每次我们移动到数组中一个新的位置 i，就将当前单调栈中所有小于nums2[i] 的元素弹出单调栈，当前位置右边的第一个更大的元素即为栈顶元素，如果栈为空则说明当前位置右边没有更大的元素。随后我们将位置 i 的元素入栈。

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement = function(nums1, nums2) {
    let len1 = nums1.length, len2 = nums2.length;
    let ans = new Array(len1);
    const m = new Map();
    const stack = [];
    for (let i = len2 - 1; i>=0; i--){
        while(stack.length && stack[stack.length - 1] <= nums2[i]){
            stack.pop();
        }
        if (stack.length) {
            m.set(nums2[i], stack[stack.length - 1]);
        }else{
            m.set(nums2[i], -1);
        }
        stack.push(nums2[i]);
    }
    for (let i = 0; i < len1; i++){
        ans[i] = m.get(nums1[i]);
    }
    return ans;

};

let nums1 = [4,1,2], nums2 = [1,3,4,2];
let result = nextGreaterElement(nums1, nums2);
console.log(result);
```

---

## 500. 键盘行

给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。

美式键盘 中：

第一行由字符 "qwertyuiop" 组成。
第二行由字符 "asdfghjkl" 组成。
第三行由字符 "zxcvbnm" 组成。

提示：

1 <= words.length <= 20
1 <= words[i].length <= 100
words[i] 由英文字母（小写和大写字母）组成

```js
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
    let strs = ["qwertyuiop", "asdfghjkl", "zxcvbnm"];
    const m = new Map();
    strs.forEach((item, index) => {
        for (let char of item){
            m.set(char,index);
        }
    });
    const ans = [];
    for (let i = 0; i < words.length; i++){
        let line = m.get(words[i][0].toLowerCase());
        let flag = true;
        for (let j = 1; j <words[i].length; j++){
            if (m.get(words[i][j].toLowerCase()) !== line) {
                flag = false;
                break;
            }
        }
        if (flag) {
            ans.push(words[i]);
        }
    }
    return ans;
};

let words = ["Hello","Alaska","Dad","Peace"];
let result = findWords(words);
console.log(result);
```

```js
var findWords = function(words) {
    const list = [];
    const rowIdx = "12210111011122000010020202";
    for (const word of words) {
        let isValid = true;
        const idx = rowIdx[word[0].toLowerCase().charCodeAt() - 'a'.charCodeAt()];
        for (let i = 1; i < word.length; ++i) {
            if (rowIdx[word[i].toLowerCase().charCodeAt() - 'a'.charCodeAt()] !== idx) {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            list.push(word);
        }
    }
    return list;
};

```

---

## 501. 二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。

假定 BST 满足如下定义：

结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树

提示：

树中节点的数目在范围 [1, 104] 内
-105 <= Node.val <= 105


进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var findMode = function(root) {
    let ans = [];
    let maxCount = 0, count = 0, base = 0;

    const update = (x) => {
        if (x === base) {
            ++count;
        }else{
            count = 1;
            base = x;
        }
        if (count === maxCount) {
            ans.push(base)
        }
        if (count > maxCount){
            maxCount = count;
            ans = [base];
        }
    }

    const dfs = (p) => {
        if (!p) {
            return;
        }
        dfs(p.left);
        update(p.val);
        dfs(p.right);
    }
    
    dfs(root);
    return ans;
};
```



---

## 504 七进制数

给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。

```js
/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
   if (num===0) {
      return "0";
   }
   let flag=false;
   if (num<0) {
      flag=true;
   }
   num=Math.abs(num);
   let ans=[];
   while(num>0){
      let e=num%7;
      num=(num-e)/7;
      ans.unshift(e);
   }
   return flag? "-"+ans.join("") : ans.join("");
};

let num = -7;
let result=convertToBase7(num);
console.log(result);
```

---

## 506. 相对名次

给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。

运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：

名次第 1 的运动员获金牌 "Gold Medal" 。
名次第 2 的运动员获银牌 "Silver Medal" 。
名次第 3 的运动员获铜牌 "Bronze Medal" 。
从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 "x"）。
使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。
提示：

n == score.length
1 <= n <= 104
0 <= score[i] <= 106

```js
/**
 * @param {number[]} score
 * @return {string[]}
 */
var findRelativeRanks = function(score) {
    const ans = new Array(score.length);
    const m = new Map();
    score.forEach((item, index) =>{
        m.set(item, index);
    });
    const awards = ["Gold Medal","Silver Medal","Bronze Medal"];
    score.sort((a, b) => b - a);
    score.forEach((item, index) => {
        if (index  < 3){
            ans[m.get(item)] = awards[index];
        }else{
            ans[m.get(item)] = (index + 1).toString();
        }
    });
    return ans;
};

let score = [10,3,8,9,4];
let result = findRelativeRanks(score);
console.log(result);
```




---
## 507. 完美数

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function(num) {
	if (num===1) {return false;}
	let sum=1;
	for (let i=2;i<=Math.sqrt(num);i++){
		if (i===Math.sqrt(num)) {
			sum+=Math.sqrt(num)
		}else{
			if (num%i===0) {
				sum+=i+num/i;
			}
		}
	}
	if (num===sum) {
		return true;
	}else{
		return false;
	}
}

let str1=121;
let result=checkPerfectNumber(str1);
console.log(result);
```

---

## 509. 斐波那契数

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
给定 n ，请计算 F(n) 。

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if (n < 2) {
        return n;
    }
    let f0 = 0, f1 = 1, f2 = 1;
    let i = 2;
    while(i <= n){
        f2 = f0 + f1;
        f0 = f1;
        f1 = f2;
        i++;
    }
    return f2;
};
```

矩阵快速幂

```js
var fib = function(n) {
    if (n < 2) {
        return n;
    }
    const q = [[1, 1], [1, 0]];
    const res = pow(q, n - 1);
    return res[0][0];
};

const pow = (a, n) => {
    let ret = [[1, 0], [0, 1]];
    while (n > 0) {
        if ((n & 1) === 1) {
            ret = multiply(ret, a);
        }
        n >>= 1;
        a = multiply(a, a);
    }
    return ret;
}

const multiply = (a, b) => {
    const c = new Array(2).fill(0).map(() => new Array(2).fill(0));
    for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
        }
    }
    return c;
}
```

通项公式

```js
var fib = function(n) {
    const sqrt5 = Math.sqrt(5);
    const fibN = Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n);
    return Math.round(fibN / sqrt5);
};
```

---

## 511. 游戏玩法分析 I

```
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| player_id    | int     |
| device_id    | int     |
| event_date   | date    |
| games_played | int     |
+--------------+---------+
```

表的主键是 (player_id, event_date)。
这张表展示了一些游戏玩家在游戏平台上的行为活动。
每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。


写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。

查询结果的格式如下所示：

Activity 表：

```
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
```

Result 表：

```
+-----------+-------------+
| player_id | first_login |
+-----------+-------------+
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |
+-----------+-------------+
```

```sql
select 
    player_id,
    min(event_date) first_login
from activity
group by player_id
```

---

## 520. 检测大写字母

我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如 "USA" 。
单词中所有字母都不是大写，比如 "leetcode" 。
如果单词不只含有一个字母，只有首字母大写， 比如 "Google" 。
给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。

提示：

1 <= word.length <= 100
word 由小写和大写英文字母组成

```js
/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
    let reg = /(^[A-Z]+$)|(^[A-Z][a-z]+$)|(^[a-z]+$)/g;
    return reg.test(word);
};
let word = "FlaG";
let result = detectCapitalUse(word);
console.log(result);
```

```js
var detectCapitalUse = function(word) {
    // 若第 1 个字母为小写，则需额外判断第 2 个字母是否为小写
    if (word.length >= 2 && word[0] === word[0].toLowerCase() && word[1] === word[1].toUpperCase()) {
        return false;
    }
    
    // 无论第 1 个字母是否大写，其他字母必须与第 2 个字母的大小写相同
    for (let i = 2; i < word.length; ++i) {
        if (word[i] === word[i].toLowerCase() ^ word[1] === word[1].toLowerCase()) {
            return false;
        }
    }
    return true;
};
```




---
## 521. 最长特殊序列 Ⅰ

给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列  的长度。如果不存在，则返回 -1 。

「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。

字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。

例如，"abc" 是 "aebdc" 的子序列，因为删除 "aebdc" 中斜体加粗的字符可以得到 "abc" 。 "aebdc" 的子序列还包括 "aebdc" 、 "aeb" 和 "" (空字符串)。

提示：

1 <= a.length, b.length <= 100
a 和 b 由小写英文字母组成

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var findLUSlength = function(a, b) {
   let m=a.length;
   let n=b.length;
   if (m!==n) {
      return Math.max(m,n);
   }
    //这样貌似有问题
   while(m>0){
      m--;
      if (a[m]!==b[m]) {
         return Math.max(m+1,n-m-1);
      }
   }
   return -1;
};

let a = "aba", b = "cdc";
let result=findLUSlength(a,b);
console.log(result);
```

字符串的子序列的长度不会超过该字符串的长度。若子序列的长度等于字符串的长度，那么子序列就是该字符串。

若两字符串不相同，那么我们可以选择较长的字符串作为最长特殊序列，显然它不会是较短的字符串的子序列。特别地，当两字符串长度相同时（但不是同一字符串），我们仍然可以选择其中的一个字符串作为最长特殊序列，它不会是另一个字符串的子序列。

若两字符串相同，那么任一字符串的子序列均会出现在两个字符串中，此时应返回 -1。

```js
var findLUSlength = function(a, b) {
    return a !== b ? Math.max(a.length, b.length) : -1;
};
```

---

## 530. 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

差值是一个正数，其数值等于两值之差的绝对值。
提示：

树中节点的数目范围是 [2, 104]
0 <= Node.val <= 105

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var getMinimumDifference = function(root) {
    let minDiff = Number.MAX_SAFE_INTEGER;
    let lastValue = -1;
    const dfs = (head) =>{
        if (head === null) {
            return;
        }
        dfs(head.left);
        if (lastValue === -1) {
            lastValue = head.val;
        }else{
            minDiff = Math.min(minDiff, head.val - lastValue);
            if (minDiff === 0) {
                return 0;
            }
            lastValue = head.val;
        }
        dfs(head.right);
    }
    dfs(root);
    return minDiff;
};
```




---
## 537.复数乘法

复数 可以用字符串表示，遵循 "实部+虚部i" 的形式，并满足下述条件：

实部 是一个整数，取值范围是 [-100, 100]
虚部 也是一个整数，取值范围是 [-100, 100]
i2 == -1
给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。

提示：

num1 和 num2 都是有效的复数表示。

```js
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var complexNumberMultiply = function(num1, num2) {
    num1=num1.replace("i","").split("+");
    num2=num2.replace("i","").split("+");
    let real=Number(num1[0])*Number(num2[0])-Number(num1[1])*Number(num2[1]);
    let imaginary_part=Number(num1[0])*Number(num2[1])+Number(num1[1])*Number(num2[0]);
    return real.toString()+"+"+imaginary_part.toString()+"i";
};


let result=complexNumberMultiply("1+-1i","1+-1i");
console.log(result);

```




---
## 540. 有序数组中的单一元素

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

提示:

1 <= nums.length <= 105
0 <= nums[i] <= 105

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
     //数组长度一定是奇数个
     let left=0;
     let right=nums.length-1;
     while(left<right){
          let mid=(left+right)>>1;
          if (nums[mid]===nums[mid^1]) {
               left=mid+1;
          }else{
               right=mid;
          }
     }
     return nums[left];
};

let test=[3,3,7,7,10,11,11];
let result=singleNonDuplicate(test);
console.log(result);
```

![有序数组中的单一元素（全数组的二分查找）](E:\pogject\学习笔记\image\leetcode\有序数组中的单一元素（全数组的二分查找）.png)


---
## 541. 反转字符串 II

给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

提示：

1 <= s.length <= 104
s 仅由小写英文组成
1 <= k <= 104

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
    s = s.split("");
    let left = 0, right = s.length - 1;
    while(left < right){
        let ret = right - left + 1;
        if (ret >= 2 * k) {
            swap(s, left, left + k -1);
            left += 2 * k;
        }else if (ret < 2 * k && ret >= k){
            swap(s, left, left + k -1);
            break;
        }else if (ret < k) {
            swap(s, left, right);
            break;
        }
    }
    return s.join("");
};

var swap = function(s, left, right){
    while(left < right){
        let temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}

let s = "abcdefg", k = 2;
let result = reverseStr(s, k);
console.log(result);
```



---

## 553.最优除法

给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。

但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。

说明:

输入数组的长度在 [1, 10] 之间。
数组中每个元素的大小都在 [2, 1000] 之间。
每个测试用例只有一个最优除法解。

```js
/**
 * @param {number[]} nums
 * @return {string}
 */
var optimalDivision = function(nums) {
   let n=nums.length;
   if (n===1) {
      return nums[0]+"";
   }
   if (n===2) {
      return nums.join("/");
   }
   let result=nums[0]+"/("+nums.slice(1,n).join("/")+")"
   return result;
};

let test=[1000,100,10,2];
let result=optimalDivision(test);
console.log(result);
```


---


----

## 564. 寻找最近的回文数

给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。

“最近的”定义为两个整数差的绝对值最小。
提示:

1 <= n.length <= 18
n 只由数字组成
n 不含前导 0
n 代表在 [1, 1018 - 1] 范围内的整数

![寻找最近的回文数](E:\pogject\学习笔记\image\leetcode\寻找最近的回文数.png)

```
/**
 * @param {string} n
 * @return {string}
 */
var nearestPalindromic = function(n) {
   let flag1=false;
   let min_val=Number(n);
   let max_val=Number(n);
   while(!flag1){
      flag1=isPalindrome(--min_val);
      if (flag1) {
         return min_val.toString();
      }
      flag1=isPalindrome(++max_val)
      if (flag1) {
         return max_val.toString();
      }
   }
};

var isPalindrome=function(n){
   n=n.toString();
   for(let i=0,j=n.length-1;i<j;i++,j--){
      if (n[i]!=n[j]) {
         return false;
      }
   }
    return true;
}

let n="110"
let result=nearestPalindromic(n);
console.log(result);
```


---
## 587.安装栅栏

在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。

 

注意:

所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。
输入的整数在 0 到 100 之间。
花园至少有一棵树。
所有树的坐标都是不同的。
输入的点没有顺序。输出顺序也没有要求。

```
/**
 * @param {number[][]} trees
 * @return {number[][]}
 */
var outerTrees = function(trees) {

};

let trees= [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]];
let result=outerTrees(trees);
console.log(result);
```

```
var outerTrees = function(trees) {
    const n = trees.length;
    if (n < 4) {
        return trees;
    }
    let leftMost = 0;
    for (let i = 0; i < n; i++) {
        if (trees[i][0] < trees[leftMost][0]) {
            leftMost = i;
        }
    }

    const res = [];
    const visit = new Array(n).fill(0);
    let p = leftMost;
    do {
        let q = (p + 1) % n;
        for (let r = 0; r < n; r++) {
            /* 如果 r 在 pq 的右侧，则 q = r */ 
            if (cross(trees[p], trees[q], trees[r]) < 0) {
                q = r;
            }
        }
        /* 是否存在点 i, 使得 p 、q 、i 在同一条直线上 */
        for (let i = 0; i < n; i++) {
            if (visit[i] || i === p || i === q) {
                continue;
            }
            if (cross(trees[p], trees[q], trees[i]) === 0) {
                res.push(trees[i]);
                visit[i] = true;
            }
        }
        if  (!visit[q]) {
            res.push(trees[q]);
            visit[q] = true;
        }
        p = q;
    } while (p !== leftMost);
    return res;
}

const cross = (p, q, r) => {
    return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);
};


```




---
## 589. N 叉树的前序遍历

给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

进阶：递归法很简单，你可以使用迭代法完成此题吗?

递归

```js
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[]}
 */
var postorder = function(root) {
   if (root===null) {
      return [];
   }
    let ans=[];
    
    if (root.children!==null) {
      let arr=root.children;
      for(let i=0;i<arr.length;i++){
         ans=ans.concat(postorder(arr[i]));
      }
    }
    ans.push(root.val);

    return ans;
};

```

迭代

```js
var postorder = function(root) {
   if (root===null) {
      return [];
   }
   let arr=[root]
    let ans=[];
    while(arr.length>0){
      let node=arr.pop();
      ans.unshift(node.val);
      if(node.children!==null){
         let temp=node.children;
         for(let i=0;i<temp.length;i++){
            arr.push(temp[i]);
         }
      }
    }
    return ans;
};
```


---
## 590. N 叉树的后序遍历

给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。

n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

进阶：递归法很简单，你可以使用迭代法完成此题吗?

递归

```js
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[]}
 */
var postorder = function(root) {
   if (root===null) {
      return [];
   }
    let ans=[];
    
    if (root.children!==null) {
      let arr=root.children;
      for(let i=0;i<arr.length;i++){
         ans=ans.concat(postorder(arr[i]));
      }
    }
    ans.push(root.val);

    return ans;
};

```

迭代

```js
var postorder = function(root) {
   if (root===null) {
      return [];
   }
   let arr=[root]
    let ans=[];
    while(arr.length>0){
      let node=arr.pop();
      ans.unshift(node.val);
      if(node.children!==null){
         let temp=node.children;
         for(let i=0;i<temp.length;i++){
            arr.push(temp[i]);
         }
      }
    }
    return ans;
};
```


---
## 591. 标签验证器

给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：

代码必须被合法的闭合标签包围。否则，代码是无效的。
闭合标签（不一定合法）要严格符合格式：<TAG_NAME>TAG_CONTENT</TAG_NAME>。其中，<TAG_NAME>是起始标签，</TAG_NAME>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。
合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。
合法的 TAG_CONTENT 可以包含其他合法的闭合标签，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的<、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的。
一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。
一个<，如果你找不到一个后续的>与之匹配，是不合法的。并且当你找到一个<或</时，所有直到下一个>的前的字符，都应当被解析为 TAG_NAME（不一定合法）。
cdata 有如下格式：<![CDATA[CDATA_CONTENT]]>。CDATA_CONTENT 的范围被定义成 <![CDATA[ 和后续的第一个 ]]>之间的字符。
CDATA_CONTENT 可以包含任意字符。cdata 的功能是阻止验证器解析CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。

```js
/**
 * @param {string} code
 * @return {boolean}
 */
var isValid = function(code) {
    let n=code.length;
    const tags=[];  //存储开始标签
    let i=0;
    while (i<n){
        console.log(code[i]);
        if (code[i]==="<") {
            if (i===n-1) {
                //必需闭合
                return false;
            }
            if (code[i+1]==="/") {
                //闭合标签时
                let j=code.indexOf(">",i+2);
                if (j<0) {
                    return false;
                }
                let tagname=code.slice(i+2,j);  //闭合标签
                if (tags.length===0 || tags[tags.length-1]!==tagname){
                    return false;
                }
                //匹配则弹出栈顶元素
                tags.pop();
                i=j+1;
                if (tags.length===0 && i!==n) {
                    return false;
                }
            }else if(code[i+1]==="!"){
                //匹配<![CDATA[]]>
                if (tags.length===0) {
                    return false;
                }
                if (i+9>n) {
                    return false;
                }
                let cdata=code.slice(i+2,i+9);
                if (cdata!=="[CDATA[") {
                    return false;
                }
                let j=code.indexOf("]]>",i+9);
                if (j<0) {
                    return false;
                }
                i=j+1;
            }else{
                //开始标签
                let j=code.indexOf(">",i+1);
                if (j<0) {
                    return false;
                }
                let tagname=code.slice(i+1,j);
                if (tagname.length<1 || tagname.length>9) {
                    return false;
                }
                for (let k=0;k<tagname.length;k++){
                    if (!(tagname[k]>="A" && tagname[k]<="Z")) {
                        return false;
                    }
                }
                tags.push(tagname);
                i=j+1;
            }
        }else{
            //内容
            if (tags.length===0) {
                return false;
            }
            i++;
        }
    }
    console.log(tags)
    return tags.length===0;
};

let code= "<A><A>456</A>  <A> 123  !!  <![CDATA[]]>  123 </A>   <A>123</A></A>";
let result=isValid(code);
console.log(result);
```




---
## 599. 两个列表的最小索引总和

假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。

提示:

1 <= list1.length, list2.length <= 1000
1 <= list1[i].length, list2[i].length <= 30 
list1[i] 和 list2[i] 由空格 ' ' 和英文字母组成。
list1 的所有字符串都是 唯一 的。
list2 中的所有字符串都是 唯一 的。

```js
/**
 * @param {string[]} list1
 * @param {string[]} list2
 * @return {string[]}
 */
var findRestaurant = function(list1, list2) {
   if (list1.length<list2.length) {
      [list1, list2]=[list2,list1]
   }
   let m=new Map();
   for (let i=0;i<list1.length;i++){
      m.set(list1[i],i);
   }
   //console.log(m);
   let minIndexSum=list1.length+list2.length;
   let ans=[]
   for (let i=0;i<list2.length;i++){
      if (m.has(list2[i])) {
         let temp=m.get(list2[i])+i;
         if (temp<minIndexSum) {
            ans=[list2[i]];
            minIndexSum=temp;
         }else if(temp===minIndexSum){
            ans.push(list2[i]);
         }else{

         }
      }
   }
   return ans;
};

let  list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"],list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun","dsee"];

let result=findRestaurant(list1, list2);
console.log(result);
```


---
## 606. 根据二叉树创建字符串

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string}
 */
var tree2str = function(root) {
    if (root===null) {
        return ""
    }
    let ans=[];
    ans.push(root.val);
    if (root.left!==null) {
        ans.push("(");
        ans=ans.concat(tree2str(root.left));
        ans.push(")")
    }
    if (root.right!==null) {
        if (root.left===null) {
            ans.push("()")
        }
        ans.push("(");
        ans=ans.concat(tree2str(root.right));
        ans.push(")");
    }
    return ans.join("");

};
```

---

## 617. 合并二叉树

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

提示：

两棵树中的节点数目在范围 [0, 2000] 内
-104 <= Node.val <= 104

**深度优先搜索（递归）**

```js
function TreeNode(val, left, right){
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */

var mergeTrees = function(root1, root2) {
    if (root1 == null){
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    root1.val = root1.val + root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
};

let nums=[2,7,9,3,1];
let result=rob(nums);
console.log(result);
```

时间复杂度：O(min(m,n))，对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。

空间复杂度：O(min(m,n))，空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。

**广度优先搜索**

```js
function TreeNode(val, left, right){
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */

var mergeTrees = function(root1, root2) {
    if (root1 == null){
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    const root3 = new TreeNode(root1.val + root2.val);
    const queue1 = [root1];
    const queue2 = [root2];
    const queue3 = [root3];

    while (queue1.length > 0 && queue2.length > 0){
        let node3 = queue3.pop();
        let node1 = queue1.pop();
        let node2 = queue2.pop();
        if (node1.left !== null || node2.left !== null) {
            if (node1.left !== null && node2.left !== null) {
                node3.left = new TreeNode(node1.left.val + node2.left.val);
                queue1.push(node1.left);
                queue2.push(node2.left);
                queue3.push(node3.left);
            }else if (node1.left !== null){
                node3.left = node1.left;
            }else if (node2.left !== null){
                node3.left = node2.left;
            }
        }
        if (node1.right !== null || node2.right !== null) {
            if (node1.right !== null && node2.right !== null) {
                node3.right = new TreeNode(node1.right.val + node2.right.val);
                queue1.push(node1.right);
                queue2.push(node2.right);
                queue3.push(node3.right);
            }else if (node1.right !== null){
                node3.right = node1.right;
            }else if (node2.right !== null){
                node3.right = node2.right;
            }
        }
    }
    return root3;
};

```




---
## 653. 两数之和 IV - 输入 BST

给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {boolean}
 */
var findTarget = function(root, k) {
    let s=new Set();
    s.add(k-root.val);
    let arr=[root];
    while(arr.length>0){
        let node=arr.shift()
        if (node.left!==null) {
            if (s.has(node.left.val)) {
                return true;
            }else{
                s.add(k-node.left.val);
                arr.push(node.left);
            }
        }
        if (node.right!==null) {
            if (s.has(node.right.val)) {
                return true;
            }else{
                s.add(k-node.right.val);
                arr.push(node.right);
            }
        }
    }
    return false;
};
```

```

```


---
## 661. 图片平滑器

图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。

每个单元格的  平均灰度 定义为：该单元格自身及  其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。

如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。

给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。

```js
/**
 * @param {number[][]} img
 * @return {number[][]}
 */
var imageSmoother = function(img) {
    let m=img.length;
    let n=img[0].length;
    const dirs=[[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]];
    let ans=new Array(m);
    for(let i=0;i<m;i++){
        ans[i]=new Array(n).fill(0);
    }
    for(let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            let sum=img[i][j];
            let count=1;
            dirs.forEach((dir)=>{
                let row=i+dir[0];
                let col=j+dir[1];
                if(row>=0 && row<m && col>=0 && col<n ){
                    count+=1;
                    sum+=img[row][col];
                }
            });
            ans[i][j]=Math.floor(sum/count);
        }
    }
    return ans;
};

let test=[[100,200,100],[200,50,200],[100,200,100]];
let result=imageSmoother(test);
console.log(result);
```


---
## 668. 乘法表中第k小的数

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

注意：

m 和 n 的范围在 [1, 30000] 之间。
k 的范围在 [1, m * n] 之间。

```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function(m, n, k) {
    let left = 1;
    let right = m * n;
    while (left < right){
        let x = left + Math.floor((right - left) /2);
        let count = Math.floor(x / n) * n;
        for (let i = Math.floor(x / n) + 1; i <= m; i++){
            count += Math.floor(x / i);
        }
        if (count >= k) {
            right = x;
        }else{
            left = x + 1;
        }
    }
    return left;
};

let  m = 3, n = 3, k = 5;
let result = findKthNumber(m, n, k);
console.log(result);
```

---

## 675. 为高尔夫比赛砍树

你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：

0 表示障碍，无法触碰
1 表示地面，可以行走
比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度
每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。

你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。

你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。

可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。
提示：

m == forest.length
n == forest[i].length
1 <= m, n <= 50
0 <= forest[i][j] <= 109

```

```



## 682. 棒球比赛

你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：

整数 x - 表示本回合新获得分数 x
"+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
"D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
"C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。

提示：

1 <= ops.length <= 1000
ops[i] 为 "C"、"D"、"+"，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]
对于 "+" 操作，题目数据保证记录此操作时前面总是存在两个有效的分数
对于 "C" 和 "D" 操作，题目数据保证记录此操作时前面总是存在一个有效的分数

```js
/**
 * @param {string[]} ops
 * @return {number}
 */
var calPoints = function(ops) {
	let sum=Number(ops[0]);
	let arr=[Number(ops[0])];
	for(let i=1;i<ops.length;i++){
		if (ops[i]==="+") {
			sum+=arr[arr.length-2]+arr[arr.length-1];
			arr.push(arr[arr.length-2]+arr[arr.length-1]);
		}else if(ops[i]==="D"){
			sum+=2*arr[arr.length-1];
			arr.push(2*arr[arr.length-1]);
		}else if (ops[i]==="C") {
			sum-=arr[arr.length-1]
			arr.pop();
		}else{
			arr.push(Number(ops[i]));
			sum+=Number(ops[i]);
		}
	}
	return sum;
};

let test=["5","-2","4","C","D","9","+","+"];
let result=calPoints(test);
console.log(result);
```




---
## 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

示例 1：

输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var repeatedStringMatch = function(a, b) {
    //首先只要b中有字母不在a中,则不可能b为a的子串
    let len_a=a.length;
    let len_b=b.length;

    let set=new Set();
    for (let i=0;i<len_a;i++){
        set.add(a[i]);
    }
    for (let i=0;i<len_b;i++){
        if (!set.has(b[i])) {
            return -1;
        }
    }
    let newStr=a;
    //判断b与a的长度，a当重复后长度最多超过b长度的2倍，如果2倍长度没有找到则返回-1
    let n=len_b%len_a===0 ? len_b/len_a : Math.floor(len_b/len_a)+1;
    if (len_a>=len_b) {
        //当a长时，返回值最多为2
        if (newStr.indexOf(b)!==-1) {
            return 1;
        }else{
            newStr+=a;
            if (newStr.indexOf(b)!==-1) {
                return 2;
            }else{
                return -1;
            }
        }
    }else{
        //当b长时，a长度最多增加到b的2倍
        for (let i=0;i<n-1;i++){
            newStr+=a;
        }
        while (newStr.length<2*len_b){
            if (newStr.indexOf(b)!==-1) {
                return n;
            }else{
                newStr+=a;
                n++;
            }
        }
        if (newStr.indexOf(b)!==-1) {
            return n;
        }else{
            return -1;
        }
        
    }
    return 0;
};


let str1 = "abc";
let str2="cabcabca";

let result=repeatedStringMatch(str1,str2);
console.log(result);
```


---
## 688. 骑士在棋盘上的概率

在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 k 步或离开了棋盘。

返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。

提示:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n

```
/**
 * @param {number} n
 * @param {number} k
 * @param {number} row
 * @param {number} column
 * @return {number}
 */
var knightProbability = function(n, k, row, column) {
    const dirs=[[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1]];
    
};

let n = 3, k = 2, row = 0, column = 0;
let result=knightProbability(n, k, row, column);
console.log(result);

```


---
## 691. 贴纸拼词

我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。

您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。

返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。

注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。

提示:

n == stickers.length
1 <= n <= 50
1 <= stickers[i].length <= 10
1 <= target <= 15
stickers[i] 和 target 由小写英文单词组成

**记忆化搜索 + 状态压缩**

```js
/**
 * @param {string[]} stickers
 * @param {string} target
 * @return {number}
 */
var minStickers = function(stickers, target) {
    const m = target.length;
    const memo = new Array(1 << m).fill(-1);
    memo[0] = 0;
    const res = dp(stickers, target, memo, (1 << m) - 1);
    return res <= m ? res : -1;
};

const dp = (stickers, target, memo, mask) =>{
    const m = target.length;
    if (memo[mask] < 0) {
        let res = m + 1;
        for (let sticker of stickers){
            let left = mask;
            const cnt = new Array(26).fill(0);
            for (let i = 0; i< sticker.length; i++){
                cnt[sticker[i].charCodeAt() - 'a'.charCodeAt()]++;
            }
            for (let i = 0; i < target.length; i++){
                const c = target[i];
                if (((mask >> i) & 1) === 1 && cnt[c.charCodeAt() - 'a'.charCodeAt()] > 0) {
                    cnt[c.charCodeAt() - 'a'.charCodeAt()]--;
                    left ^= 1 << i;
                }
            }
            if (left < mask) {
                res = Math.min(res, dp(stickers, target, memo, left) + 1);
            }
        }
        memo[mask] = res;
    }
    return memo[mask];
}

let stickers = ["with","example","science"], target = "thehat";
let result = minStickers(stickers, target);
console.log(result);
```

---

## 693. 交替位二进制数

给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var hasAlternatingBits = function(n) {
	n=n.toString(2);
	for(let i=0;i<n.length;i++){
		if (n[i]==n[i-1]) {
			return false;
		}
	}
	return true;
};

let n=7;
let result=hasAlternatingBits(n);
console.log(result);
```

```js
var hasAlternatingBits = function(n) {
    const a = n ^ (n >> 1);
    return (a & (a + 1)) === 0;
};
```


---
## 713. 乘积小于 K 的子数组

给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。
提示: 

1 <= nums.length <= 3 * 104
1 <= nums[i] <= 1000
0 <= k <= 106

使用子数组

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function(nums, k) {
    let n=nums.length;
    let arr=[];
    let ans=0;
    let sum=1;  //连续子数组和
    for (let i=0;i<n;i++){
        if (nums[i]<k) {
            while (arr.length>0 && sum*nums[i]>=k){
                sum/=arr.shift();
            }
            arr.push(nums[i]);
            sum*=nums[i];
            ans+=arr.length;
        }else{
            arr=[];
            sum=1;
        }
    }
    return ans;
};

let nums = [100,2,3,4,100,5,6,7,100], k = 100;
let result=numSubarrayProductLessThanK(nums,k);
console.log(result);
```

不使用额外空间

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function(nums, k) {
    let ans=0;
    let sum=1;  //连续子数组和
    let i=0;
    for (let j=0;j<nums.length;j++){
        if (nums[j]<k) {
            while (i<j && sum*nums[j]>=k){
                sum/=nums[i];
                i++;
            }
            sum*=nums[j];
            ans+=(j-i+1);
        }else{
            i=j+1;
            sum=1;
        }
    }
    return ans;
};

let nums = [100,2,3,4,100,5,6,7,100], k = 100;
let result=numSubarrayProductLessThanK(nums,k);
console.log(result);
```




---
## 717.  比特与2比特字符

有两种特殊字符：

第一种字符可以用一个比特 0 来表示
第二种字符可以用两个比特(10 或 11)来表示、
给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。

提示:

1 <= bits.length <= 1000
bits[i] == 0 or 1

```js
/**
 * @param {number[]} bits
 * @return {boolean}
 */
var isOneBitCharacter = function(bits) {
    let n=bits.length-1;
    if (bits[n]===1) {
        return false;
    }
    for(let i=0;i<n;){
        if (i===n-1) {
            if (bits[i]===1) {
                return false;
            }
        }
        if (bits[i]==1) {
            i+=2;
        }else{
            i++;
        }
    }
    return true;
};

let test=[1, 1, 1, 0];
let result=isOneBitCharacter(test);
console.log(result);

```

```js
var isOneBitCharacter = function(bits) {
    let i = 0, n = bits.length;
    while (i < n - 1) {
        i += bits[i] + 1;
    }
    return i === n - 1;
};

```


---
## 720. 词典中最长的单词

给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。

若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。

hash集合

```js
/**
 * @param {string[]} words
 * @return {string}
 */
var longestWord = function(words) {
    words.sort((a,b)=>{
        if (a.length!==b.length) {
            //首先按照单词的长度升序排序
            return a.length-b.length;
        }else{
            //如果单词的长度相同则按照字典序降序排序
            return b.localeCompare(a);
        }
    });
    let longest="";
    let candidates=new Set();
    candidates.add("");
    let n=words.length;
    for(let i=0;i<n;i++){
        let word=words[i];
        if (candidates.has(word.slice(0,word.length-1))) {
            candidates.add(word);
            longest=word;
        }
    }
    return longest;
};

let words = ["w","wo","wor","worl", "world"];
let result=longestWord(words);
console.log(result);
```

字典树

```js
var longestWord = function(words) {
    const trie = new Trie();
    for (const word of words) {
        trie.insert(word);
    }
    let longest = "";
    for (const word of words) {
        if (trie.search(word)) {
            if (word.length > longest.length || (word.length === longest.length && word.localeCompare(longest) < 0)) {
                longest = word;
            }
        }
    }
    return longest;
};

class Node {
    constructor() {
        this.children = {};
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.children = new Node();
        this.isEnd = false;
    }

    insert(word) {
        let node = this;
        for (let i = 0; i < word.length; i++) {
            const ch = word[i];
            const index = ch.charCodeAt() - 'a'.charCodeAt();
            if (!node.children[index]) {
                node.children[index] = new Node();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }

    search(word) {
        let node = this;
        for (let i = 0; i < word.length; i++) {
            const ch = word[i];
            const index = ch.charCodeAt() - 'a'.charCodeAt();
            if (!node.children[index] || !node.children[index].isEnd) {
                return false;
            }
            node = node.children[index];
        }
        return node && node.isEnd;
    }
}

```

728. 自除数
自除数 是指可以被它包含的每一位数整除的数。

例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
自除数 不允许包含 0 。

给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。

提示：

1 <= left <= right <= 104

```js
/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function(left, right) {
	let ans=[];
	for (let i=left;i<=right;i++){
		let n=i.toString();
		if (n.indexOf("0")===-1) {
			let flag=true;
			for (let j=0;j<n.length;j++){
				if (i%Number(n[j])!==0) {
					flag=false;
					break;
				}
			}
			if (flag) {
				ans.push(i);
			}
		}
	}
	return ans;
};

let left = 1, right = 22;
let result=selfDividingNumbers(left,right);
console.log(result);
```


---
## 744. 寻找比目标字母大的最小字母

给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'

提示：

2 <= letters.length <= 104
letters[i] 是一个小写字母
letters 按非递减顺序排序
letters 最少包含两个不同的字母
target 是一个小写字母

```js
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
	//let n="z".charCodeAt(0)+1;
	//target=target.charCodeAt(0);
	if (target>=letters[letters.length-1]) {
		return letters[0];
	}
	let i=0,j=letters.length-1;
	let mid;
	while(i<j){
		mid=i+Math.floor((j-i)/2);
		if (letters[mid]>target) {
			j=mid;
		}else{
			i=mid+1;
		}
	}
	return letters[i];
	//String.fromCharCode()
};

let letters = ["c", "f", "j"],target = "c";
let result=nextGreatestLetter(letters,target);
console.log(result);
```




---
## 747.至少是其他数字两倍的最大数

给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。

请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。

提示：

1 <= nums.length <= 50
0 <= nums[i] <= 100
nums 中的最大元素是唯一的

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var dominantIndex = function(nums) {
    if (nums.length===1) {
        return 0;
    }
    //找到最大值与次大比较即可
    let maxValue=nums[0]>nums[1] ? nums[0] : nums[1];
    let secondMaxValue=nums[0]>nums[1] ? nums[1] : nums[0];
    let MaxValueIndex=nums[0]>nums[1] ? 0 : 1;
    for (let i=2;i<nums.length;i++){
        if (nums[i]>maxValue) {
            secondMaxValue=maxValue;
            maxValue=nums[i];
            MaxValueIndex=i;
        }else{
            if (nums[i]>secondMaxValue) {
                secondMaxValue=nums[i];
            }
        }
    }
    if (maxValue>=2*secondMaxValue) {
        return MaxValueIndex;
    }else{
        return -1;
    }
};

let str1 = [3,6,1,0];
let result=dominantIndex(str1);
console.log(result);

```


---
## 762.二进制表示中质数个计算置位

给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。

计算置位位数 就是二进制表示中 1 的个数。

例如， 21 的二进制表示 10101 有 3 个计算置位。

提示：

1 <= left <= right <= 106
0 <= right - left <= 104

```js
/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
var countPrimeSetBits = function(left, right) {
	let ans=0;
	let palimds=new Set();
	let n=Math.ceil(Math.log2(right));
	while(n>2){
		let flag=true;
		for(let i=2;i<=n/2;i++){
			if (n%i===0) {
				flag=false;
				break;
			}
		}
		if (flag) {
			palimds.add(n);
		}
		n--;
	}
	palimds.add(2);
	//console.log(palimds);
	for(let i=left;i<=right;i++){
		let s=i.toString(2);
		let sum=0;
		for (let c of s){
			if (c==="1") {
				sum+=1;
			}
		}
		if (palimds.has(sum)) {
			ans++;
		}
		//console.log(s,sum);
	}

	return ans;
};

let left = 10, right = 15;
let result=countPrimeSetBits(left,right);
console.log(result);
```

```js
/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 */
var countPrimeSetBits = function(left, right) {
	let ans=0;
	for(let i=left;i<=right;i++){
		if(isPrime(bitCount(i))){
			ans++;
		}
	}
	return ans;
};

const isPrime=(n)=>{
	if (n<2) {
		return false;
	}
	for (let i=2;i*i<=n;i++){
		if (n%i===0) {
			return false;
		}
	}
	return true;
}

const bitCount=(n)=>{
	return n.toString(2).split("0").join("").length;
}

let left = 10, right = 15;
let result=countPrimeSetBits(left,right);
console.log(result);
```

![二进制表示中质数个计算置位](E:\pogject\学习笔记\image\leetcode\二进制表示中质数个计算置位.png)

```js
var countPrimeSetBits = function(left, right) {
    let ans = 0;
    for (let x = left; x <= right; ++x) {
        if (((1 << bitCount(x)) & 665772) != 0) {
            ++ans;
        }
    }
    return ans;
};

const bitCount = (x) => {
    return x.toString(2).split('0').join('').length;
}


```


---
## 780.到达终点

给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。

从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。


提示:

1 <= sx, sy, tx, ty <= 109

![到达终点(反向计算)](E:\pogject\学习笔记\image\leetcode\到达终点(反向计算).png)

```js
/**
 * @param {number} sx
 * @param {number} sy
 * @param {number} tx
 * @param {number} ty
 * @return {boolean}
 */
var reachingPoints = function(sx, sy, tx, ty) {
    while(tx>sx && ty>sy && tx!==ty){
        if (tx>ty) {
            tx%=ty;
        }else{
            ty%=tx;
        }
    }
    if (tx===sx && ty===sy) {
        return true;
    }else if(tx===sx){
        return ty>sy && (ty-sy)%tx===0;
    }else if(ty===sy){
        return tx>sx && (tx-sx)%sy===0;
    }else{
        return false;
    }
    
};

let sx = 1, sy = 1, tx = 3, ty = 5;
let result=reachingPoints(sx, sy, tx, ty);
console.log(result);

```




---
## 796.旋转字符串

给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。

s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 

例如, 若 s = 'abcde'，在旋转一次之后结果就是'bcdea' 。

```js
/**
 * @param {string} s
 * @param {string} goal
 * @return {boolean}
 */
var rotateString = function(s, goal) {
    if (s.length!==goal.length) {
        return false;
    }
    let index0=0;
    while(index0<s.length){
        index0=s.indexOf(goal[0],index0);
        if (index0===-1) {
            return false;
        }else{
            if (s.slice(index0)+s.slice(0,index0)===goal) {
                return true;
            }else{
                index0++;
            }
        }
    }
    return false;
};

let  s = "abcde", goal = "cdeab";
let result=rotateString(s,goal);
console.log(result);
```

```js
var rotateString = function(s, goal) {
    return s.length === goal.length && (s + s).indexOf(goal) !== -1;
};

```




---
## 798. 得分最高的最小轮调

给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 > 0 [不计分]、3 > 1 [不计分]、0 <= 2 [计 1 分]、2 <= 3 [计 1 分]，4 <= 4 [计 1 分]。
在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 。

提示：

1 <= nums.length <= 105
0 <= nums[i] < nums.length

```

```


---
## 804.唯一摩尔斯密码词

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:

'a' 对应 ".-" ，
'b' 对应 "-..." ，
'c' 对应 "-.-." ，以此类推。
为了方便，所有 26 个英文字母的摩尔斯密码表如下：

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。

例如，"cab" 可以写成 "-.-..--..." ，(即 "-.-." + ".-" + "-..." 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。
对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。

```js
/**
 * @param {string[]} words
 * @return {number}
 */
var uniqueMorseRepresentations = function(words) {
    const passwords=[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];
    let s=new Set();
    let index;
    for(let i=0;i<words.length;i++){
        let pass;
        for(let j=0;j<words[i].length;j++){
            index=words[i].charCodeAt(j)-"a".charCodeAt(0);
            pass+=passwords[index];
        }
        s.add(pass);
    }
    return s.size;
};

let words = ["gin", "zen", "gig", "msg"];
let result=uniqueMorseRepresentations(words);
console.log(result);
```


---
## 806.写字符串需要的行数

我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。

现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。

注:

字符串 S 的长度在 [1, 1000] 的范围。
S 只包含小写字母。
widths 是长度为 26的数组。
widths[i] 值的范围在 [2, 10]。

```js
/**
 * @param {number[]} widths
 * @param {string} s
 * @return {number[]}
 */
var numberOfLines = function(widths, s) {
    let index;
    let sum=0;
    let line=0;
    for (let c of s){
        index=c.charCodeAt()-"a".charCodeAt();
        if (sum+widths[index]>100) {
            line++;
            sum=0;
        }
        sum+=widths[index];
    }
    line++;
    return [line,sum];
};

let widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10];
let s = "abcdefghijklmnopqrstuvwxyz";
let result=numberOfLines(widths,s);
console.log(result);
```


---
## 812.最大三角形面积

给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。

注意:

3 <= points.length <= 50.
不存在重复的点。
 -50 <= points[i][j] <= 50.
结果误差值在 10^-6 以内都认为是正确答案。

**枚举**

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var largestTriangleArea = function(points) {
    const n = points.length;
    let ans = 0.0;
    for (let i = 0; i < n; i++){
        for (let j = i + 1; j < n; j++){
            for (let k = j + 1; k < n; k++){
                ans = Math.max(ans, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));
            }
        }
    }
    return ans;
};

var triangleArea= (x1, y1, x2, y2, x3, y3) =>{
    return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3* y1 -x1 * y3 - x2 * y1 - x3 * y2);
};

let points = [[0,0],[0,1],[1,0],[0,2],[2,0]];
let result = largestTriangleArea(points);
console.log(result);
```

**凸包**

```
var largestTriangleArea = function(points) {
    const convexHull = getConvexHull(points);
    const n = convexHull.length;
    let ret = 0.0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1, k = i + 2; j + 1 < n; j++) {
            while (k + 1 < n) {
                const curArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);
                const nextArea = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k + 1][0], convexHull[k + 1][1]);
                if (curArea >= nextArea) {
                    break;
                }
                k++;
            }
            const area = triangleArea(convexHull[i][0], convexHull[i][1], convexHull[j][0], convexHull[j][1], convexHull[k][0], convexHull[k][1]);
            ret = Math.max(ret, area);
        }
    }
    return ret;
}

const getConvexHull = (points) => {
    const n = points.length;
    if (n < 4) {
        return points;
    }
    /* 按照 x 大小进行排序，如果 x 相同，则按照 y 的大小进行排序 */
    points.sort((a, b) => {
        if (a[0] === b[0]) {
            return a[1] - b[1];
        }
        return a[0] - b[0];
    });
    const hull = [];
    /* 求出凸包的下半部分 */
    for (let i = 0; i < n; i++) {
        while (hull.length > 1 && cross(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {
            hull.pop();
        }
        hull.push(points[i]);
    }
    let m = hull.length;
    /* 求出凸包的上半部分 */
    for (let i = n - 2; i >= 0; i--) {
        while (hull.length > m && cross(hull[hull.length - 2], hull[hull.length - 1], points[i]) <= 0) {
            hull.pop();
        }
        hull.push(points[i]);
    }
    /* hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0] */
    hull.pop();
    m = hull.length;
    const hullArr = new Array(m).fill(0);
    for (let i = 0; i < m; i++) {
        hullArr[i] = hull[i];
    }
    return hullArr;
}

const triangleArea = (x1, y1, x2, y2, x3, y3) => {
    return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);
}

const cross = (p, q, r) => {
    return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);
};

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/largest-triangle-area/solution/zui-da-san-jiao-xing-mian-ji-by-leetcode-yefh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





---

## 819.最常见的单词

给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。

题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。

提示：

1 <= 段落长度 <= 1000
0 <= 禁用单词个数 <= 100
1 <= 禁用单词长度 <= 10
答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。)
paragraph 只包含字母、空格和下列标点符号!?',;.
不存在没有连字符或者带有连字符的单词。
单词里只包含字母，不会出现省略号或者其他标点符号。

```js
/**
 * @param {string} paragraph
 * @param {string[]} banned
 * @return {string}
 */
var mostCommonWord = function(paragraph, banned) {
    paragraph=paragraph.replace(/[!?',;.]/g," ");
    paragraph=paragraph.toLowerCase().split(" ");
    let m=new Map();
    let max=0;
    let ans="";
    for (let word of paragraph){
        if (word!=="" && banned.indexOf(word)===-1) {
            m.set(word,m.has(word) ? m.get(word)+1 : 1);
            if (m.get(word)>max){
                max=m.get(word);
                ans=word;
            }
        }
    }
    return ans;
};

let paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.";
let banned = ["hit"]
let result=mostCommonWord(paragraph,banned);
console.log(result);
```


---
## 821.字符的最短距离

给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。

返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。

两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。

 

提示：
1 <= s.length <= 104
s[i] 和 c 均为小写英文字母
题目数据保证 c 在 s 中至少出现一次

```js
/**
 * @param {string} s
 * @param {character} c
 * @return {number[]}
 */
var shortestToChar = function(s, c) {
    let n=s.length;
    let ans=new Array(n).fill(0);
    let leftIndex=s.indexOf(c);
    let rightIndex=s.indexOf(c,leftIndex+1);
    let d1,d2;
    for(let i=0;i<n;i++){
        d1=Math.abs(i-leftIndex);
        if (rightIndex!==-1) {
            d2=Math.abs(i-rightIndex)
            if (d1<d2) {
                ans[i]=d1;
            }else{
                ans[i]=d2;
            }
            if (i===rightIndex) {
                leftIndex=rightIndex;
                rightIndex=s.indexOf(c,leftIndex+1);
            }
        }else{
            ans[i]=d1;
        }
    }
    return ans;
};

let s = "loveleetcode", c = "e";
let result=shortestToChar(s,c);
console.log(result);
```


---
## 824.山羊拉丁文

给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。

请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：

如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加"ma"。
例如，单词 "apple" 变为 "applema" 。
如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
例如，单词 "goat" 变为 "oatgma" 。
根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
例如，在第一个单词后添加 "a" ，在第二个单词后添加 "aa" ，以此类推。
返回将 sentence 转换为山羊拉丁文后的句子。

提示：

1 <= sentence.length <= 150
sentence 由英文字母和空格组成
sentence 不含前导或尾随空格
sentence 中的所有单词由单个空格分隔

```js
/**
 * @param {string} sentence
 * @return {string}
 */
var toGoatLatin = function(sentence) {
    sentence=sentence.split(" ");
    let n=sentence.length;
    let ans=[];
    let s=new Set(["a","e","i","o","u","A","E","I","O","U"]);
    let a="a";
    for(let i=0;i<n;i++){
        if (s.has(sentence[i][0])) {
            ans.push(sentence[i]+"ma"+a);
        }else{
            ans.push(sentence[i].slice(1)+sentence[i][0]+"ma"+a);
        }
        a+="a";
    }
    return ans.join(" ");
};

let s = "I speak Goat Latin";
let result=toGoatLatin(s);
console.log(result);
```




---
## 825. 适龄的朋友

在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：

age[y] <= 0.5 * age[x] + 7
age[y] > age[x]
age[y] > 100 && age[x] < 100
否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

- `n == ages.length`
- `1 <= n <= 2 * 104`
- `1 <= ages[i] <= 120`

```js
/**
 * @param {number[]} ages
 * @return {number}
 */
var numFriendRequests = function(ages) {
    if (ages.length===1) {return 0;}
    let count=0;
    ages.sort((a,b)=>b-a);  //从大到小排序
    let flag=0;  //移动指针
    for (let i=0;i<ages.length;i++){
        for (let j=flag;j<ages.length;j++){
            if (i!==j) {
                if (ages[j]>ages[i]*0.5+7) {
                    count++;
                    //console.log(ages[i]+"->"+ages[j]);
                }else{
                    break;
                }
            }
        }
        //age变化则移动指针
        if (ages[i]>ages[i+1]) {
            //console.log(ages[flag]);
            flag=i+1;
        }
    }
    return count;
};

let str1 = [30,100,110,120,20];
let result=numFriendRequests(str1);
console.log(result);

```


---
## 838. 推多米诺

n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。

给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：

dominoes[i] = 'L'，表示第 i 张多米诺骨牌被推向左侧，
dominoes[i] = 'R'，表示第 i 张多米诺骨牌被推向右侧，
dominoes[i] = '.'，表示没有推动第 i 张多米诺骨牌。
返回表示最终状态的字符串。

提示：

n == dominoes.length
1 <= n <= 105
dominoes[i] 为 'L'、'R' 或 '.'

```js
/**
 * @param {string} dominoes
 * @return {string}
 */
var pushDominoes = function(dominoes) {
    let n=dominoes.length;
    dominoes=dominoes.split("");
    let left=-1;  //往右倒的
    let right=n;  //往左倒的
    for(let i=0;i<n;i++){
        if(dominoes[i]==="L"){
            right=i;
            if (left===-1) {
                //前面向right倒的没有或倒完了
                while(dominoes[right-1]==="."){
                    dominoes[--right]="L";
                }
                right=n;
            }else{
                //前面有向right倒的
                while((left+1)!==(right-1) && (left+1)!==right && left!==(right-1)){
                    dominoes[++left]="R";
                    dominoes[--right]="L";
                }
                left=-1;
                right=n;
            }
        }else if(dominoes[i]==="R"){
            if (left!==-1) {
                //连续遇到往右倒的
                while(dominoes[left+1]==="."){
                    dominoes[++left]="R";
                }
            }
            left=i;

        }else{}
    }
    if (right===n && left!==-1) {
        while((left+1)<n){
            //后面只有往右倒的
            dominoes[++left]="R";
        }
    }
    return dominoes.join("");
};

let test=".L.R...LR..L..";
let result=pushDominoes(test);
console.log(result);
```




---
## 846. 一手顺子

Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。

给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。

提示：

1 <= hand.length <= 104
0 <= hand[i] <= 109
1 <= groupSize <= hand.length

示例 1：

输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
示例 2：

输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。

```js
/**
 * @param {number[]} hand
 * @param {number} groupSize
 * @return {boolean}
 */
var isNStraightHand = function(hand, groupSize) {
    if (hand.length%groupSize!==0) {
        //当不能整除则不能排列为相同size的
        return false;
    }
    if (groupSize===1) {
        //当size为1则可以
        return true;
    }
    //从小到大排序
    hand.sort((a,b)=>a-b);
    //console.log(hand.length/groupSize);
    //console.log(hand);
    let len=hand.length;  //记录初始长度

    for (let i=0;i<len/groupSize;i++){
        let temp=hand[0];  //每一次排列一定是从最小的开始
        //console.log(temp);
        hand.shift();  //删除第一张牌

        for (let j=1;j<groupSize;j++){
            //从第二张开始找就行
            let index=hand.indexOf(temp+j);
            if (index===-1) {
                //如果不存在比上一张大1的牌
                return false;
            }
            //存在则删除
            //console.log(hand[index]);
            hand.splice(index,1);

        }
        //console.log("---")
    }

    return true;
};

let hand = [9,13,15,23,22,25,16,21,18,21,24,23,10,21,16,18,16,18,5,20,19,20,10,14,26,2,9,19,12,28,17,5,7,25,22,16,17,21,11];
let groupSize = 10;

console.log(isNStraightHand(hand,groupSize));
```


---
## 883. 三维形体投影面积

在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。

现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。

投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。

返回 所有三个投影的总面积 。

提示：

n == grid.length == grid[i].length
1 <= n <= 50
0 <= grid[i][j] <= 50

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var projectionArea = function(grid) {
    let n=grid.length;
    let sumXY=0;
    let sumXZ=new Array(n).fill(0);
    let sumYZ=new Array(n).fill(0);
    for (let i=0;i<n;i++){
        for (let j=0;j<n;j++){
            if (grid[i][j]>0) {
                sumXY+=1;
                sumXZ[i]=Math.max(sumXZ[i],grid[i][j]);
                sumYZ[j]=Math.max(sumYZ[j],grid[i][j]);
            }
        }
    }
    for (let i=0;i<n;i++){
        sumXY+=sumXZ[i]+sumYZ[i];
    }
    return sumXY;
};

let grid=[[1,2],[3,4]];
let result=projectionArea(grid);
console.log(result);
```




---
## 868. 二进制间距

给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。

如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。

```js
/**
 * @param {number} n
 * @return {number}
 */
var binaryGap = function(n) {
    n=n.toString(2);
    let ans=0;
    let count=0;
    let flag=false;
    for (let i=0;i<n.length;i++){
        if (n[i]==="1") {
            if (n[i-1]==="1") {
                ans=Math.max(1,ans);
            }else{
                if (count>1) {
                    ans=Math.max(ans,count);
                }
            }
            count=1;
        }else if (n[i]==="0") {
            if (count>0) {
                count++;
            }
        }
    }
    return ans;
};

let test=22;
let result=binaryGap(test);
console.log(result);
```

```js
var binaryGap = function(n) {
    let last = -1, ans = 0;
    for (let i = 0; n != 0; ++i) {
        if ((n & 1) === 1) {
            if (last !== -1) {
                ans = Math.max(ans, i - last);
            }
            last = i;
        }
        n >>= 1;
    }
    return ans;
};

```


---
## 905. 按奇偶排序数组

给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。

返回满足此条件的 任一数组 作为答案。

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArrayByParity = function(nums) {
    let temp;
    for (let i=0,j=nums.length-1;i<j;){
        if (isEven(nums[i])) {  //左边位是偶数，不动
            i++;
        }else{
            //左边位是奇数，与右边的偶数换位置
            if(isEven(nums[j])){
                temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }else{
                j--;
            }
        }
    }
    return nums;
};
var isEven=function(num){
    return num%2===0;
}

let test=[3,1,2,4]
let result=sortArrayByParity(test);
console.log(result);
```


---
## 908. 最小差值 I

给你一个整数数组 nums，和一个整数 k 。

在一个操作中，您可以选择 0 <= i < nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。

nums 的 分数 是 nums 中最大和最小元素的差值。 

在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。

提示：

1 <= nums.length <= 104
0 <= nums[i] <= 104
0 <= k <= 104

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var smallestRangeI = function(nums, k) {
    let maxValue=nums[0];
    let minValue=nums[0];
    for (let i=1;i<nums.length;i++){
        maxValue=Math.max(maxValue,nums[i]);
        minValue=Math.min(minValue,nums[i]);
    }
    if (maxValue-minValue-2*k<=0) {
        return 0;
    }else{
        return maxValue-minValue-2*k;
    }
};

let nums = [1,3,6], k = 3;
let result=smallestRangeI(nums,k);
console.log(result);
```




---
## 913. 猫和老鼠

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

**老鼠从节点 1 开始**，第一个出发；**猫从节点 2 开始**，第二个出发。**在节点 0 处有一个洞**。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，**猫无法移动到洞中（节点 0**）。

然后，游戏在出现以下三种情形之一时结束：

- 如果猫和老鼠出现在同一个节点，猫获胜。
- 如果老鼠到达洞中，老鼠获胜。
- 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。

给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：

- 如果老鼠获胜，则返回 1；

- 如果猫获胜，则返回 2；
- 如果平局，则返回 0 。

提示：

3 <= graph.length <= 50
1 <= graph[i].length < graph.length
0 <= graph[i][j] < graph.length
graph[i][j] != i
graph[i] 互不相同
猫和老鼠在游戏中总是移动

![猫和老鼠动态规划1](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划1.png)

![猫和老鼠动态规划2](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划2.png)

```js
const MOUSE_WIN=1;
const CAT_WIN=2;
const DRAW=0;

/**
 * @param {number[][]} graph
 * @return {number}
 */
var catMouseGame = function(graph) {
    this.n=graph.length;
    this.graph=graph;
    this.dp=new Array(n).fill(0).map(()=>new Array(n).fill(0).map(()=>new Array(n*2).fill(-1)));
    //console.log(this.dp);
    return getResult(1,2,0);
};

const getResult=(mouse,cat,turns)=>{
    if (turns===n*2) {
        return DRAW;
    }
    if (dp[mouse][cat][turns]<0) {
        if (mouse===0) {
            dp[mouse][cat][turns]=MOUSE_WIN;
        }else if(cat===mouse){
            dp[mouse][cat][turns]=CAT_WIN;
        }else{
            getNextResult(mouse,cat,turns);
        }
    }
    return dp[mouse][cat][turns];
}

const getNextResult=(mouse,cat,turns)=>{
    const curMove=turns%2===0 ? mouse : cat;
    const defaultResult=curMove===mouse ? CAT_WIN : MOUSE_WIN;
    let result=defaultResult;
    const nextNodes=graph[curMove];
    for (let next of nextNodes){
        if (curMove===cat  && next===0) {
            continue;
        }
        const nextMouse=curMove===mouse ? next : mouse;
        const nextCat=curMove===cat ? next : cat;
        const nextResult=getResult(nextMouse,nextCat,turns+1);
        if (nextResult!==defaultResult) {
            result=nextResult;
            if (result!==DRAW) {
                break;
            }
        }
    }
    dp[mouse][cat][turns]=result;
}


let test = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]];
let result=catMouseGame(test);
console.log(result);
```


---
## 917. 仅仅反转字母

给你一个字符串 s ，根据下述规则反转字符串：

所有非英文字母保留在原有位置。
所有英文字母（小写或大写）位置反转。
返回反转后的 s 。

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseOnlyLetters = function(s) {
	s=s.split("");
    let right=s.length-1;
    let left=0;
    let temp="";
    //console.log(set);
    while(left<right){
    	let acci1=s[left].toLowerCase().charCodeAt()
        if (acci1>96 && acci1<123) {
            temp=s[left];
    		let acci2=s[right].toLowerCase().charCodeAt()
            if (acci2>96 && acci2<123) {
                s[left]=s[right];
                s[right]=temp;
                left++;
                right--;
            }else{
                right--;
            }
        }else{
            left++;
        }
    }
    return s.join("");
};

let test= "a-bC-dEf-ghIj";
let result=reverseOnlyLetters(test);
console.log(result);

//console.log("a".charCodeAt());  //97
//console.log("z".charCodeAt());  //122
//console.log("A".charCodeAt());  //65
//console.log("Z".charCodeAt());  //90

```

933. 最近的请求次数
写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。

提示：

1 <= t <= 109
保证每次对 ping 调用所使用的 t 值都 严格递增
至多调用 ping 方法 104 次

```js
var RecentCounter = function() {
    this.requests=[];
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
    this.requests.push(t);
    while(this.requests.length>1 && t-3000>this.requests[0]){
        this.requests.shift();
    }
    return this.requests.length;
};

/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */

```




---
## 937. 重新排列日志文件

给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。

有两种不同类型的日志：

字母日志：除标识符之外，所有字均由小写字母组成
数字日志：除标识符之外，所有字均由数字组成
请按下述规则将日志重新排序：

所有 字母日志 都排在 数字日志 之前。
字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。
数字日志 应该保留原来的相对顺序。
返回日志的最终顺序。

 

提示：

1 <= logs.length <= 100
3 <= logs[i].length <= 100
logs[i] 中，字与字之间都用 单个 空格分隔
题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字

```js
/**
 * @param {string[]} logs
 * @return {string[]}
 */
var reorderLogFiles = function(logs) {
    let n=logs.length;
    const arr=new Array(n).fill(0);
    for (let i=0;i<n;i++){
        arr[i]=[logs[i],i];
    }
    arr.sort((a,b)=>logCompare(a,b));
    const ans=new Array(n).fill(0);
    for (let i=0;i<n;i++){
        ans[i]=arr[i][0];
    }
    return ans;
};

const logCompare=(log1,log2)=>{
    let split1=split(log1[0]," ");
    let split2=split(log2[0]," ");
    let isDigit1=isDigit(split1[1][0]);
    let isDigit2=isDigit(split2[1][0]);
    if (isDigit1 && isDigit2) {
        return log1[1]-log2[1];
    }
    if (!isDigit1 && !isDigit2) {
        let sc=compareTo(split1[1],split2[1]);
        if (sc!==0) {
            return sc;
        }
        return compareTo(split1[0],split2[0]);
    }
    return isDigit1 ? 1 : -1;
};

const isDigit=(ch)=>{
    return parseFloat(ch).toString()==="NaN" ? false : true;
};

const compareTo=(left,right)=>{
    for (let i=0;i<Math.min(left.length,right.length);i++){
        if (left[i].charCodeAt()<right[i].charCodeAt()) {
            return -1;
        }
        if (left[i].charCodeAt()>right[i].charCodeAt()) {
            return 1;
        }
    }
    if (left.length===right.length) {
        return 0;
    }
    if (left.length>right.length) {
        return 1;
    }
    return -1;
};

const split=(str,separator)=>{
    let firstItem=str.split(separator)[0];
    let ret=[firstItem];
    let index=str.indexOf(separator);
    ret.push(str.slice(index+1,str.length));
    return ret;
}

let logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"];
let result=reorderLogFiles(logs);
console.log(result);
```


---
## 942.增减字符串匹配

由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:

如果 perm[i] < perm[i + 1] ，那么 s[i] == 'I' 
如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 
给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。

提示：

1 <= s.length <= 105
s 只包含字符 "I" 或 "D"

```js
/**
 * @param {string} s
 * @return {number[]}
 */
var diStringMatch = function(s) {
    let ans=[];
    let n=s.length;
    let left=0,right=n;
    for (let i=0;i<n;i++){
        if (s[i]==="I") {
            //比后一个小则加入当前没有加入最小的的一个
            ans.push(left);
            left++;
        }else if(s[i]==="D"){
            //比后一个大则加入当前没有加入最大的的一个
            ans.push(right);
            right--;
        }
    }
    ans.push(left);  //或 ans.push(right);

    return ans;
};

let s = "DDDII";
let result=diStringMatch(s)
console.log(result);
```

---

## 944.删列造序

给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。

这些字符串可以每个一行，排成一个网格。例如，strs = ["abc", "bce", "cae"] 可以排列为：

```
abc
bce
cae
```

你需要找出并删除 不是按字典序升序排列的 列。在上面的例子（下标从 0 开始）中，列 0（'a', 'b', 'c'）和列 2（'c', 'e', 'e'）都是按升序排列的，而列 1（'b', 'c', 'a'）不是，所以要删除列 1 。

返回你需要删除的列数。

提示：

n == strs.length
1 <= n <= 100
1 <= strs[i].length <= 1000
strs[i] 由小写英文字母组成

```js
/**
 * @param {string[]} strs
 * @return {number}
 */
var minDeletionSize = function(strs) {
    if (strs.length < 2){
        return 0;
    }
    let n=strs.length;
    let m=strs[0].length;
    let ans=0;
    for (let i=0;i<m;i++){
        for (let j=1;j<n;j++){
            if (strs[j][i].charCodeAt() < strs[j-1][i].charCodeAt()){
                ans++;
                break;
            }
        }
    }
    return ans;
};

let strs = ["zyx","wvu","tsr"];
let result=minDeletionSize(strs);
console.log(result);
```

---

## 953. 验证外星语词典

某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。

给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。

提示：

1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
在 words[i] 和 order 中的所有字符都是英文小写字母。

```js
/**
 * @param {string[]} words
 * @param {string} order
 * @return {boolean}
 */
var isAlienSorted = function(words, order) {
    if (words.length === 1) {
        return true;
    }
    const m = new Map();
    order.split("").forEach((item, index)=>{
        m.set(item,index);
    });
    for (let i = 0; i < words.length - 1; i++){
        let flag = false;
        for (let j = 0; j < words[i].length, j < words[i + 1].length; j++){
            if (m.get(words[i][j]) > m.get(words[i+1][j])) {
                console.log(words[i][j],words[i+1][j])
                return false;
            }else if (m.get(words[i][j]) < m.get(words[i+1][j])){
                //满足字典序
                flag = true;
                break;
            }
        }
        if (!flag) {
            //比较两个字符串的长度
            if (words[i].length > words[i + 1].length ){
                return false;
            }
        }
    }
    return true;
};

let words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz";
let result = isAlienSorted(words, order);
console.log(result);
```




---
## 954. 二倍数对数组

给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 <= i < len(arr) / 2，都有 arr[2 * i + 1] = 2 * arr[2 * i]” 时，返回 true；否则，返回 false。

提示：

0 <= arr.length <= 3 * 104
arr.length 是偶数
-105 <= arr[i] <= 105

超时

```js
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var canReorderDoubled = function(arr) {
	let n=arr.length;
	arr.sort((a,b)=>a-b);
	//console.log(arr);
	let temp,index0;
	while(arr.length>0){
		temp=arr.shift();
		if (temp<0) {
			index0=arr.indexOf(temp/2);
		}else{
			index0=arr.indexOf(temp*2);
		}
		if (index0===-1) {
			return false;
		}else{
			arr.splice(index0,1);
		}
	}
	return true;
};

let arr = [4,-2,2,-4];
let result=canReorderDoubled(arr);
console.log(result);
```

hashmap

```js
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var canReorderDoubled = function(arr) {
	let n=arr.length;
	if (n===0) {
		return false;
	}
	arr.sort((a,b)=>b-a);
	//console.log(arr);
	let m=new Map();
	m.set(arr[0],1);
	for (let i=1;i<n;i++){
		//console.log(s);
		if (arr[i]>=0) {
			if (m.has(arr[i]*2)) {
				m.set(arr[i]*2,m.get(arr[i]*2)-1);
				if (m.get(arr[i]*2)===0) {
					m.delete(arr[i]*2);
				}
			}else{
				m.set(arr[i],m.has(arr[i]) ? m.get(arr[i])+1 : 1);
			}
		}else{
			if (m.has(arr[i]/2)) {
				m.set(arr[i]/2,m.get(arr[i]/2)-1);
				if (m.get(arr[i]/2)===0) {
					m.delete(arr[i]/2);
				}
			}else{
				m.set(arr[i],m.has(arr[i]) ? m.get(arr[i])+1 : 1);
			}
		}
	}
	//console.log(m);
	return m.size===0;
};

let arr = [2,1,2,1,1,1,2,2];
let result=canReorderDoubled(arr);
console.log(result);
```

---

## 961. 在长度 2N 的数组中找出重复 N 次的元素

给你一个整数数组 nums ，该数组具有以下属性：

nums.length == 2 * n.
nums 包含 n + 1 个 不同的 元素
nums 中恰有一个元素重复 n 次
找出并返回重复了 n 次的那个元素。

提示：

2 <= n <= 5000
nums.length == 2 * n
0 <= nums[i] <= 104
nums 由 n + 1 个 不同的 元素组成，且其中一个元素恰好重复 n 次

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var repeatedNTimes = function(nums) {
    let n = nums.length / 2;
    let m = new Map();
    for (let i = 0; i < 2 * n; i++){
        m.set(nums[i], m.has(nums[i]) ? m.get(nums[i]) + 1 : 1);
        if (m.get(nums[i]) === n) {
            return nums[i];
        }
    }
};

let nums = [1,2,3,3];
let result = repeatedNTimes(nums);
console.log(result);
```

那么数组中剩余的元素均只出现了一次。也就是说，我们只需要找到重复出现的元素即为答案。

```js
var repeatedNTimes = function(nums) {
    const found = new Set();
    for (const num of nums) {
        if (found.has(num)) {
            return num;
        }
        found.add(num);
    }
    // 不可能的情况
    return -1;
};

```



我们可以每次随机选择两个不同的下标，判断它们对应的元素是否相等即可。如果相等，那么返回任意一个作为答案。

```js
var repeatedNTimes = function(nums) {
    const n = nums.length;

    while (true) {
        const x = Math.floor(Math.random() * n), y = Math.floor(Math.random() * n);
        if (x !== y && nums[x] === nums[y]) {
            return nums[x];
        }
    }
};
```

我们只需要遍历所有间隔 2 个位置及以内的下标对，判断对应的元素是否相等即可。

```js
var repeatedNTimes = function(nums) {
    const n = nums.length;
    for (let gap = 1; gap <= 3; ++gap) {
        for (let i = 0; i + gap < n; ++i) {
            if (nums[i] === nums[i + gap]) {
                return nums[i];
            }
        }
    }
    // 不可能的情况
    return -1;
};
```

---






---
## 969. 煎饼排序

给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。

一次煎饼翻转的执行过程如下：

选择一个整数 k ，1 <= k <= arr.length
反转子数组 arr[0...k-1]（下标从 0 开始）
例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。

以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。

提示：

1 <= arr.length <= 100
1 <= arr[i] <= arr.length
arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）

```js
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var pancakeSort = function(arr) {
    let result=[];
    let n=arr.length;
    while(n>1){
        let maxValueIndex=findMaxValueIndex(arr,n);
        if (maxValueIndex!==n-1) {
            if (maxValueIndex!==0) {
                result.push(maxValueIndex+1);
                swapArrSort(arr,maxValueIndex);
            }
            result.push(n);
            swapArrSort(arr,n-1);
        }
        n--;
        //console.log(arr);
    }
    return result;

};
var findMaxValueIndex=function(arr,n){
    for(let i=0;i<n;i++){
        if (arr[i]===n) {
            return i;
        }
    }
}
var swapArrSort=function(arr,n){
    let temp;
    for(let i=0,j=n;i<j;i++,j--){
        temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}


let test=[3,2,4,5,6,1];
let result=pancakeSort(test);
console.log(result);

```




---
## 1001. 网格照明

在大小为 n x n 的网格 grid 上，每个单元格都有一盏灯，最初灯都处于 关闭 状态。

给你一个由灯的位置组成的二维数组 lamps ，其中 lamps[i] = [rowi, coli] 表示 打开 位于 grid[rowi][coli] 的灯。即便同一盏灯可能在 lamps 中多次列出，不会影响这盏灯处于 打开 状态。

当一盏灯处于打开状态，它将会照亮 自身所在单元格 以及同一 行 、同一 列 和两条 对角线 上的 所有其他单元格 。

另给你一个二维数组 queries ，其中 queries[j] = [rowj, colj] 。对于第 j 个查询，如果单元格 [rowj, colj] 是被照亮的，则查询结果为 1 ，否则为 0 。在第 j 次查询之后 [按照查询的顺序] ，关闭 位于单元格 grid[rowj][colj] 上及相邻 8 个方向上（与单元格 grid[rowi][coli] 共享角或边）的任何灯。

返回一个整数数组 ans 作为答案， ans[j] 应等于第 j 次查询 queries[j] 的结果，1 表示照亮，0 表示未照亮。

提示：

1 <= n <= 109
0 <= lamps.length <= 20000
0 <= queries.length <= 20000
lamps[i].length == 2
0 <= rowi, coli < n
queries[j].length == 2
0 <= rowj, colj < n

```
/**
 * @param {number} n
 * @param {number[][]} lamps
 * @param {number[][]} queries
 * @return {number[]}
 */
var gridIllumination = function(n, lamps, queries) {
    let grids=new Array(n);
    for (let i=0;i<n;i++){
        grids[i]=new Array(n).fill(0);
    }
    //N,NE,E,ES,S,SE,E,EN
    const dirs=[[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]
    lamps.forEach((lamp)=>{
        if (grids[lamp[0]][lamp[1]]<4*(n-1)+1) {
            //避免灯重复变亮
            dirs.forEach((dir)=>{
                let row=lamp[0];
                let col=lamp[1];
                while(row>=0 && row<n && col>=0 && col<n ){
                    grids[row][col]+=1;
                    row+=dir[0];
                    col+=dir[1];
                }
            });
            grids[lamp[0]][lamp[1]]+=4*(n-1)+1;
        }
    });
    //console.log(grids);
    const result=[];
    queries.forEach((query)=>{
        if (grids[query[0]][query[1]]>0) {
            result.push(1);
        }else{
            result.push(0);
        }
        if (grids[query[0]][query[1]]>4*(n-1)) {
            //查询的灯亮着
            //关闭该灯并设置被照明的网格-1
            shutTheLamp(grids,query[0],query[1],n);
            //console.log(grids);
        }
        dirs.forEach((dir)=>{
            let row=query[0]+dir[0];
            let col=query[1]+dir[1];
            if(row>=0 && row<n && col>=0 && col<n ){
                if (grids[row][col]>4*(n-1)) {
                    //查询灯其他方向上位置的灯亮着
                    //关闭该灯并设置被照明的网格-1
                    shutTheLamp(grids,row,col,n);
                    //console.log(grids);
                }
            }
        });
    });
    return result;
};

var shutTheLamp=function(grids,row0,col0,n){
    const dirs=[[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]];
    dirs.forEach((dir)=>{
        let row=row0;
        let col=col0;
        while(row>=0 && row<n && col>=0 && col<n ){
            grids[row][col]-=1;
            row+=dir[0];
            col+=dir[1];
        }
    });
    grids[row0][col0]-=(4*(n-1)+1);
};

let n = 1;
//let lamps =[[2,5],[4,2],[0,3],[0,5],[1,4],[4,2],[3,3],[1,0]];
//let queries = [[4,3],[3,1],[5,3],[0,5],[4,4],[3,3]];
let lamps=[[0,0],[0,0]];
let queries=[[0,0],[0,0]];
let result=gridIllumination(n,lamps,queries);
console.log(result);
```

哈希表

![网格照明(哈希表)](E:\pogject\学习笔记\image\leetcode\网格照明(哈希表).png)

```
var gridIllumination = function(n, lamps, queries) {
    const row = new Map();
    const col = new Map();
    const diagonal = new Map();
    const antiDiagonal = new Map();
    const points = new Set();
    for (const lamp of lamps) {
        if (points.has(hash(lamp[0], lamp[1]))) {
            continue;
        }
        points.add(hash(lamp[0], lamp[1]));
        row.set(lamp[0], (row.get(lamp[0]) || 0) + 1);
        col.set(lamp[1], (col.get(lamp[1]) || 0) + 1);
        diagonal.set(lamp[0] - lamp[1], (diagonal.get(lamp[0] - lamp[1]) || 0) + 1);
        antiDiagonal.set(lamp[0] + lamp[1], (antiDiagonal.get(lamp[0] + lamp[1]) || 0) + 1);
    }
    const ret = new Array(queries.length).fill(0);
    for (const [i, [r, c]] of queries.entries()) {
        if (row.get(r) || col.get(c) || diagonal.get(r - c) || antiDiagonal.get(r + c)) {
            ret[i] = 1;
        }
        for (let x = r - 1; x < r + 2; x++) {
            for (let y = c - 1; y < c + 2; y++) {
                if (x < 0 || y < 0 || x >= n || y >= n || !points.has(hash(x, y))) {
                    continue;
                }
                points.delete(hash(x, y));
                row.set(x, row.get(x) - 1);
                col.set(y, col.get(y) - 1);
                diagonal.set(x - y, diagonal.get(x - y) - 1);
                antiDiagonal.set(x + y, antiDiagonal.get(x + y) - 1);
            }
        }
    }
    return ret;
}

const hash = (x, y) => {
    return '' + x + y;
};

```


---
## 1020. 飞地的数量

给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。

一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。

返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。

来提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid[i][j] 的值为 0 或 1

方法一：深度优先搜索
根据飞地的定义，如果从一个陆地单元格出发无法移动到网格边界，则这个陆地单元格是飞地。因此可以将所有陆地单元格分成两类：第一类陆地单元格和网格边界相连，这些陆地单元格不是飞地；第二类陆地单元格不和网格边界相连，这些陆地单元格是飞地。

我们可以从网格边界上的每个陆地单元格开始深度优先搜索，遍历完边界之后，所有和网格边界相连的陆地单元格就都被访问过了。然后遍历整个网格，如果网格中的一个陆地单元格没有被访问过，则该陆地单元格不和网格的边界相连，是飞地。

代码实现时，由于网格边界上的单元格一定不是飞地，因此遍历网格统计飞地的数量时只需要遍历不在网格边界上的单元格。

```js
var numEnclaves = function(grid) {
    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    const m = grid.length;
    const n = grid[0].length;
    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));

    const dfs = (grid, row, col) => {
        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {
            return;
        }
        visited[row][col] = true;
        for (const dir of dirs) {
            dfs(grid, row + dir[0], col + dir[1]);
        }
    };

    for (let i = 0; i < m; i++) {
        dfs(grid, i, 0);
        dfs(grid, i, n - 1);
    }
    for (let j = 1; j < n - 1; j++) {
        dfs(grid, 0, j);
        dfs(grid, m - 1, j);
    }
    let enclaves = 0;
    for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
            if (grid[i][j] === 1 && !visited[i][j]) {
                enclaves++;
            }
        }
    }
    return enclaves;
}

let test=[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]];
let result=numEnclaves(test);
console.log(result);
```

方法二：广度优先搜索
也可以通过广度优先搜索判断每个陆地单元格是否和网格边界相连。

首先从网格边界上的每个陆地单元格开始广度优先搜索，访问所有和网格边界相连的陆地单元格，然后遍历整个网格，统计飞地的数量。

```js
var numEnclaves = function(grid) {
    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    const m = grid.length;
    const n = grid[0].length;
    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));
    const queue=[];

    for (let i = 0; i < m; i++) {
        if (grid[i][0]===1) {
            visited[i][0]=true;
            queue.push([i,0]);
        }
        if (grid[i][n-1]===1) {
            visited[i][n-1]=true;
            queue.push([i,n-1]);
        }
    }
    for (let j = 1; j < n - 1; j++) {
        if (grid[0][j]===1) {
            visited[0][j]=true;
            queue.push([0,j]);
        }
        if (grid[m-1][j]===1) {
            visited[m-1][j]=true;
            queue.push([m-1,j]);
        }
    }
    while(queue.length){
        const cell=queue.shift();
        const currRow=cell[0];
        const currCol=cell[1];
        for (const dir of dirs){
            const nextRow=currRow+dir[0];
            const nextCol=currCol+dir[1];
            if (nextRow > 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {
            visited[nextRow][nextCol]=true;
            queue.push([nextRow,nextCol]);
        }
        }

    }
    let enclaves = 0;
    for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
            if (grid[i][j] === 1 && !visited[i][j]) {
                enclaves++;
            }
        }
    }
    return enclaves;
}

let test=[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]];
let result=numEnclaves(test);
console.log(result);
```

方法三：并查集
除了深度优先搜索和广度优先搜索的方法以外，也可以使用并查集判断每个陆地单元格是否和网格边界相连。

并查集的核心思想是计算网格中的每个陆地单元格所在的连通分量。对于网格边界上的每个陆地单元格，其所在的连通分量中的所有陆地单元格都不是飞地。如果一个陆地单元格所在的连通分量不同于任何一个网格边界上的陆地单元格所在的连通分量，则该陆地单元格是飞地。

并查集的做法是，遍历整个网格，对于网格中的每个陆地单元格，将其与所有相邻的陆地单元格做合并操作。由于需要判断每个陆地单元格所在的连通分量是否和网格边界相连，因此并查集还需要记录每个单元格是否和网格边界相连的信息，在合并操作时更新该信息。

在遍历网格完成并查集的合并操作之后，再次遍历整个网格，通过并查集中的信息判断每个陆地单元格是否和网格边界相连，统计飞地的数量。

```js
var numEnclaves = function(grid) {
    const m = grid.length, n = grid[0].length;
    const uf = new UnionFind(grid);
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                const index = i * n + j;
                if (j + 1 < n && grid[i][j + 1] === 1) {
                    uf.union(index, index + 1);
                }
                if (i + 1 < m && grid[i + 1][j] === 1) {
                    uf.union(index, index + n);
                }
            }
        }
    }
    let enclaves = 0;
    for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
            if (grid[i][j] === 1 && !uf.isOnEdge(i * n + j)) {
                enclaves++;
            }
        }
    }
    return enclaves;
}

class UnionFind {
    constructor(grid) {
        const m = grid.length, n = grid[0].length;
        this.parent = new Array(m * n).fill(0);
        this.onEdge = new Array(m * n).fill(false);
        this.rank = new Array(m * n).fill(0);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (grid[i][j] === 1) {
                    const index = i * n + j;
                    this.parent[index] = index;
                    if (i === 0 || i === m - 1 || j === 0 || j === n - 1) {
                        this.onEdge[index] = true;
                    }
                }
            }
        }
    }

    find(i) {
        if (this.parent[i] !== i) {
            this.parent[i] = this.find(this.parent[i]);
        }
        return this.parent[i];
    }

    union(x, y) {
        const rootx = this.find(x);
        const rooty = this.find(y);
        if (rootx !== rooty) {
            if (this.rank[rootx] > this.rank[rooty]) {
                this.parent[rooty] = rootx;
                this.onEdge[rootx] |= this.onEdge[rooty];
            } else if (this.rank[rootx] < this.rank[rooty]) {
                this.parent[rootx] = rooty;
                this.onEdge[rooty] |= this.onEdge[rootx];
            } else {
                this.parent[rooty] = rootx;
                this.onEdge[rootx] |= this.onEdge[rooty];
                this.rank[rootx]++;
            }
        }
    }

    isOnEdge(i) {
        return this.onEdge[this.find(i)];
    }
}

```




---
## 1044.最长重复子串

给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。

提示：

2 <= s.length <= 3 * 104
s 由小写英文字母组成

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    let strA;
    for (let k=s.length-1;k>0;k--){
        for (let i=0;i+k<s.length;i++){
            strA=s.slice(i,i+k);
            if (i!==s.lastIndexOf(strA)){
                return strA;
            }
        }
        
    }
    return "";
};

let str1 = "basanaadsfenafdrrgeana";
let result=longestDupSubstring(str1);
console.log(result);
```

超时


---
## 1154.  一年中的第几天

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

提示：

date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

```js
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    let y=Number(date.split("-")[0]);
    let m=Number(date.split("-")[1]);
    let d=Number(date.split("-")[2]);
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];

    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }

    let total=0;
    for (let i=0;i<m-1;i++){
        total+=monthOfDays[i]
    }
    total+=d;
    if (m>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }

    return total;
};

let str1 = "2022-01-01";

let result=dayOfYear(str1);
console.log(result);
```

**普通闰年:公历年份是4的倍数的，一般是闰年。（如2004年就是闰年）；
世纪闰年:公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是世纪闰年，2000年是世纪闰年）；**


---
## 1185. 一周中的第几天

给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

输入：day = 31, month = 8, year = 2019
输出："Saturday"

题目规定输入的日期一定是在 1971 到 2100 年之间的有效日期，即在 1971 年 1 月 1日，到 2100 年 12 月 31 日之间。通过查询日历可知，1970 年 12 月 31 日是星期四，我们只需要算出输入的日期距离 1970 年 12 月 31 日有几天，再加上 3 后对 7求余，即可得到输入日期是一周中的第几天。

求输入的日期距离 1970 年 12 月 31 日的天数，可以分为三部分分别计算后求和：

（1）输入年份之前的年份的天数贡献；
（2）输入年份中，输入月份之前的月份的天数贡献；
（3）输入月份中的天数贡献。

```js
var isLeap=function(y){
    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }
    return is_leap;
}

/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(year,month,day) {
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];
    let is_leap=isLeap(year);

    let total=0;
    for (let i=0;i<month-1;i++){
        total+=monthOfDays[i]
    }
    total+=day;
    if (month>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }
    return total;
};

/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    let totalDays=0;
    for(let y=1971;y<year;y++){
        totalDays+=365;
        if (isLeap(y)){
            console.log(y);
            totalDays+=1
        }
    }
    totalDays+=dayOfYear(year,month,day)+3;
    return weekdays[totalDays%7];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```

直接使用API

```js
/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    let weekDay=date.getDay();  //从 Date 对象返回一周中的某一天 (0 ~ 6)。
    return weekdays[weekDay];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```


---
## 1189. “气球” 的最大数量

给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。

字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。

提示：

1 <= text.length <= 10^4
text 全部由小写英文字母组成

```js
/**
 * @param {string} text
 * @return {number}
 */
var maxNumberOfBalloons = function(text) {
    let m=new Map([["b",0],["a",0],["l",0],["o",0],["n",0]]);
    for(let i=0;i<text.length;i++){
        if (m.has(text[i])) {
            m.set(text[i],m.get(text[i])+1);
        }
    }
    let minNum=text.length;
    m.forEach((v,k)=>{
        if (k==="l" || k==="o") {
            minNum=Math.min(minNum,v>>1);
        }else{
            minNum=Math.min(minNum,v);
        }
    });
    return minNum;
};


let test="loonbalxballpoon";
let result=maxNumberOfBalloons(test);
console.log(result);
```




---
## 1219. 黄金矿工

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

提示：

1 <= grid.length, grid[i].length <= 15
0 <= grid[i][j] <= 100
最多 25 个单元格中有黄金。

![黄金矿工回溯算法](E:\pogject\学习笔记\image\leetcode\黄金矿工回溯算法.png)

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var getMaximumGold = function(grid) {
    this.grid=grid;
    this.m=this.grid.length;
    this.n=this.grid[0].length;
    this.dirs=[[-1,0],[1,0],[0,-1],[0,1]];
    this.ans=0;

    const dfs=(x,y,gold,dirs)=>{
        gold+=grid[x][y];
        this.ans=Math.max(ans,gold);

        const rec=grid[x][y];
        grid[x][y]=0;

        for (let d=0;d<4;d++){
            const nx=x+this.dirs[d][0];
            const ny=y+this.dirs[d][1];
            if (nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0) {
                dfs(nx,ny,gold);
            }
        }
        grid[x][y]=rec;
    }

    for (let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            if (grid[i][j]!==0) {
                dfs(i,j,0);
            }
        }
    }
    return ans;
};

let test=[[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]];
let result=getMaximumGold(test);
console.log(result);
```


---
## 1299. 将每个元素替换为右侧最大元素

给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。

完成所有替换操作后，请你返回这个数组。

 提示：

1 <= arr.length <= 104
1 <= arr[i] <= 105

```js
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var replaceElements = function(arr) {
    let n = arr.length -1;
    let MaxRightValue = arr[n];
    arr[n--] = -1;
    while (n >= 0){
        let temp = arr[n];
        arr[n--] = MaxRightValue;
        MaxRightValue = Math.max(MaxRightValue, temp);
    }
    return arr;
};

let arr = [17,18,5,4,6,1];
let result = replaceElements(arr);
console.log(result);
```

```

```



---



## 1305. 两棵二叉搜索树中的所有元素

给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。
提示：

每棵树的节点数在 [0, 5000] 范围内
-105 <= Node.val <= 105

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {number[]}
 */
var getAllElements = function(root1, root2) {
    let value1=[];
    let value2=[]
    //中序遍历
    const inorder=(root,ret)=>{
        if (root) {
            inorder(root.left,ret);
            ret.push(root.val);
            inorder(root.right,ret);
        }
    };

    inorder(root1,value1);
    inorder(root2,value2);

    let ans=[];
    while(value1.length>0 && value2.length>0){
        if (value1[0]<value2[0]) {
            ans.push(value1.shift());
        }else{
            ans.push(value2.shift());
        }
    }
    ans=ans.concat(value1).concat(value2);
    return ans;
};

```




---
## 1380. 矩阵中的幸运数

给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。

幸运数是指矩阵中满足同时下列两个条件的元素：

在同一行的所有元素中最小
在同一列的所有元素中最大


提示：

m == mat.length
n == mat[i].length
1 <= n, m <= 50
`1 <= matrix[i][j] <= 10^5`
矩阵中的所有元素都是不同的

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var luckyNumbers  = function(matrix) {
     let m=matrix.length;
     let n=matrix[0].length;
     const maxColArr=new Array(n).fill(0);;  //每一列的最大值
     const minRowArr=new Array(m).fill(0);  //每一行的最大值索引;
     for(let i=0;i<m;i++){
          for(let j=0;j<n;j++){
               maxColArr[j]=Math.max(maxColArr[j],matrix[i][j]);
               //矩阵中的所有元素都是不同的
               minRowArr[i]=matrix[i][minRowArr[i]]<matrix[i][j] ? minRowArr[i] : j;
          }
     }
     //console.log(matrix);
     //console.log(maxColArr);
     //console.log(minRowArr);
     let result=[];
     for (let i=0;i<m;i++){
          if (matrix[i][minRowArr[i]]===maxColArr[minRowArr[i]]) {
               result.push(matrix[i][minRowArr[i]]);
          }
     }
     return result;

};

let test=[[1,10,4,2],[9,3,8,7],[15,16,17,12]];
let result=luckyNumbers(test);
console.log(result);
```




---
## 1405. 最长快乐字符串

如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。

给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：

s 是一个尽可能长的快乐字符串。
s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。
s 中只含有 'a'、'b' 、'c' 三种字母。
如果不存在这样的字符串 s ，请返回一个空字符串 ""。

来提示：

0 <= a, b, c <= 100
a + b + c > 0

```js
/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {string}
 */
var longestDiverseString = function(a, b, c) {
    let result=[];
    const arr=[[a,'a'],[b,'b'],[c,'c']];
    while(true){
        arr.sort((a,b)=>b[0]-a[0]);
        let hasNext=false;
        for(const [i,[c,ch]] of arr.entries()){
            if (c<=0) {
                break;
            }
            const m=result.length;
            if (m>=2 && result[m-2]===ch && result[m-1]===ch) {
                continue;
            }
            hasNext=true;
            result.push(ch);
            arr[i][0]--;
            break;
        }
        if (!hasNext) {
            break;
        }
    }
    return result.join("");
};



let test=100;
let result=longestDiverseString(1,1,7);
console.log(result);

```


---
## 1447. 最简分数

给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。

 提示：

1 <= n <= 100

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var simplifiedFractions = function(n) {
    if(n===1){
        return [];
    }
    let result=[];
    for(let i=2;i<=n;i++){
        for(j=1;j<i;j++){
            if (gcd(i,j)===1) {
                result.push(j+"/"+i);
            }
        }
    }
    return result;
};
var gcd=function(a,b){
    //辗转相除获取最大公约数
    if (a%b===0) {
        return b;
    }
    return arguments.callee(b,a%b);
}
let test=5;
let result=simplifiedFractions(test);
console.log(result);
```




---
## 1576.替换所有的问号

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你 不能 修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

提示：

1 <= s.length <= 100

s 仅包含小写英文字母和 '?' 字符

在替换时，实际不需要遍历所有的小写字母，只需要遍历三个互不相同的字母，就能保证一定找到一个与前后字符均不相同的字母，在此我们可以限定三个不同的字母为 (‘a’,‘b’,‘c’)。



```js
/**
 * @param {string} s
 * @return {string}
 */
var modifyString = function(s) {
    s=s.split("");
    for (let i=0;i<s.length;i++){
        if (s[i]==="?") {
            if (s[i-1]!=="a" && s[i+1]!=="a") {
                //前后都不为a则设为a
                s[i]="a";
            }else if (s[i-1]==="b" || s[i+1]==="b"){
                //有一个a和一个b，则设为c
                s[i]="c";
            }else{
                //前后都是a时,设为b
                s[i]="b";
            }
        }
    }
    return s.join("");
};

let test = "aza??byw?ipkj?";
let result=modifyString(test)
console.log(result);

//使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定
//fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
/*
console.log("az".charCodeAt(0));  //97
console.log("az".charCodeAt(1));  //122
console.log(String.fromCharCode(97));  //a
console.log(String.fromCharCode(122));  //z
*/
```

```

```


---
## 1601. 最多可达成的换楼请求数目

我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。

给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。

一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。

请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。

提示：

1 <= n <= 20
1 <= requests.length <= 16
requests[i].length == 2
0 <= fromi, toi < n

回溯 + 枚举

```
/**
 * @param {number} n
 * @param {number[][]} requests
 * @return {number}
 */
var maximumRequests = function(n, requests) {
   const delta=new Array(n).fill(0);
   let zero=n,ans=0,cnt=0;
   const dfs=(requests,pos)=>{
      if (pos===requests.length) {
         if (zero===n) {
            ans=Math.max(ans,cnt);
         }
         return;
      }
      //不选 requests[pos]
      dfs(requests,pos+1);
      //选 requests[pos]
      let z=zero;
      ++cnt;
      const r=requests[pos];
      let x=r[0],y=r[1];
      //增加或减少前为0,zero减 1
      zero-=delta[x]===0 ? 1:0;
      --delta[x];
      //增加或减少后为0,zero加1
      zero+=delta[x]===0 ? 1:0;
      //增加或减少前为0,zero减 1
      zero-=delta[y]===0 ? 1:0;
      ++delta[y];
      //增加或减少后为0,zero加1
      zero+=delta[y]===0 ? 1:0;
      dfs(requests,pos+1);
      --delta[y];
      ++delta[x];
      --cnt;
      zero=z;
   }
   dfs(requests,0);
   return ans;
};

let n = 5;
let requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
let result=maximumRequests(n,requests);
console.log(result);
```


---
## 1606. 找到处理最多请求的服务器

你有 k 个服务器，编号为 0 到 k-1 ，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 不能同时处理超过一个请求 。请求分配到服务器的规则如下：

第 i （序号从 0 开始）个请求到达。
如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。
如果第 (i % k) 个服务器空闲，那么对应服务器会处理该请求。
否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 i 个服务器在忙，那么会查看第 (i+1) 个服务器，第 (i+2) 个服务器等等。
给你一个 严格递增 的正整数数组 arrival ，表示第 i 个任务的到达时间，和另一个数组 load ，其中 load[i] 表示第 i 个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 最繁忙的服务器 。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。

请你返回包含所有 最繁忙服务器 序号的列表，你可以以任意顺序返回这个列表。

提示：

1 <= k <= 105
1 <= arrival.length, load.length <= 105
arrival.length == load.length
1 <= arrival[i], load[i] <= 109
arrival 保证 严格递增 。

超时

```js
/**
 * @param {number} k
 * @param {number[]} arrival
 * @param {number[]} load
 * @return {number[]}
 */
var busiestServers = function(k, arrival, load) {
	let n=arrival.length;
	let serveNum=new Array(k).fill(0);  //执行的任务数
	let taskTime=new Array(k).fill(0);  //还需要多久执行完正在执行的任务
	serveNum[0]=1;
	taskTime[0]=load[0];
	let k1=0;
	for (let i=1;i<n;i++){
		for(let k2=0;k2<k;k2++){
			taskTime[k2]-=(arrival[i]-arrival[i-1]);
		}
		k1=i%k;
		if (taskTime[k1]<=0) {
			taskTime[k1]=load[i];
			serveNum[k1]++;
		}else{
			let flag=true;
			for (let j=k1+1;j<k;j++){
				if (taskTime[j]<=0) {
					taskTime[j]=load[i];
					serveNum[j]++;
					flag=false;
					break;
				}
			}
			if (flag) {
				//需要遍历完所有服务器
				for (let j=0;j<k1;j++){
					if (taskTime[j]<=0) {
						taskTime[j]=load[i];
						serveNum[j]++;
						break;
					}
				}
			}
		}
		//console.log(taskTime);
	}
	let ans=[0];
	for (let i=1;i<k;i++){
		if (serveNum[i]>serveNum[ans[0]]) {
			ans=[i];
		}else if(serveNum[i]===serveNum[ans[0]]){
			ans.push(i);
		}
	}
	return ans;
};
let k = 7, arrival = [1,3,4,5,6,11,12,13,15,19,20,21,23,25,31,32], load = [9,16,14,1,5,15,6,10,1,1,7,5,11,4,4,6] ;
let result=busiestServers(k, arrival, load);
console.log(result);

```

官方解答

![找到处理最多请求的服务器](E:\pogject\学习笔记\image\leetcode\找到处理最多请求的服务器.png)

```

```






---
## 1614.括号的最大嵌套深度

如果字符串满足以下条件之一，则可以称之为 **有效括号字符串**（valid parentheses string，可以简写为 VPS）：

- 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。

- 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。

- 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。

类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：

- depth("") = 0

- depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
- depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
- depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串

例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。

**给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。**

提示：

1 <= s.length <= 100
s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
题目数据保证括号表达式 s 是 有效的括号表达式

栈处理

```js
/**
 * @param {string} s
 * @return {number}
 */
var maxDepth = function(s) {
    let arr=[];
    let maxDeep=0;
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        if (s[i]===")") {
            //右括号就入栈
            if (arr.length!==0) {
                if (count>0) {
                    //如果前面已经出栈，但栈不为空，局部值减1
                    count--;
                }
            }
            arr.unshift(s[i]);
            //console.log(arr,count);
        }
        if (s[i]==="(") {
            //是左括号则弹出一个右括号,局部计数加一
            arr.shift();
            count++;
            if (arr.length===0) {
                //当出栈后栈为空，则一个区域匹配完，判断最大值
                maxDeep=count>maxDeep ? count : maxDeep;
                count=0;
            }
            //console.log(arr,count);
        }
    }
    return maxDeep;
};

let test = "(1)+((2))+(((((4)((()))))((3))))";
let result=maxDepth(test)
console.log(result);
```

方法一：遍历

对于括号计算类题目，我们往往可以用栈来思考。

遍历字符串 s，如果遇到了一个左括号，那么就将其入栈；如果遇到了一个右括号，那么就弹出栈顶的左括号，与该右括号匹配。这一过程中的栈的大小的最大值，即为 s 的嵌套深度。

代码实现时，由于我们只需要考虑栈的大小，我们可以用一个变量 size 表示栈的大小，当遇到左括号时就将其加一，遇到右括号时就将其减一，从而表示栈中元素的变化。这一过程中 size 的最大值即为 s 的嵌套深度。

```js
/**
 * @param {string} s
 * @return {number}
 */
//不用栈空间是一样的
var maxDepth = function(s) {
    let maxDeep=0;
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        if (s[i]===")") {
            count++;
            maxDeep=count>maxDeep ? count : maxDeep;
        }
        if (s[i]==="(") {
            count--;
        }
    }
    return maxDeep;
};
```


---
## 1629.按键持续时间最长的键

LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。

给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。

测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。

注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。

请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。

提示：

releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed 仅由小写英文字母组成

```js
/**
 * @param {number[]} releaseTimes
 * @param {string} keysPressed
 * @return {character}
 */
var slowestKey = function(releaseTimes, keysPressed) {
    let maxTime=releaseTimes[0];
    let char=keysPressed[0];
    for (let i=1;i<releaseTimes.length;i++){
        let duration=releaseTimes[i]-releaseTimes[i-1]
        if (duration>maxTime) {
            maxTime=duration;
            char=keysPressed[i];
        }
        if (duration===maxTime) {
            if (keysPressed[i].codePointAt(0)>char.codePointAt(0)) {
                char=keysPressed[i];
            }
        }
    }
    return char;
};

let test= [9,29,49,50];
let result=slowestKey(test,"cbcd");
console.log(result);
```


---
## 1672.最富有客户的资产总量

给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。

客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。

提示：

m == accounts.length
n == accounts[i].length
1 <= m, n <= 50
1 <= accounts[i][j] <= 100

```js
/**
 * @param {number[][]} accounts
 * @return {number}
 */
var maximumWealth = function(accounts) {
    let ans=0;
    for (let i=0;i<accounts.length;i++){
        let sum=0;
        accounts[i].forEach((item)=>{
            sum+=item;
        });
        ans=sum>ans ? sum : ans;
    }
    return ans;
};

let test= [[1,2,3],[3,2,1]];
let result=maximumWealth(test);
console.log(result);
```




---
## 1705. 吃苹果的最大数目

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

提示：

apples.length == n
days.length == n
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立

核心思路就是每次都吃最快腐烂的苹果 按照苹果的腐烂时间给苹果排序 需要用到优先队列
首先用实现一个优先队列的插入方法 核心思想二分法就可以
然后将苹果按照过期时间排序 并记录苹果的数量
苹果吃完了 就将队列第一项删除 或者腐烂了也需要删除
直到所有的苹果都遍历完了并且优先队列也空了

```
/**
 * @param {number[]} apples
 * @param {number[]} days
 * @return {number}
 */
var eatenApples = function(apples, days) {
    let count=0;
    let rest=0;
    let temp=0;  //每天长出后有效个苹果
    let max_day=0;

    for (let i=0;i<apples.length;i++){
        if (apples[i]>0) {
            temp=apples[i]>days[i] ? days[i]+1 : apples[i];  //
            apples[i]=temp;
        }
    }
    return apples;
    //return count;
};

let str1 = [1,2,3,5,2];
let str2=[3,2,1,4,2];
let result=eatenApples(str1,str2);
console.log(result);

```


---
## 1706.  球会落何处

 用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。

箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。

将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。
将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。
在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 "V" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。

返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。

```

```




---
## 1719. 重构一棵树的方案数

给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：

pairs 中没有重复元素
xi < yi
令 ways 为满足下面条件的有根树的方案数：

树所包含的所有节点值都在 pairs 中。
一个数对 [xi, yi] 出现在 pairs 中 当且仅当 xi 是 yi 的祖先或者 yi 是 xi 的祖先。
注意：构造出来的树不一定是二叉树。
两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。

请你返回：

如果 ways == 0 ，返回 0 。
如果 ways == 1 ，返回 1 。
如果 ways > 1 ，返回 2 。
一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。

我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。

提示：

1 <= pairs.length <= 105
1 <= xi < yi <= 500
pairs 中的元素互不相同。

```
/**
 * @param {number[][]} pairs
 * @return {number}
 */
var checkWays = function(pairs) {
    const adj = new Map();
    for (const p of pairs) {
        if (!adj.has(p[0])) {
            adj.set(p[0], new Set());
        }
        if (!adj.has(p[1])) {
            adj.set(p[1], new Set());
        }
        adj.get(p[0]).add(p[1]);
        adj.get(p[1]).add(p[0]);
    }
    /* 检测是否存在根节点*/
    let root = -1;
    const entries = new Set();
    for (const entry of adj.entries()) {
        entries.add(entry);
    }
    for (const [node, neg] of entries) {
        if (neg.size === adj.size - 1) {
            root = node;
        }
    }
    if (root === -1) {
        return 0;
    }
    let res = 1;
    for (const [node, neg] of entries) {
        /* 如果当前节点为根节点 */
        if (root === node) {
            continue;
        }
        const currDegree = neg.size;
        let parentNode = -1;
        let parentDegree = Number.MAX_SAFE_INTEGER;
        /* 根据degree的大小找到当前节点的父节点 */
        for (const neighbour of neg) {
            if (adj.has(neighbour) && adj.get(neighbour).size < parentDegree && adj.get(neighbour).size >= currDegree) {
                parentNode = neighbour;
                parentDegree = adj.get(neighbour).size;
            }
        }
        if (parentNode === -1) {
            return 0;
        }
        /* 检测父节点的集合是否包含所有的孩子节点 */
        for (const neighbour of neg) {
            if (neighbour === parentNode) {
                continue;
            }
            if (!adj.get(parentNode).has(neighbour)) {
                return 0;
            }
        }
        if (parentDegree === currDegree) {
            res = 2;
        }
    }
    return res;
};


let test= [[1,2],[2,3],[1,3]];
let result=checkWays(test);
console.log(result);
```


---
## 1728. 猫和老鼠 II

一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。

它们所处的环境设定是一个 rows x cols 的方格 grid ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。

玩家由字符 'C' （代表猫）和 'M' （代表老鼠）表示。
地板由字符 '.' 表示，玩家可以通过这个格子。
墙用字符 '#' 表示，玩家不能通过这个格子。
食物用字符 'F' 表示，玩家可以通过这个格子。
字符 'C' ， 'M' 和 'F' 在 grid 中都只会出现一次。
猫和老鼠按照如下规则移动：

老鼠 先移动 ，然后两名玩家轮流移动。
每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 grid 。
catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。
它们可以停留在原地。
老鼠可以跳跃过猫的位置。
游戏有 4 种方式会结束：

如果猫跟老鼠处在相同的位置，那么猫获胜。
如果猫先到达食物，那么猫获胜。
如果老鼠先到达食物，那么老鼠获胜。
如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。
给你 rows x cols 的矩阵 grid 和两个整数 catJump 和 mouseJump ，双方都采取最优策略，如果老鼠获胜，那么请你返回 true ，否则返回 false 。

提示：

rows == grid.length
cols = grid[i].length
1 <= rows, cols <= 8
grid[i][j] 只包含字符 'C' ，'M' ，'F' ，'.' 和 '#' 。
grid 中只包含一个 'C' ，'M' 和 'F' 。
1 <= catJump, mouseJump <= 8

```
const MOUSE_TURN = 0, CAT_TURN = 1;
const UNKNOWN = 0, MOUSE_WIN = 1, CAT_WIN = 2;
const MAX_MOVES = 1000;
const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
var canMouseWin = function(grid, catJump, mouseJump) {
    this.rows = grid.length;
    this.cols = grid[0].length;
    let startMouse = -1, startCat = -1;

    const getPos = (row, col) => {
        return row * this.cols + col;
    };

    const getPrevStates = (mouse, cat, turn) => {
        const prevStates = [];
        const mouseRow = Math.floor(mouse / this.cols), mouseCol = mouse % this.cols;
        const catRow = Math.floor(cat / this.cols), catCol = cat % this.cols;
        const prevTurn = turn === MOUSE_TURN ? CAT_TURN : MOUSE_TURN;
        const maxJump = prevTurn === MOUSE_TURN ? mouseJump : catJump;
        const startRow = prevTurn === MOUSE_TURN ? mouseRow : catRow;
        const startCol = prevTurn === MOUSE_TURN ? mouseCol : catCol;
        prevStates.push([mouse, cat, prevTurn]);
        for (const dir of dirs) {
            for (let i = startRow + dir[0], j = startCol + dir[1], jump = 1; i >= 0 && i < rows && j >= 0 && j < this.cols && grid[i].charAt(j) !== '#' && jump <= maxJump; i += dir[0], j += dir[1], jump++) {
                const prevMouseRow = prevTurn === MOUSE_TURN ? i : mouseRow;
                const prevMouseCol = prevTurn === MOUSE_TURN ? j : mouseCol;
                const prevCatRow = prevTurn === MOUSE_TURN ? catRow : i;
                const prevCatCol = prevTurn === MOUSE_TURN ? catCol : j;
                const prevMouse = getPos(prevMouseRow, prevMouseCol);
                const prevCat = getPos(prevCatRow, prevCatCol);
                prevStates.push([prevMouse, prevCat, prevTurn]);
            }
        }
        return prevStates;
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < this.cols; j++) {
            const c = grid[i][j];
            if (c === 'M') {
                startMouse = getPos(i, j);
            } else if (c === 'C') {
                startCat = getPos(i, j);
            } else if (c === 'F') {
                food = getPos(i, j);
            }
        }
    }
    const total = rows * this.cols;
    const degrees = new Array(total).fill(0).map(() => new Array(total).fill(0).map(() => new Array(2).fill(0)));
    const results = new Array(total).fill(0).map(() => new Array(total).fill(0).map(() => new Array(2).fill(0).map(() => new Array(2).fill(0))));
    const queue = [];
    // 计算每个状态的度
    for (let mouse = 0; mouse < total; mouse++) {
        let mouseRow = Math.floor(mouse / this.cols), mouseCol = mouse % this.cols;
        if (grid[mouseRow][mouseCol] === '#') {
            continue;
        }
        for (let cat = 0; cat < total; cat++) {
            let catRow = Math.floor(cat / this.cols), catCol = cat % this.cols;
            if (grid[catRow][catCol] === '#') {
                continue;
            }
            degrees[mouse][cat][MOUSE_TURN]++;
            degrees[mouse][cat][CAT_TURN]++;
            for (const dir of dirs) {
                for (let row = mouseRow + dir[0], col = mouseCol + dir[1], jump = 1; row >= 0 && row < rows && col >= 0 && col < this.cols && grid[row][col] !== '#' && jump <= mouseJump; row += dir[0], col += dir[1], jump++) {
                    const nextMouse = getPos(row, col), nextCat = getPos(catRow, catCol);
                    degrees[nextMouse][nextCat][MOUSE_TURN]++;
                }
                for (let row = catRow + dir[0], col = catCol + dir[1], jump = 1; row >= 0 && row < rows && col >= 0 && col < this.cols && grid[row][col] !== '#' && jump <= catJump; row += dir[0], col += dir[1], jump++) {
                    const nextMouse = getPos(mouseRow, mouseCol), nextCat = getPos(row, col);
                    degrees[nextMouse][nextCat][CAT_TURN]++;
                }
            }
        }
    }
    // 猫和老鼠在同一个单元格，猫获胜
    for (let pos = 0; pos < total; pos++) {
        const row = Math.floor(pos / this.cols), col = pos % this.cols;
        if (grid[row][col] === '#') {
            continue;
        }
        results[pos][pos][MOUSE_TURN][0] = CAT_WIN;
        results[pos][pos][MOUSE_TURN][1] = 0;
        results[pos][pos][CAT_TURN][0] = CAT_WIN;
        results[pos][pos][CAT_TURN][1] = 0;
        queue.push([pos, pos, MOUSE_TURN]);
        queue.push([pos, pos, CAT_TURN]);
    }
    // 猫和食物在同一个单元格，猫获胜
    for (let mouse = 0; mouse < total; mouse++) {
        const mouseRow = Math.floor(mouse / this.cols), mouseCol = mouse % this.cols;
        if (grid[mouseRow][mouseCol] === '#' || mouse === food) {
            continue;
        }
        results[mouse][food][MOUSE_TURN][0] = CAT_WIN;
        results[mouse][food][MOUSE_TURN][1] = 0;
        results[mouse][food][CAT_TURN][0] = CAT_WIN;
        results[mouse][food][CAT_TURN][1] = 0;
        queue.push([mouse, food, MOUSE_TURN]);
        queue.push([mouse, food, CAT_TURN]);
    }
    // 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜
    for (let cat = 0; cat < total; cat++) {
        const catRow = Math.floor(cat / this.cols), catCol = cat % this.cols;
        if (grid[catRow][catCol] === '#' || cat === food) {
            continue;
        }
        results[food][cat][MOUSE_TURN][0] = MOUSE_WIN;
        results[food][cat][MOUSE_TURN][1] = 0;
        results[food][cat][CAT_TURN][0] = MOUSE_WIN;
        results[food][cat][CAT_TURN][1] = 0;
        queue.push([food, cat, MOUSE_TURN]);
        queue.push([food, cat, CAT_TURN]);
    }
    // 拓扑排序
    while (queue.length) {
        const state = queue.shift();
        const mouse = state[0], cat = state[1], turn = state[2];
        const result = results[mouse][cat][turn][0];
        const moves = results[mouse][cat][turn][1];
        const prevStates = getPrevStates(mouse, cat, turn);
        for (const prevState of prevStates) {
            const prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];
            if (results[prevMouse][prevCat][prevTurn][0] === UNKNOWN) {
                const canWin = (result === MOUSE_WIN && prevTurn === MOUSE_TURN) || (result === CAT_WIN && prevTurn === CAT_TURN);
                if (canWin) {
                    results[prevMouse][prevCat][prevTurn][0] = result;
                    results[prevMouse][prevCat][prevTurn][1] = moves + 1;
                    queue.push([prevMouse, prevCat, prevTurn]);
                } else {
                    degrees[prevMouse][prevCat][prevTurn]--;
                    if (degrees[prevMouse][prevCat][prevTurn] === 0) {
                        const loseResult = prevTurn === MOUSE_TURN ? CAT_WIN : MOUSE_WIN;
                        results[prevMouse][prevCat][prevTurn][0] = loseResult;
                        results[prevMouse][prevCat][prevTurn][1] = moves + 1;
                        queue.push([prevMouse, prevCat, prevTurn]);
                    }
                }
            }
        }
    }

    return results[startMouse][startCat][MOUSE_TURN][0] === MOUSE_WIN && results[startMouse][startCat][MOUSE_TURN][1] <= MAX_MOVES;
}

let grid = ["####F","#C...","M...."], catJump = 1, mouseJump = 2;
let result=canMouseWin(grid, catJump, mouseJump);
console.log(result);
```




---
## 1748. 唯一元素的和

给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。

请你返回 nums 中唯一元素的 和 。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var sumOfUnique = function(nums) {
    let obj={};
    let sum=0;
    for(let i=0;i<nums.length;i++){
        obj[nums[i]]===undefined ? obj[nums[i]]=1 : ++obj[nums[i]];
        if (obj[nums[i]]===1) {
            //计数为1时，加该值
            sum+=nums[i];
        }
        if (obj[nums[i]]===2) {
            //计数为2时,减掉
            sum-=nums[i];
        }
    }
    return sum;
};


let test=[2,2,1,1,1,2,2];
let result=sumOfUnique(test);
console.log(result);
```

```js
var sumOfUnique = function(nums) {
    const cnt = new Map();
    for (const num of nums) {
        cnt.set(num, (cnt.get(num) || 0) + 1);
    }
    let ans = 0;
    for (const [num, c] of cnt.entries()) {
        if (c === 1) {
            ans += num;
        }
    }
    return ans;
};
```

```js
var sumOfUnique = function(nums) {
    let ans = 0;
    const state = new Map();
    for (const num of nums) {
        if (!state.has(num)) {
            ans += num;
            state.set(num, 1);
        } else if (state.get(num) === 1) {
            ans -= num;
            state.set(num, 2);
        }
    }
    return ans;
};

```


---
## 1791. 找出星型图的中心节点

有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。

给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。

提示：

3 <= n <= 105
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
题目数据给出的 edges 表示一个有效的星型图

```js
/**
 * @param {number[][]} edges
 * @return {number}
 */
var findCenter = function(edges) {
    let set=new Set();
    for(let i=0;i<edges.length;i++){
        if (set.has(edges[i][0])) {
            return edges[i][0];
        }
        if (set.has(edges[i][1])) {
            return edges[i][1];
        }
        set.add(edges[i][0]);
        set.add(edges[i][1]);
    }
};

let test=[[1,2],[2,3],[4,2]];
let result=findCenter(test);
console.log(result);

```


---
## 1823. 找出游戏的获胜者

共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。

游戏遵循如下规则：

从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findTheWinner = function(n, k) {
    let arr=new Array(n).fill(0);
    for (let i=0;i<n;i++){
        arr[i]=i+1;
    }
    while(arr.length>1){
        for (let i=1;i<k;i++){
            arr.push(arr.shift());
        }
        arr.shift();
    }
    return arr[0];
};

let n = 6, k = 5;
let result=findTheWinner(n,k);
console.log(result);
```

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findTheWinner = function(n, k) {
    let arr=new Array(n).fill(0);
    for (let i=0;i<n;i++){
        arr[i]=i+1;
    }
    let k1;
    while(arr.length>1){
        k1=k;
        if (k>arr.length) {
            k1=k%arr.length;
            if (k1===0) {
                k1=arr.length;
            }
        }

        for (let i=1;i<k1;i++){
            arr.push(arr.shift());
        }
        arr.shift();
    }
    return arr[0];
};

let n = 6, k = 5;
let result=findTheWinner(n,k);
console.log(result);
```




---
## 1984. 学生分数的最小差值

给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。

从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。

返回可能的 最小差值 。

提示：

1 <= k <= nums.length <= 1000
0 <= nums[i] <= 105

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minimumDifference = function(nums, k) {
    if (nums.length<2) {
        return 0;
    }
    nums.sort((a,b)=>a-b);  //排序
    let mindiff=nums[nums.length-1]-nums[0];  //初始为最大差值
    for(i=0;i<nums.length-k+1;i++){
        let temp=nums[i+k-1]-nums[i];
        mindiff=temp<mindiff ? temp : mindiff;
        if (mindiff===0) {
            return 0;
        }
    }
    return mindiff;
};

let test=[9,4,1,7];
let result=minimumDifference(test,2);
console.log(result);
```


---
## 1994. 好子集的数目

给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。

比方说，如果 nums = [1, 2, 3, 4] ：
[2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。

nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。

提示：

1 <= nums.length <= 105
1 <= nums[i] <= 30

```
const PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
const NUM_MAX = 30;
const MOD = 1000000007;
var numberOfGoodSubsets = function(nums) {
    const freq = new Array(NUM_MAX + 1).fill(0);
    for (const num of nums) {
        ++freq[num];
    }

    const f = new Array(1 << PRIMES.length).fill(0);
    f[0] = 1;
    for (let i = 0; i < freq[1]; ++i) {
        f[0] = f[0] * 2 % MOD;
    }
    
    for (let i = 2; i <= NUM_MAX; ++i) {
        if (freq[i] === 0) {
            continue;
        }
        
        // 检查 i 的每个质因数是否均不超过 1 个
        let subset = 0, x = i;
        let check = true;
        for (let j = 0; j < PRIMES.length; ++j) {
            const prime = PRIMES[j];
            if (x % (prime * prime) == 0) {
                check = false;
                break;
            }
            if (x % prime === 0) {
                subset |= (1 << j);
            }
        }
        if (!check) {
            continue;
        }

        // 动态规划
        for (let mask = (1 << PRIMES.length) - 1; mask > 0; --mask) {
            if ((mask & subset) === subset) {
                f[mask] = ((f[mask] + (f[mask ^ subset]) * freq[i]) % MOD);
            }
        }
    }

    let ans = 0;
    for (let mask = 1, maskMax = (1 << PRIMES.length); mask < maskMax; ++mask) {
        ans = (ans + f[mask]) % MOD;
    }
    
    return ans;
};


let test= [4,2,3,15];
let result=numberOfGoodSubsets(test);
console.log(result);
```




---
## 1995. 统计特殊四元组

给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：

nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d

提示：
4 <= nums.length <= 50
1 <= nums[i] <= 100

直接枚举

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var countQuadruplets = function(nums) {
    let count=0;
    if (nums[0]+nums[1]+nums[2]===nums[3]) {count+=1;}
    for(let d=4;d<nums.length;d++){
        //1 <= nums[i] <= 100
        for(let a=0;a<=d-3;a++){
            if (nums[a]>=nums[d]) {
                continue
            }
            for(let b=a+1;b<=d-2;b++){
                if (nums[a]+nums[b]>=nums[d]) {
                    continue
                }
                for(let c=b+1;c<=d-1;c++){
                    if (nums[a]+nums[b]+nums[c]===nums[d]) {
                        console.log(a,b,c,d);
                        count+=1;
                    }
                }
            }
        }
    }
    return count;
};


let str1= [56,50,33,1,86,80,85,42,90];
let result=countQuadruplets(str1);
console.log(result);

```

使用哈希表存储 nums[d]

```

```


---
## 2006. 差的绝对值为 K 的数对数目

给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i < j 且 |nums[i] - nums[j]| == k 。

|x| 的值定义为：

如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。

提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100
1 <= k <= 99

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var countKDifference = function(nums, k) {
    nums.sort((a,b)=>a-b);
    let i=0;
    let j=1;
    let n=nums.length;
    let result=0;
    for(let i=0;i<n-1;i++){
        for(let j=i+1;j<n;j++){
            if (nums[j]-nums[i]===k) {
                result+=1;
            }
            if (nums[j]-nums[i]>k) {
                break;
            }
        }
    }
    return result;
};

let test=[1,2,2,1];
let result=countKDifference(test,1);
console.log(result);
```

哈希表 + 一次遍历

```js
var countKDifference = function(nums, k) {
    let res = 0, n = nums.length;
    const cnt = new Map();
    for (let j = 0; j < n; ++j) {
        res += (cnt.get(nums[j] - k) || 0) + (cnt.get(nums[j] + k) || 0);
        cnt.set(nums[j], (cnt.get(nums[j]) || 0) + 1);
    }
    return res;
};
```


---
## 2016. 增量元素之间的最大差值

给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 <= i < j < n 且 nums[i] < nums[j] 。

返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。

提示：

n == nums.length
2 <= n <= 1000
1 <= nums[i] <= 109

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumDifference = function(nums) {
     let max_diff=0;
     let min_val=nums[0];
     for(let i=1;i<nums.length;i++){
        let diff=nums[i]-min_val;
        max_diff=max_diff>diff ? max_diff : diff;
        min_val=nums[i]<min_val ? nums[i] : min_val;
     }
    return max_diff>0 ? max_diff : -1;
};

let test=[1,5,2,10];
let result=maximumDifference(test);
console.log(result);

```




---
## 2022. 将一维数组转变成二维数组

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

提示：

1 <= original.length <= 5 * 104
1 <= original[i] <= 105
1 <= m, n <= 4 * 104

```js
/**
 * @param {number[]} original
 * @param {number} m
 * @param {number} n
 * @return {number[][]}
 */
var construct2DArray = function(original, m, n) {
	if (original.length!==m*n) {
		return [];
	}
	let newArr=[];
	for (let i=0;i<m;i++){
		newArr.push(original.slice(i*n,(i+1)*n));
	}
	return newArr;
};

let str1=[1,2,3,4];
let result=construct2DArray(str1,2,2);
console.log(result);
```


---
## 2024. 考试的最大困扰度

一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 'T' 表示）或者 false （用 'F' 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。

给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：

每次操作中，将问题的正确答案改为 'T' 或者 'F' （也就是将 answerKey[i] 改为 'T' 或者 'F' ）。
请你返回在不超过 k 次操作的情况下，最大 连续 'T' 或者 'F' 的数目。

提示：

n == answerKey.length
1 <= n <= 5 * 104
answerKey[i] 要么是 'T' ，要么是 'F'
1 <= k <= n

在指定字符的情况下，我们可以计算其最大连续数目。具体地，我们使用滑动窗口的方法，从左到右枚举右端点，维护区间中另一种字符的数量为 sum，当 sum 超过 k，我们需要让左端点右移，直到 sum≤k。移动过程中，我们记录滑动窗口的最大长度，即为指定字符的最大连续数目。

本题的答案为分别指定字符为 TT 和 FF 时的最大连续数目的较大值。

```js
/**
 * @param {string} answerKey
 * @param {number} k
 * @return {number}
 */
var maxConsecutiveAnswers = function(answerKey, k) {
	return Math.max(maxConsecutiveChar(answerKey,k,"T"),maxConsecutiveChar(answerKey,k,"F"));
};
var maxConsecutiveChar=function(answerKey,k,ch){
	let n=answerKey.length;
	let ans=0;
	for (let left=0,right=0,sum=0;right<n;right++){
		sum+=answerKey.charAt(right)!==ch ? 1 : 0;
		while(sum>k){
			sum-=answerKey[left++]!==ch ? 1 : 0;
		}
		ans=Math.max(ans,right-left+1);
	}
	return ans;
}

let answerKey = "TTFF", k = 2;
let result=maxConsecutiveAnswers(answerKey,k);
console.log(result);
```




---
## 2028. 找出缺失的观测数据

现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。

给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。

返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。

k 个数字的 平均值 为这些数字求和后再除以 k 。

注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。

提示：

m == rolls.length
1 <= n, m <= 105
1 <= rolls[i], mean <= 6

```js
/**
 * @param {number[]} rolls
 * @param {number} mean
 * @param {number} n
 * @return {number[]}
 */
var missingRolls = function(rolls, mean, n) {
	let m=rolls.length;
	let sum=mean*(m+n);
	let sumM=0;
	for (let i=0;i<m;i++){
		sumM+=rolls[i];
	}
	let sumN=sum-sumM;
	if (sumN>6*n || sumN<n) {
		//n位的和最大位6*n,最小为n
		return [];
	}

	let meanN=Math.floor(sumN/n);
	sumN-=meanN*n;
	
	return new Array(n-sumN).fill(meanN).concat(new Array(sumN).fill(meanN+1));
};

let rolls = [3,2,4,3], mean = 4, n = 2;
let result=missingRolls(rolls,mean,n);
console.log(result);
```




---
## 2039. 网络空闲的时刻

给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。

题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。

编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。

在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：

如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。
否则，该数据服务器 不会重发 信息。
当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。

请返回计算机网络变为 空闲 状态的 最早秒数 。

```
/**
 * @param {number[][]} edges
 * @param {number[]} patience
 * @return {number}
 */
var networkBecomesIdle = function(edges, patience) {
    const n = patience.length, graph = new Map()
    for(const edge of edges) {
        var l1, l2
        if(graph.has(edge[0]))
            l1 = graph.get(edge[0])
        else
            l1 = new Array()
        l1.push(edge[1])
        graph.set(edge[0], l1)
        if(graph.has(edge[1]))
            l2 = graph.get(edge[1])
        else
            l2 = new Array()
        l2.push(edge[0])
        graph.set(edge[1], l2)
    }
    const distance = new Array(n).fill(Number.MAX_SAFE_INTEGER)
    distance[0] = 0
    let queue = [0], cost = 0
    while(queue.length > 0) {
        cost += 1
        next = new Array()
        for(const server of queue)
            for(const other of graph.get(server))
                if(distance[other] == Number.MAX_SAFE_INTEGER) {
                    distance[other] = cost
                    next.push(other)
                }
        queue = next
    }
    let ans = 0
    for(let i = 1; i < n; i++) {
        const d = distance[i] * 2, p = patience[i]
        ans = Math.max(ans, Math.floor((d - 1) / p) * p + d)
    }
    return ans + 1
};

```




---
## 2043. 简易银行系统

你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 n 个账户，编号从 1 到 n 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 balance 中，其中第 (i + 1) 个账户的初始余额是 balance[i] 。

请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：

指定的账户数量在 1 和 n 之间，且
取款或者转账需要的钱的总数 小于或者等于 账户余额。
实现 Bank 类：

Bank(long[] balance) 使用下标从 0 开始的整数数组 balance 初始化该对象。
boolean transfer(int account1, int account2, long money) 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。
boolean deposit(int account, long money) 向编号为 account 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 false 。
boolean withdraw(int account, long money) 从编号为 account 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。

```js
/**
 * @param {number[]} balance
 */
var Bank = function(balance) {
    this.balance=balance;
    this.number=this.balance.length;
};

/** 
 * @param {number} account1 
 * @param {number} account2 
 * @param {number} money
 * @return {boolean}
 */
Bank.prototype.transfer = function(account1, account2, money) {
    if (account1<=this.number && account2<=this.number) {
        if (this.balance[account1-1]>=money) {
            this.balance[account1-1]-=money;
            this.balance[account2-1]+=money;
            return true;
        }else{
            return false;
        }
    }else{
        return false;
    }
};

/** 
 * @param {number} account 
 * @param {number} money
 * @return {boolean}
 */
Bank.prototype.deposit = function(account, money) {
    if (account<=this.number){
        this.balance[account-1]+=money;
        return true;
    }else{
        return false;
    }
};

/** 
 * @param {number} account 
 * @param {number} money
 * @return {boolean}
 */
Bank.prototype.withdraw = function(account, money) {
    if (account<=this.number){
        if (this.balance[account-1]>=money) {
            this.balance[account-1]-=money;
            return true;
        }else{
            return false;
        }
    }else{
        return false;
    }
};

/**
 * Your Bank object will be instantiated and called as such:
 * var obj = new Bank(balance)
 * var param_1 = obj.transfer(account1,account2,money)
 * var param_2 = obj.deposit(account,money)
 * var param_3 = obj.withdraw(account,money)
 */
```




---
## 2044统计按位或能得到最大值的子集数目

给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。

如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。

对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。

提示：

1 <= nums.length <= 16
1 <= nums[i] <= 105

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var countMaxOrSubsets = function(nums) {
   let maxOr=0,cnt=0;
   for (let i=0;i<1<<nums.length;i++){
      let orVal=0;
      for(let j=0;j<nums.length;j++){
         if (((i>>j)&1)===1) {
            orVal|=nums[j];
         }
      }
      if (orVal>maxOr) {
         maxOr=orVal;
         cnt=1;
      }else if(orVal===maxOr){
         cnt++;
      }
   }
   return cnt;
};

let nums = [3,2,1,5];
let result=countMaxOrSubsets(nums);
console.log(result);
```

```js
var countMaxOrSubsets = function(nums) {
    this.nums = nums;
    this.maxOr = 0;
    this.cnt = 0;
    dfs(0, 0);
    return cnt;
};

const dfs = (pos, orVal) => {
    if (pos === nums.length) {
        if (orVal > maxOr) {
            maxOr = orVal;
            cnt = 1;
        } else if (orVal === maxOr) {
            cnt++;
        }
        return;
    }
    dfs(pos + 1, orVal | nums[pos]);
    dfs(pos + 1, orVal);
}

```


---
## 2049. 统计最高分的节点数目

给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。

**一个子树的 大小 为这个子树内节点的数目**。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。

请你返回有 最高得分 节点的 数目 。

提示：

n == parents.length
2 <= n <= 105
parents[0] == -1
对于 i != 0 ，有 0 <= parents[i] <= n - 1
parents 表示一棵二叉树。

在一棵树中，当把一个节点和与它相连的所有边删除，剩余部分最多为三棵非空子树，即原节点的左子树（如果有），右子树（如果有），以及把以这个节点为根结点的子树移除所形成的子树（除根结点外均有）。而这个节点的分数为这些子树的节点个数的乘积。我们可以先用parents 数组统计出每个节点的子节点，然后使用深度优先搜索来计算以每个节点为根结点的子树的大小，同时计算每个节点的大小，作为深度优先搜索的返回值，最后统计最大分数出现的次数。在实现上，统计最大分数出现的次数可以放到深度优先搜索中完成，从而节省一部分空间。

```js
/**
 * @param {number[]} parents
 * @return {number}
 */
var countHighestScoreNodes = function(parents) {
   //记录每一个结点的父节点、左右子树结点数
   let n=parents.length;
   const children=new Array(n);
   let maxScore=0;
   let cnt=0;
   for (let i=0;i<n;i++){
      children[i]=[];
   }
   for (let i=0;i<n;i++){
      let p=parents[i];
      if (p!==-1) {
         children[p].push(i);
      }
   }
   //使用深度优先搜索来计算以每个节点为根结点的子树的大小
   const dfs=(node)=>{
      let score=1;
      let size=n-1; //size为与父结点向上相连的结点数目
      for (let c of children[node]){
         let t=dfs(c);
         score *=t;
         size-=t;
      }
      if (node!==0){
         score*=size;
      }
      if (score===maxScore) {
         cnt++;
      }else if(score>maxScore){
         maxScore=score;
         cnt=1;
      }
      return n-size;
   }
   dfs(0);
   return cnt;
};

let parents = [-1,2,0,2,0]
let result=countHighestScoreNodes(parents);
console.log(result);
```


---
## 


---
## 2055. 蜡烛之间的盘子

给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。

比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。
请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。

提示：

3 <= s.length <= 105
s 只包含字符 '*' 和 '|' 。
1 <= queries.length <= 105
queries[i].length == 2
0 <= lefti <= righti < s.length

```js
/**
 * @param {string} s
 * @param {number[][]} queries
 * @return {number[]}
 */
var platesBetweenCandles = function(s, queries) {
   let ans=new Array(queries.length).fill(0);
   let n=s.length;
   const preSum=new Array(n).fill(0);
   for(let i=0,sum=0;i<n;i++){
      if (s[i]==="*") {
         sum++;
      }
      preSum[i]=sum;
   }
   const left=new Array(n).fill(0);
   for(let i=0,l=-1;i<n;i++){
      if (s[i]==="|") {
         l=i;
      }
      left[i]=l;
   }
   const right=new Array(n).fill(0);
   for(let i=n-1,r=-1;i>=0;i--){
      if (s[i]==="|") {
         r=i;
      }
      right[i]=r;
   }
   for(let i=0;i<queries.length;i++){
      let x=right[queries[i][0]];
      let y=left[queries[i][1]];
      ans[i]=x===-1 || y===-1 || x>=y ? 0: preSum[y]-preSum[x];
   }
   return ans;
};

let s = "**|**|***|", queries = [[2,5],[5,9]];
let result=platesBetweenCandles(s,queries);
console.log(result);
```




---
## 2100. 适合打劫银行的日子

你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。

如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：

第 i 天前和后都分别至少有 time 天。
第 i 天前连续 time 天警卫数目都是非递增的。
第 i 天后连续 time 天警卫数目都是非递减的。
更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].

请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。

提示：

1 <= security.length <= 105
0 <= security[i], time <= 105

```js
/**
 * @param {number[]} security
 * @param {number} time
 * @return {number[]}
 */
var goodDaysToRobBank = function(security, time) {
   let ans=[];
   let n=security.length;
   let notbigthanbefore=new Array(n).fill(0);  //存储紧挨着当前元素之前连续非递增的元素个数
   let notsmallthanlater=new Array(n).fill(0);  //存储紧挨着当前元素之后连续非递减的元素个数
   let addcount=0;
   let minuscount=0;
   for(let i=1;i<n;i++){
      if (security[i]>security[i-1]) {
         notbigthanbefore[i]=0;
         notsmallthanlater[i]=++addcount;
         minuscount=0;
      }else if(security[i]<security[i-1]){
         notbigthanbefore[i]=++minuscount;
         notsmallthanlater[i]=0;
         addcount=0;
      }else{
         notbigthanbefore[i]=++minuscount;
         notsmallthanlater[i]=++addcount;
      }
   }
   //console.log(notbigthanbefore);
   //console.log(notsmallthanlater);
   for(let i=time;i<n-time;i++){
      if (notbigthanbefore[i]>=time && notsmallthanlater[i+time]>=time) {
         ans.push(i);
      }
   }
   return ans;
};

let security = [1,2,3,4,5,6], time = 2;
let result=goodDaysToRobBank(security,time);
console.log(result);
```

```js
var goodDaysToRobBank = function(security, time) {
    const n = security.length;
    const left = new Array(n).fill(0);
    const right = new Array(n).fill(0);
    for (let i = 1; i < n; i++) {
        if (security[i] <= security[i - 1]) {
            left[i] = left[i - 1] + 1;
        }
        if (security[n - i - 1] <= security[n - i]) {
            right[n - i - 1] = right[n - i] + 1;
        }
    }

    const ans = [];
    for (let i = time; i < n - time; i++) {
        if (left[i] >= time && right[i] >= time) {
            ans.push(i);    
        }
    }
    return ans;
};

```




---
## 2104子数组范围和

给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。

返回 nums 中 所有 子数组范围的 和 。

子数组是数组中一个连续 非空 的元素序列。

提示：

1 <= nums.length <= 1000
-109 <= nums[i] <= 109


进阶：你可以设计一种时间复杂度为 O(n) 的解决方案吗

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var subArrayRanges = function(nums) {
   let ans=0;
   let n=nums.length;
   for(let i=0;i<n;i++){
      let minValue=Number.MAX_VALUE,maxValue=-Number.MAX_VALUE;
      for(let j=i;j<n;j++){
         minValue=Math.min(minValue,nums[j]);
         maxValue=Math.max(maxValue,nums[j]);
         ans+=maxValue-minValue;
      }
   }
   return ans;

};

let str1=[1,2,3,4,5];
let result=subArrayRanges(str1);
console.log(result);
```

