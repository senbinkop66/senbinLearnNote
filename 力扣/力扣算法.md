

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum =function(nums,target){
    len_nums=nums.length;
    for (let i=0; i<len_nums-1; i++){
        for (let j=i+1; j<len_nums; j++){
            if (nums[i]+nums[j]==target) {
                return [i,j];
            }
        }
    }
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=twoSum(str1,6);
//console.log(typeof result);
console.log(result);
```



## 2.两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    //直接在l1上操作
    let temp=0;
    let head=l1;  //存储l1的头结点，方便返回

    while (l1.next){
        if (l2.next) {
            temp+=l1.val+l2.val;
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
            l2=l2.next;
        }else{
            //当l1更长时
            temp+=l1.val+l2.val;  //计算l2的最后一个
            l2.val=0;  //然后把l2值设置为0
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
        }
    }

    while(l2.next){
        //当l2更长时
        temp+=l1.val+l2.val;  //计算l1的最后一个
        l1.val=temp%10;
        l1.next=new ListNode();  //在l1后加next结点，值设为0
        l1=l1.next;
        l1.val=0;  
        temp=Math.floor(temp/10);
        l2=l2.next;
    }
    temp+=l1.val+l2.val;  //读取最后的一个，就算l1和l2刚好长度相同也一样
    l1.val=temp%10;
    temp=Math.floor(temp/10);
    if (temp===1) {
        //最后是否会进位
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=1;
    }
    return head;

};
```

注意 当li.next()返回false后在后面的要计算当前位的值.



## 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**提示：**

- `0 <= s.length <= 5 * 104`

- `s` 由英文字母、数字、符号和空格组成

- **例 1:**

  ```
  输入: s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s==="") {return 0;}
    let maxLen=1;
    let flag;
    let count=1;
    let newArr=[];  //存储子串数组
    for (let i=0;i<s.length;i++){
        newArr.push(s[i]);
        flag=true;
        for (let j=i+1;j<s.length;j++){
            if (newArr.includes(s[j])) {
                //当子串数组中已有时
                maxLen=count>maxLen ? count : maxLen;
                flag=false;
                count=1;
                newArr=[];
                break;
            }else{
                newArr.push(s[j]);
                count++;
            }
        }
        if (flag) {
            maxLen=count>maxLen ? count : maxLen;
            break;
        }
    }
    return maxLen;
};


let str1 = "heflfdddswertllo";
let result=lengthOfLongestSubstring(str1);
console.log(result);
```



## 4. 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    let newArr=new Array();
    //双指针
    let i=0;
    let j=0;
    while(i<nums1.length && j<nums2.length){
        if (nums1[i]<=nums2[j]) {
            newArr.push(nums1[i]);
            i++;
        }
        if (nums2[j]<=nums1[i]) {
            console.log(nums2[j]);
            newArr.push(nums2[j]);
            j++;
        }
    }

    while (i<nums1.length){
        newArr.push(nums1[i]);
        i++;
    }
    while(j<nums2.length){
        newArr.push(nums2[j]);
        j++;
    }
    //return newArr;
    let n=nums1.length+nums2.length;
    if (n%2===0) {
        return parseFloat((newArr[n/2]+newArr[n/2-1])/2);
    }else{
        return parseFloat(newArr[Math.floor(n/2)]);
    }
    console.log(newArr);
};


let str1 = [1,2];
let str2=[3,4];
let result=findMedianSortedArrays(str1,str2);
console.log(result);
```

## 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if (s.length===1) {return 1;}
    let maxLen=s.length;
    let flag1=false;
    let flag2=false;
    let newArr=[];  //
    //从最长到最短判断
    for (let i=0;i<s.length;i++){
        for (let j=i;j<s.length;i++){
            if (s[j]!===s[s.length-1-j]) {

                flag1=true;
                break;
            }
        }
        for (let j=i;j<s.length;i++){
            if (s[i]!===s[s.length-1-i]) {
                flag1=true;
                break;
            }
        }
    }
    return maxLen;
};


let str1 = "babad";
let str2=[3,4];
let result=longestPalindrome(str1);
console.log(result);
```

## 6.Z 字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P    A    H   N
A P L S I  I G
Y    I     R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`

```
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows===1) {return s;}
    
    return newStr;
};

let str1 = "basanaadsfenafdrrgeana";
let result=convert(str1);
console.log(result);
```



## 208. 实现 Trie (前缀树)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次

```js
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @return {boolean}
 */
 //搜索
Trie.prototype.search = function(word) {
    let node=this.startsWith(word);
    //若搜索到了前缀的末尾，就说明字典树中存在该前缀。
    //此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。
    return node!==undefined && node.isEnd!==undefined;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
//查找前缀
Trie.prototype.startsWith = function(prefix) {
    let node=this.children;
    for (let ch of prefix){
        //子节点不存在。说明字典树中不包含该前缀，返回空指针
        if (!node[ch]) {
            return false;
        }
        //子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
        node=node[ch];
    }
    return node;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

let test=new Trie();

test.insert("apple");
result=test.search("apple");
console.log(result);  //true

result=test.search("app");
console.log(result);  //false

result=test.startsWith("app");
console.log(result);  //

test.insert("app");
result=test.search("app");
console.log(result);  //
```



## 472. 连接词

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

提示：

1 <= words.length <= 104
0 <= words[i].length <= 1000
words[i] 仅由小写字母组成
0 <= sum(words[i].length) <= 105

方法一：字典树 + 深度优先搜索
判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。

1. 为了方便处理，首先将数组 words 按照字符串的长度递增的顺序排序，排序后可以确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。
2. 在将数组 words 排序之后，遍历数组，跳过空字符串，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入结果数组，如果不是连接词则将该单词加入字典树。
3. 判断一个单词是不是连接词的做法是在字典树中深度优先搜索。从该单词的第一个字符（即下标 00处的字符）开始，在字典树中依次搜索每个字符对应的结点，可能有以下几种情况：

- 如果一个字符对应的结点是单词的结尾，则找到了一个更短的单词，从该字符的后一个字符开始搜索下一个更短的单词；
- 如果一个字符对应的结点在字典树中不存在，则当前的搜索结果失败，回到上一个单词的结尾继续搜索。

如果找到一个更短的单词且这个更短的单词的最后一个字符是当前单词的最后一个字符，则当前单词是连接词。由于数组 words 中没有重复的单词，因此在判断一个单词是不是连接词时，该单词一定没有加入字典树，由此可以确保判断连接词的条件成立。

由于一个连接词由多个更短的非空单词组成，如果存在一个较长的连接词的组成部分之一是一个较短的连接词，则一定可以将这个较短的连接词换成多个更短的非空单词，因此不需要将连接词加入字典树。

```
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @param {start} int 单词开始索引位置
 * @return {boolean}
 */
 //查找一个词从索引开始后的连续部分是否已存在
Trie.prototype.dfs = function(word,start) {
    let node=this.children;
    for (let i=start;i<word.length;i++){
        node=node[word[i]];
        //深度优先遍历
        if (node!==undefined) {
            if (node.isEnd!==undefined) {
                return i+1;
            }else{
                continue;
            }
        }
        node=node[word[i]];
        if (!node) {
            //得考虑这个单词不行可能那个单词行,carbat比如cat与car
            return false;
        }
        
        if (node && i===word.length-1){
            return i+1;
        }
    }
};



/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const trie=new Trie();

    trie.insert(words[0]);
    trie.insert(words[1]);
    //console.log(trie);
   
    for (let i=2;i<words.length;i++){
        let word=words[i];
        let start;
        let count=0;
        for(start=0;start<word.length;){
            let index=trie.dfs(word,start);
            if (index===false) {
                trie.insert(word);
                break;
            }else{
                if (index<word.length) {
                    start=index;
                    count++;
                }else{
                    if (count>1) {
                        result.push(word);
                    }
                }
            }
        }

    }
    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```



## 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

示例 1：

输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var repeatedStringMatch = function(a, b) {
    //首先只要b中有字母不在a中,则不可能b为a的子串
    let len_a=a.length;
    let len_b=b.length;

    let set=new Set();
    for (let i=0;i<len_a;i++){
        set.add(a[i]);
    }
    for (let i=0;i<len_b;i++){
        if (!set.has(b[i])) {
            return -1;
        }
    }
    let newStr=a;
    //判断b与a的长度，a当重复后长度最多超过b长度的2倍，如果2倍长度没有找到则返回-1
    let n=len_b%len_a===0 ? len_b/len_a : Math.floor(len_b/len_a)+1;
    if (len_a>=len_b) {
        //当a长时，返回值最多为2
        if (newStr.indexOf(b)!==-1) {
            return 1;
        }else{
            newStr+=a;
            if (newStr.indexOf(b)!==-1) {
                return 2;
            }else{
                return -1;
            }
        }
    }else{
        //当b长时，a长度最多增加到b的2倍
        for (let i=0;i<n-1;i++){
            newStr+=a;
        }
        while (newStr.length<2*len_b){
            if (newStr.indexOf(b)!==-1) {
                return n;
            }else{
                newStr+=a;
                n++;
            }
        }
        if (newStr.indexOf(b)!==-1) {
            return n;
        }else{
            return -1;
        }
        
    }
    return 0;
};


let str1 = "abc";
let str2="cabcabca";

let result=repeatedStringMatch(str1,str2);
console.log(result);
```

## 825. 适龄的朋友

在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：

age[y] <= 0.5 * age[x] + 7
age[y] > age[x]
age[y] > 100 && age[x] < 100
否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

- `n == ages.length`
- `1 <= n <= 2 * 104`
- `1 <= ages[i] <= 120`

```js
/**
 * @param {number[]} ages
 * @return {number}
 */
var numFriendRequests = function(ages) {
    if (ages.length===1) {return 0;}
    let count=0;
    ages.sort((a,b)=>b-a);  //从大到小排序
    let flag=0;  //移动指针
    for (let i=0;i<ages.length;i++){
        for (let j=flag;j<ages.length;j++){
            if (i!==j) {
                if (ages[j]>ages[i]*0.5+7) {
                    count++;
                    //console.log(ages[i]+"->"+ages[j]);
                }else{
                    break;
                }
            }
        }
        //age变化则移动指针
        if (ages[i]>ages[i+1]) {
            //console.log(ages[flag]);
            flag=i+1;
        }
    }
    return count;
};

let str1 = [30,100,110,120,20];
let result=numFriendRequests(str1);
console.log(result);

```



## 1044.最长重复子串

给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。

提示：

2 <= s.length <= 3 * 104
s 由小写英文字母组成

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    let strA;
    for (let k=s.length-1;k>0;k--){
        for (let i=0;i+k<s.length;i++){
            strA=s.slice(i,i+k);
            if (i!==s.lastIndexOf(strA)){
                return strA;
            }
        }
        
    }
    return "";
};

let str1 = "basanaadsfenafdrrgeana";
let result=longestDupSubstring(str1);
console.log(result);
```

超时

## 1154.  一年中的第几天

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

提示：

date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

```js
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    let y=Number(date.split("-")[0]);
    let m=Number(date.split("-")[1]);
    let d=Number(date.split("-")[2]);
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];

    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }

    let total=0;
    for (let i=0;i<m-1;i++){
        total+=monthOfDays[i]
    }
    total+=d;
    if (m>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }

    return total;
};

let str1 = "2021-12-21";

let result=dayOfYear(str1);
console.log(result);
```

**普通闰年:公历年份是4的倍数的，一般是闰年。（如2004年就是闰年）；
世纪闰年:公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是世纪闰年，2000年是世纪闰年）；**

## 1705. 吃苹果的最大数目

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

提示：

apples.length == n
days.length == n
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立

核心思路就是每次都吃最快腐烂的苹果 按照苹果的腐烂时间给苹果排序 需要用到优先队列
首先用实现一个优先队列的插入方法 核心思想二分法就可以
然后将苹果按照过期时间排序 并记录苹果的数量
苹果吃完了 就将队列第一项删除 或者腐烂了也需要删除
直到所有的苹果都遍历完了并且优先队列也空了

```
/**
 * @param {number[]} apples
 * @param {number[]} days
 * @return {number}
 */
var eatenApples = function(apples, days) {
    let count=0;
    let rest=0;
    let temp=0;  //每天长出后有效个苹果
    let max_day=0;

    for (let i=0;i<apples.length;i++){
        if (apples[i]>0) {
            temp=apples[i]>days[i] ? days[i]+1 : apples[i];  //
            apples[i]=temp;
        }
    }
    return apples;
    //return count;
};

let str1 = [1,2,3,5,2];
let str2=[3,2,1,4,2];
let result=eatenApples(str1,str2);
console.log(result);

```

