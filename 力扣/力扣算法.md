

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum =function(nums,target){
    len_nums=nums.length;
    for (let i=0; i<len_nums-1; i++){
        for (let j=i+1; j<len_nums; j++){
            if (nums[i]+nums[j]==target) {
                return [i,j];
            }
        }
    }
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=twoSum(str1,6);
//console.log(typeof result);
console.log(result);
```



## 2.两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let temp=0;
    let head=l1;

    while (l1.next){
        if (l2.next) {
            temp+=l1.val+l2.val;
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
            l2=l2.next;
        }else{
            temp+=l1.val+l2.val;
            l2.val=0;  //
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
        }
    }

    while(l2.next){
        temp+=l1.val+l2.val;
        l1.val=temp%10;
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=0;
        temp=Math.floor(temp/10);
        l2=l2.next;
    }
    temp+=l1.val+l2.val;
    l1.val=temp%10;
    temp=Math.floor(temp/10);
    if (temp===1) {
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=1;
    }
    return head;

};
```

链表连接可以优化代码



## 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**提示：**

- `0 <= s.length <= 5 * 104`

- `s` 由英文字母、数字、符号和空格组成

- **例 1:**

  ```
  输入: s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s==="") {return 0;}
    let maxLen=1;
    let flag;
    let count=1;
    let newArr=[];  //存储子串数组
    for (let i=0;i<s.length;i++){
        newArr.push(s[i]);
        flag=true;
        for (let j=i+1;j<s.length;j++){
            if (newArr.includes(s[j])) {
                //当子串数组中已有时
                maxLen=count>maxLen ? count : maxLen;
                flag=false;
                count=1;
                newArr=[];
                break;
            }else{
                newArr.push(s[j]);
                count++;
            }
        }
        if (flag) {
            maxLen=count>maxLen ? count : maxLen;
            break;
        }
    }
    return maxLen;
};


let str1 = "heflfdddswertllo";
let result=lengthOfLongestSubstring(str1);
console.log(result);
```



## 4. 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    let newArr=new Array();
    //双指针
    let i=0;
    let j=0;
    while(i<nums1.length && j<nums2.length){
        if (nums1[i]<=nums2[j]) {
            newArr.push(nums1[i]);
            i++;
        }
        if (nums2[j]<=nums1[i]) {
            console.log(nums2[j]);
            newArr.push(nums2[j]);
            j++;
        }
    }

    while (i<nums1.length){
        newArr.push(nums1[i]);
        i++;
    }
    while(j<nums2.length){
        newArr.push(nums2[j]);
        j++;
    }
    //return newArr;
    let n=nums1.length+nums2.length;
    if (n%2===0) {
        return parseFloat((newArr[n/2]+newArr[n/2-1])/2);
    }else{
        return parseFloat(newArr[Math.floor(n/2)]);
    }
    console.log(newArr);
};


let str1 = [1,2];
let str2=[3,4];
let result=findMedianSortedArrays(str1,str2);
console.log(result);
```

## 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if (s.length===1) {return 1;}
    let maxLen=s.length;
    let flag1=false;
    let flag2=false;
    let newArr=[];  //
    //从最长到最短判断
    for (let i=0;i<s.length;i++){
        for (let j=i;j<s.length;i++){
            if (s[j]!===s[s.length-1-j]) {

                flag1=true;
                break;
            }
        }
        for (let j=i;j<s.length;i++){
            if (s[i]!===s[s.length-1-i]) {
                flag1=true;
                break;
            }
        }
    }
    return maxLen;
};


let str1 = "babad";
let str2=[3,4];
let result=longestPalindrome(str1);
console.log(result);
```

## 6.Z 字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P    A    H   N
A P L S I  I G
Y    I     R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`

```
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows===1) {return s;}
    
    return newStr;
};

let str1 = "basanaadsfenafdrrgeana";
let result=convert(str1);
console.log(result);
```

## 7. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

```java
import java.util.*;

class Solution {
	public int reverse(int x) {
		if (x>-10 && x<10) return x;
		long result=0;
		while(x!=0){
			result=result*10+x%10;
			x=x/10;
		}
		//检测是否溢出，溢出则返回0
		return (int) result==result ? (int) result :0;
	}
}


public class TestOperateString{
	public static void main(String[] args) {

		//int[] testnums={1,2,3,4,5,6,7,8,9,10};
		//char[] testStr={'h','e','l','l','o','b'};

		int n=-136469;

		Solution mysolution=new Solution();
		//mysolution.reverseString(testStr);
		int result=mysolution.reverse(n);
		System.out.println(result);
		//System.out.println(Arrays.toString(testStr));
	}
}
```

注意检查是否溢出

## 8. 字符串转换整数 (atoi)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

```js
/**
 * @param {string} s
 * @return {number}
 */
var myAtoi = function(s) {
    s=s.trim();
    let patt=/[^0-9+-]/
    if (patt.test(s[0])) {
        return 0;
    }
    let nums=new Array();
    nums.push(s[0]);
    for (let i=1;i<s.length;i++){
        if (/\D/.test(s[i])) {
            //查找到非数字停止
            break;
        }else{
            nums.push(s[i]);
        }
    }

    let num=nums.join("");
    if (num==="+" || num==="-") {return 0;}
    num=parseInt(num);
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "+-12";
let result=myAtoi(str1);
console.log(result);

```

直接调用内置函数

```js
var myAtoi = function(s) {
    s=s.trim();
    let num=parseInt(s);
    if (isNaN(num)) {
        return 0;
    }
    const START=-Math.pow(2,31);
    const END=Math.pow(2,31)-1;

    if (num<START) {return START;}
    if (num>END) {return END;}
    return num;
};


let str1 = "words and 987";
let result=myAtoi(str1);
console.log(result);
```

### 

## 9.回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

提示：
-231 <= x <= 231 - 1

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x<0) {
        return false;
    }
    x=x.toString();

    for (let i=0;i<x.length/2;i++){
        if (x[i]!==x[x.length-1-i]) {
            return false;
        }
    }
    return true;
};

let str1 = -121;
let result=isPalindrome(str1);
console.log(result);

```

## 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符

直接调用正则方法

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    return new RegExp("^"+p+"$").test(s);
};
```

动态规划

```
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    //动态规划 dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配
    let lenS=s.length;
    let lenP=p.length;

    let dp=new Array(lenS+1);

    for (let i=0;i<dp.length;i++){
        //先构造dp[][]数组，将其每一项初始化为false
        dp[i]=new Array(lenP+1).fill(false);

    }
    //base case
    dp[0][0] = true; // s为空、p为空 两者都是空串的时候 可匹配

    //s不为空 p为空，必为false(dp数组默认值为false，无需处理)

    /*//s为空，p不为空(dp[0][]) 由于*可以匹配0个字符，所以有可能为true 
    要进行处理（看看有无*来挽救） 注意 dp[0][j] 当j=1时，表示p的前1个字符
    自然是p[j-1]呢，p的下标是从0开始*/
    for (let j=1;j<lenP;j++){
        if (p[j-1]==="*") {
            dp[0][j]=dp[0][j-2];
        }
    }

    // 迭代 状态转移
    for (let i=1;i<=lenS;i++){
        for (let j=1;j<lenP;j++){
            if (s[i-1]===p[j-1] || p[j-1]===".") {
                //最好简单情况 到这里 s、p 可以直接匹配
                dp[i][j]=dp[i-1][j-1];
            }else if(p[j-1]==="*"){
                //不满足直接对应相等，但 p这个字符是 ‘*’ 的话 仔细考虑
                if (s[i-1]===p[j-2] || p[j-2]===".") {
                    //s当前字符 可匹配上 p前一个字符
                    ////*匹配0次的情况 ｜｜ *匹配1次或多次的情况 
                    dp[i][j]=dp[i][j-2]  || dp[i-1][j];
                }else if(s[i-1]!==p[j-2]){
                    //s当前字符 无法匹配上 p前一个字符，只能是 *匹配0次的情况
                    dp[i][j]=dp[i][j-2];
                }
            }
        }
    }

    return dp[lenS][lenP];
};

let str1 = "mississippi";
let str2="mis*is*p*.";
let result=isMatch(str1,str2);
console.log(result);

```

## 13. 罗马数字转整数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 IV (4) 和 IX  (9)。
X 可以放在 L (50) 和 C (100) 的左边，来表示 XL 40 和 XC90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 CD 400 和 CM 900。
给定一个罗马数字，将其转换成整数。

提示：

1 <= s.length <= 15
s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {

	let romanObj={I:1,V:5,X:10,L:50,C:100,D:500,M:1000};
	let sum=0;

	let i=0;
	while(s.length>0){
		if (s.length===1) {
			sum+=romanObj[s[0]];
			break;
		}
		if (s[0]=="I") {
			if (s[1]==="V") {
				sum+=4;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="X") {
				sum+=9;
				s=s.slice(2);
				continue;
			}
			sum+=1;
			s=s.slice(1);
			continue;
		}else if(s[0]=="X") {
			if (s[1]==="L") {
				sum+=40;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="C") {
				sum+=90;
				s=s.slice(2);
				continue;
			}
			sum+=10;
			s=s.slice(1);
			continue;
		}else if(s[0]=="C") {
			if (s[1]==="D") {
				sum+=400;
				s=s.slice(2);
				continue;
			}
			if (s[1]==="M") {
				sum+=900;
				s=s.slice(2);
				continue;
			}
			sum+=100;
			s=s.slice(1);
			continue;
		}
		sum+=romanObj[s[0]];
		s=s.slice(1);
	}
	return sum;
};

let str1="MCMXCIV";
let result=romanToInt(str1);
console.log(result);
```

## 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length===1) {return strs[0];}
    let minLen=strs[0].length;
    for (let i=0;i<strs.length;i++){
        if (strs[i].length===0) {
            return "";
        }
        if (strs[i].length<minLen) {
            minLen=strs[i].length;
        }
    }
    let alphas=new Array("");
    for (let i=0;i<minLen;i++){
        for (let j=1;j<strs.length;j++){
            if (strs[j][i]!=strs[0][i]) {
                return alphas.join("");
            }
        }
        alphas.push(strs[0][i]);
    }
    return alphas.join("");
};


let str1 = ["flower","flow","flight"];
let result=longestCommonPrefix(str1);
//console.log(typeof result);
console.log(result);

```

利用数组的 Reduce 方法实现的最简洁代码

取第一个字符串为公共前缀
逐个对比，返回两两元素的公共前缀
将 2 中的公共前缀和下一个元素对比，得到新的公共前缀

## 15. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
提示：

0 <= nums.length <= 3000
-105 <= nums[i] <= 105

繁琐的思路，需要简化代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
	if (nums.length<3) {
		return [];
	}

	if (nums.length===3) {
		if (nums[0]+nums[1]+nums[2]===0) {
			return [[...nums]];
		}else{
			return[]
		}
	}

	let newArr=[];

	const positiveInterger=[];
	const negativeInterger=[];
	const zeros=[];

	nums.sort((a,b)=>a-b);
	let count=0;
	let temp=nums[0];
	//非零相同值最多需要留两个就可
	for (let i=0;i<nums.length;i++){
		//这里可用indexOf与lastIndexOf处理
		if (nums[i]!==temp) {
			temp=nums[i];
			count=1;
			if (nums[i]<0) {
				negativeInterger.push(nums[i]);
			}else if(nums[i]>0){
				positiveInterger.push(nums[i]);
			}else{
				zeros.push(0);
			}
		}else{
			if (nums[i]!==0) {
				if (count<2) {
					count+=1
					if (nums[i]<0) {
						negativeInterger.push(nums[i]);
					}else{
						positiveInterger.push(nums[i]);
					}
				}
			}else{
				zeros.push(0);
			}
		}
	}
	if (zeros.length!==0) {
		//有0时把0作为负数处理
		negativeInterger.push(0);
		//正数则为
		//positiveInterger.unshift(0);
	}
	if (zeros.length>2) {
		newArr.push([0,0,0]);
	}

	//console.log(positiveInterger);
	//console.log(negativeInterger);

	//需要匹配最大正数索引边界，动态变化
	let maxPositiveIndex=positiveInterger.length-1;
	//最大负数和
	let maxSum1;
	for (let i=0;i<negativeInterger.length-1;i++){
		//两负一正时
		if (maxPositiveIndex===-1) {
			//当正整数遍历完时，退出
			break;
		}
		if (i>0) {
			if (negativeInterger[i]===negativeInterger[i-1]) {
				continue;
			}
		}
		maxSum1=-(negativeInterger[i]+negativeInterger[i+1]);
		if (positiveInterger[maxPositiveIndex]>maxSum1) {
			maxPositiveIndex--;
		}
		for (let j=i+1;j<negativeInterger.length;j++){
			//计算两个负数和后取绝对值
			if (maxPositiveIndex===-1) {
				//当正整数遍历完时，退出
				break;
			}
			if (negativeInterger[j]===negativeInterger[j+1]) {
				continue;
			}
			let NegativeSum=-(negativeInterger[i]+negativeInterger[j]);
			//去找是否有相等的值
			for (let k=maxPositiveIndex;k>=0;k--){
				//因为是排好序的
				if (positiveInterger[k]<NegativeSum) {
					//如果小于则不存在，退出
					break;
				}
				if(positiveInterger[k]===NegativeSum) {
					//如果相等
					newArr.push([negativeInterger[i],negativeInterger[j],positiveInterger[k]]);
					break;
				}
				//如果大于就往前找
			}
		}
		if (positiveInterger[maxPositiveIndex]===maxSum1) {
			maxPositiveIndex--;
		}
	}

    //需要匹配最大负数索引边界，动态变化
    let maxNegativeIndex=negativeInterger.length-1;
    //最小正数和
	let maxSum2;
    for (let i=0;i<positiveInterger.length-1;i++){
        //两正一负时
        if (maxNegativeIndex===-1) {
            //当正整数遍历完时，退出
            break;
        }
        if (i>0) {
        	if (positiveInterger[i]===positiveInterger[i-1]) {
        		continue;
        	}
        }
        maxSum2=-(positiveInterger[i]+positiveInterger[i+1]);
        if (negativeInterger>maxSum2) {
        	maxNegativeIndex--;
        }

        for (let j=i+1;j<positiveInterger.length;j++){
            //计算两个负数和后取绝对值
            if (maxNegativeIndex===-1) {
                //当正整数遍历完时，退出
                break;
            }
            if (positiveInterger[j]===positiveInterger[j+1]) {
            	continue;
            }
            let PositiveSum=-(positiveInterger[i]+positiveInterger[j]);
            //去找是否有相等的值
            for (let k=maxNegativeIndex;k>=0;k--){
                //因为是排好序的
                if (negativeInterger[k]<PositiveSum) {
                    //如果小于则不存在，退出
                    break;
                }
                if(negativeInterger[k]===PositiveSum){
                    //如果相等
                    newArr.push([positiveInterger[i],positiveInterger[j],negativeInterger[k]]);
                    break;
                }
                //如果大于，则往前查找，最大正数索引边界减一
            }
        }
        if (negativeInterger===maxSum2) {
        	//移动最大位，可以避免重复
        	maxNegativeIndex--;
        }
    }

	return newArr;
};

let str1=[-1,0,1,2,-1,-4,-2,-3,3,0,4];
let result=threeSum(str1);
console.log(result);
```

简化，直接使用双指针

```

```

## 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

栈实现

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    if (s.length%2!==0) {
        return false;
    }
    let leftBrackets=["(","[","{"];
    let rightBrackets=[")","]","}"];

    let stack=[];
    for (let i=0;i<s.length;i++){
        //是否是右括号
        let index=rightBrackets.indexOf(s[i]);
        if (index!==-1) {
            //是右括号
            if (stack.length===0) {
                //如果栈为空，则不合法
                return false;
            }
            //则去看栈顶是否相匹配
            if (stack[stack.length-1]===leftBrackets[index]){
                //如果匹配，则出栈
                stack.pop();
            }else{
                //不匹配，则进栈
                stack.push(s[i]);
            }
        }else{
            //是左括号则直接进栈
            stack.push(s[i]);
        }
        //console.log(stack);
    }
    if (stack.length===0) {
        return true;
    }else{
        return false;
    }
};

let str1 = "{[{{[{}]}[({[]})]}]}";
let result=isValid(str1);
console.log(result);
```

## 21.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列

方法一：递归
思路

我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：

list1[0]+merge(list1[1:],list2)    ,list1[0]<list2[0]
list2[0]+merge(list1,list2[1:])    ,otherwise

也就是说，**两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并**。

算法

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```js
var mergeTwoLists = function(list1, list2) {
    //如果一个为空，则直接返回另一个
    if (list1===null) {
        return list2
    }else if (list2===null) {
        return list1;
    }else if(list1.val<list2.val){
        list1.next=mergeTwoLists(list1.next,list2);
        return list1;
    }else{
        list2.next=mergeTwoLists(list1,list2.next);
        return list2;
    }
};
```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。
- 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m次，因此空间复杂度为 O(n+m)。

方法二：迭代
思路

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

算法

首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

**在循环终止的时候， l1 和 l2 至多有一个是非空的**。由于输入的两个链表都是有序的，**所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大**。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

var mergeTwoLists = function(list1, list2) {
    const head=new ListNode();
    let list3=head;
    while(list1!=null && list2!=null){
        if (list1.val<list2.val) {
            list3.next=list1;
            list1=list1.next;
        }else{
            list3.next=list2;
            list2=list2.next;
        }
        list3=list3.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    list3.next=list1===null ? list2:list1;
    //注意返回的是什么
    return head.next;
};

let str1 = [-9,3];
let str2=[5,7];
let list1=new ListNode();
let list2=new ListNode();
let head1=list1;
let head2=list2;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
for (let i=0;i<str2.length;i++){
    list2.val=str2[i];
    list2.next=new ListNode();
    list2=list2.next;
}
//console.log(head2);

let result=mergeTwoLists(head1,head2);
console.log(result);


```

复杂度分析

- 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

- 空间复杂度：O(1)。我们只需要常数的空间存放若干变量。

```

```

## 26.删除有序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

提示：

0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let start=0;
    while(start<nums.length){
        if (nums[start]===nums[start+1]) {
            //删除重复中的后一个
            nums.splice(start+1,1);
        }else{
            start++;
        }
    }
    console.log(nums);
    return nums.length;
};


let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeDuplicates(test);
console.log(result);
```

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\双指针删除排序数组中的重复项.png)

```js
var removeDuplicates = function(nums) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let fast = 1, slow = 1;
    while (fast < n) {
        if (nums[fast] !== nums[fast - 1]) {
            //如果不同，则赋值给前面的重复位或当前位
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
};
```

**把不相同的用来覆盖前面相同的，不涉及删除消耗相对较小**

复杂度分析

- 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。


- 空间复杂度：O(1)。只需要使用常数的额外空间。


## 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let flag=0;
    let count=0;
    while (flag < n-count) {
        if (nums[flag]===val) {
            //如果匹配则把后面的值赋值到这里判断
            //只需移动元素匹配次数
            nums[flag]=nums[n-1-count];
            count++;
        }else{
            flag++;
        }
    }
    console.log(nums);
    return flag;
};

let test=[0,0,1,1,1,2,2,3,3,4];
let result=removeElement(test,2);
console.log(result);
```

![移除元素双指针](E:\pogject\学习笔记\image\leetcode\移除元素双指针.png)

## 28. 实现 strStr()

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

![方法一：暴力匹配strStr](E:\pogject\学习笔记\image\leetcode\方法一：暴力匹配strStr.png)

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    if (haystack.length<needle.length) {return -1;}
    if (needle==="") {return 0;}
    if (haystack.length===needle.length && haystack===needle) {return 0;}
    if (haystack.length===needle.length && haystack!==needle) {return -1;}
    for (let i=0;i<haystack.length-needle.length+1;i++){
        if (haystack[i]===needle[0]) {
            let flag=true;
            for (let j=1;j<needle.length;j++){
                if (haystack[i+j]!==needle[j]){
                    flag=false;
                    break;
                }
            }
            if (flag) {
                return i;
            }

        }
    }
    return -1;
};


let str1 = "heffdddllo";
let str2 = "ell";
let result=strStr(str1,str2);
console.log(result);

```

调用内置方法

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle);
};
```

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr.png)

![KMPStrStr](E:\pogject\学习笔记\image\leetcode\KMPStrStr2.png)

```js
var strStr=function(haystack,needle){
    const n=haystack.length,m=needle.length;
    if (m===0) {
        return 0;
    }

    const pi=new Array(m).fill(0);

    //needle部分的前缀函数
    for (let i=1,j=0;i<m;i++){
        while (j>0 && needle[i]!=needle[j]){
            j=pi[j-1];
        }
        if (needle[i]===needle[j]) {
            j++;
        }
        pi[i]=j;
    }

    //求 haystack 部分的前缀函数
    for (let i=0,j=0;i<n;i++){
        while(j>0 && haystack[i]!=needle[j]){
            j=pi[j-1];
        }
        if (haystack[i]==needle[j]) {
            j++;
        }
        if (j===m) {
            return i-m+1;
        }
    }
    return -1;
};

```

## 29.两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

提示：

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。

暴力解法，连减计数,会超时

```

```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除二分查找.png)



```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //二分查找
    let left=1;
    let right=MAX_VALUE;
    let ans=0;
    while(left<=right){
        //注意溢出，并且不能使用除法
        const mid=left+((right-left)>>1);
        const check=quickAdd(divisor,mid,dividend);
        if (check) {
            ans=mid;
            // 注意溢出
            if (mid===MAX_VALUE) {
                break;
            }
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    return rev ? -ans : ans;
};

// 快速乘
const quickAdd=(y,z,x)=>{
    // x 和 y 是负数，z 是正数
    // 需要判断 z * y >= x 是否成立
    let result=0;
    let add=y;
    while(z!==0){
        if ((z&1)!==0) {
            //需要保证 result + add >= x
            if (result<x-add) {
                return false;
            }
            result+=add;
        }
        if (z!==1) {
            //需要保证 add + add >= x
            if (add<x-add) {
                return false;
            }
            add+=add;
        }
        // 不能使用除法
        z>>=1;
    }
    return true;
};

let str1 = 10;
let str2 = 3;
let result=divide(str1,str2);
console.log(result);
```

![两数相除二分查找](E:\pogject\学习笔记\image\leetcode\两数相除类二分查找.png)

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const MAX_VALUE=2**31-1;
    const MIN_VALUE=-(2**31);

    // 考虑被除数为最小值的情况
    if (dividend===MIN_VALUE) {
        if (divisor===1) {
            //直接返回答案-2^31
            return MIN_VALUE;
        }
        if (divisor===-1) {
            //为2^31,产生了溢出。此时我们需要返回2^31-1
            return MAX_VALUE;
        }
    }

    //考虑除数为最小值的情况
    if (divisor===MIN_VALUE) {
        //被除数只有为MIN_VALUE时为1，其他都为0
        return dividend===MIN_VALUE ? 1: 0;
    }

    // 考虑被除数为 0 的情况
    if (dividend===0) {
        return 0;
    }

    // 一般情况，使用类二分查找
    // 将所有的正数取相反数，这样就只需要考虑一种情况
    let rev=false;
    if(dividend>0){
        dividend=-dividend;
        rev=!rev;
    }
    if (divisor>0) {
        divisor=-divisor;
        rev=!rev;
    }

    //类二分查找
    const candidates=[divisor];
    let index=0;
    //注意溢出
    while(candidates[index]>=dividend-candidates[index]){
        //处理的都是负数
        candidates.push(candidates[index]+candidates[index]);
        index++;
    }
    //console.log(candidates);
    let ans=0;
    console.log(ans,dividend);
    for (let i=candidates.length-1;i>=0;--i){
        if (candidates[i]>=dividend) {
            ans+=1<<i;
            dividend-=candidates[i];
            console.log(ans,dividend);
        }
    }
    return rev ? -ans : ans;
};


let str1 = 10000;
let str2 = 33;
let result=divide(str1,str2);
console.log(result);
```

## 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。
提示:

1 <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4
nums 为无重复元素的升序排列数组
-10^4 <= target <= 10^4

二分查找

因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=Math.floor((right+left)/2);
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=Math.floor((right+left)/2);
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=Math.floor((right+left)/2);
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    let left=0;
    let right=nums.length-1;
    let middle=(right+left)>>1;
    //console.log(left,right,middle);
    while(left<=right){
        if (nums[middle]<target) {
            left=middle+1;
            middle=(right+left)>>1;
        }else if (nums[middle]>target) {
            right=middle-1;
            middle=(right+left)>>1;
        }else{
            return middle;
        }
        //console.log(left,right,middle);
    }
    return middle+1;
};


let test = [1,2,3,5,6,7,20,100,289,328];
let result=searchInsert(test,1);
console.log(result);
```

## 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

![最大子数组和动态规划](E:\pogject\学习笔记\image\leetcode\最大子数组和动态规划.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    //只有一个元素直接返回
    if (nums.length===1) { return nums[0]; }

    //动态规划
    let pre=0;
    let maxSum=nums[0];
    nums.forEach((x)=>{
        pre=Math.max(pre+x,x);
        maxSum=Math.max(maxSum,pre);
    });
    //console.log(nums);
    return maxSum;
};

let test = [-2,1,-3,4,-1,2,1,-5,4];
let result=maxSubArray(test,1);
console.log(result);
```

**方法二：分治**



## 58. 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

提示：

1 <= s.length <= 104
s 仅有英文字母和空格 ' ' 组成
s 中至少存在一个单词

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        //反向遍历
        if(s[i]!==" "){
            count++;
        }else{
            //如果前面是字母，则这里单词就结束
            if (count>0) {
                return count;
            }
        }
    }
    return count;
};

let test = "   fly me   to   the moon  ";
let result=lengthOfLastWord(test);
console.log(result);
```

## 66. 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    digits[digits.length-1]+=1;
    for (let i=digits.length-1;i>0;i--){
        if (digits[i]<10){
            break;
        }else{
             digits[i]=0;
             digits[i-1]+=1;
        }
    }
    if (digits[0]===10) {
        digits[0]=1;
        digits[digits.length]=0;
    }
    return digits;
};
```

## 67. 二进制求和

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。
示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"


提示：

每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    if (a.length<b.length) {
        //交换变量的值,解构赋值
        [a,b]=[b,a];
    }
    let result=[];
    let temp=0;
    for(let i=0;i<b.length;i++){
        //先遍历短的一个
        temp+=Number(a[a.length-1-i])+Number(b[b.length-1-i])
        result.unshift((temp%2).toString());
        temp=temp>1 ? 1 : 0;
    }

    for(let j=a.length-b.length-1;j>=0;j--){
        //继续遍历长的一个剩余的位
        if (temp===1) {
            temp+=Number(a[j]);
            result.unshift((temp%2).toString());
            temp=temp>1 ? 1 : 0;
        }else{
            result.unshift(a[j]);
        }
    }
    if (temp===1) {
        //最后是否需要进位
        result.unshift("1")
    }
    return result.join("");
};

let test = "100";
let result=addBinary(test,"110010");
console.log(result);
```

考虑一个最朴素的方法：先将 a和 b转化成十进制数，求和后再转化为二进制数。

方法二：位运算

## 69. Sqrt(x)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
提示：

0 <= x <= 2^31 - 1

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    if (x<2) {
        return x;
    }
    //因为只需要整数部分，所以只需要找到平方小于等于x的的最接近的一个整数
    let left=1;
    let right=x>>1;
    let middle=(left+right)>>1;
    //二分查找
    while(left<=right){
        //注意溢出
        if (middle*middle>x) {
            right=middle-1;
        }else if (middle*middle<x) {
            left=middle+1;
        }else{
            return middle;
        }
        middle=(left+right)>>1;
    }
    return middle;
};

let test = 3;
let result=mySqrt(test);
console.log(result);
```

牛顿迭代法，或其他函数代替

## 70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

递归

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<3){
        return n;
    }else{
        //找到规律
        return climbStairs(n-1)+climbStairs(n-2);
    }

};

let test = 5;
let result=climbStairs(test);
console.log(result);
for (let i=1;i<20;i++){
    console.log(climbStairs(i));
}
/*
1
2
3
5
8
13
21
34
55
*/
```

```js
//动态规划
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```

方法一：动态规划

方法二：**矩阵快速幂**

方法三：通项公式

## 71. 简化路径

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。

1 <= path.length <= 3000
path 由英文字母，数字，'.'，'/' 或 '_' 组成。
path 是一个有效的 Unix 风格绝对路径。

```js
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    path=path.split("/")
    let result=[];
    path.forEach((item)=>{
        if (item!=="" && item!==".") {
            //对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理
            if (item==="..") {
                //当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录
                result.pop();
            }else{
                //当我们遇到「目录名」时，就把它放入栈。
                result.push(item);
            }
        }
    });
    //console.log(path);
    return "/"+result.join("/");
};

//let test = "/a/./b/../../c/";
let test = "/../";
let result=simplifyPath(test);
console.log(result);

```



## 83.删除排序链表中的重复元素

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。

返回同样按升序排列的结果链表。
提示：

链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列

方法一：一次遍历
当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。

```js
var deleteDuplicates = function(head) {
    if (!head) {
        return head;
    }

    let cur = head;
    while (cur.next) {
        if (cur.val === cur.next.val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return head;
};

```



```js
function ListNode(val,next){
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if (head===null) {
        //如果为空
        return head;
    }
    let pre=head;
    let temp=head.val;
    while (head.next){
        if (head.next.val===temp) {
            //如果与前一个结点相同,跳过相同的那个
            head.next=head.next.next;
            //head=head.next;
        }else{
            //不同在移动到下一个
            head=head.next;
            temp=head.val;
        }
    }
    return pre;
};

let str1 = [1,1,2,3,3];
let list1=new ListNode();
let head1=list1;
for (let i=0;i<str1.length;i++){
    list1.val=str1[i];
    list1.next=new ListNode();
    list1=list1.next;
}
//console.log(head1);
let result=deleteDuplicates(head1)
console.log(result);
```

## 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

提示：

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-10^9 <= nums1[i], nums2[j] <= 10^9

**进阶：**你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？

方法二：双指针,直接放会出现覆盖

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    const sorted = new Array(m + n).fill(0);
    var cur;
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            cur = nums2[p2++];
        } else if (p2 === n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (let i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
};
```

方法三：逆向双指针,不会产生覆盖现象

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    var cur;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 === -1) {
            cur = nums2[p2--];
        } else if (p2 === -1) {
            cur = nums1[p1--];
        } else if (nums1[p1] > nums2[p2]) {
            cur = nums1[p1--];
        } else {
            cur = nums2[p2--];
        }
        nums1[tail--] = cur;
    }
};
```



```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let len=m+n-1;
    while(m>=1 && n>=1){
        if (nums1[m-1]>=nums2[n-1]) {
            //如果访问到num1元素大于等于比nums2的
            nums1[len--]=nums1[--m];
        }else{
            //如果访问到num1元素小于比nums2的
            nums1[len--]=nums2[--n];
        }
    }
    while(m>=1){
        //n=0时候
        nums1[len--]=nums1[--m];
    }
    while(n>=1){
        //m=0时
        nums1[len--]=nums2[--n];
    }
};

let test =[1,2,3,0,0,0];
let test2=[2,5,6];
//let result=merge(test);
//console.log(result);
merge(test,3,test2,3);
console.log(test);
```

方法一：直接合并后排序

```js
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m, ...nums2);
    nums1.sort((a, b) => a - b);
};
```

## 89.格雷编码

n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：

- 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
- 第一个整数是 0
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同

给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

1 <= n <= 16

方法一：对称生成

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let result=[0];
    for (let i=1;i<=n;i++){
        let len=result.length;
        while(len>0){
            //对此生成
            result.push(result[--len] | (1<<(i-1)));
            //console.log(result[j] | (1<<(i-1)));
        }
    }
    return result;
};
```

```
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let maxValue=Math.pow(2,n)-1;
    let maxValueHex=maxValue.toString(2);
    let maxLen=maxValueHex.length;
    let arr=new Array(maxLen).fill("0");
    let hexs=[];
    for (let i=0;i<Math.pow(2,n);i++){
        let hex=(arr.join("")+i.toString(2)).slice(-maxLen);
        hexs.push(hex);
        //console.log(hex);
    }
    let newArr=[];
    for (let i=0;i<Math.pow(2,n);i++){
        
    }
    return 0;
};

let test=5;
let result=grayCode(test);
console.log(result);
```

方法二：二进制数转格雷码

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let result=[];
    for (let i=0;i<1<<n;i++){
        result.push((i>>1)^i);
    }
    return result;
};

let test=5;
let result=grayCode(test);
console.log(result);
```



## 94.二叉树的中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。
提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    
    if (root===null) {
        return [];
    }
    let result=[];

    result=result.concat(inorderTraversal(root.left));
    result.push(root.val);
    result=result.concat(inorderTraversal(root.right));
    return result;
};

let test =[1,null,2,3];

let root=new TreeNode(test[0]);
let result=inorderTraversal(test);
console.log(result);


```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

方法二：迭代

方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。

```js
var inorderTraversal = function(root) {
    let result=[];
    let stack=[];

    while(root || stack.length){
        while(root){
            stack.push(root);
            root=root.left;
        }
        root=stack.pop();
        result.push(root.val);
        root=root.right;
    }
    return result;
};
```

方法三：Morris 中序遍历

![Morris 中序遍历二叉树](E:\pogject\学习笔记\image\leetcode\Morris 中序遍历二叉树.png)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result=[];
    let predecessor=null;

    while(root){
        if (root.left) {
            //predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
            predecessor=root.left;
            while(predecessor.right && predecessor.right!==root){
                predecessor=predecessor.right;
            }
            // 让 predecessor 的右指针指向 root，继续遍历左子树
            if (!predecessor.right) {
                predecessor.right=root;
                root=root.left;
            }else{
                //说明左子树已经访问完了，我们需要断开链接
                result.push(root.val);
                predecessor.right=null;
                root=root.right;
            }
        }else{
            //如果没有左孩子，则直接访问右孩子
            result.push(root.val);
            root=root.right;
        }

    }
    return result;
};
```

## 100.相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
提示：

两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104

方法一：深度优先搜索

如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。

如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if (p===null && q===null) {
        return true;
    }else if (p===null || q===null) {
        return false;
    }else{
        if (p.val===q.val) {
            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
        }else{
            return false;
        }
    }
};
```

方法二：广度优先搜索

也可以通过广度优先搜索判断两个二叉树是否相同。同样首先判断两个二叉树是否为空，如果两个二叉树都不为空，则从两个二叉树的根节点开始广度优先搜索。

使用**两个队列**分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。

1. 比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；
2. 如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；
3. 如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。

**如果搜索结束时两个队列同时为空，则两个二叉树相同**。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。

```js
var isSameTree = function(p, q) {
    if (p===null && q===null) {
        return true;
    }
    if(p===null || q===null) {
        return false;
    }
    let arr1=[p];
    let arr2=[q];

    while(arr1.length>0 && arr2.length>0){
        let node1=arr1.shift();
        let node2=arr2.shift();
        if (node1.val!==node2.val) {
            return false;
        }
        let left1=node1.left,right1=node1.right;
        let left2=node2.left,right2=node2.right;

        if ((!left1)^(!left2) || (!right1)^(!right2)) {
            return false;
        }
        if (left1) {
            arr1.push(left1);
        }
        if (right1) {
            arr1.push(right1);
        }
        if (left2) {
            arr2.push(left2);
        }
        if (right2) {
            arr2.push(right2);
        }
    }
    if (arr1.length===0 && arr2.length===0) {
        return true;
    }else{
        return false;
    }

};
```

## 101.对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

方法一：递归

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值

- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，**通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q左移，p 左移时，q 右移**。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

function check(p,q){
    if (p===null && q===null) {
        return true;
    }
    if (p===null || q===null) {
        return false;
    }
    return p.val===q.val && check(p.left,q.right) && check(p.right,q.left);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root,root);
};

```

方法二：迭代

方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？**首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法**。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```js
function check(p,q){
    let arr=[p,q];
    while(arr.length>0){
        node1=arr.shift();
        node2=arr.shift();
        if (!node1 && !node2) {
            //都为空,跳过，检查后面的
            continue;
        }
        if ((!node1 || !node2) || node1.val!==node2.val) {
            //值不等或一个为空，一个不为空
            return false;
        }
        arr.push(node1.left);
        arr.push(node2.right);
        arr.push(node1.right);
        arr.push(node2.left);
    }
    return true;
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root,root);
};
```

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

```

```

## 104.二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

方法一：深度优先搜索

如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1

而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
};
```

方法二：广度优先搜索

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的**队列里存放的是「当前层的所有节点」**。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们**需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展**，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。

```js
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }
    let arr=[root];
    let count=0;
    while(arr.length>0){
        let len=arr.length;
        while(len>0){
            //需要将队列里的所有节点都拿出来进行拓展
            node=arr.shift();
            if (node.left!==null) {
                //加入的这层在下一次外循环拿出判断
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        count++;
    }
    return count;
};
```

## 108. 将有序数组转换为二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「**每个节点的左右两个子树的高度差的绝对值不超过 1** 」的二叉树。

提示：

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 按 严格递增 顺序排列

二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。

给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。

如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。

直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 11，可以使得树保持平衡。**如果数组长度是奇数，则根节点的选择是唯一的**，**如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点**，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。

当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考「1382. 将二叉搜索树变平衡」，这两道题的构造方法完全相同，这种方法是正确的，1382 题解中给出了这个方法的正确性证明：1382 官方题解，感兴趣的同学可以戳进去参考。

递归的基准情形是平衡二叉搜索树不包含任何数字，此时平衡二叉搜索树为空。

在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为[left,right]。对于整个中序遍历序列，下标范围从left=0 到 right=nums.length−1。当 left>right 时，平衡二叉搜索树为空。

以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。

方法一：中序遍历，总是选择中间位置左边的数字作为根节点

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置左边的数字作为根节点
    let mid=(left+right)>>1;  //左边
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}

let test =[-10,-3,0,5,9];
let result=sortedArrayToBST(test);
console.log(result);
```

方法二：中序遍历，总是选择中间位置右边的数字作为根节点

```js
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置右边的数字作为根节点
    let mid=(left+right+1)>>1;  //右边
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}
```

方法三：中序遍历，**选择任意一个中间位置数字作为根节点**

```js
var sortedArrayToBST = function(nums) {
    return helper(nums,0,nums.length-1);
};
function helper(nums,left,right){
    if (left>right) {
        return null;
    }
    // 总是选择中间位置右边的数字作为根节点
    let mid=(left+right+Math.round(Math.random()))>>1;  //左右随机一个
    let root=new TreeNode(nums[mid]);
    root.left=helper(nums,left,mid-1);
    root.right=helper(nums,mid+1,right);
    return root;
}
```

## 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

方法一：自顶向下的递归

有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    if (root===null) {
        return true;
    }
    let leftDeep=maxDepth(root.left);
    let rightDeep=maxDepth(root.right);
    if (Math.abs(leftDeep-rightDeep)>1) {
        //左右子树高度差的绝对值不超过 1
        return false;
    }
    
    let leftIsBalance=isBalanced(root.left);
    let rightIsBalance=isBalanced(root.right);
    
    if (leftIsBalance && rightIsBalance) {
    	//左右子树也必需是平衡二叉树
        return true;
    }else{
        return false;
    }
};

var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
};
```

方法二：自底向上的递归

方法一由于是自顶向下递归，**因此对于同一个节点，函数 height 会被重复调用**，导致时间复杂度较高。**如果使用自底向上的做法，则对于每个节点，函数height 只会被调用一次。**

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    return getHeight(root)>=0;
};

function getHeight(root){
    if (root===null) {
        return 0;
    }
    let leftHeight=getHeight(root.left);
    let rightHeight=getHeight(root.right);
    if (leftHeight===-1  || rightHeight===-1 || Math.abs(leftHeight-rightHeight)>1) {
        //只要遇到不平衡时就返回-1，整棵树也是不平衡的
        return -1;
    }else{
        //平衡时
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```

## 111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

方法一：深度优先搜索

首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。

对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。

```js

/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (root===null){
        //如果结点为空
        return 0;
    }else if (root.left===null && root.right===null){
        //如果没有子树，则深度为1
        return 1;
    }else if (root.left===null && root.right!==null) {
        //如果只存在右子树
        return 1+minDepth(root.right);
    }else if (root.left!==null && root.right===null) {
        //如果只存在左子树
        return 1+minDepth(root.left);
    }else{
        //左右子树都存在
        return 1+Math.min(minDepth(root.left),minDepth(root.right));
    }
};
```

方法二：广度优先搜索

同样，我们可以想到使用广度优先搜索的方法，遍历整棵树。

当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。

```js
var minDepth = function(root) {
    if (root===null) {
        return 0;
    }
    let count=0;
    let arr=[root];
    let flag=true;
    while(flag){
        let len=arr.length;
        while(len>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                //当在一层遇到叶子结点，则退出循环
                flag=false;
            }
            if (node.left!==null) {
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        //如果这层没有叶子结点
        count++;
    }
    return count;
};

var minDepth = function(root) {
    if (root===null) {
        return 0;
    }
    let count=0;
    let arr=[root];

    while(true){
        let len=arr.length;
        count++;
        while(len>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                //当在一层遇到叶子结点，则退出循环,返回深度
                return count;
            }
            if (node.left!==null) {
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
    }
};
```

## 112.路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

方法一：广度优先搜索

首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。

这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (root===null) {
        return false;
    }
    let result=[root];
    while(result.length>0){
        let len=result.length;
        while(len>0){
            let node=result.shift();
            if (node.left!==null) {
                node.left.val+=node.val;
                result.push(node.left);
            }
            if (node.right!==null) {
                node.right.val+=node.val;
                result.push(node.right);
            }
            if (node.left===null && node.right===null) {
                if (node.val===targetSum) {
                    return true;
                }
            }
            len--;
        }
    }
    return false;
};
```

方法二：递归

观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。

不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

```js
var hasPathSum = function(root, targetSum) {
    if (root===null) {
        return false;
    }
    if (root.left===null && root.right===null) {
        return targetSum===root.val;
    }
    return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);
};
```

## 118.杨辉三角

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
提示:

1 <= numRows <= 30

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    let result=[[1]];
    for(n=2;n<=numRows;n++){
        let arr=new Array(n);
        arr[0]=1;
        arr[n-1]=1;
        for(i=1;i<n-1;i++){
            arr[i]=result[n-2][i-1]+result[n-2][i];
        }
        result.push(arr);
    }
    return result;
};

let test=5;
let result=generate(test);
console.log(result);
```

## 119.杨辉三角 II

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。
提示:

0 <= rowIndex <= 33

```js
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let result=[1];
    for(n=2;n<=rowIndex+1;n++){
        let arr=new Array(n);
        arr[0]=1;
        arr[n-1]=1;
        for(i=1;i<n-1;i++){
            arr[i]=result[i-1]+result[i];
        }
        result=arr;
    }
    return result;
};

let test=3;
let result=getRow(test);
console.log(result);
```

## 121.买卖股票的最佳时机 

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

方法一：暴力法, 会超时

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let max=0;
    for (let i=1;i<prices.length;i++){
        for (let j=0;j<i;j++){
            let profit=prices[i]-prices[j]
            max=profit>max ? profit : max;
        }
    }
    return max;
};
let test=[7,1,5,3,6,4];
let result=maxProfit(test);
console.log(result);
```

方法二：一次遍历

我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```js
var maxProfit = function(prices) {
    let max=0;
    let minPrice=Number.MAX_VALUE;
    for (let i=0;i<prices.length;i++){
        if (prices[i]<minPrice) {
            minPrice=prices[i];
        }else{
            let profit=prices[i]-minPrice;
            max=profit>max ? profit : max;
        }
    }
    return max;
};
```

## 125.  验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s=s.toLowerCase();
    s=s.replace(/[^a-z0-9]/g,"")
    console.log(s);
    for (let i=0;i<s.length/2;i++){
        if (s[i]!==s[s.length-1-i]) {
            return false;
        }
    }
    return true;
};


let str1 = "A man, a plan, a canal: Panama";
let result=isPalindrome(str1);
console.log(result);

```

## 136. 只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

![只出现一次的数字位运算](E:\pogject\学习笔记\image\leetcode\只出现一次的数字位运算.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let single=0;
    for (let i=0;i<nums.length;i++){
        single^=nums[i];
    }
    return single;
};

let test=[4,1,2,1,2];
let result=singleNumber(test);
console.log(result);
```

## 141.环形链表

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

提示：

链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？

方法一：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if (head===null) {
        return false;
    }
    let set=new Set();
    while(head.next!==null){
        if (set.has(head)) {
            return true;
        }else{
            set.add(head);
            head=head.next;
        }
    }
    return false;
};
```

方法二：快慢指针

![环形链表快慢指针](E:\pogject\学习笔记\image\leetcode\环形链表快慢指针.png)

```js
var hasCycle = function(head) {
    if (head===null || head.next===null) {
        return false;
    }
    let slow=head;
    let fast=head.next;
    while(slow!==fast){
        if (fast===null || fast.next===null) {
            return false;
        }else{
            slow=slow.next;  //慢指针
            fast=fast.next.next;  //快指针
        }
    }
    return true;
};
```

## 144.二叉树的前序遍历

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[root.val];
    //递归
    result=result.concat(preorderTraversal(root.left));
    result=result.concat(preorderTraversal(root.right));
    return result;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //迭代
        let node=arr.pop();
        result.push(node.val);  //出栈
        if (node.right!==null) {
            //右子树先入栈确保后访问右子树
            arr.push(node.right);
        }
        if (node.left!==null) {
            arr.push(node.left);
        }

    }
    return result;
};
```

方法三：Morris 遍历
思路与算法

有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。

**Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减**。其前序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：

- 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
- 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。

重复步骤 2 和步骤 3，直到遍历结束。

这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let p=root;
    let q;

    let result=[];
    while(p!==null){
        let q=p.left;
        if (q!==null) {
            //如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点
            while(q.right!==null && q.right!==p){
                q=q.right;
            }
            if (q.right===null) {
                //如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。
                result.push(p.val);  //然后将当前节点加入答案
                q.right=p;  //并将前驱节点的右子节点更新为当前节点
                p=p.left;  //当前节点更新为当前节点的左子节点。
                continue;
            }else{
                //q.right!==null && q.right===p
                //如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
                q.right=null;
            }
        }else{
            //如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
            result.push(p.val);
        }
        p=p.right;
    }
    return result;
};
```

## 145.二叉树的后序遍历

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[];
    //递归
    result=result.concat(postorderTraversal(root.left));
    result=result.concat(postorderTraversal(root.right));
    result.push(root.val);
    return result;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //反向迭代
        let node=arr.pop();  //出栈
        result.unshift(node.val);  //从数组前面进入队列
        if (node.left!==null) {
            //左子树先入栈确保先访问右子树
            arr.push(node.left);
        }
        if (node.right!==null) {
            //后入栈，先访问
            arr.push(node.right);
        }
        
    }
    return result;
};
```

## 155.最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。

- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。

```js
var MinStack = function() {
    this.data=new Array();
    this.minValue=new Array();  //存储每一个栈顶对应的最小值
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    if (this.data.length===0) {
        this.minValue.push(val)
    }else{
        this.minValue.push(Math.min(this.minValue[this.minValue.length-1],val));
    }
    //顺序不能反
    this.data.push(val);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.data.pop();
    this.minValue.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.data[this.data.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.minValue[this.minValue.length-1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

## 160.相交链表

给你两个单链表的头节点 headA 和 headB ，**请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。**
题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。
自定义评测：

评测系统 的输入如下（你设计的程序 不适用 此输入）：

- intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
- listA - 第一个链表
- listB - 第二个链表
- skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
- skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

提示：

- listA 中节点数目为 m

- listB 中节点数目为 n
- 1 <= m, n <= 3 * 104
- 1 <= Node.val <= 105
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    //方法一：哈希集合
    //首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中*/
    const visited=new Set();
    let p=headA;
    while(p!==null){
        visited.add(p);
        p=p.next;
    }
    p=headB;
    while(p!==null){
        if (visited.has(p)) {
            return p;
        }
        p=p.next;
    }
    return null;
};
```

![相交链表(双指针)](E:\pogject\学习笔记\image\leetcode\相交链表(双指针).png)

```js
var getIntersectionNode = function(headA, headB) {
    
    if (headA===null || headB===null) {
        return null;
    }
    let p=headA;
    let q=headB;

    while(p!==q){
        p=p===null ? headB : p.next;
        q=q===null ? headA : q.next;
    }
    return p;
};
```

## 168. Excel表列名称

给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

```js
/**
 * @param {number} columnNumber
 * @return {string}
 */
var convertToTitle = function(columnNumber) {

    let result=[];
    while(columnNumber>0){
        if (columnNumber===26) {
            //剩余为26的特殊处理
            result.unshift("Z");
            break;
        }
        let r=columnNumber%26;
        if (r>0) {
            let alpha=String.fromCharCode(0x60+r).toUpperCase();
            result.unshift(alpha);
            columnNumber=columnNumber-r;
        }else{
            result.unshift("Z");
            columnNumber=columnNumber-26;
        }
        //console.log(columnNumber,r);
        columnNumber=columnNumber/26;
    }
    
    return result.join("");
};

let test=52;
let result=convertToTitle(test);
console.log(result);
```

```
var convertToTitle = function(columnNumber) {
    let ans = [];
    while (columnNumber > 0) {
        const a0 = (columnNumber - 1) % 26 + 1;
        ans.push(String.fromCharCode(a0 - 1 + 'A'.charCodeAt()));
        columnNumber = Math.floor((columnNumber - a0) / 26);
    }
    ans.reverse();
    return ans.join('');
};
```

## 169. 多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

进阶：

尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    let n=nums.length>>1;
    //console.log(n);
    let obj={};
    for (let i=0;i<nums.length;i++){
        obj[nums[i]]===undefined ? obj[nums[i]]=1 : ++obj[nums[i]];
    }
    //console.log(obj);
    let result;
    Object.keys(obj).forEach((key)=>{
        if (obj[key]>n) {
            result=key;
        }
    });
    return result;

};

let test=[2,2,1,1,1,2,2];
let result=majorityElement(test);
console.log(result);
```

```

```

## 171. Excel 表列序号

给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。

```js
/**
 * @param {string} columnTitle
 * @return {number}
 */
var titleToNumber = function(columnTitle) {
    let result=0;
    let n=columnTitle.length
    for (let i=0; i<n; i++){
        let num=columnTitle.charCodeAt(n-1-i)-64;
        result+=num*Math.pow(26,i);
    }
    return result;
};


let test="FXSHRXW";
let result=titleToNumber(test);
console.log(result);
```

## 175. 组合两个表

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：

```
FirstName, LastName, City, State
```

```mysql
select FirstName,LastName,City,State 
from Person left join Address 
on Person.PersonId=Address.PersonId;
```

## 181. 超过经理收入的员工

Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。
给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。

```mysql
select a.Name as 'Employee' 
from Employee as a,Employee as b 
where a.ManagerId=b.Id and a.Salary>b.Salary;
```

```mysql
select a.Name as 'Employee' 
from Employee as a join Employee as b 
on a.ManagerId=b.Id and a.Salary>b.Salary;
```

## 182. 查找重复的电子邮箱

编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。

```mysql
select Email from (
	select Email,count(Email) as num 
	from Person group by Email 
) as statistic where num>1;

```

```mysql
select Email from Person group by Email having count(Email) >1;
```

## 183. 从不订购的客户

某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

```mysql
select customers.name as 'Customers' from customers 
where customers.id not in (
	select customerid from orders
);
```

## 190. 颠倒二进制位

颠倒给定的 32 位无符号整数的二进制位。

提示：

输入是一个长度为 32 的二进制字符串

进阶: 如果多次调用这个函数，你将如何优化你的算法？

```js
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    let rev=0;
    for (let i=0;i<32 && n>0;++i){
        rev |=(n & 1) << (31-i);  //按位或操作符用管道符
        n >>>=1;  //无符号右移用 3 个大于号表示
    }
    return rev >>> 0;
};

```

```js
var reverseBits = function(n) {
    const M1 = 0x55555555; // 01010101010101010101010101010101
    const M2 = 0x33333333; // 00110011001100110011001100110011
    const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    const M8 = 0x00ff00ff; // 00000000111111110000000011111111

    n = n >>> 1 & M1 | (n & M1) << 1;
    n = n >>> 2 & M2 | (n & M2) << 2;
    n = n >>> 4 & M4 | (n & M4) << 4;
    n = n >>> 8 & M8 | (n & M8) << 8;
    return (n >>> 16 | n << 16) >>> 0;
};
```

## 191. 位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let ret=0;
    for (let i=0;i<32;i++){
        if ((n & (1 << i))!==0) {
            //当且仅当 n 的第 i 位为 1 时，运算结果不为 0。
            ret++;
        }
    }
    return ret;
};
```

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let ret=0;
    while(n){
        //因为每次运算会使得 nn 的最低位的 11 被翻转，因此运算次数就等于 nn 的二进制位中 11 的个数。
        n&=n-1;
        ret++;
    }
    return ret;
};
```

## 193. 有效电话号码

给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

```bash
grep -P '^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$' file.txt

awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt

gawk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt
```

## 195. 第十行

给定一个文本文件 file.txt，请只打印这个文件中的第十行。
说明:

如果文件少于十行，你应当输出什么？

至少有三种不同的解法，请尝试尽可能多的方法来解题。

```bash
awk 'NR=10' file.txt
sed -n 10p file.txt
tail -n +10 file.txt|head -1
```

## 196. 删除重复的电子邮箱

编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。
提示：

执行 SQL 之后，输出是整个 Person 表。
使用 delete 语句。

```mysql
delete p1 from Person p1,Person p2 
where p1.Email=p2.Email and p1.Id>p2.Id;
```

## 197. 上升的温度

编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。

返回结果 不要求顺序 。

```mysql
select weather.id as 'Id' 
from weather join weather w on DATEDIFF(weather.recordDate,w.recordDate)=1
 and weather.Temperature>w.Temperature;
```

## 202. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let set=new Set();
    while(true){
        console.log(n);
        let str=n.toString();
        if (set.has(n)) {
            //如果该数已经计算过，则不是快乐数
            return false;
        }else{
            set.add(n);
        }
        n=0;
        for(let i=0;i<str.length;i++){
            n+=str[i]*str[i];
        }
        if (n===1) {
            return true;
        }
    }
};

let test=19;
let result=isHappy(test);
console.log(result);
```

## 203. 移除链表元素

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

方法一：递归

```js
var removeElements = function(head, val) {
    if (head===null) {
        return head;
    }
    head.next=removeElements(head.next,val);
    //相等则返回后继
    return head.val===val ? head.next : head;
};
```

方法二：迭代

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
    const pre=new ListNode(0);
    pre.next=head;
    let temp=pre;
    while(temp.next!==null){
        if (temp.next.val===val) {
            temp.next=temp.next.next;
        }else{
            temp=temp.next;
        }
    }
    return pre.next;
};
```

## 205. 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

提示：

1 <= s.length <= 5 * 104
t.length == s.length
s 和 t 由任意有效的 ASCII 字符组成

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
    let m1=new Map();
    let m2=new Map();
    for (let i=0;i<s.length;i++){
        if (m1.has(s[i])) {
            //当映射存在
            if (m1.get(s[i])!==t[i]) {
                return false;
            }
        }else{
            m1.set(s[i],t[i]);
        }
        if (m2.has(t[i])) {
            if (m2.get(t[i])!==s[i]) {
                return false;
            }
        }else{
            m2.set(t[i],s[i]);
        }
    }
    return true;
};

let test="paper";
let result=isIsomorphic(test,"title");
console.log(result);
```

## 206. 反转链表

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

方法一：迭代

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev=null;
    let curr=head;
    while(curr){
        const next=curr.next;  //当前结点的后继
        curr.next=prev;  //将当前节点的 next 指针改为指向前一个节点
        prev=curr;  //先存储其前一个节点
        curr=next;  //存储后一个节点
    }
    return prev;
};
```

方法二：递归

```js
var reverseList = function(head) {
    if (head===null || head.next===null) {
        return head;
    }
    const newHead=reverseList(head.next);
    head.next.next=head;
    head.next=null;
    return newHead;
};
```



## 208. 实现 Trie (前缀树)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次

```js
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @return {boolean}
 */
 //搜索
Trie.prototype.search = function(word) {
    let node=this.startsWith(word);
    //若搜索到了前缀的末尾，就说明字典树中存在该前缀。
    //此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。
    return node!==undefined && node.isEnd!==undefined;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
//查找前缀
Trie.prototype.startsWith = function(prefix) {
    let node=this.children;
    for (let ch of prefix){
        //子节点不存在。说明字典树中不包含该前缀，返回空指针
        if (!node[ch]) {
            return false;
        }
        //子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
        node=node[ch];
    }
    return node;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

let test=new Trie();

test.insert("apple");
result=test.search("apple");
console.log(result);  //true

result=test.search("app");
console.log(result);  //false

result=test.startsWith("app");
console.log(result);  //

test.insert("app");
result=test.search("app");
console.log(result);  //
```

## 217. 存在重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
    let set=new Set();
    for(let i=0;i<nums.length;i++){
        if (set.has(nums[i])) {
            return true;
        }else{
            set.add(nums[i]);
        }
    }
    return false;
};

let test=[1,1,1,3,3,4,3,2,4,2];
let result=containsDuplicate(test);
console.log(result);
```

## 219. 存在重复元素 II

给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。

方法一：哈希表

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    let m=new Map();
    for(let i=0;i<nums.length;i++){
        if (m.has(nums[i])) {
            if (Math.abs(m.get(nums[i])-i)<=k) {
                return true;
            }else{
                m.set(nums[i],i);
            }
        }else{
            m.set(nums[i],i);
        }
        //console.log(m);
    }
    return false;
};

let test=[1,0,1,1];
let result=containsNearbyDuplicate(test,1);
console.log(result);
```

方法二：滑动窗口

```js
var containsNearbyDuplicate = function(nums, k) {
    const set = new Set();
    const length = nums.length;
    for (let i = 0; i < length; i++) {
        if (i > k) {
            set.delete(nums[i - k - 1]);
        }
        if (set.has(nums[i])) {
            return true;
        }
        set.add(nums[i])
    }
    return false;
};

```

## 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

提示：

1 <= x <= 9
最多调用100 次 push、pop、top 和 empty
每次调用 pop 和 top 都保证栈不为空

进阶：你能否仅用一个队列来实现栈。

方法一：两个队列

```js
var MyStack = function() {
    this.queue1=[];
    this.queue2=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue2.push(x);
    while(this.queue1.length>0){
        this.queue2.push(this.queue1.shift());
    }
    let temp=this.queue1;
    this.queue1=this.queue2;
    this.queue2=temp;
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    return this.queue1.shift();
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue1[0];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue1.length===0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */

```

方法二：一个队列

```js
var MyStack = function() {
    this.queue=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    let n=this.queue.length;
    this.queue.push(x);
    for (let i=0;i<n;i++){
        this.queue.push(this.queue.shift());
    }
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    return this.queue.shift();
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue[0];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length===0;
};
```

## 226. 翻转二叉树

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (root===null) {
        return root;
    }
    if (root.left || root.right) {
        let temp=root.left;
        root.left=root.right;
        root.right=temp;
        invertTree(root.left);
        invertTree(root.right);
    }
    return root;
};
```

```js
var invertTree = function(root) {
    if (root === null) {
        return null;
    }
    const left = invertTree(root.left);
    const right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
};
```

## 228. 汇总区间

给定一个  无重复元素 的 有序 整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

"a->b" ，如果 a != b
"a" ，如果 a == b

提示：

0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
nums 中的所有值都 互不相同
nums 按升序排列

```js
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    if (nums.length===0) {
        return [];
    }
    let i=0;
    let j=1;
    let result=[];
    for(j;j<nums.length;j++){
        if (nums[j]-nums[j-1]!==1) {
            if (i===j-1) {
                result.push(nums[i].toString());
            }else{
                result.push(nums[i].toString()+"->"+nums[j-1].toString());
            }
            i=j;
        }
    }
    if (i===j-1) {
        result.push(nums[i].toString());
    }else{
        result.push(nums[i].toString()+"->"+nums[j-1].toString());
    }
    return result;
};

let test=[0,1,2,4,5,7];
let result=summaryRanges(test);
console.log(result);
```

```js
var summaryRanges = function(nums) {
    const ret = [];
    let i = 0;
    const n = nums.length;
    while (i < n) {
        const low = i;
        i++;
        while (i < n && nums[i] === nums[i - 1] + 1) {
            i++;
        }
        const high = i - 1;
        const temp = ['' + nums[low]];
        if (low < high) {
            temp.push('->');
            temp.push('' + nums[high]);
        }
        ret.push(temp.join(''));
    }
    return ret;
};
```

## 231. 2 的幂

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

进阶：你能够不使用循环/递归解决此问题吗？出处。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    if (n<=0) {
        //小于等于0的不满足
        return false;
    }
    while(n>=1){
        if (n===1) {
            return true;
        }
        if (n%2!==0) {
            //如果不能被2整除则不满足
            return false;
        }
        n=n/2;
    }
};

let test=5;
let result=isPowerOfTwo(test);
console.log(result);
```

![2 的幂（二进制表示）](E:\pogject\学习笔记\image\leetcode\2 的幂（二进制表示）.png)

判断是否为最大 2 的幂的约数

```js
var isPowerOfTwo = function(n) {
    const BIG = 1 << 30;
    return n > 0 && BIG % n === 0;
};
```

## 232. 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
进阶：

你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。

```js
var MyQueue = function() {
    this.stack1=[];  //用于存储
    this.stack2=[];  //用于反转元素的入队顺序
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    while(this.stack1.length>0){
        //把栈1的所有元素弹出到栈2
        this.stack2.push(this.stack1.pop());
    }
    this.stack1.push(x);  //进队列元素压到栈1底部
    while(this.stack2.length>0){
        //把栈2的所有元素弹出到栈1
        this.stack1.push(this.stack2.pop());
    }
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    return this.stack1.pop();
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    return this.stack1[this.stack1.length-1];
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.stack1.length===0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

```js
var MyQueue = function() {
    this.stack1=[];  //用于存储
    this.stack2=[];  //反转元素的入队顺序
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    while(this.stack1.length>0){
        //把栈1的所有元素弹出到栈2
        this.stack2.push(this.stack1.pop());
    }
    this.stack1.push(x);  //进队列元素压到栈1底部
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    while(this.stack2.length>0){
        //把栈2的所有元素弹出到栈1
        this.stack1.push(this.stack2.pop());
    }
    return this.stack1.pop();
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    while(this.stack2.length>0){
        //把栈2的所有元素弹出到栈1
        this.stack1.push(this.stack2.pop());
    }
    return this.stack1[this.stack1.length-1];
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.stack1.length===0 && this.stack2.length===0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

## 234. 回文链表

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
提示：

链表中节点数目在范围[1, 105] 内
0 <= Node.val <= 9

进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    let nums=[];
    while(head!==null){
        nums.push(head.val);
        head=head.next;
    }
    let n=nums.length;
    let m=n>>1;
    for(let i=0;i<m;i++){
        if (nums[i]!==nums[n-1-i]) {
            return false;
        }
    }
    return true;

};
```

递归

```js
let frontPointer;

const recursivelyCheck = (currentNode) => {
    if (currentNode !== null) {
        if (!recursivelyCheck(currentNode.next)) {
            return false;
        }
        if (currentNode.val !== frontPointer.val) {
            return false;
        }
        frontPointer = frontPointer.next;
    }
    return true;
}

var isPalindrome = function(head) {
    frontPointer = head;
    return recursivelyCheck(head);
};
```

## 235. 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。

![二叉搜索树的最近公共祖先（两次遍历）](E:\pogject\学习笔记\image\leetcode\二叉搜索树的最近公共祖先（两次遍历）.png)

一次遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    //注意是二叉搜索
    if (root.val<p.val && root.val<q.val) {
        return lowestCommonAncestor(root.right,p,q);
    }else if(root.val>p.val && root.val>q.val) {
        return lowestCommonAncestor(root.left,p,q);
    }else{
        //返回的是结点
        return root;
    }
};
```

## 237. 删除链表中的节点

请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。

题目数据保证需要删除的节点 不是末尾节点 。

提示：

链表中节点的数目范围是 [2, 1000]
-1000 <= Node.val <= 1000
链表中每个节点的值都是唯一的
需要删除的节点 node 是 链表中的一个有效节点 ，且 不是末尾节点

删除链表中的节点的常见的方法是定位到待删除节点的上一个节点，修改上一个节点的 next 指针，使其指向待删除节点的下一个节点，即可完成删除操作。

这道题中，传入的参数 node 为要被删除的节点，无法定位到该节点的上一个节点。注意到要被删除的节点不是链表的末尾节点，因此 node.next 不为空，可以通过对 node 和 node.next 进行操作实现删除节点。

在给定节点 node 的情况下，可以通过修改 node 的 next 指针的指向，删除 node 的下一个节点。但是题目要求删除 node，为了达到删除 node 的效果，只要在删除节点之前，将 node 的节点值修改为 node.next 的节点值即可。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    node.val=node.next.val;
    node.next=node.next.next;
};
```

## 242.  有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

使用数组计数

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length!==t.length) {
        return false;
    }
    var alphas1=new Array();
    var alphas2=new Array();
    var counts1=new Array();
    var counts2=new Array();
    for (let i=0;i<s.length;i++){
        let index1=alphas1.indexOf(s[i]);
        let index2=alphas2.indexOf(t[i]);
        if (index1!==-1) {
            counts1[index1]+=1;
        }else{
            counts1.push(1);
            alphas1.push(s[i]);
        }
        if (index2!==-1) {
            counts2[index2]+=1;
        }else{
            counts2.push(1);
            alphas2.push(t[i]);
        }
    }
    if (alphas1.length!==alphas2.length) {return false;}
    for (let i=0;i<alphas1.length;i++){
        if (counts1[i]!==counts2[alphas2.indexOf(alphas1[i])]) {
            return false;
        }
    }
    return true;

};

let str1 = "anaagram";
let str2 = "naggaram";
let result=isAnagram(str1,str2);
console.log(result);
```

使用对象计数



## 257. 二叉树的所有路径

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。
提示：

树中节点的数目在范围 [1, 100] 内
-100 <= Node.val <= 100

迭代

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    root.val=[root.val];
    let arr=[root];
    let result=[];
    while(arr.length>0){
        let n=arr.length;
        while(n>0){
            let node=arr.shift();
            if (node.left===null && node.right===null) {
                result.push(node.val.join("->"));
            }
            if (node.left!==null) {
                node.left.val=node.val.concat([node.left.val])
                arr.push(node.left);
            }
            if (node.right!==null) {
                node.right.val=node.val.concat([node.right.val])
                arr.push(node.right);
            }
            n--;
        }
    }
    return result;
};
```

方法一：深度优先搜索    二：广度优先搜索

```

```

## 258. 各位相加

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。

提示：

0 <= num <= 231 - 1

进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

```js
/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {

    while(num>9){
        let arr=(""+num).split("");
        num=0;
        arr.forEach((item)=>{
            num+=Number(item);
        });
        console.log(num);
    }
    return num;
};

let test=236;
let result=addDigits(test);
console.log(result);
```

对于9的倍数来说，各位和肯定是9，81=8+1=9 729=7+2+9=18=1+8=9

任何数都可以表现为 9n+b b in [0,1,2,3,4,5,6,7,8]

已知9n各位和为9，最后结果即为9+b

最后对0做一下特殊处理

```js
/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
    if (num===0) {
        return 0;
    }
    if (num%9===0) {
        return 9;
    }else{
        return num%9;
    }
};

let test=236;
let result=addDigits(test);
console.log(result);
```

## 263. 丑数

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

![判断丑数](E:\pogject\学习笔记\image\leetcode\判断丑数.png)

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isUgly = function(n) {
    if (n<=0) {
        return false;
    }
    let factors=[2,3,5];
    for (let f of factors){
        //对n反复除以2,3,5
        while(n%f===0){
            n/=f;
        }
    }
    return n===1;
};

let test=100;
let result=isUgly(test);
console.log(result);
```

## 268. 丢失的数字

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
提示：

n == nums.length
1 <= n <= 104
0 <= nums[i] <= n
nums 中的所有数字都 独一无二

进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

数学方法

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let n=nums.length;
    let sum=n*(n+1)/2;
    for (let i=0;i<n;i++){
        sum-=nums[i];
    }
    return sum;
};

let test=[9,6,4,2,3,5,7,0,1];
let result=missingNumber(test);
console.log(result);
```

排序

将数组排序之后，即可根据数组中每个下标处的元素是否和下标相等，得到丢失的数字。

```js
var missingNumber = function(nums) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i) {
            return i;
        }
    }
    return n;
};

```

哈希集合

使用哈希集合，可以将时间复杂度降低到 O(n)*O*(*n*)。

```js
var missingNumber = function(nums) {
    const set = new Set();
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        set.add(nums[i]);
    }
    let missing = -1;
    for (let i = 0; i <= n; i++) {
        if (!set.has(i)) {
            missing = i;
            break;
        }
    }
    return missing;
};

```

位运算

```js
var missingNumber = function(nums) {
    let xor = 0;
    const n = nums.length;
    for (let i = 0; i < nums.length; i++) {
        xor ^= nums[i];
    }
    for (let i = 0; i <= n; i++) {
        xor ^= i;
    }
    return xor;
};

```

## 278. 第一个错误的版本

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

 

提示：

1 <= bad <= n <= 231 - 1

```js
/**
 * Definition for isBadVersion()
 * 
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n) {
        let left=1;
        let right=n;
        while(left<right){
             let mid = Math.floor(left + (right - left) / 2); // 防止计算时溢出
            if (isBadVersion(mid)) {
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    };
};

```



## 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

双指针

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

1. 左指针左边均为非零数；
2. 右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。



```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let flag1=nums.length-1;  //标识最后的最后一个非0的位置
    for (let i=nums.length-1;i>=0;i--) {
        if (nums[i]===0) {
            if (i!==flag1) {
                for (let j=i;j<flag1;j++){
                    nums[j]=nums[j+1];
                }
                nums[flag1]=0;
                flag1--;
            }else{
                flag1--;
            }
        }
    }
    return nums;
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let result=moveZeroes(str1);
//console.log(typeof result);
console.log(result);

```

## 190. 单词规律

给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

说明:
你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    

```js
/**
 * @param {string} pattern
 * @param {string} s
 * @return {boolean}
 */
var wordPattern = function(pattern, s) {
    s=s.split(" ");
    if (pattern.length!==s.length) {
        return false;
    }
    let m1=new Map();
    let m2=new Map();
    for(let i=0;i<pattern.length;i++){
        if(m1.has(pattern[i])){
            if (m1.get(pattern[i])!==s[i]) {
                return false;
            }
        }else{
            m1.set(pattern[i],s[i]);
        }
        if(m2.has(s[i])){
            if (m2.get(s[i])!==pattern[i]) {
                return false;
            }
        }else{
            m2.set(s[i],pattern[i]);
        }
    }
    return true;
};

let test="dog cat cat fish";
let result=wordPattern("abba",test);
console.log(result);
```

## 292. Nim 游戏

你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合， 你作为先手 。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

提示：

1 <= n <= 231 - 1

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    return n%4!==0;
};

let test=5;
let result=canWinNim(test);
console.log(result);
```

## 303. 区域和检索 - 数组不可变

给定一个整数数组  nums，处理以下类型的多个查询:

计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )

提示：

0 <= nums.length <= 104
-105 <= nums[i] <= 105
0 <= i <= j < nums.length
最多调用 104 次 sumRange 方法

```js
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.nums=nums;
};

/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    let sum=this.nums[right];
    for (let i=left;i<right;i++){
        sum+=this.nums[i];
    }
    return sum;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */

```

```js
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    let n=nums.length;
    this.sums=new Array(n+1).fill(0); //前n个数的和
    for (let i=0;i<n;i++){
        this.sums[i+1]=this.sums[i]+nums[i];
    }
};

/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {
    return this.sums[right+1]-this.sums[left];
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */

```

## 306.累加数

累加数 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。

说明：累加序列里的数 不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。

提示：

1 <= num.length <= 35
num 仅由数字（0 - 9）组成

进阶：你计划如何处理由过大的整数输入导致的溢出?

```
/**
 * @param {string} num
 * @return {boolean}
 */
var isAdditiveNumber = function(num) {
    if (num.length<3) {
        //累加数至少3位才行
        return false;
    }
    let len=num.length;
    let i=0,j=1,k=2;
    let a,b;
    let sumab;
    while(i<len){
        a=Number(num.slice(0,i));
        while(j<len-Math.max(j-i,i)){
            b=Number(num.slice(i,j));
            while(k<len-Math.max(j-i,i)){
                c=(a+b).toString();
                if (num.indexOf(c)!==k) {

                }
            }
            
            
        }
    }
    return false;
};

let test= "199100199";
let result=isAdditiveNumber(test);
console.log(result);
```

## 

## 326. 3 的幂

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x

进阶：你能不使用循环或者递归来完成本题吗？

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    if (n<=0) {
        return false;
    }
    if (n%3!==0 && n!==1) {
        return false;
    }
    while(n>1){
        n/=3;
    }
    return n===1;
};

let test=81;
let result=isPowerOfThree(test);
console.log(result);
```

```

```

## 334.递增的三元子序列

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

提示：

1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1

**进阶：**你能实现时间复杂度为 `O(n)` ，空间复杂度为 `O(1)` 的解决方案吗？

暴力解法，超时

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    if (nums.length<3) {
        return false;
    }
    let flag=0;
    let i;
    for (let i=0;i<nums.length-2;){
        for (let j=i+1;j<nums.length-1;j++){
            if (nums[i]<nums[j]) {
                for (let k=j+1;k<nums.length;k++){
                    if (nums[j]<nums[k]) {
                        return true;
                    }
                }
            }
            
        }
    }
    return false;
};

let test=[2,1,5,0,4,6];
let result=increasingTriplet(test);
console.log(result);
```

找到局部最小最大值

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    if (nums.length<3) {
        return false;
    }
    let min=nums[0]<nums[1] ? nums[0] : nums[1];  //局部最小在第一个与第二个开始计算
    let max=nums[1];  //局部最大值从第二个值开始计算
    for (let i=2;i<nums.length;i++){
        if (min<max) {
            //如果已经找到max>min
            if (nums[i]>max) {
                //如果当前值大于max,则满足题意条件
                return true;
            }else{
                //如果不满足
                if (nums[i]<=min) {
                    //如果当前值比min小，就把min设为当前值
                    min=nums[i];
                }else{
                    //如果当前值比min大，把max设为当前值，
                    max=nums[i];
                }
            }
        }else{
            //当min>max时，从第二个开始值都不大于前面的时候
            if (nums[i]<=min) {
                //如果当前值比min小，就把min,max都设为当前值
                max=nums[i];
                min=nums[i];
            }else{
                //如果当前值比min大，把max设为当前值，后面就会满足max>min了
                max=nums[i];
            }
        }
    }
    return false;
};

let test=[1,0,0,0,0,-1,0,0,0,1000];  //[1,1,-2,6]
let result=increasingTriplet(test);
console.log(result);
```

![递增的三元子序列（双向遍历）](E:\pogject\学习笔记\image\leetcode\递增的三元子序列（双向遍历）.png)

![递增的三元子序列（贪心）](E:\pogject\学习笔记\image\leetcode\递增的三元子序列（贪心）.png)

## 

## 338. 比特位计数

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。
提示：

0 <= n <= 105


进阶：

很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）

**提示：**

- `0 <= n <= 105`

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var countBits = function(n) {
    let result=[0];
    let len=1;
    while(n>0){
        len=result.length < n ? result.length : n;
        for(let i=0;i<len;i++){
            result.push(1+result[i])
        }
        n=n-len;
    }
    //console.log(result);
    return result;
};

for(let i=0;i<=64;i++){
    let result=countBits(i);
    console.log(i,result[i]);
}

```

Brian Kernighan 算法

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 0; i <= n; i++) {
        bits[i] = countOnes(i);
    }
    return bits
};

const countOnes = (x) => {
    let ones = 0;
    while (x > 0) {
        x &= (x - 1);
        ones++;
    }
    return ones;
}

```

动态规划——最高有效位

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    let highBit = 0;
    for (let i = 1; i <= n; i++) {
        if ((i & (i - 1)) == 0) {
            highBit = i;
        }
        bits[i] = bits[i - highBit] + 1;
    }
    return bits;
};

```

动态规划——最低有效位

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        bits[i] = bits[i >> 1] + (i & 1);
    }
    return bits;
};
```

动态规划——最低设置位

```js
var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        bits[i] = bits[i & (i - 1)] + 1;
    }
    return bits;
};
```



## 342. 4的幂

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

**进阶：**你能不使用循环或者递归来完成本题吗？

二进制表示中 11 的位置

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfFour = function(n) {
    return n>0 && (n&(n-1))===0 && (n&0xaaaaaaaa)===0;
};
```

如果 n 是 4的幂，那么它可以表示成 4^x的形式，我们可以发现它除以 3 的余数一定为 1，

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfFour = function(n) {
     return n > 0 && (n & (n - 1)) === 0 && n % 3 === 1;
};
```

## 344. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    let n=s.length-1;
    let m=n>>1;
    for(let i=0;i<=m;i++){
        let temp=s[i];
        s[i]=s[n-i];
        s[n-i]=temp;
    }
    return s;
};

let test= ["A"," ","m","a","n",","," ","a"," ","p","l","a","n",","," ","a"," ","c","a","n","a","l",":"," ","P","a","n","a","m","a"];
let result=reverseString(test);
console.log(result);
```

```js
var reverseString = function(s) {
    const n = s.length;
    for (let left = 0, right = n - 1; left < right; ++left, --right) {
        [s[left], s[right]] = [s[right], s[left]];
    }
};

```

## 345. 反转字符串中的元音字母

给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
    s=s.split("");
    let right=s.length-1;
    let left=0;
    let temp="";
    let set=new Set(["a","e","i","o","u","A","E","I","O","U"]);
    //console.log(set);
    while(left<right){
        if (set.has(s[left])) {
            temp=s[left];
            if (set.has(s[right])) {
                s[left]=s[right];
                s[right]=temp;
                left++;
                right--;
            }else{
                right--;
            }
        }else{
            left++;
        }
    }
    return s.join("");
};

let test="leetcode";
let result=reverseVowels(test);
console.log(result);
```

## 349. 两个数组的交集

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
提示：

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    let result=[];
    let set=new Set();
    for(let i=0;i<nums1.length;i++){
        set.add(nums1[i]);
    }
    for(let i=0;i<nums2.length;i++){
        if (set.has(nums2[i])) {
            result.push(nums2[i]);
            set.delete(nums2[i]);
        }
    }
    return result;
};

let test=[1,2,4,2,1,4,6];
let result=intersection(test,[9,4,9,8,4]);
console.log(result);
```

```js
const set_intersection = (set1, set2) => {
    if (set1.size > set2.size) {
        return set_intersection(set2, set1);
    }
    const intersection = new Set();
    for (const num of set1) {
        if (set2.has(num)) {
            intersection.add(num);
        }
    }
    return [...intersection];
}

var intersection = function(nums1, nums2) {
    const set1 = new Set(nums1);
    const set2 = new Set(nums2);
    return set_intersection(set1, set2);
};

```

## 350. 两个数组的交集 II

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

```js

```

使用双指针

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
    nums1.sort((a,b)=>a-b);
    nums2.sort((a,b)=>a-b);

    let i=0,j=0;
    let results=new Array();
    let temp=nums1[0];
    for (i=0,j=0;i<nums1.length,j<nums2.length;){
        if (nums1[i]==nums2[j]) {
            results.push(nums1[i]);
            i++;
            j++;
        }else{
            if (nums1[i]<nums2[j]) {
                i++;
            }else{
                j++;
            }
        }
    }
    return results;
};
```

## 367. 有效的完全平方数

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

提示：

1 <= num <= 2^31 - 1

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
    let result=true;
    //2分法
    let left=0;
    let right=num;
    let mid;
    while(left<=right){
        mid=(left+right)>>1;
        if(mid*mid>num) {
            right=mid-1;
        }else if(mid*mid<num){
            left=mid+1;
        }else{
            return true;
        }
        //console.log(mid);
    }
    return false;
};

let test=100000000;
let result=isPerfectSquare(test);
console.log(result);

```



## 373.查找和最小的K对数字

给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

提示:

- 1 <= nums1.length, nums2.length <= 104
- -109 <= nums1[i], nums2[i] <= 109
- nums1, nums2 均为升序排列
- 1 <= k <= 1000

```
var kSmallestPairs = function(nums1, nums2, k) {
    m = nums1.length
    n = nums2.length
    /*二分查找第 k 小的数对和的大小*/
    let left = nums1[0] + nums2[0];
    let right = nums1[m - 1] + nums2[n - 1];
    let pairSum = right;
    while (left <= right) {
        const mid = left + ((right - left) >> 1);
        let cnt = 0;
        let start = 0;
        let end = n - 1;
        while (start < m && end >= 0) {
            if (nums1[start] + nums2[end] > mid) {
                end--;
            } else {
                cnt += end + 1;
                start++;
            }
        }
        if (cnt < k) {
            left = mid + 1;
        } else {
            pairSum = mid;
            right = mid - 1;
        }
    }

    const ans = [];
    let pos = n - 1;
    /*找到小于目标值 pairSum 的数对*/
    for (let i = 0; i < m; i++) {
        while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {
            pos--;
        }
        for (let j = 0; j <= pos && k > 0; j++, k--) {
            const list = [];
            list.push(nums1[i]);
            list.push(nums2[j]);
            ans.push(list);
        }
    }

    /*找到等于目标值 pairSum 的数对*/
    pos = n - 1;
    for (let i = 0; i < m && k > 0; i++) {
        while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {
            pos--;
        }
        for (let j = i; k > 0 && j >= 0 && nums1[j] + nums2[pos] == pairSum; j--, k--) {
            const list = [];
            list.push(nums1[i]);
            list.push(nums2[pos]);
            ans.push(list);
        }
    }
    return ans;
}

let str1=[0,1,3,6];
let str2=[2,3,4,5];
let result=kSmallestPairs(str1,str2,3);
console.log(result);

```

## 374. 猜数字大小

猜数字游戏的规则如下：

每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

-1：我选出的数字比你猜的数字小 pick < num
1：我选出的数字比你猜的数字大 pick > num
0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。

提示：

1 <= n <= 231 - 1
1 <= pick <= n

```js
/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return              -1 if num is lower than the guess number
 *                       1 if num is higher than the guess number
 *                       otherwise return 0
 */
var guess = function(num) {
    if (num>1702766719) {
        return -1;
    }else if(num<1702766719){
        return 1;
    }else{
        return 0;
    }
}


/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    let left=1;
    let right=n;
    let mid;
    while(left<right){
        mid= Math.floor(left + (right - left) / 2);  // 防止计算时溢出;
        if(guess(mid)===-1) {
            right=mid-1;
        }else if(guess(mid)===1){
            left=mid+1;
        }else{
            return mid;
        }
        //console.log(mid);
    }
    return left;
};

let test=2126753390;
let result=guessNumber(test);
console.log(result);
```

## 383. 赎金信

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

提示：

1 <= ransomNote.length, magazine.length <= 105
ransomNote 和 magazine 由小写英文字母组成

```js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    let m=new Map();
    for(let i=0;i<magazine.length;i++){
        m.set(magazine[i],m.has(magazine[i]) ? m.get(magazine[i])+1 : 1);
    }
    for(let i=0;i<ransomNote.length;i++){
        if (m.has(ransomNote[i])) {
            if (m.get(ransomNote[i])===0) {
                return false;
            }else{
                m.set(ransomNote[i],m.get(ransomNote[i])-1);
            }
        }else{
            return false;
        }
    }
    return true;
};


let test="ab";
let result=canConstruct("aa",test);
console.log(result);

```

## 389. 找不同

给定两个字符串 s 和 t ，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。
提示：

0 <= s.length <= 1000
t.length == s.length + 1
s 和 t 只包含小写字母

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function(s, t) {
    if (s.length===0) {
        return t;  //只有一个字母
    }
    let m=new Map();
    for(let i=0;i<s.length;i++){
        m.set(s[i],m.has(s[i]) ? m.get(s[i])+1 : 1);
    }
    for(let i=0;i<t.length;i++){
        if (m.has(t[i])) {
            if (m.get(t[i])===0) {
                return t[i];
            }else{
                m.set(t[i],m.get(t[i])-1);
            }
        }else{
            return t[i];
        }
    }
};


let test="ab";
let result=findTheDifference(test,"acb");
console.log(result);

```

求和

```js
var findTheDifference = function(s, t) {
    let as = 0, at = 0;
    for (let i = 0; i < s.length; i++) {
        as += s[i].charCodeAt();
    }
    for (let i = 0; i < t.length; i++) {
        at += t[i].charCodeAt();
    }
    return String.fromCharCode(at - as);
};

```

位运算

如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。使用位运算的技巧解决本题。

```js
var findTheDifference = function(s, t) {
    let ret = 0;
    for (const ch of s) {
        ret ^= ch.charCodeAt();
    }
    for (const ch of t) {
        ret ^= ch.charCodeAt();
    }
    return String.fromCharCode(ret);
};

```



## 390. 消除游戏

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

- 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。

- 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。

- 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。

给你整数 n ，返回 arr 最后剩下的数字。

提示：

1 <= n <= 10^9

直接遍历数组删除会超时

**方法一：等差数列模拟**

![消除游戏等差数列模拟](E:\pogject\学习笔记\image\leetcode\消除游戏等差数列模拟.png)

```js
/**
 * @param {number} n
 * @return {number}
 */
var lastRemaining = function(n) {
    let a1=1;
    //删除次数k,元素数目为cnt,首元素a1,末尾元素an,公差step
    let k=0,cnt=n,step=1;
    while(cnt>1){
        if (k%2===0) {
            // 正向
            a1=a1+step;
        }else{
            //反向，得考虑奇数个或偶数个
            a1=(cnt%2===0) ? a1 : a1+step;
        }
        k++;
        //有符号右移由两个大于号（>>）表示
        cnt=cnt>>1;
        //左移操作符用两个小于号（<<）表示
        step=step<<1;
    }
    
    return a1;
};


console.log(lastRemaining(50));

```

复杂度分析

- 时间复杂度：O(log n)，其中 n 为初始整数列表的元素数目。每次删除都会将元素数目减半，所以时间复杂度为 O(logn)。


- 空间复杂度：O(1)。只需要使用常数的额外空间。

## 392. 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

提示：

0 <= s.length <= 100
0 <= t.length <= 10^4
两个字符串都只由小写字符组成。

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    if (s.length===0) {
        //s为空时一定是
        return true;
    }
    if (s.length===t.length) {
        return s===t;
    }
    if(s.length>t.length){
        return false;
    }
    for (let i=0,j=0;i<s.length;j++){
        if (s.length-i>t.length-j) {
            return false;
        }
        /*
        if (j===t.length) {
            //遍历完t,但s没有遍历完
            return false;
        }
        */
        if (s[i]===t[j]) {
            i++;
        }
    }
    return true;
};


let test1="abec";
let test2="abcde";
let result=isSubsequence(test1,test2);
console.log(result);

```

动态规划

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    let m=t.length;
    let n=s.length;
    const f=new Array(m+1);
    for(let j=0;j<m+1;j++){
        f[j]=new Array(26).fill(m);
    }

    //预处理出对于 t 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。
    for(let i=m-1;i>=0;i--){
        for(let j=0;j<26;j++){
            if (t.charCodeAt(i)==="a".charCodeAt()+j) {
                f[i][j]=i;
            }else{
                f[i][j]=f[i+1][j];
            }
        }
    }
    //console.log(f);
    let add=0;
    for(let i=0;i<n;i++){
        if (f[add][s.charCodeAt(i)-"a".charCodeAt()]===m) {
            //m表示遍历完t了
            return false;
        }
        add=f[add][s.charCodeAt(i)-"a".charCodeAt()]+1;
    }
    return true;
};


let test1="abecd";
let test2="zxabdeccde";
let result=isSubsequence(test1,test2);
console.log(result);

```

## 401. 二进制手表

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。
给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。
分钟必须由两位数组成，可能会以零开头：

例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。

提示：

0 <= turnedOn <= 10

```js
/**
 * @param {number} turnedOn
 * @return {string[]}
 */
var readBinaryWatch = function(turnedOn) {
    if (turnedOn>8) {
        return [];
    }
    //const hours=[0,1,2,4,8];
    //const minutes=[0,1,2,4,8,16,32];
    const hourOfNums=new Array(4);  //亮几个灯时能代表的小时数,最多亮三盏灯
    for(let i=0;i<4;i++){
        hourOfNums[i]=new Array();
    }
    for(let i=0;i<12;i++){
        let numOfOne=countBitOfOne(i.toString(2));
        hourOfNums[numOfOne].push(i.toString());
    }

    const minuteOfNums=new Array(6);  //亮几个灯时能代表的分钟数,最多亮5盏灯
    for(let i=0;i<6;i++){
        minuteOfNums[i]=new Array();
    }
    for(let i=0;i<60;i++){
        let numOfOne=countBitOfOne(i.toString(2));
        minuteOfNums[numOfOne].push(("00"+i.toString()).slice(-2));
    }

    let result=[];
    for(let h=0;h<=turnedOn;h++){
        let m=turnedOn-h;
        if (h<=3 && m<=5) {
            for(let i=0;i<hourOfNums[h].length;i++){
                for(let j=0;j<minuteOfNums[m].length;j++){
                    result.push(hourOfNums[h][i]+":"+minuteOfNums[m][j]);
                }
            }
            
        }
    }
    return result;
};

var countBitOfOne=function(bits){
    let count=0;
    bits=bits.split("");
    for(let i=0;i<bits.length;i++){
        count+=Number(bits[i]);
    }
    return count;
}

let test=1;
let result=readBinaryWatch(test);
console.log(result);

```

## 404. 左叶子之和

给定二叉树的根节点 root ，返回所有左叶子之和。
提示:

节点数在 [1, 1000] 范围内
-1000 <= Node.val <= 1000

```

```



## 472. 连接词

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

提示：

1 <= words.length <= 104
0 <= words[i].length <= 1000
words[i] 仅由小写字母组成
0 <= sum(words[i].length) <= 105

方法一：字典树 + 深度优先搜索
判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。

1. 为了方便处理，首先将数组 words 按照字符串的长度递增的顺序排序，排序后可以确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。
2. 在将数组 words 排序之后，遍历数组，跳过空字符串，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入结果数组，如果不是连接词则将该单词加入字典树。
3. 判断一个单词是不是连接词的做法是在字典树中深度优先搜索。从该单词的第一个字符（即下标 00处的字符）开始，在字典树中依次搜索每个字符对应的结点，可能有以下几种情况：

- 如果一个字符对应的结点是单词的结尾，则找到了一个更短的单词，从该字符的后一个字符开始搜索下一个更短的单词；
- **如果一个字符对应的结点在字典树中不存在，则当前的搜索结果失败，回到上一个单词的结尾继续搜索。**

如果找到一个更短的单词且这个更短的单词的最后一个字符是当前单词的最后一个字符，则当前单词是连接词。由于数组 words 中没有重复的单词，因此在判断一个单词是不是连接词时，该单词一定没有加入字典树，由此可以确保判断连接词的条件成立。

由于一个连接词由多个更短的非空单词组成，如果存在一个较长的连接词的组成部分之一是一个较短的连接词，则一定可以将这个较短的连接词换成多个更短的非空单词，因此不需要将连接词加入字典树。

```
var Trie = function() {
    this.children={};  //
};

/** 
 * @param {string} word
 * @return {void}
 */
//插入字符串
Trie.prototype.insert = function(word) {
    let node=this.children;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

/** 
 * @param {string} word
 * @param {start} int 单词开始索引位置
 * @return {boolean}
 */
 //查找一个词从索引开始后的连续部分是否已存在
Trie.prototype.dfs = function(word,start) {
    let node=this.children;
    for (let i=start;i<word.length;i++){
        node=node[word[i]];
        //深度优先遍历
        if (node!==undefined) {
            if (node.isEnd!==undefined) {
                return i+1;
            }else{
                continue;
            }
        }
        node=node[word[i]];
        if (!node) {
            //得考虑这个单词不行可能那个单词行,carbat比如cat与car
            return false;
        }
        
        if (node && i===word.length-1){
            return i+1;
        }
    }
};



/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const trie=new Trie();

    trie.insert(words[0]);
    trie.insert(words[1]);
    //console.log(trie);
   
    for (let i=2;i<words.length;i++){
        let word=words[i];
        let start;
        let count=0;
        for(start=0;start<word.length;){
            let index=trie.dfs(word,start);
            if (index===false) {
                trie.insert(word);
                break;
            }else{
                if (index<word.length) {
                    start=index;
                    count++;
                }else{
                    if (count>1) {
                        result.push(word);
                    }
                }
            }
        }

    }
    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```

```

//插入字符串
function insertWord(dictTree,word) {
    let node=dictTree;
    for (let ch of word){
        //对于当前字符对应的子节点
        if (!node[ch]) {
            /*子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，
            然后沿着指针移动到子节点，继续搜索下一个字符。*/
            node[ch]={};
        }
        //子节点存在。沿着指针移动到子节点，继续处理下一个字符。
        node=node[ch];
    }
    node.isEnd=true;
};

//检查单词是否是连接词
function checkWord(dictTree,word,start){
    
    let node=dictTree;
    let count=0;  //计数找到多少个更短的单词
    let i; //i为要检查单词开始的索引
    let tempNode=[];  //记录一个路径上是单词的尾结点
    let tempIndex=[];  //记录一个路径上尾结点对应的索引
    for(i=0;i<word.length;){
        if (node[word[i]]===undefined && count<1) {
            //如果一个短的单词都没有找到，则不是连接词
            return false;
        }
        if (node[word[i]]===undefined){
            //当已经找到一个更短的单词时，字母在该路径不存在
            if (count>0) {
                //当尾结点数大于终末尾结点数时,则可以退回到上一次尾结点
                if (tempNode.length>count){
                    
                }
            }
        }else{
            //当一个字母在该路径存在
            node=node[word[i]];
            if (node.isEnd!==undefined) {
                //node是一个单词的尾结点
                tempNode.push(node);  //记录索引和结点指针
                tempIndex.push(i);
                //如果路径上还有结点,继续深度搜索
                if (node[word[i+1]]===undefined) {
                    //当是尾结点且后面不匹配
                    count+=1;
                    //从当前位置开始匹配下一份更短单词
                    node=dictTree;
                }
            }
            i++;
        }

    }
    return true;
}

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    words.sort((a,b)=>a.length-b.length);  //按长度从小到大排序
    words=words.filter(item=>item.length>0);

    let result=[];  //结果数组
    if (words.length<3) {
        //不足三个词就不符合题意
        return result;
    }

    const dictTree={};

    insertWord(dictTree,words[0]);
    insertWord(dictTree,words[1]);
    //console.log(dictTree);
   
   for (let i=2;i<words.length;i++){
        let word=words[i];
        if (dictTree[word[0]]===undefined) {
            //因为单词是从短到长排序的
            //如果单词的第一个字母不在字典树的开始，则一定不是连接词，插入
            insertWord(dictTree,word);
            continue;  //跳过余下检查
        }

        let isConcatWord=checkWord(dictTree,word)
        if (isConcatWord) {
            //如果是连接词
            result.push(word);
        }else{
            //不是则插入
            insertWord(dictTree,word)
        }
    }

    return result;
};


let str1= ["cat","cats","","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"];
let result=findAllConcatenatedWordsInADict(str1);
console.log(result);


```



## 507. 完美数

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function(num) {
	if (num===1) {return false;}
	let sum=1;
	for (let i=2;i<=Math.sqrt(num);i++){
		if (i===Math.sqrt(num)) {
			sum+=Math.sqrt(num)
		}else{
			if (num%i===0) {
				sum+=i+num/i;
			}
		}
	}
	if (num===sum) {
		return true;
	}else{
		return false;
	}
}

let str1=121;
let result=checkPerfectNumber(str1);
console.log(result);
```

## 540. 有序数组中的单一元素

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

提示:

1 <= nums.length <= 105
0 <= nums[i] <= 105

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
     //数组长度一定是奇数个
     let left=0;
     let right=nums.length-1;
     while(left<right){
          let mid=(left+right)>>1;
          if (nums[mid]===nums[mid^1]) {
               left=mid+1;
          }else{
               right=mid;
          }
     }
     return nums[left];
};

let test=[3,3,7,7,10,11,11];
let result=singleNonDuplicate(test);
console.log(result);
```

![有序数组中的单一元素（全数组的二分查找）](E:\pogject\学习笔记\image\leetcode\有序数组中的单一元素（全数组的二分查找）.png)



## 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

示例 1：

输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var repeatedStringMatch = function(a, b) {
    //首先只要b中有字母不在a中,则不可能b为a的子串
    let len_a=a.length;
    let len_b=b.length;

    let set=new Set();
    for (let i=0;i<len_a;i++){
        set.add(a[i]);
    }
    for (let i=0;i<len_b;i++){
        if (!set.has(b[i])) {
            return -1;
        }
    }
    let newStr=a;
    //判断b与a的长度，a当重复后长度最多超过b长度的2倍，如果2倍长度没有找到则返回-1
    let n=len_b%len_a===0 ? len_b/len_a : Math.floor(len_b/len_a)+1;
    if (len_a>=len_b) {
        //当a长时，返回值最多为2
        if (newStr.indexOf(b)!==-1) {
            return 1;
        }else{
            newStr+=a;
            if (newStr.indexOf(b)!==-1) {
                return 2;
            }else{
                return -1;
            }
        }
    }else{
        //当b长时，a长度最多增加到b的2倍
        for (let i=0;i<n-1;i++){
            newStr+=a;
        }
        while (newStr.length<2*len_b){
            if (newStr.indexOf(b)!==-1) {
                return n;
            }else{
                newStr+=a;
                n++;
            }
        }
        if (newStr.indexOf(b)!==-1) {
            return n;
        }else{
            return -1;
        }
        
    }
    return 0;
};


let str1 = "abc";
let str2="cabcabca";

let result=repeatedStringMatch(str1,str2);
console.log(result);
```

## 688. 骑士在棋盘上的概率

在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 k 步或离开了棋盘。

返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。

提示:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n

```
/**
 * @param {number} n
 * @param {number} k
 * @param {number} row
 * @param {number} column
 * @return {number}
 */
var knightProbability = function(n, k, row, column) {
    const dirs=[[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1]];
    
};

let n = 3, k = 2, row = 0, column = 0;
let result=knightProbability(n, k, row, column);
console.log(result);

```



## 717.  比特与2比特字符

有两种特殊字符：

第一种字符可以用一个比特 0 来表示
第二种字符可以用两个比特(10 或 11)来表示、
给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。

提示:

1 <= bits.length <= 1000
bits[i] == 0 or 1

```js
/**
 * @param {number[]} bits
 * @return {boolean}
 */
var isOneBitCharacter = function(bits) {
    let n=bits.length-1;
    if (bits[n]===1) {
        return false;
    }
    for(let i=0;i<n;){
        if (i===n-1) {
            if (bits[i]===1) {
                return false;
            }
        }
        if (bits[i]==1) {
            i+=2;
        }else{
            i++;
        }
    }
    return true;
};

let test=[1, 1, 1, 0];
let result=isOneBitCharacter(test);
console.log(result);

```

```js
var isOneBitCharacter = function(bits) {
    let i = 0, n = bits.length;
    while (i < n - 1) {
        i += bits[i] + 1;
    }
    return i === n - 1;
};

```



## 747.至少是其他数字两倍的最大数

给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。

请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。

提示：

1 <= nums.length <= 50
0 <= nums[i] <= 100
nums 中的最大元素是唯一的

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var dominantIndex = function(nums) {
    if (nums.length===1) {
        return 0;
    }
    //找到最大值与次大比较即可
    let maxValue=nums[0]>nums[1] ? nums[0] : nums[1];
    let secondMaxValue=nums[0]>nums[1] ? nums[1] : nums[0];
    let MaxValueIndex=nums[0]>nums[1] ? 0 : 1;
    for (let i=2;i<nums.length;i++){
        if (nums[i]>maxValue) {
            secondMaxValue=maxValue;
            maxValue=nums[i];
            MaxValueIndex=i;
        }else{
            if (nums[i]>secondMaxValue) {
                secondMaxValue=nums[i];
            }
        }
    }
    if (maxValue>=2*secondMaxValue) {
        return MaxValueIndex;
    }else{
        return -1;
    }
};

let str1 = [3,6,1,0];
let result=dominantIndex(str1);
console.log(result);

```



## 825. 适龄的朋友

在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。

如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：

age[y] <= 0.5 * age[x] + 7
age[y] > age[x]
age[y] > 100 && age[x] < 100
否则，x 将会向 y 发送一条好友请求。

注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

- `n == ages.length`
- `1 <= n <= 2 * 104`
- `1 <= ages[i] <= 120`

```js
/**
 * @param {number[]} ages
 * @return {number}
 */
var numFriendRequests = function(ages) {
    if (ages.length===1) {return 0;}
    let count=0;
    ages.sort((a,b)=>b-a);  //从大到小排序
    let flag=0;  //移动指针
    for (let i=0;i<ages.length;i++){
        for (let j=flag;j<ages.length;j++){
            if (i!==j) {
                if (ages[j]>ages[i]*0.5+7) {
                    count++;
                    //console.log(ages[i]+"->"+ages[j]);
                }else{
                    break;
                }
            }
        }
        //age变化则移动指针
        if (ages[i]>ages[i+1]) {
            //console.log(ages[flag]);
            flag=i+1;
        }
    }
    return count;
};

let str1 = [30,100,110,120,20];
let result=numFriendRequests(str1);
console.log(result);

```



## 846. 一手顺子

Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。

给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。

提示：

1 <= hand.length <= 104
0 <= hand[i] <= 109
1 <= groupSize <= hand.length

示例 1：

输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
示例 2：

输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。

```js
/**
 * @param {number[]} hand
 * @param {number} groupSize
 * @return {boolean}
 */
var isNStraightHand = function(hand, groupSize) {
    if (hand.length%groupSize!==0) {
        //当不能整除则不能排列为相同size的
        return false;
    }
    if (groupSize===1) {
        //当size为1则可以
        return true;
    }
    //从小到大排序
    hand.sort((a,b)=>a-b);
    //console.log(hand.length/groupSize);
    //console.log(hand);
    let len=hand.length;  //记录初始长度

    for (let i=0;i<len/groupSize;i++){
        let temp=hand[0];  //每一次排列一定是从最小的开始
        //console.log(temp);
        hand.shift();  //删除第一张牌

        for (let j=1;j<groupSize;j++){
            //从第二张开始找就行
            let index=hand.indexOf(temp+j);
            if (index===-1) {
                //如果不存在比上一张大1的牌
                return false;
            }
            //存在则删除
            //console.log(hand[index]);
            hand.splice(index,1);

        }
        //console.log("---")
    }

    return true;
};

let hand = [9,13,15,23,22,25,16,21,18,21,24,23,10,21,16,18,16,18,5,20,19,20,10,14,26,2,9,19,12,28,17,5,7,25,22,16,17,21,11];
let groupSize = 10;

console.log(isNStraightHand(hand,groupSize));
```

## 913. 猫和老鼠

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

**老鼠从节点 1 开始**，第一个出发；**猫从节点 2 开始**，第二个出发。**在节点 0 处有一个洞**。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，**猫无法移动到洞中（节点 0**）。

然后，游戏在出现以下三种情形之一时结束：

- 如果猫和老鼠出现在同一个节点，猫获胜。
- 如果老鼠到达洞中，老鼠获胜。
- 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。

给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：

- 如果老鼠获胜，则返回 1；

- 如果猫获胜，则返回 2；
- 如果平局，则返回 0 。

提示：

3 <= graph.length <= 50
1 <= graph[i].length < graph.length
0 <= graph[i][j] < graph.length
graph[i][j] != i
graph[i] 互不相同
猫和老鼠在游戏中总是移动

![猫和老鼠动态规划1](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划1.png)

![猫和老鼠动态规划2](E:\pogject\学习笔记\image\leetcode\猫和老鼠动态规划2.png)

```js
const MOUSE_WIN=1;
const CAT_WIN=2;
const DRAW=0;

/**
 * @param {number[][]} graph
 * @return {number}
 */
var catMouseGame = function(graph) {
    this.n=graph.length;
    this.graph=graph;
    this.dp=new Array(n).fill(0).map(()=>new Array(n).fill(0).map(()=>new Array(n*2).fill(-1)));
    //console.log(this.dp);
    return getResult(1,2,0);
};

const getResult=(mouse,cat,turns)=>{
    if (turns===n*2) {
        return DRAW;
    }
    if (dp[mouse][cat][turns]<0) {
        if (mouse===0) {
            dp[mouse][cat][turns]=MOUSE_WIN;
        }else if(cat===mouse){
            dp[mouse][cat][turns]=CAT_WIN;
        }else{
            getNextResult(mouse,cat,turns);
        }
    }
    return dp[mouse][cat][turns];
}

const getNextResult=(mouse,cat,turns)=>{
    const curMove=turns%2===0 ? mouse : cat;
    const defaultResult=curMove===mouse ? CAT_WIN : MOUSE_WIN;
    let result=defaultResult;
    const nextNodes=graph[curMove];
    for (let next of nextNodes){
        if (curMove===cat  && next===0) {
            continue;
        }
        const nextMouse=curMove===mouse ? next : mouse;
        const nextCat=curMove===cat ? next : cat;
        const nextResult=getResult(nextMouse,nextCat,turns+1);
        if (nextResult!==defaultResult) {
            result=nextResult;
            if (result!==DRAW) {
                break;
            }
        }
    }
    dp[mouse][cat][turns]=result;
}


let test = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]];
let result=catMouseGame(test);
console.log(result);
```

## 969. 煎饼排序

给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。

一次煎饼翻转的执行过程如下：

选择一个整数 k ，1 <= k <= arr.length
反转子数组 arr[0...k-1]（下标从 0 开始）
例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。

以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。

提示：

1 <= arr.length <= 100
1 <= arr[i] <= arr.length
arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）

```js
/**
 * @param {number[]} arr
 * @return {number[]}
 */
var pancakeSort = function(arr) {
    let result=[];
    let n=arr.length;
    while(n>1){
        let maxValueIndex=findMaxValueIndex(arr,n);
        if (maxValueIndex!==n-1) {
            if (maxValueIndex!==0) {
                result.push(maxValueIndex+1);
                swapArrSort(arr,maxValueIndex);
            }
            result.push(n);
            swapArrSort(arr,n-1);
        }
        n--;
        //console.log(arr);
    }
    return result;

};
var findMaxValueIndex=function(arr,n){
    for(let i=0;i<n;i++){
        if (arr[i]===n) {
            return i;
        }
    }
}
var swapArrSort=function(arr,n){
    let temp;
    for(let i=0,j=n;i<j;i++,j--){
        temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}


let test=[3,2,4,5,6,1];
let result=pancakeSort(test);
console.log(result);

```



## 1001. 网格照明

在大小为 n x n 的网格 grid 上，每个单元格都有一盏灯，最初灯都处于 关闭 状态。

给你一个由灯的位置组成的二维数组 lamps ，其中 lamps[i] = [rowi, coli] 表示 打开 位于 grid[rowi][coli] 的灯。即便同一盏灯可能在 lamps 中多次列出，不会影响这盏灯处于 打开 状态。

当一盏灯处于打开状态，它将会照亮 自身所在单元格 以及同一 行 、同一 列 和两条 对角线 上的 所有其他单元格 。

另给你一个二维数组 queries ，其中 queries[j] = [rowj, colj] 。对于第 j 个查询，如果单元格 [rowj, colj] 是被照亮的，则查询结果为 1 ，否则为 0 。在第 j 次查询之后 [按照查询的顺序] ，关闭 位于单元格 grid[rowj][colj] 上及相邻 8 个方向上（与单元格 grid[rowi][coli] 共享角或边）的任何灯。

返回一个整数数组 ans 作为答案， ans[j] 应等于第 j 次查询 queries[j] 的结果，1 表示照亮，0 表示未照亮。

提示：

1 <= n <= 109
0 <= lamps.length <= 20000
0 <= queries.length <= 20000
lamps[i].length == 2
0 <= rowi, coli < n
queries[j].length == 2
0 <= rowj, colj < n

```
/**
 * @param {number} n
 * @param {number[][]} lamps
 * @param {number[][]} queries
 * @return {number[]}
 */
var gridIllumination = function(n, lamps, queries) {
    let grids=new Array(n);
    for (let i=0;i<n;i++){
        grids[i]=new Array(n).fill(0);
    }
    //N,NE,E,ES,S,SE,E,EN
    const dirs=[[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]
    lamps.forEach((lamp)=>{
        if (grids[lamp[0]][lamp[1]]<4*(n-1)+1) {
            //避免灯重复变亮
            dirs.forEach((dir)=>{
                let row=lamp[0];
                let col=lamp[1];
                while(row>=0 && row<n && col>=0 && col<n ){
                    grids[row][col]+=1;
                    row+=dir[0];
                    col+=dir[1];
                }
            });
            grids[lamp[0]][lamp[1]]+=4*(n-1)+1;
        }
    });
    //console.log(grids);
    const result=[];
    queries.forEach((query)=>{
        if (grids[query[0]][query[1]]>0) {
            result.push(1);
        }else{
            result.push(0);
        }
        if (grids[query[0]][query[1]]>4*(n-1)) {
            //查询的灯亮着
            //关闭该灯并设置被照明的网格-1
            shutTheLamp(grids,query[0],query[1],n);
            //console.log(grids);
        }
        dirs.forEach((dir)=>{
            let row=query[0]+dir[0];
            let col=query[1]+dir[1];
            if(row>=0 && row<n && col>=0 && col<n ){
                if (grids[row][col]>4*(n-1)) {
                    //查询灯其他方向上位置的灯亮着
                    //关闭该灯并设置被照明的网格-1
                    shutTheLamp(grids,row,col,n);
                    //console.log(grids);
                }
            }
        });
    });
    return result;
};

var shutTheLamp=function(grids,row0,col0,n){
    const dirs=[[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]];
    dirs.forEach((dir)=>{
        let row=row0;
        let col=col0;
        while(row>=0 && row<n && col>=0 && col<n ){
            grids[row][col]-=1;
            row+=dir[0];
            col+=dir[1];
        }
    });
    grids[row0][col0]-=(4*(n-1)+1);
};

let n = 1;
//let lamps =[[2,5],[4,2],[0,3],[0,5],[1,4],[4,2],[3,3],[1,0]];
//let queries = [[4,3],[3,1],[5,3],[0,5],[4,4],[3,3]];
let lamps=[[0,0],[0,0]];
let queries=[[0,0],[0,0]];
let result=gridIllumination(n,lamps,queries);
console.log(result);
```

哈希表

![网格照明(哈希表)](E:\pogject\学习笔记\image\leetcode\网格照明(哈希表).png)

```
var gridIllumination = function(n, lamps, queries) {
    const row = new Map();
    const col = new Map();
    const diagonal = new Map();
    const antiDiagonal = new Map();
    const points = new Set();
    for (const lamp of lamps) {
        if (points.has(hash(lamp[0], lamp[1]))) {
            continue;
        }
        points.add(hash(lamp[0], lamp[1]));
        row.set(lamp[0], (row.get(lamp[0]) || 0) + 1);
        col.set(lamp[1], (col.get(lamp[1]) || 0) + 1);
        diagonal.set(lamp[0] - lamp[1], (diagonal.get(lamp[0] - lamp[1]) || 0) + 1);
        antiDiagonal.set(lamp[0] + lamp[1], (antiDiagonal.get(lamp[0] + lamp[1]) || 0) + 1);
    }
    const ret = new Array(queries.length).fill(0);
    for (const [i, [r, c]] of queries.entries()) {
        if (row.get(r) || col.get(c) || diagonal.get(r - c) || antiDiagonal.get(r + c)) {
            ret[i] = 1;
        }
        for (let x = r - 1; x < r + 2; x++) {
            for (let y = c - 1; y < c + 2; y++) {
                if (x < 0 || y < 0 || x >= n || y >= n || !points.has(hash(x, y))) {
                    continue;
                }
                points.delete(hash(x, y));
                row.set(x, row.get(x) - 1);
                col.set(y, col.get(y) - 1);
                diagonal.set(x - y, diagonal.get(x - y) - 1);
                antiDiagonal.set(x + y, antiDiagonal.get(x + y) - 1);
            }
        }
    }
    return ret;
}

const hash = (x, y) => {
    return '' + x + y;
};

```

## 1020. 飞地的数量

给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。

一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。

返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。

来提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid[i][j] 的值为 0 或 1

方法一：深度优先搜索
根据飞地的定义，如果从一个陆地单元格出发无法移动到网格边界，则这个陆地单元格是飞地。因此可以将所有陆地单元格分成两类：第一类陆地单元格和网格边界相连，这些陆地单元格不是飞地；第二类陆地单元格不和网格边界相连，这些陆地单元格是飞地。

我们可以从网格边界上的每个陆地单元格开始深度优先搜索，遍历完边界之后，所有和网格边界相连的陆地单元格就都被访问过了。然后遍历整个网格，如果网格中的一个陆地单元格没有被访问过，则该陆地单元格不和网格的边界相连，是飞地。

代码实现时，由于网格边界上的单元格一定不是飞地，因此遍历网格统计飞地的数量时只需要遍历不在网格边界上的单元格。

```js
var numEnclaves = function(grid) {
    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    const m = grid.length;
    const n = grid[0].length;
    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));

    const dfs = (grid, row, col) => {
        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {
            return;
        }
        visited[row][col] = true;
        for (const dir of dirs) {
            dfs(grid, row + dir[0], col + dir[1]);
        }
    };

    for (let i = 0; i < m; i++) {
        dfs(grid, i, 0);
        dfs(grid, i, n - 1);
    }
    for (let j = 1; j < n - 1; j++) {
        dfs(grid, 0, j);
        dfs(grid, m - 1, j);
    }
    let enclaves = 0;
    for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
            if (grid[i][j] === 1 && !visited[i][j]) {
                enclaves++;
            }
        }
    }
    return enclaves;
}

let test=[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]];
let result=numEnclaves(test);
console.log(result);
```

方法二：广度优先搜索
也可以通过广度优先搜索判断每个陆地单元格是否和网格边界相连。

首先从网格边界上的每个陆地单元格开始广度优先搜索，访问所有和网格边界相连的陆地单元格，然后遍历整个网格，统计飞地的数量。

```js
var numEnclaves = function(grid) {
    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    const m = grid.length;
    const n = grid[0].length;
    const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));
    const queue=[];

    for (let i = 0; i < m; i++) {
        if (grid[i][0]===1) {
            visited[i][0]=true;
            queue.push([i,0]);
        }
        if (grid[i][n-1]===1) {
            visited[i][n-1]=true;
            queue.push([i,n-1]);
        }
    }
    for (let j = 1; j < n - 1; j++) {
        if (grid[0][j]===1) {
            visited[0][j]=true;
            queue.push([0,j]);
        }
        if (grid[m-1][j]===1) {
            visited[m-1][j]=true;
            queue.push([m-1,j]);
        }
    }
    while(queue.length){
        const cell=queue.shift();
        const currRow=cell[0];
        const currCol=cell[1];
        for (const dir of dirs){
            const nextRow=currRow+dir[0];
            const nextCol=currCol+dir[1];
            if (nextRow > 0 && nextRow < m && nextCol >= 0 && nextCol < n && grid[nextRow][nextCol] == 1 && !visited[nextRow][nextCol]) {
            visited[nextRow][nextCol]=true;
            queue.push([nextRow,nextCol]);
        }
        }

    }
    let enclaves = 0;
    for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
            if (grid[i][j] === 1 && !visited[i][j]) {
                enclaves++;
            }
        }
    }
    return enclaves;
}

let test=[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]];
let result=numEnclaves(test);
console.log(result);
```

方法三：并查集
除了深度优先搜索和广度优先搜索的方法以外，也可以使用并查集判断每个陆地单元格是否和网格边界相连。

并查集的核心思想是计算网格中的每个陆地单元格所在的连通分量。对于网格边界上的每个陆地单元格，其所在的连通分量中的所有陆地单元格都不是飞地。如果一个陆地单元格所在的连通分量不同于任何一个网格边界上的陆地单元格所在的连通分量，则该陆地单元格是飞地。

并查集的做法是，遍历整个网格，对于网格中的每个陆地单元格，将其与所有相邻的陆地单元格做合并操作。由于需要判断每个陆地单元格所在的连通分量是否和网格边界相连，因此并查集还需要记录每个单元格是否和网格边界相连的信息，在合并操作时更新该信息。

在遍历网格完成并查集的合并操作之后，再次遍历整个网格，通过并查集中的信息判断每个陆地单元格是否和网格边界相连，统计飞地的数量。

```js
var numEnclaves = function(grid) {
    const m = grid.length, n = grid[0].length;
    const uf = new UnionFind(grid);
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === 1) {
                const index = i * n + j;
                if (j + 1 < n && grid[i][j + 1] === 1) {
                    uf.union(index, index + 1);
                }
                if (i + 1 < m && grid[i + 1][j] === 1) {
                    uf.union(index, index + n);
                }
            }
        }
    }
    let enclaves = 0;
    for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
            if (grid[i][j] === 1 && !uf.isOnEdge(i * n + j)) {
                enclaves++;
            }
        }
    }
    return enclaves;
}

class UnionFind {
    constructor(grid) {
        const m = grid.length, n = grid[0].length;
        this.parent = new Array(m * n).fill(0);
        this.onEdge = new Array(m * n).fill(false);
        this.rank = new Array(m * n).fill(0);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (grid[i][j] === 1) {
                    const index = i * n + j;
                    this.parent[index] = index;
                    if (i === 0 || i === m - 1 || j === 0 || j === n - 1) {
                        this.onEdge[index] = true;
                    }
                }
            }
        }
    }

    find(i) {
        if (this.parent[i] !== i) {
            this.parent[i] = this.find(this.parent[i]);
        }
        return this.parent[i];
    }

    union(x, y) {
        const rootx = this.find(x);
        const rooty = this.find(y);
        if (rootx !== rooty) {
            if (this.rank[rootx] > this.rank[rooty]) {
                this.parent[rooty] = rootx;
                this.onEdge[rootx] |= this.onEdge[rooty];
            } else if (this.rank[rootx] < this.rank[rooty]) {
                this.parent[rootx] = rooty;
                this.onEdge[rooty] |= this.onEdge[rootx];
            } else {
                this.parent[rooty] = rootx;
                this.onEdge[rootx] |= this.onEdge[rooty];
                this.rank[rootx]++;
            }
        }
    }

    isOnEdge(i) {
        return this.onEdge[this.find(i)];
    }
}

```



## 1044.最长重复子串

给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。

提示：

2 <= s.length <= 3 * 104
s 由小写英文字母组成

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    let strA;
    for (let k=s.length-1;k>0;k--){
        for (let i=0;i+k<s.length;i++){
            strA=s.slice(i,i+k);
            if (i!==s.lastIndexOf(strA)){
                return strA;
            }
        }
        
    }
    return "";
};

let str1 = "basanaadsfenafdrrgeana";
let result=longestDupSubstring(str1);
console.log(result);
```

超时

## 1154.  一年中的第几天

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

提示：

date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

```js
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    let y=Number(date.split("-")[0]);
    let m=Number(date.split("-")[1]);
    let d=Number(date.split("-")[2]);
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];

    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }

    let total=0;
    for (let i=0;i<m-1;i++){
        total+=monthOfDays[i]
    }
    total+=d;
    if (m>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }

    return total;
};

let str1 = "2022-01-01";

let result=dayOfYear(str1);
console.log(result);
```

**普通闰年:公历年份是4的倍数的，一般是闰年。（如2004年就是闰年）；
世纪闰年:公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是世纪闰年，2000年是世纪闰年）；**

## 1185. 一周中的第几天

给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

输入：day = 31, month = 8, year = 2019
输出："Saturday"

题目规定输入的日期一定是在 1971 到 2100 年之间的有效日期，即在 1971 年 1 月 1日，到 2100 年 12 月 31 日之间。通过查询日历可知，1970 年 12 月 31 日是星期四，我们只需要算出输入的日期距离 1970 年 12 月 31 日有几天，再加上 3 后对 7求余，即可得到输入日期是一周中的第几天。

求输入的日期距离 1970 年 12 月 31 日的天数，可以分为三部分分别计算后求和：

（1）输入年份之前的年份的天数贡献；
（2）输入年份中，输入月份之前的月份的天数贡献；
（3）输入月份中的天数贡献。

```js
var isLeap=function(y){
    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }
    return is_leap;
}

/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(year,month,day) {
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];
    let is_leap=isLeap(year);

    let total=0;
    for (let i=0;i<month-1;i++){
        total+=monthOfDays[i]
    }
    total+=day;
    if (month>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }
    return total;
};

/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    let totalDays=0;
    for(let y=1971;y<year;y++){
        totalDays+=365;
        if (isLeap(y)){
            console.log(y);
            totalDays+=1
        }
    }
    totalDays+=dayOfYear(year,month,day)+3;
    return weekdays[totalDays%7];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```

直接使用API

```js
/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */
var dayOfTheWeek = function(day, month, year) {
    let date=new Date(year,month-1,day);
    let weekdays=["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    let weekDay=date.getDay();  //从 Date 对象返回一周中的某一天 (0 ~ 6)。
    return weekdays[weekDay];
};

//let test=[0,0,1,1,1,2,2,3,3,4];
let result=dayOfTheWeek(31,8,2019);
console.log(result);
```

## 1189. “气球” 的最大数量

给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。

字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。

提示：

1 <= text.length <= 10^4
text 全部由小写英文字母组成

```js
/**
 * @param {string} text
 * @return {number}
 */
var maxNumberOfBalloons = function(text) {
    let m=new Map([["b",0],["a",0],["l",0],["o",0],["n",0]]);
    for(let i=0;i<text.length;i++){
        if (m.has(text[i])) {
            m.set(text[i],m.get(text[i])+1);
        }
    }
    let minNum=text.length;
    m.forEach((v,k)=>{
        if (k==="l" || k==="o") {
            minNum=Math.min(minNum,v>>1);
        }else{
            minNum=Math.min(minNum,v);
        }
    });
    return minNum;
};


let test="loonbalxballpoon";
let result=maxNumberOfBalloons(test);
console.log(result);
```



## 1219. 黄金矿工

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

提示：

1 <= grid.length, grid[i].length <= 15
0 <= grid[i][j] <= 100
最多 25 个单元格中有黄金。

![黄金矿工回溯算法](E:\pogject\学习笔记\image\leetcode\黄金矿工回溯算法.png)

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var getMaximumGold = function(grid) {
    this.grid=grid;
    this.m=this.grid.length;
    this.n=this.grid[0].length;
    this.dirs=[[-1,0],[1,0],[0,-1],[0,1]];
    this.ans=0;

    const dfs=(x,y,gold,dirs)=>{
        gold+=grid[x][y];
        this.ans=Math.max(ans,gold);

        const rec=grid[x][y];
        grid[x][y]=0;

        for (let d=0;d<4;d++){
            const nx=x+this.dirs[d][0];
            const ny=y+this.dirs[d][1];
            if (nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0) {
                dfs(nx,ny,gold);
            }
        }
        grid[x][y]=rec;
    }

    for (let i=0;i<m;i++){
        for(let j=0;j<n;j++){
            if (grid[i][j]!==0) {
                dfs(i,j,0);
            }
        }
    }
    return ans;
};

let test=[[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]];
let result=getMaximumGold(test);
console.log(result);
```

## 1380. 矩阵中的幸运数

给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。

幸运数是指矩阵中满足同时下列两个条件的元素：

在同一行的所有元素中最小
在同一列的所有元素中最大


提示：

m == mat.length
n == mat[i].length
1 <= n, m <= 50
`1 <= matrix[i][j] <= 10^5`
矩阵中的所有元素都是不同的

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var luckyNumbers  = function(matrix) {
     let m=matrix.length;
     let n=matrix[0].length;
     const maxColArr=new Array(n).fill(0);;  //每一列的最大值
     const minRowArr=new Array(m).fill(0);  //每一行的最大值索引;
     for(let i=0;i<m;i++){
          for(let j=0;j<n;j++){
               maxColArr[j]=Math.max(maxColArr[j],matrix[i][j]);
               //矩阵中的所有元素都是不同的
               minRowArr[i]=matrix[i][minRowArr[i]]<matrix[i][j] ? minRowArr[i] : j;
          }
     }
     //console.log(matrix);
     //console.log(maxColArr);
     //console.log(minRowArr);
     let result=[];
     for (let i=0;i<m;i++){
          if (matrix[i][minRowArr[i]]===maxColArr[minRowArr[i]]) {
               result.push(matrix[i][minRowArr[i]]);
          }
     }
     return result;

};

let test=[[1,10,4,2],[9,3,8,7],[15,16,17,12]];
let result=luckyNumbers(test);
console.log(result);
```



## 1405. 最长快乐字符串

如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。

给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：

s 是一个尽可能长的快乐字符串。
s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。
s 中只含有 'a'、'b' 、'c' 三种字母。
如果不存在这样的字符串 s ，请返回一个空字符串 ""。

来提示：

0 <= a, b, c <= 100
a + b + c > 0

```js
/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {string}
 */
var longestDiverseString = function(a, b, c) {
    let result=[];
    const arr=[[a,'a'],[b,'b'],[c,'c']];
    while(true){
        arr.sort((a,b)=>b[0]-a[0]);
        let hasNext=false;
        for(const [i,[c,ch]] of arr.entries()){
            if (c<=0) {
                break;
            }
            const m=result.length;
            if (m>=2 && result[m-2]===ch && result[m-1]===ch) {
                continue;
            }
            hasNext=true;
            result.push(ch);
            arr[i][0]--;
            break;
        }
        if (!hasNext) {
            break;
        }
    }
    return result.join("");
};



let test=100;
let result=longestDiverseString(1,1,7);
console.log(result);

```

## 1447. 最简分数

给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。

 提示：

1 <= n <= 100

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var simplifiedFractions = function(n) {
    if(n===1){
        return [];
    }
    let result=[];
    for(let i=2;i<=n;i++){
        for(j=1;j<i;j++){
            if (gcd(i,j)===1) {
                result.push(j+"/"+i);
            }
        }
    }
    return result;
};
var gcd=function(a,b){
    //辗转相除获取最大公约数
    if (a%b===0) {
        return b;
    }
    return arguments.callee(b,a%b);
}
let test=5;
let result=simplifiedFractions(test);
console.log(result);
```



## 1576.替换所有的问号

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你 不能 修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

提示：

1 <= s.length <= 100

s 仅包含小写英文字母和 '?' 字符

在替换时，实际不需要遍历所有的小写字母，只需要遍历三个互不相同的字母，就能保证一定找到一个与前后字符均不相同的字母，在此我们可以限定三个不同的字母为 (‘a’,‘b’,‘c’)。



```js
/**
 * @param {string} s
 * @return {string}
 */
var modifyString = function(s) {
    s=s.split("");
    for (let i=0;i<s.length;i++){
        if (s[i]==="?") {
            if (s[i-1]!=="a" && s[i+1]!=="a") {
                //前后都不为a则设为a
                s[i]="a";
            }else if (s[i-1]==="b" || s[i+1]==="b"){
                //有一个a和一个b，则设为c
                s[i]="c";
            }else{
                //前后都是a时,设为b
                s[i]="b";
            }
        }
    }
    return s.join("");
};

let test = "aza??byw?ipkj?";
let result=modifyString(test)
console.log(result);

//使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定
//fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
/*
console.log("az".charCodeAt(0));  //97
console.log("az".charCodeAt(1));  //122
console.log(String.fromCharCode(97));  //a
console.log(String.fromCharCode(122));  //z
*/
```

```

```

## 1614.括号的最大嵌套深度

如果字符串满足以下条件之一，则可以称之为 **有效括号字符串**（valid parentheses string，可以简写为 VPS）：

- 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。

- 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。

- 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。

类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：

- depth("") = 0

- depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
- depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
- depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串

例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。

**给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。**

提示：

1 <= s.length <= 100
s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
题目数据保证括号表达式 s 是 有效的括号表达式

栈处理

```js
/**
 * @param {string} s
 * @return {number}
 */
var maxDepth = function(s) {
    let arr=[];
    let maxDeep=0;
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        if (s[i]===")") {
            //右括号就入栈
            if (arr.length!==0) {
                if (count>0) {
                    //如果前面已经出栈，但栈不为空，局部值减1
                    count--;
                }
            }
            arr.unshift(s[i]);
            //console.log(arr,count);
        }
        if (s[i]==="(") {
            //是左括号则弹出一个右括号,局部计数加一
            arr.shift();
            count++;
            if (arr.length===0) {
                //当出栈后栈为空，则一个区域匹配完，判断最大值
                maxDeep=count>maxDeep ? count : maxDeep;
                count=0;
            }
            //console.log(arr,count);
        }
    }
    return maxDeep;
};

let test = "(1)+((2))+(((((4)((()))))((3))))";
let result=maxDepth(test)
console.log(result);
```

方法一：遍历

对于括号计算类题目，我们往往可以用栈来思考。

遍历字符串 s，如果遇到了一个左括号，那么就将其入栈；如果遇到了一个右括号，那么就弹出栈顶的左括号，与该右括号匹配。这一过程中的栈的大小的最大值，即为 s 的嵌套深度。

代码实现时，由于我们只需要考虑栈的大小，我们可以用一个变量 size 表示栈的大小，当遇到左括号时就将其加一，遇到右括号时就将其减一，从而表示栈中元素的变化。这一过程中 size 的最大值即为 s 的嵌套深度。

```js
/**
 * @param {string} s
 * @return {number}
 */
//不用栈空间是一样的
var maxDepth = function(s) {
    let maxDeep=0;
    let count=0;
    for (let i=s.length-1;i>=0;i--){
        if (s[i]===")") {
            count++;
            maxDeep=count>maxDeep ? count : maxDeep;
        }
        if (s[i]==="(") {
            count--;
        }
    }
    return maxDeep;
};
```

## 1629.按键持续时间最长的键

LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。

给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。

测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。

注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。

请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。

提示：

releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed 仅由小写英文字母组成

```js
/**
 * @param {number[]} releaseTimes
 * @param {string} keysPressed
 * @return {character}
 */
var slowestKey = function(releaseTimes, keysPressed) {
    let maxTime=releaseTimes[0];
    let char=keysPressed[0];
    for (let i=1;i<releaseTimes.length;i++){
        let duration=releaseTimes[i]-releaseTimes[i-1]
        if (duration>maxTime) {
            maxTime=duration;
            char=keysPressed[i];
        }
        if (duration===maxTime) {
            if (keysPressed[i].codePointAt(0)>char.codePointAt(0)) {
                char=keysPressed[i];
            }
        }
    }
    return char;
};

let test= [9,29,49,50];
let result=slowestKey(test,"cbcd");
console.log(result);
```



## 1705. 吃苹果的最大数目

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

提示：

apples.length == n
days.length == n
1 <= n <= 2 * 104
0 <= apples[i], days[i] <= 2 * 104
只有在 apples[i] = 0 时，days[i] = 0 才成立

核心思路就是每次都吃最快腐烂的苹果 按照苹果的腐烂时间给苹果排序 需要用到优先队列
首先用实现一个优先队列的插入方法 核心思想二分法就可以
然后将苹果按照过期时间排序 并记录苹果的数量
苹果吃完了 就将队列第一项删除 或者腐烂了也需要删除
直到所有的苹果都遍历完了并且优先队列也空了

```
/**
 * @param {number[]} apples
 * @param {number[]} days
 * @return {number}
 */
var eatenApples = function(apples, days) {
    let count=0;
    let rest=0;
    let temp=0;  //每天长出后有效个苹果
    let max_day=0;

    for (let i=0;i<apples.length;i++){
        if (apples[i]>0) {
            temp=apples[i]>days[i] ? days[i]+1 : apples[i];  //
            apples[i]=temp;
        }
    }
    return apples;
    //return count;
};

let str1 = [1,2,3,5,2];
let str2=[3,2,1,4,2];
let result=eatenApples(str1,str2);
console.log(result);

```

## 1719. 重构一棵树的方案数

给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：

pairs 中没有重复元素
xi < yi
令 ways 为满足下面条件的有根树的方案数：

树所包含的所有节点值都在 pairs 中。
一个数对 [xi, yi] 出现在 pairs 中 当且仅当 xi 是 yi 的祖先或者 yi 是 xi 的祖先。
注意：构造出来的树不一定是二叉树。
两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。

请你返回：

如果 ways == 0 ，返回 0 。
如果 ways == 1 ，返回 1 。
如果 ways > 1 ，返回 2 。
一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。

我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。

提示：

1 <= pairs.length <= 105
1 <= xi < yi <= 500
pairs 中的元素互不相同。

```
/**
 * @param {number[][]} pairs
 * @return {number}
 */
var checkWays = function(pairs) {
    const adj = new Map();
    for (const p of pairs) {
        if (!adj.has(p[0])) {
            adj.set(p[0], new Set());
        }
        if (!adj.has(p[1])) {
            adj.set(p[1], new Set());
        }
        adj.get(p[0]).add(p[1]);
        adj.get(p[1]).add(p[0]);
    }
    /* 检测是否存在根节点*/
    let root = -1;
    const entries = new Set();
    for (const entry of adj.entries()) {
        entries.add(entry);
    }
    for (const [node, neg] of entries) {
        if (neg.size === adj.size - 1) {
            root = node;
        }
    }
    if (root === -1) {
        return 0;
    }
    let res = 1;
    for (const [node, neg] of entries) {
        /* 如果当前节点为根节点 */
        if (root === node) {
            continue;
        }
        const currDegree = neg.size;
        let parentNode = -1;
        let parentDegree = Number.MAX_SAFE_INTEGER;
        /* 根据degree的大小找到当前节点的父节点 */
        for (const neighbour of neg) {
            if (adj.has(neighbour) && adj.get(neighbour).size < parentDegree && adj.get(neighbour).size >= currDegree) {
                parentNode = neighbour;
                parentDegree = adj.get(neighbour).size;
            }
        }
        if (parentNode === -1) {
            return 0;
        }
        /* 检测父节点的集合是否包含所有的孩子节点 */
        for (const neighbour of neg) {
            if (neighbour === parentNode) {
                continue;
            }
            if (!adj.get(parentNode).has(neighbour)) {
                return 0;
            }
        }
        if (parentDegree === currDegree) {
            res = 2;
        }
    }
    return res;
};


let test= [[1,2],[2,3],[1,3]];
let result=checkWays(test);
console.log(result);
```



## 1748. 唯一元素的和

给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。

请你返回 nums 中唯一元素的 和 。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var sumOfUnique = function(nums) {
    let obj={};
    let sum=0;
    for(let i=0;i<nums.length;i++){
        obj[nums[i]]===undefined ? obj[nums[i]]=1 : ++obj[nums[i]];
        if (obj[nums[i]]===1) {
            //计数为1时，加该值
            sum+=nums[i];
        }
        if (obj[nums[i]]===2) {
            //计数为2时,减掉
            sum-=nums[i];
        }
    }
    return sum;
};


let test=[2,2,1,1,1,2,2];
let result=sumOfUnique(test);
console.log(result);
```

```js
var sumOfUnique = function(nums) {
    const cnt = new Map();
    for (const num of nums) {
        cnt.set(num, (cnt.get(num) || 0) + 1);
    }
    let ans = 0;
    for (const [num, c] of cnt.entries()) {
        if (c === 1) {
            ans += num;
        }
    }
    return ans;
};
```

```js
var sumOfUnique = function(nums) {
    let ans = 0;
    const state = new Map();
    for (const num of nums) {
        if (!state.has(num)) {
            ans += num;
            state.set(num, 1);
        } else if (state.get(num) === 1) {
            ans -= num;
            state.set(num, 2);
        }
    }
    return ans;
};

```

## 1791. 找出星型图的中心节点

有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。

给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。

提示：

3 <= n <= 105
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui != vi
题目数据给出的 edges 表示一个有效的星型图

```js
/**
 * @param {number[][]} edges
 * @return {number}
 */
var findCenter = function(edges) {
    let set=new Set();
    for(let i=0;i<edges.length;i++){
        if (set.has(edges[i][0])) {
            return edges[i][0];
        }
        if (set.has(edges[i][1])) {
            return edges[i][1];
        }
        set.add(edges[i][0]);
        set.add(edges[i][1]);
    }
};

let test=[[1,2],[2,3],[4,2]];
let result=findCenter(test);
console.log(result);

```



## 1984. 学生分数的最小差值

给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。

从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。

返回可能的 最小差值 。

提示：

1 <= k <= nums.length <= 1000
0 <= nums[i] <= 105

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minimumDifference = function(nums, k) {
    if (nums.length<2) {
        return 0;
    }
    nums.sort((a,b)=>a-b);  //排序
    let mindiff=nums[nums.length-1]-nums[0];  //初始为最大差值
    for(i=0;i<nums.length-k+1;i++){
        let temp=nums[i+k-1]-nums[i];
        mindiff=temp<mindiff ? temp : mindiff;
        if (mindiff===0) {
            return 0;
        }
    }
    return mindiff;
};

let test=[9,4,1,7];
let result=minimumDifference(test,2);
console.log(result);
```



## 1995. 统计特殊四元组

给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：

nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d

提示：
4 <= nums.length <= 50
1 <= nums[i] <= 100

直接枚举

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var countQuadruplets = function(nums) {
    let count=0;
    if (nums[0]+nums[1]+nums[2]===nums[3]) {count+=1;}
    for(let d=4;d<nums.length;d++){
        //1 <= nums[i] <= 100
        for(let a=0;a<=d-3;a++){
            if (nums[a]>=nums[d]) {
                continue
            }
            for(let b=a+1;b<=d-2;b++){
                if (nums[a]+nums[b]>=nums[d]) {
                    continue
                }
                for(let c=b+1;c<=d-1;c++){
                    if (nums[a]+nums[b]+nums[c]===nums[d]) {
                        console.log(a,b,c,d);
                        count+=1;
                    }
                }
            }
        }
    }
    return count;
};


let str1= [56,50,33,1,86,80,85,42,90];
let result=countQuadruplets(str1);
console.log(result);

```

使用哈希表存储 nums[d]

```

```

## 2006. 差的绝对值为 K 的数对数目

给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i < j 且 |nums[i] - nums[j]| == k 。

|x| 的值定义为：

如果 x >= 0 ，那么值为 x 。
如果 x < 0 ，那么值为 -x 。

提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100
1 <= k <= 99

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var countKDifference = function(nums, k) {
    nums.sort((a,b)=>a-b);
    let i=0;
    let j=1;
    let n=nums.length;
    let result=0;
    for(let i=0;i<n-1;i++){
        for(let j=i+1;j<n;j++){
            if (nums[j]-nums[i]===k) {
                result+=1;
            }
            if (nums[j]-nums[i]>k) {
                break;
            }
        }
    }
    return result;
};

let test=[1,2,2,1];
let result=countKDifference(test,1);
console.log(result);
```

哈希表 + 一次遍历

```js
var countKDifference = function(nums, k) {
    let res = 0, n = nums.length;
    const cnt = new Map();
    for (let j = 0; j < n; ++j) {
        res += (cnt.get(nums[j] - k) || 0) + (cnt.get(nums[j] + k) || 0);
        cnt.set(nums[j], (cnt.get(nums[j]) || 0) + 1);
    }
    return res;
};
```



## 2022. 将一维数组转变成二维数组

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

提示：

1 <= original.length <= 5 * 104
1 <= original[i] <= 105
1 <= m, n <= 4 * 104

```js
/**
 * @param {number[]} original
 * @param {number} m
 * @param {number} n
 * @return {number[][]}
 */
var construct2DArray = function(original, m, n) {
	if (original.length!==m*n) {
		return [];
	}
	let newArr=[];
	for (let i=0;i<m;i++){
		newArr.push(original.slice(i*n,(i+1)*n));
	}
	return newArr;
};

let str1=[1,2,3,4];
let result=construct2DArray(str1,2,2);
console.log(result);
```

