原始访问 http://gmall-h5-api.atguigu.cn

# 初始化

## 安装vue cli

如果没有安装 Vue CLI 就先安装

```bash
npm install -g @vue/cli
```

## 创建一个项目

windows下使用bash不能交互式选择，用cmd就行

```bash
>vue create app


Vue CLI v5.0.6
? Please pick a preset: Default ([Vue 2] babel, eslint)
? Pick the package manager to use when installing dependencies: NPM


Vue CLI v5.0.6
✨  Creating project in E:\pogject\vueProject\shangpinghui\app.
🗃  Initializing git repository...
⚙️  Installing CLI plugins. This might take a while...


added 848 packages in 41s
🚀  Invoking generators...
📦  Installing additional dependencies...


added 83 packages in 6s
⚓  Running completion hooks...

📄  Generating README.md...

🎉  Successfully created project app.
👉  Get started with the following commands:

 $ cd app
 $ npm run serve

```

## 目录文件描述

```bash
$ ls
README.md        jsconfig.json  package-lock.json  public/  vue.config.js
babel.config.js  node_modules/  package.json       src/
```

脚手架目录:public + assets文件夹区别

1. node_modules:放置项目依赖的地方

2. public:一般放置一些共用的静态资源，打包上线的时候，public文件夹里面资源原封不动打包到dist文件夹里面

3. src：程序员源代码文件夹

   -  -----assets文件夹：经常放置一些静态资源（图片），assets文件夹里面资源webpack会进行打包为一个模块（js文件夹里面）

   -  -----components文件夹:一般放置非路由组件（或者项目共用的组件）

4. ​    App.vue 唯一的根组件

5. ​    main.js 入口文件【程序最先执行的文件】

6. ​    babel.config.js:babel配置文件

7. ​    package.json：看到项目描述、项目依赖、项目运行指令

8. ​    README.md:项目说明文件







## 配置项目package.json

浏览器自动打开

​    在package.json文件中

```json
  "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  }
```

关闭eslint校验工具

创建vue.config.js文件：需要对外暴露

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  lintOnSave:false
})
```

 src文件夹的别名的设置

因为项目大的时候src（源代码文件夹）：里面目录会很多，找文件不方便，设置src文件夹的别名的好处，找文件会方便一些

创建jsconfig.json文件

```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "baseUrl": "./",
    "moduleResolution": "node",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "exclude":[
      "node_modules",
      "dist"
    ],
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  }
}
```

## 配置git

```bash
echo "# vue-app-sph" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:senbinkop66/vue-app-sph.git
git push -u origin main
```

## 安装less less-loader@5

```bash
cnpm i --save less less-loader@5
```

切记less-loader安装5版本的，不要安装在最新版本，安装最新版本less-loader会报错，报的错误setOption函数未定义

需要在style标签的身上加上lang="less",不添加样式不生效

```vue
<style scoped lang="less">
</style>
```

## 安装vue-router

```
cnpm i --save vue-router
```



## 路由的配置

### vue-router

路由分为KV

node平台（并非语言）

对于后台而言:K即为URL地址  V即为相应的中间件

```
http://localhost:8080/0607

app.get("/0607",(res,req)=>{

  res.send('我是祖国的老花骨朵');

});

```

前端路由:

K即为URL（网络资源定位符）

V即为相应的路由组件

### 路由的一个分析

确定项目结构顺序:上中下 -----只有中间部分的V在发生变化，中间部分应该使用的是路由组件

2个非路由组件|四个路由组件

两个非路由组件：Header 、Footer

路由组件:Home、Search、Login（没有底部的Footer组件，带有二维码的）、Register（没有底部的Footer组件，带二维码的）



### 安装路由

```bash
cnpm i --save vue-router@3
```

--save:可以让你安装的依赖，在package.json文件当中进行记录

这里安装vue-router@4会编译时会报错



## 创建路由组件

【一般放在views|pages文件夹】

配置路由

配置完四个路由组件



## 创建非路由组件

（2个：Header、Footer）



非路由组件使用分为几步:

第一步：定义

第二步：引入

第三步：注册

第四步:使用



清除默认样式

```html
    <!-- 引入reset.css清除默认样式 -->
    <link rel="stylesheet" type="text/css" href="<%= BASE_URL %>reset.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_2758111_9hehey1sgko.css">
```



非路由组件的结构的搭建：

静态页面：

结构 + 样式 +图片资源



项目采用的less样式,浏览器不识别less语法，需要一些loader进行处理，把less语法转换为CSS语法



```
面试题：v-show与v-if区别?
v-show:通过样式display控制
v-if：通过元素上树与下树进行操作

面试题:开发项目的时候，优化手段有哪些?
1:v-show|v-if
2:按需加载
8)首页|搜索底部是有Footer组件，而登录注册是没有Footer组件
Footer组件显示|隐藏，选择v-show|v-if
路由元信息
```



## 路由的跳转

  跳转路由的2种基本方式

​    声明式: `<router-link to="">` 声明式导航（router-link：务必要有to属性）

​    编程式: `this.$router.push()/replace()`

 编程式导航更好用：因为可以书写自己的业务逻辑



路由传参

params参数：路由需要占位，程序就崩了，属于URL当中一部分

query参数：路由不需要占位，写法类似于ajax当中query参数

```vue
	<div>
		<h1>Search</h1>
		<h2>params---{{$route.params.keyword}}</h2>
		<h2>query---{{$route.query.keyword}}</h2>
	</div>
```



```js
// 第一种：字符串
 this.$router.push("/search/" + this.keyword + "?k=" + this.keyword.toUpperCase());
// 第二种：模板字符串
 this.$router.push(`/search/${this.keyword}?k=${this.keyword.toUpperCase()}`);
// 第三种：对象
this.$router.push({name: "search", params:{keyword: "abc" || undefined}, query:{keyword:this.keyword}});
```





路由传递参数先关面试题
     1:路由传递参数（对象写法）path是否可以结合params参数一起使用?
     不可以：不能这样书写，程序会崩掉

不可以用path和params配置的组合, 只能用name和params配置的组合

query配置可以与path或name进行组合使用



​      2:如何指定params参数可传可不传? 

`path: '/search/:keyword?'`

 如果路由要求传递路由参数，但是你就不传参数，URL会出现问题
 如何指定params参数可以传递、或者不传递，在配置路由的时候，在占位后面加一个问号

```js
 {
    //命名路由,给路由起一个名字
    name: "search",
    path: "/search:keyword?",
    component: Search,
    meta: { show: true },
}    
```

 3:params参数可以传递也可以不传递，但是如果传递是空串，如何解决？

 使用undefined解决：params参数可以传递、不传递（空的字符串）

```js
this.$router.push({name: "search", params:{keyword: "abc" || undefined}, query:{keyword:this.keyword}});
```



  4:如果指定name与params配置, 但params中数据是一个"", 无法跳转，路径会出问题

解决1: 不指定params

解决2: 指定params参数值为undefined



 5: 路由组件能不能传递props数据?

 可以: 可以将query或且params参数映射/转换成props传递给路由组件对象

实现: props: (route)=>({keyword1:route.params.keyword, keyword2: route.query.keyword })

```js
 //新增配置项:props,给路由组件传递props参数
        //第一种布尔模式,相当于把params参数，作为props属性值传递给这个路由组件
        // props:true,

        //第二种:对象形式
        // props:{a:1,b:'kkk'}

        //第三种写法:函数写法.一般是把query参数与params参数当中props传递给路由组件!!!
        //route就是当前路由
        // props:(route)=>{
        //      //是将当前箭头函数返回结果，作为props传递给search路由组件!!!
        //      return {a:route.params.keyword,b:'可以传递参数'};
        // }

```

```

```



编程式导航路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误?

注意:编程式导航（push|replace）才会有这种情况的异常，声明式导航是没有这种问题，因为声明式导航内部已经解决这种问题。
这种异常，对于程序没有任何影响的。

为什么会出现这种现象:

vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，当传递参数多次且重复，会抛出异常，因此出现上面现象,

解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误

```js
// catch()处理错误
this.$router.push(`/search/${this.keyword}`).catch(() => {})
// 指定成功的回调函数
this.$router.push(`/search/${this.keyword}`, () => {})
// 指定失败的回调函数
this.$router.push(`/search/${this.keyword}`, undefined, () => {})

```



第一种解决方案：是给push函数，传入相应的成功的回调与失败的回调

```js
// 验证Vue-Router引入Promise技术,最笨的方法,给push传递第二个、第三个参数【回调函数】
// 下面这种写法：治标不治本！！！！
let reuslt = this.$router.push({name: "search", params:{keyword: "abc" || undefined}, query:{keyword:this.keyword}}, (data)=>{console.log(data)}, (err)=>{console.error(err)});
console.log(reuslt);
```

第一种解决方案可以暂时解决当前问题，但是以后再用push|replace还是会出现类似现象，因此我们需要从‘根’治病；

```js
//问题1:push方法,里面this是谁? vueRouter类的实例
//this: 当前组件实例
this.$router.push({name:'search',params:{keyword:this.keyword}});
//问题2:push方法里面的this是谁?windows
let result = this.$router.push;
result({name:'search',params:{keyword:this.keyword}})
```



解决2: 修正Vue原型上的push和replace方法 (优秀)

```js
// 缓存原型上的push函数
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace
// 给原型对象上的push指定新函数函数
VueRouter.prototype.push = function (location, onComplete, onAbort) {
  // 判断如果没有指定回调函数, 通过call调用源函数并使用catch来处理错误
  if (onComplete===undefined && onAbort===undefined) {
    return originPush.call(this, location, onComplete, onAbort).catch(() => {})
  } else { // 如果有指定任意回调函数, 通过call调用源push函数处理
    originPush.call(this, location, onComplete, onAbort)
  }
}
VueRouter.prototype.replace = function (location, onComplete, onAbort) {
  if (onComplete===undefined && onAbort===undefined) {
    return originReplace.call(this, location, onComplete, onAbort).catch(() => {})
  } else {
    originReplace.call(this, location, onComplete, onAbort)
  }
}

```



路由的跳转与传参

第一种声明式导航:为什么使用router-link组件的时候，会出现卡顿那？
router-link是一个组件：相当于VueComponent类的实例对象，一瞬间
new VueComponent很多实例（1000+），很消耗内存，因此导致卡顿。





## 将Home组件的静态组件拆分



静态页面（样式）

拆分静态组件

发请求获取服务器数据进行展示

开发动态业务

拆分组件：结构+样式+图片资源

一共要拆分为七个组件

```

```





## axios二次封装

AJAX:客户端可以'敲敲的'向服务器端发请求，在页面没有刷新的情况下，实现页面的局部更新。
XMLHttpRequest、$、fetch、axios

跨域:如果多次请求协议、域名、端口号有不同的地方，称之为跨域
JSONP、CROS、代理

工作的时候src目录下的API文件夹，一般关于axios二次封装的文件

进度条：nprogress模块实现进度条功能

工作的时候，修改进度条的颜色，修改源码样式.bar类名的

```bash
cnpm i --save axios
cnpm i --save nprogress
```

```js
  //配置代理跨域
  devServer: {
    proxy: {
      "/api": {
        // 只对请求路由以/api开头的请求进行代理转发
        target: `http://gmall-h5-api.atguigu.cn`, // 转发的目标url
        changeOrigin: true   // 支持跨域
      }
    }
  }
})
```

```js
//获取商品分类的数据
export const reqBaseCategoryList = () => {
   //箭头函数可以在程序任意地方使用,箭头函数返回即为服务器的数据
   //下面箭头函数返回值：返回的是什么? promise,即为返回服务器的数据
   //return关键字，千万别忘记书写，如果忘记书写，你在任意地方获取的都是undeinfed
   return requests({method: 'get', url: '/product/getBaseCategoryList'});
}
```



```js
  async mounted() {
    const result = await reqBaseCategoryList();
    console.log("result", result);
  }
```



## 使用vuex管理状态

vuex:Vue官方提供的一个插件，插件可以管理项目共用数据。
vuex：书写任何项目都需要vuex？
项目大的时候，需要有一个地方‘统一管理数据’即为仓库store

当项目比较大，组件通信数据比较复杂，这种情况在使用vuex

Vuex是插件，通过vuex仓库进行存储项目的数据

Vuex基本使用:

```bash
cnpm i --save vuex@3
```

vuex模块式开发【modules】

由于项目体积比较大，你向服务器发请求的接口过多，服务器返回的数据也会很多，如果还用以前的方式存储数据，导致vuex中的state数据格式比较复杂。采用vuex模块式管理数据。

Vuex核心概念:state、actions、mutations、getters、modules



## 商品分类三级联动展示动态数据

以前基础课程的时候，发请求操作如下：在组件的mounted中书写axios.get||post,获取到数据存储到组件的data当中进行使用

你们写项目的时候发请求在哪里发呀？
mounted|created:都可以

mounted：模板已经变为真是DOM【只不过没有数据，显示空白】，因为ajax是异步，需要时间的。
created：稍微好那么一丢丢（不算啥）



## 优化项目

v-if|v-show
按需加载
函数防抖与节流
按需加载:对于loadsh插件，它里面封装的函数功能很多
import _ from lodash 相当于把全部功能引入进来，但是我们只是需要节流。

```bash
cnpm i --save lodash
```



```js
  //底下的这种写法:是将lodash全部API引入,将来项目打包的时候，体积会大一些
  // import _ from "lodash";
  //引入手段:按需引入
  import throttle from "lodash/throttle"
```





函数防抖与节流*******面试题

正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）

防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发

需要把防抖与节流的原理，通过JS实现【闭包 + 延迟器】



## 搜索模块中的三级联动与过渡动画


1.1在home模块当中，使用了一个功能三级联动功能---->[typeNav]
1.2在search模块当中，也使用三级联动的功能------->[typeNav]
1.3注意的事项
注意1：以后在开发项目的时候，如果发现某一个组件在项目当中多个地方出现频繁的使用
咱们经常把这类的组件注册为全局组件。
注册全局组件的好处是什么那：只需要注册一次，可以在程序任意地方使用

注意2:咱们经常把项目中共用的全局组件放置于components里面，以后需要注意，
项目当中全局组件（共用的组件）一般放置于components文件夹中

注意3：全局组件只需要注册一次，就可以在项目当中任意的地方使用，注册全局组件一般是在入口文件注册。



2)组件name属性的作用?

2.1开发者工具中可以看见组件的名字
2.2注册全局组件的时候，可以通过组件实例获取相应组件的名字



## 开发listContainer|Floor组件业务

接下来需要开发listContainer与floor组件
场景:开发项目，产品经理画出原型，前端与后端人员需要介入（开发项目），
leader（老大）刚开完会，前端与后端负责哪些模块，后端人员（....开发服务器），
前端人员【项目起步、开发静态页面、查分静态组件】，回首一看回台‘哥哥’，接口没有写好，
向这种情况，前端人员可以mock一些数据【前端程序员自己模拟的一些假的接口】，当中工作中项目上线，需要把mock
数据变为后台哥哥给的接口数据替换。

mock数据。

注意：因为后台老师没有给我们写好其他接口【老师们特意的：因为就是想练习mock数据】
但是项目中mock数据，你就把他当中真实接口数据用就行。

注意：mock（模拟数据）数据需要使用到mockjs模块，可以帮助我们模拟数据。
注意：mockjs【并非mock.js mock-js】
http://mockjs.com/  官方地址

```bash
cnpm i mockjs --save
```

第一步:安装依赖包mockjs

第二部：在src文件夹下创建一个文件夹，文件夹mock文件夹。

第三步:准备模拟的数据
把mock数据需要的图片放置于public文件夹中！
比如:listContainer中的轮播图的数据

```
[
   {id:1,imgUrl:'xxxxxxxxx'}, 
   {id:2,imgUrl:'xxxxxxxxx'}, 
   {id:3,imgUrl:'xxxxxxxxx'}, 
]
```

第四步：在mock文件夹中创建一个server.js文件
注意：在server.js文件当中对于banner.json||floor.json的数据没有暴露，但是可以在server模块中使用。
对于webpack当中一些模块：图片、json，不需要对外暴露，因为默认就是对外暴露。


第五步:通过mock模块模拟出数据

通过Mock.mock方法进行模拟数据

第六步:回到入口文件，引入serve.js
mock需要的数据|相关mock代码页书写完毕，关于mock当中serve.js需要执行一次，
如果不执行，和你没有书写一样的。



第七步:在API文件夹中创建mockRequest【axios实例：baseURL:'/mock'】
专门获取模拟数据用的axios实例。

在开发项目的时候：切记，单元测试，某一个功能完毕，一定要测试是否OK



## mockjs模块实现模拟数据

---对于将来实际工作的时候，后台没有准备好接口（服务器没有开发出来），前端工程师可以利用mock技术，
实现模拟数据，将来项目上线（后台真实接口）写好了，替换为真实接口即可。
---对于咱们而言，后台老师确实没有给首页中轮播这部分的接口，mock数据，你可以当中一个真实接口就行了。
上线的时候，对于mock数据对于项目而言没有任何影响。

对于项目而言:真实的接口 /api/xxxx    模拟的数据/mock/xxxx
模拟数据JSON：没有空格，最好使用格式化插件进行格式化。





## swiper基本的使用

8.1:swiper可以在移动端使用？还是PC端使用？
答：swiper移动端可以使用，pc端也可以使用。

8.2:swiper常用于哪些场景？
常用的场景即为轮播图----【carousel:轮播图】
swiper最新版本为7版本的，项目当中使用的是5版本

提醒:当年学习过移动端视口、rem、高清图等等。
swiper插件：可以在移动端、PC端都可以使用，这个插件经常可以快速开发轮播图。
前端开发:轮播图、分页器、日历。

Swiper使用步骤：
第一步：引入依赖包【swiper.js|swiper.css】
第二步:静态页面中结构必须完整【container、wrap、slider】，类名不能瞎写
第三步:初始化swiper实例



https://www.swiper.com.cn/ 官网地址

```bash
cnpm i swiper@5 --save
```



swiper在Vue项目中使用 （开发ListContainer组件【首页banner图片】）
提示：卸载插件，你可以不用删除node_modules文件夹，可以使用npm uninstall xxxx进行卸载
1.1swiper安装到项目当中

1.2在相应的组件引入swiper.js|swiper.css 

但是需要注意，home模块很多组件都使用到swiper.css,没必要在每一个组件内部都引入样式一次，
只需要在入口文件引入一次即可。

1.3:初始化swiper实例在哪里书写?
初始化swiper实例之前，页面中的节点（结构）务必要有，
对于Vue一个组件而言，mounted[组件挂载完毕：相应的结构不就有了吗]
mounted-->组件挂载完毕

1.4动态效果为什么没有出来？
Swiper需要获取到轮播图的节点DOM，才能给swiper轮播添加动态效果，
因为没有获取到节点。

1.5第一种解决方案，延迟器（不是完美的解决方案）
同学的想法：都不是完美的【错误的想法】
created里面：created执行与mounted执行，时间差可能2ms，白扯
updated里面：如果组件有很多响应式（data），只要有一个属性值发生变化updated还会再次执行，再次初始化实例。

总结：第一种解决方案可以通过延迟器（异步）去解决问题，
但是这种解决方案存在风险（无法确定用户请求到底需要多长时间），因此没办法确定
延迟器时间。




2:Swiper在Vue项目中使用完美解决方案
第一种解决方案问题出现在哪里：v-for,在遍历来自于Vuex（数据:通过ajax向服务器发请求，存在异步）

watch:监听属性，watch可以检测到属性值的变化，当属性值发生变化的时候，可以出发一次。

Vuex当中的仓库数据bannerList（组件在使用）：
bannerList仓库数据有没有发生过变化？
一定是有的：bannerList初始值空数组，当服务器的数据返回以后，它的bannerList存储的属性值会发生变化【变为服务器返回的数据】
组件实例在使用仓库中的bannerList，组件的这个属性bannerList一定是发生过变化，watch可以监听到。


组件实例的一个方法:$nextTick
this.$nextTick(()=>{

})
nextTick官网解释:
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM。
注意：组件实例的$nextTick方法，在工作当中经常使用，经常结合第三方插件使用，获取更新后的DOM节点

总结:
1:Swiper插件工作的是很常用（今晚把API、基本使用方法）看看
2:组件实例的$nextTick方法。
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM



## 开发Floor组件

开发Floor组件：Floor组件它被复用的（重复使用两次）

3.1:Floor组件获取mock数据，发请求的action书写在哪里?
派发action应该是在父组件的组件挂载完毕生命周期函数中书写，因为父组件需要通知Vuex发请求，父组件
获取到mock数据，通过v-for遍历 生成多个floor组件，因此达到复用作用。

3.2:父组件派发action，通知Vuex发请求，Home父组件获取仓库的数据，通过v-for遍历出多个Floor组件

3.3v-for|v-show|v-if|这些指令可以在自定义标签（组件）的身上使用



3.4组件间通信******面试必问的东西
props:父子
插槽:父子
自定义事件:子父
全局事件总线$bus:万能
pubsub:万能
Vuex:万能
$ref:父子通信
3.5为什么在Floor组件的mounted中初始化SWiper实例轮播图可以使用.
因为父组件的mounted发请求获取Floor组件，当父组件的mounted执行的时候。
Floor组件结构可能没有完整，但是服务器的数据回来以后Floor组件结构就一定是完成的了
，因此v-for在遍历来自于服务器的数据，如果服务器的数据有了，Floor结构一定的完整的。
否则，你都看不见Floor组件



## 完成search静态组件

项目节点:学习的并不是基础的语法，'套路'
再次提醒：组件通信很重要-----【七种组件通信：务必要会】
接下来开发search搜索模块：注意在老师给你们的文件夹中有search静态组件，复制过来即可。
2.1书写静态页面【布局、样式】
2.2拆分组件
2.3获取服务器数据展示数据
2.4玩业务

//是搜索模块需要携带给接口的参数
{
  "category1Id": "61",//一级分类的id
  "category2Id": "61",//二级分类的id
  "category3Id": "61",//三级分类的id
  "categoryName": "手机",//产品的名字
  "keyword": "小米",//关键字
  "order": "1:desc",//排序
  "pageNo": 1,//当前第几页
  "pageSize": 10,//每一页需要展示多少条数据
  "props": ["1:1700-2799:价格", "2:6.65-6.74英寸:屏幕尺寸"],//平台属性的选择参数
  "trademark": "4:小米"//品牌参数
}

注意：搜索的接口，需要传递参数，至少是一个空对象（KV没有，但是至少给服务器一个对象）
3)获取search模块数据
4)展示商品列表数据



根据用户的搜索条件展示不同的数据。

根据前台传递参数决定的
根据不同条件，展示不同的数据。----->取决于后台返回的数据


1:发请求，获取搜索模块的数据
2:根据用户搜索的条件携带参数给服务器，展示用户搜索的内筒



开发遇见问题:用户条件可以发生多次变化，但是咱们的请求，只是会发一次【mounted中书写的】

请求的性能优化:
发一个请求，需要向服务器携带参数：带100个参数   带1参数  【消耗宽带】
对于给服务器携带的参数：如果数值为undefind，向服务器发请求的时候，参数步携带给服务器的



## 面包屑的业务完成



## 分页功能

第三方插件:elementUI实现超级简单
但是需要自己封装。也属于前台项目当中比较重要的一部分。





安装element-ui

```bash
cnpm i element-ui -S
```



## 开发详情业务

熟悉静态页面、书写样式
拆分组件
获取服务器动态展示
完成动态业务



滚动行为的设置。

注意
在工作中假报错现象很常见，因为什么导致的，尽可能解决掉-----【不解决掉对于你的程序没有任何影响】



## 放大镜的功能

----插件:插件解决可以【巧劲】

5.1遮罩层为什么能动。
获取节点（DOM：必须要定位），通过JS动态修改left|top、定位元素才有left、top属性





6)产品个数业务
以后项目当中：凡是出现文本框【用户输入：一定有'幺蛾子',思考情况一定要多思考】
