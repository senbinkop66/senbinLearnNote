

## 初始化

### 安装vue cli

如果没有安装 Vue CLI 就先安装

```bash
npm install -g @vue/cli
```

### 创建一个项目

windows下使用bash不能交互式选择，用cmd就行

```bash
>vue create app


Vue CLI v5.0.6
? Please pick a preset: Default ([Vue 2] babel, eslint)
? Pick the package manager to use when installing dependencies: NPM


Vue CLI v5.0.6
✨  Creating project in E:\pogject\vueProject\shangpinghui\app.
🗃  Initializing git repository...
⚙️  Installing CLI plugins. This might take a while...


added 848 packages in 41s
🚀  Invoking generators...
📦  Installing additional dependencies...


added 83 packages in 6s
⚓  Running completion hooks...

📄  Generating README.md...

🎉  Successfully created project app.
👉  Get started with the following commands:

 $ cd app
 $ npm run serve


  App running at:
  - Local:   http://localhost:8080/
  - Network: http://172.16.0.219:8080/
```



### 目录文件描述

```bash
$ ls
README.md        jsconfig.json  package-lock.json  public/  vue.config.js
babel.config.js  node_modules/  package.json       src/
```

脚手架目录:public + assets文件夹区别

1. node_modules:放置项目依赖的地方

2. public:一般放置一些共用的静态资源，打包上线的时候，public文件夹里面资源原封不动打包到dist文件夹里面

3. src：程序员源代码文件夹

   -  -----assets文件夹：经常放置一些静态资源（图片），assets文件夹里面资源webpack会进行打包为一个模块（js文件夹里面）

   -  -----components文件夹:一般放置非路由组件（或者项目共用的组件）

4. ​    App.vue 唯一的根组件

5. ​    main.js 入口文件【程序最先执行的文件】

6. ​    babel.config.js:babel配置文件

7. ​    package.json：看到项目描述、项目依赖、项目运行指令

8. ​    README.md:项目说明文件

```bash
1111@DESKTOP-RE2QT69 MINGW64 /e/pogject/vueProject/shangpinghui/app/src (master)
$ ls
App.vue  assets/      main.js  pages/   store/
api/     components/  mock/    router/  utils/

```





### 配置项目package.json

浏览器自动打开

​    在package.json文件中

```json
  "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  }
```

关闭eslint校验工具

创建vue.config.js文件：需要对外暴露

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  lintOnSave:false
})
```

 src文件夹的别名的设置

因为项目大的时候src（源代码文件夹）：里面目录会很多，找文件不方便，设置src文件夹的别名的好处，找文件会方便一些

创建jsconfig.json文件

```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "baseUrl": "./",
    "moduleResolution": "node",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "exclude":[
      "node_modules",
      "dist"
    ],
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  }
}
```



### 配置git

```bash
echo "# vue-app-sph" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:senbinkop66/vue-app-sph.git
git push -u origin main
```



### 安装less less-loader@5

```bash
cnpm i --save less less-loader@5
```

切记less-loader安装5版本的，不要安装在最新版本，安装最新版本less-loader会报错，报的错误setOption函数未定义

需要在style标签的身上加上lang="less",不添加样式不生效

```vue
<style scoped lang="less">
</style>
```



### axios二次封装

Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。

```
从浏览器中创建 XMLHttpRequests
从 node.js 创建 http 请求
支持 Promise API
拦截请求和响应
转换请求数据和响应数据
取消请求
自动转换 JSON 数据
客户端支持防御 XSRF
```

AJAX:客户端可以'敲敲的'向服务器端发请求，在页面没有刷新的情况下，实现页面的局部更新。
XMLHttpRequest、$、fetch、axios

跨域:如果多次请求协议、域名、端口号有不同的地方，称之为跨域
JSONP、CROS、代理

工作的时候src目录下的API文件夹，一般关于axios二次封装的文件

进度条：nprogress模块实现进度条功能

工作的时候，修改进度条的颜色，修改源码样式.bar类名的

```bash
cnpm i --save axios
cnpm i --save nprogress
```

```js
  //配置代理跨域
  devServer: {
    proxy: {
      "/api": {
        // 只对请求路由以/api开头的请求进行代理转发
        target: `http://gmall-h5-api.atguigu.cn`, // 转发的目标url
        changeOrigin: true   // 支持跨域
      }
    }
  }
})
```

```js
//获取商品分类的数据
export const reqBaseCategoryList = () => {
   //箭头函数可以在程序任意地方使用,箭头函数返回即为服务器的数据
   //下面箭头函数返回值：返回的是什么? promise,即为返回服务器的数据
   //return关键字，千万别忘记书写，如果忘记书写，你在任意地方获取的都是undeinfed
   return requests({method: 'get', url: '/product/getBaseCategoryList'});
}
```



```js
  async mounted() {
    const result = await reqBaseCategoryList();
    console.log("result", result);
  }
```







#### 请求拦截器

请求的时候有请求拦截器

```js
//请求拦截器:将来项目中【N个请求】，只要发请求,会触发请求拦截器!!!
requests.interceptors.request.use(config => {
  //请求拦截器:请求头【header】,请求头能否给服务器携带参数
  //请求拦截器：其实项目中还有一个重要的作用,给服务器携带请求们的公共的参数
  //进度条开始
  NProgress.start();

  if (store.state.shopcart.USER_ID) {
    //游客身份
    config.headers.userTempId = store.state.shopcart.USER_ID;
  }
  //token[公共参数]
  if (store.state.user.token) {
    config.headers.token = store.state.user.token;
  }

  //每一次发请求,请求头携带用户临时身份
  // config.headers.userTempId = SET_USERID();
  //不管那个模块发请求,请求拦截器，都可以触发。请求拦截器可以通过请求头每一次协大公共参数给服务器【用户未登录的临时身份】

  // 必须返回配置对象
  return config;
});
```



#### 响应拦截器

响应拦截器：请求数据返回会执行

```js
//响应拦截器：请求数据返回会执行
requests.interceptors.response.use((response) => {
  //res:实质就是项目中发请求、服务器返回的数据
  //进度条结束,  隐藏进度条
  NProgress.done();
  return response.data;
}, (err) => {
  NProgress.done();
  //温馨提示:某一天发请求,请求失败,请求失败的信息打印出来
  console.log(err.message);
  //终止Promise链
  return Promise.reject();
});
```



### 打包项目

```
npm run build
```



-----

## 使用vuex管理状态

vuex:Vue官方提供的一个插件，插件可以管理项目共用数据。
vuex：书写任何项目都需要vuex？
项目大的时候，需要有一个地方‘统一管理数据’即为仓库store

当项目比较大，组件通信数据比较复杂，这种情况在使用vuex

Vuex是插件，通过vuex仓库进行存储项目的数据

Vuex基本使用:

```bash
cnpm i --save vuex@3
```

vuex模块式开发【modules】

由于项目体积比较大，你向服务器发请求的接口过多，服务器返回的数据也会很多，如果还用以前的方式存储数据，导致vuex中的state数据格式比较复杂。采用vuex模块式管理数据。

Vuex核心概念:state、actions、mutations、getters、modules

```js
//home模块专享的小仓库
//任何的小仓库:state、mutations、actions、getters 
//引入请求函数
import { reqBaseCategoryList, reqBannerList, reqFloorList } from "@/api";

//仓库存储数据的地方
let state = {
  //商品分类的数据,仓库里面数据起始数值不要瞎写【服务器返回的是啥】
  category: [],  //所有分类的数组
  bannerList:[],  //广告位轮播数据的数组
  floorList: [],  //所有楼层数据的数组
}

//唯一可以修改仓库数据地方【工人】
let mutations = {
  GETCATEGORY(state, category) {
    state.category = category;
  },
  GETBANNERLIST(state, bannerList) {
    state.bannerList = bannerList;
  },
  GETFLOORLIST(state, floorList) {
    state.floorList = floorList;
  }
}

// 可以处理业务逻辑【if、异步语句等等】
let actions = {
  //商品分类的actions
  //actions地盘:可不可以书写异步语句
  async getCategory({ commit, state, dispatch }) {
    //获取服务器的数据,存储在vuex仓库中
    //reqCategory函数执行,返回的是Promise对象【pending、成功、失败】
    //await 等待成功的结果
    let result = await reqBaseCategoryList();
    //判断服务器返回的状态是200->成功
    if (result.code === 200) {
      //提交mutation存储服务器数据
      commit("GETCATEGORY", result.data);
    }
  },
  //获取banner图的action
  async getBannerList({commit, state, dispatch}) {
    //获取首页数据
    let result = await reqBannerList();
    if (result.code === 200) {
      commit("GETBANNERLIST", result.data);
    }
  },
  //获取Floor组件的数据
  async getFloorList({commit, state, dispatch}) {
    //获取首页数据
    let result = await reqFloorList();
    if (result.code === 200) {
      commit("GETFLOORLIST", result.data);
    }
  },

}

//仓库计算属性
let getters = {};

//对外暴露小仓库
export default {
  state,
  mutations,
  actions,
  getters
}
```



### 





----

## 路由的配置

### vue-router

路由分为KV

node平台（并非语言）

对于后台而言:K即为URL地址  V即为相应的中间件

```js
http://localhost:8080/0607

app.get("/0607",(res,req)=>{

  res.send('123');

});

```

前端路由:

K即为URL（网络资源定位符）

V即为相应的路由组件



### 安装路由

```bash
cnpm i --save vue-router@3
```

--save:可以让你安装的依赖，在package.json文件当中进行记录

这里安装vue-router@4会编译时会报错

### 创建路由组件

路由一般放在views|pages文件夹

```bash
─pages
│  ├─AddCartSuccess
│  ├─Center
│  │  ├─images
│  │  ├─MyOrder
│  │  └─TeamOrder
│  ├─Detail
│  │  ├─ImageList
│  │  ├─images
│  │  └─Zoom
│  ├─Home
│  │  ├─Brand
│  │  │  └─images
│  │  ├─Floor
│  │  │  └─images
│  │  ├─Like
│  │  │  └─images
│  │  ├─ListContainer
│  │  │  └─images
│  │  ├─Rank
│  │  │  └─images
│  │  └─Recommend
│  │      └─images
│  ├─Login
│  │  └─images
│  ├─Pay
│  │  └─images
│  ├─PaySuccess
│  │  └─images
│  ├─Register
│  ├─Search
│  │  ├─images
│  │  └─SearchSelector
│  │      └─images
│  ├─ShopCart
│  │  └─images
│  └─Trade
│      └─images
```



### 路由配置

确定项目结构顺序:上中下 -----只有中间部分的V在发生变化，中间部分应该使用的是路由组件

2个非路由组件|四个路由组件

两个非路由组件：Header 、Footer

路由组件: Home、Search、Login（没有底部的Footer组件）、Register（没有底部的Footer组件）

```js
//引入相应的路由组件
import Home from "@/pages/Home";
import Search from "@/pages/Search";
import Login from "@/pages/Login";
import Register from "@/pages/Register";
import Detail from "@/pages/Detail";
import AddCartSuccess from "@/pages/AddCartSuccess";
import ShopCart from "@/pages/ShopCart";
import Trade from "@/pages/Trade";
import Pay from "@/pages/Pay";
import PaySuccess from "@/pages/PaySuccess";
import Center from "@/pages/Center";
//个人中心的二级路由组件
import MyOrder from '@/pages/Center/MyOrder';
import TeamOrder from '@/pages/Center/TeamOrder'

export default [
  {
    name: "home",
    path: "/home",
    component: Home,
    //路由元信息,新学习的一个配置项!!!!给当前路由添加一些额外数据
    //它的右侧是一个对象[可以有多个键值对]
    //路由配置项：书写的时候不要胡写、乱写、瞎写【在VC组件身上获取不到,没有任何意义】
    meta: { isHideFooter: false },
  },
  {
    path: "/login",
    component: Login,
    meta: { isHideFooter: true },
  },
  {
    path: "/register",
    component: Register,
    meta: { isHideFooter: true },
  },
  {
    //命名路由,给路由起一个名字
    name: "search",
    path: "/search/:keyword?",
    component: Search,
    meta: { isHideFooter: true },
    //新增配置项:props,给路由组件传递props参数
        //第一种布尔模式,相当于把params参数，作为props属性值传递给这个路由组件
        // props:true,

        //第二种:对象形式
        // props:{a:1,b:'kkk'}

        //第三种写法:函数写法.一般是把query参数与params参数当中props传递给路由组件!!!
        //route就是当前路由
        // props:(route)=>{
        //      //是将当前箭头函数返回结果，作为props传递给search路由组件!!!
        //      return {a:route.params.keyword,b:'可以传递参数'};
        // }
  },
  {
    path: "/detail/:skuId?",
    component: Detail,
    meta: { isHideFooter: false },
  },
  {
    path: "/addcartsuccess",
    component: AddCartSuccess,
    meta: { isHideFooter: false },
  },
  {
    path: "/shopcart",
    component: ShopCart,
    meta: { isHideFooter: false },
  },
  {
    path: "/trade",
    component: Trade,
    meta: { isHideFooter: false },
  },
  {
    path: "/pay",
    component: Pay,
    meta: { isHideFooter: false },
  },
  {
    path: "/paysuccess",
    component: PaySuccess,
    meta: { isHideFooter: false },
  },
  {
    path: "/center",
    component: Center,
    meta: { isHideFooter: false },
    //二级路由配置的地方
    children: [
      {
        path: "myorder",
        component: MyOrder,
      },
      {
        path: "teamorder",
        component: TeamOrder,
      },
      {
        path: "/center",
        redirect: "/center/myorder",
      },
    ],
  },
  //重定向到首页
  {
    path: "/",
    redirect: "/home"
  }
]
```



### 路由的跳转

#### 跳转路由的基本方式

  跳转路由的2种基本方式

​    声明式: `<router-link to="">` 声明式导航（router-link：务必要有to属性）

​    编程式: `this.$router.push()/replace()`

 编程式导航更好用：因为可以书写自己的业务逻辑



#### 路由传参

params参数：路由需要占位，程序就崩了，属于URL当中一部分

query参数：路由不需要占位，写法类似于ajax当中query参数

```vue
	<div>
		<h1>Search</h1>
		<h2>params---{{$route.params.keyword}}</h2>
		<h2>query---{{$route.query.keyword}}</h2>
	</div>
```



```js
// 第一种：字符串
 this.$router.push("/search/" + this.keyword + "?k=" + this.keyword.toUpperCase());
// 第二种：模板字符串
 this.$router.push(`/search/${this.keyword}?k=${this.keyword.toUpperCase()}`);
// 第三种：对象
this.$router.push({name: "search", params:{keyword: "abc" || undefined}, query:{keyword:this.keyword}});
```

路由的跳转与传参

第一种声明式导航:为什么使用router-link组件的时候，会出现卡顿那？
router-link是一个组件：相当于VueComponent类的实例对象，一瞬间
new VueComponent很多实例（1000+），很消耗内存，因此导致卡顿。



路由传递参数先关面试题
     1:路由传递参数（对象写法）path是否可以结合params参数一起使用?
     不可以：不能这样书写，程序会崩掉

不可以用path和params配置的组合, 只能用name和params配置的组合

query配置可以与path或name进行组合使用



​      2:如何指定params参数可传可不传? 

`path: '/search/:keyword?'`

 如果路由要求传递路由参数，但是你就不传参数，URL会出现问题
 如何指定params参数可以传递、或者不传递，在配置路由的时候，在占位后面加一个问号

```js
 {
    //命名路由,给路由起一个名字
    name: "search",
    path: "/search:keyword?",
    component: Search,
    meta: { show: true },
}    
```

 3:params参数可以传递也可以不传递，但是如果传递是空串，如何解决？

 使用undefined解决：params参数可以传递、不传递（空的字符串）

```js
this.$router.push({name: "search", params:{keyword: "abc" || undefined}, query:{keyword:this.keyword}});
```



  4:如果指定name与params配置, 但params中数据是一个"", 无法跳转，路径会出问题

解决1: 不指定params

解决2: 指定params参数值为undefined



 5: 路由组件能不能传递props数据?

 可以: 可以将query或且params参数映射/转换成props传递给路由组件对象

实现: props: (route)=>({keyword1:route.params.keyword, keyword2: route.query.keyword })

```js
 //新增配置项:props,给路由组件传递props参数
        //第一种布尔模式,相当于把params参数，作为props属性值传递给这个路由组件
        // props:true,

        //第二种:对象形式
        // props:{a:1,b:'kkk'}

        //第三种写法:函数写法.一般是把query参数与params参数当中props传递给路由组件!!!
        //route就是当前路由
        // props:(route)=>{
        //      //是将当前箭头函数返回结果，作为props传递给search路由组件!!!
        //      return {a:route.params.keyword,b:'可以传递参数'};
        // }

```



编程式导航路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误?

注意:编程式导航（push|replace）才会有这种情况的异常，声明式导航是没有这种问题，因为声明式导航内部已经解决这种问题。
这种异常，对于程序没有任何影响的。

为什么会出现这种现象:

vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise，当传递参数多次且重复，会抛出异常，因此出现上面现象,

解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误

```js
// catch()处理错误
this.$router.push(`/search/${this.keyword}`).catch(() => {})
// 指定成功的回调函数
this.$router.push(`/search/${this.keyword}`, () => {})
// 指定失败的回调函数
this.$router.push(`/search/${this.keyword}`, undefined, () => {})

```



第一种解决方案：是给push函数，传入相应的成功的回调与失败的回调

```js
// 验证Vue-Router引入Promise技术,最笨的方法,给push传递第二个、第三个参数【回调函数】
// 下面这种写法：治标不治本！！！！
let reuslt = this.$router.push({name: "search", params:{keyword: "abc" || undefined}, query:{keyword:this.keyword}}, (data)=>{console.log(data)}, (err)=>{console.error(err)});
console.log(reuslt);
```

第一种解决方案可以暂时解决当前问题，但是以后再用push|replace还是会出现类似现象，因此我们需要从‘根’治病；

```js
//问题1:push方法,里面this是谁? vueRouter类的实例
//this: 当前组件实例
this.$router.push({name:'search',params:{keyword:this.keyword}});

//问题2:push方法里面的this是谁?windows
let result = this.$router.push;
result({name:'search',params:{keyword:this.keyword}})
```



解决2: 修正Vue原型上的push和replace方法 (优秀)

```js
// 缓存原型上的push函数
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace

// 给原型对象上的push指定新函数函数
VueRouter.prototype.push = function (location, onComplete, onAbort) {
  // 判断如果没有指定回调函数, 通过call调用源函数并使用catch来处理错误
  if (onComplete===undefined && onAbort===undefined) {
    return originPush.call(this, location, onComplete, onAbort).catch(() => {})
  } else { // 如果有指定任意回调函数, 通过call调用源push函数处理
    originPush.call(this, location, onComplete, onAbort)
  }
}

VueRouter.prototype.replace = function (location, onComplete, onAbort) {
  if (onComplete === undefined && onAbort === undefined) {
    return originReplace.call(this, location, onComplete, onAbort).catch(() => {})
  } else {
    originReplace.call(this, location, onComplete, onAbort)
  }
}

```









----

## 创建非路由组件

（2个：Header、Footer）

```
├─components
│  ├─Footer
│  │  └─images
│  ├─Header
│  │  └─images
│  ├─Pagination
│  └─TypeNav
```

### 全局注册

```js
import Vue from 'vue'
import App from './App.vue'

//引入路由，注册路由功能
import router from './router';
//注册仓库功能
import store from './store';

//引入mockServe文件,让咱们模拟接口跑起来
import "@/mock/mockServe.js"


Vue.config.productionTip = false

//注册两个全局组件:Header、Footer,全局组件写法【定义一次,可以直接在任意地方使用】
//Vue.component(组件的名字,组件)
//组件:实质是VueComponent构造函数,为什么下面Header组件打印并非是VueComponent构造函数,因为Header组件暴露的
//配置项(JS),并非暴露Vue.extend()[返回VueComponent构造函数],用的是简写方式
import Header from "@/components/Header";
import Footer from "@/components/Footer";
import TypeNav from "@/components/TypeNav";
import Pagination from "@/components/Pagination";



Vue.component(Header.name, Header);
Vue.component(Footer.name, Footer);
Vue.component(TypeNav.name, TypeNav);
Vue.component(Pagination.name, Pagination);

import 'element-ui/lib/theme-chalk/index.css';

//按需引入
import { Button, Row, Col, MessageBox, Message, Input} from 'element-ui';
//element-ui大多数组件，注册为全局组件Vue.component|Vue.use
Vue.use(Button);
Vue.use(Row);
Vue.use(Col);
Vue.use(Input)
//按需引入写法不同的:MessageBox、Message、Loading、Notification
Vue.prototype.$msgbox = MessageBox;
//想消息提示框
Vue.prototype.$alert = MessageBox.alert;
Vue.prototype.$message = Message;

//将项目全部请求函数引入进来[分别暴露]
import * as http from "@/api";

new Vue({
  //配置全局事件总线
  beforeCreate(){
    //配置全局事件总线
    Vue.prototype.$bus = this;
    //通过Vue.prototype原型对象,将全部请求函数挂载到原型对象身上[VC:就可以使用请求函数]
    Vue.prototype.$http = http;
  },
  //下面代码作用:给项目添加路由功能,给全部VC实例身上拥有两个属性,$router|$route
  router,
  //下面的代码作用:给项目添加仓库功能,主要的作用是给全部VC拥有一个$store属性
  store,
  render: h => h(App),
}).$mount('#app');

```

### 非路由组件的结构的搭建

静态页面：

结构 + 样式 +图片资源

项目采用的less样式,浏览器不识别less语法，需要一些loader进行处理，把less语法转换为CSS语法

非路由组件使用分为几步:

第一步：定义

第二步：引入

第三步：注册

第四步:使用

```vue
<template>
  <div id="app">
    <Header />
    <!-- 路由组件出口的位置:不设置路由组件不知道在哪里显示 -->
    <router-view></router-view>
    <!-- 发现底部的Footer会随着路由的变化进行显示与隐藏 -->
    <Footer v-show="!$route.meta.isHideFooter"></Footer>

    <!-- 分页器务必知道四个条件:total pageSize pageNo pagerCount -->
  </div>
</template>

<script>


export default {
  name: 'App',
  data(){
    return {
      test: ""
    }
  },
  mounted() {
    //App的根组件挂载完毕,发一次请求即可
    this.$store.dispatch("getCategory");
    console.log("app挂载");
  }
}
</script>

<style scoped>

</style>

```



### 清除默认样式

```html
    <!-- 引入reset.css清除默认样式 -->
    <link rel="stylesheet" type="text/css" href="<%= BASE_URL %>reset.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_2758111_9hehey1sgko.css">
```



```
面试题：v-show与v-if区别?
v-show:通过样式display控制
v-if：通过元素上树与下树进行操作

面试题:开发项目的时候，优化手段有哪些?
1:v-show|v-if
2:按需加载
8)首页|搜索底部是有Footer组件，而登录注册是没有Footer组件
Footer组件显示|隐藏，选择v-show|v-if
路由元信息
```



-----







----

## 实现登录注册

一般项目都有登录注册功能【这个业务很重要】。当然有一些项目不需要注册，后台管理系统项目，一般不需要注册。



### 注册的业务

输入注册信息，验证通过后执行注册功能
手机号: 11 位手机号
验证码: 4-6
登录密码 | 确认密码: 首字母大写、包含英文、数字、特殊字符等等。

获取验证码

```js
//获取验证码接口
export const reqGetCode = (phone) => requests({url: `/user/passport/sendCode/${phone}`, method: "get"});
```

完成注册

获取到验证码后，点击注册，发送手机号、密码、验证码到服务器执行注册， 注册成功后跳转到登录页面

```js
// 注册用户的接口
export const reqRegister = (data) => requests({url: `/user/passport/register`, method: "post", data});
```

```js
//注册按钮的回调
async register() {
    // 解构出参数
    const { phone, code, password, password1 } = this;
    if (phone && code && password == password1) {
        //通知vuex发请求，进行用户的注册
        try {
            //注册成功
            await this.$store.dispatch("registerUser", { phone, code, password });
            //让用户跳转到登录页面进行登录
            this.$router.push("/login");
        } catch (error) {
            // 注册失败
            alert(error.message);
        }
    }
}
```





### 登录业务

点击登录按钮的时候，验证手机号和密码格式，然后把手机号、密码携带给服务器，服务器需要判断该用户是否注册过。

```js
//登录的接口:请求体携带参数 phone&&password
export const reqUserLogin = (data) => requests({url: "user/passport/login", method: "post", data});
```

token【令牌：字符串，服务器下发给用户的身份凭证】

**axios vue 加密**

因为安全的要求，所以我们要把前端所有的请求都得加密与服务端应用进行通讯，当然服务端的响应也是加密的，前端也需要对应得解密。

```

```

**为什么刷新页面，用户信息就消失?**
用户刷新页面，用户信息消失没了获取不到，因为token没有携带给服务器。

Vuex存储数据是否持持久化的?**并非持久化**

**需要本地存储持久化存储token**

获取到的token需要保存，在退出登录前都可用

```js
let result = await reqUserLogin(userInfo);
    //登录成功
    if (result.code === 200) {
      commit("SET_TOKEN", result.data.token);
      commit("SET_PHONE", userInfo.phone);
      //以后开发的时候:经常的登录的成功获取token【持久化存储】
      localStorage.setItem("TOKEN", result.data.token);  // 46a0064e2e21457b8013fd7e6cb9e2f6
      return "ok";
    } else {
      // 登录失败
      return Promise.reject(new Error(result.message));
    }
```

如果是用户注册并验证成功，进行登录，跳转到主页面，如果用户登录失败给一个提示即可。

请求一些信息都需要带上token

```js
  if (store.state.shopcart.USER_ID) {
    //游客身份
    config.headers.userTempId = store.state.shopcart.USER_ID;
  }
  //token[公共参数]
  if (store.state.user.token) {
    config.headers.token = store.state.user.token;
  }
```

```js
//获取用户登录成功以后用户信息的接口
export const reqUserInfo = () => requests({url: "/user/passport/auth/getUserInfo", method: "get"});
```



为什么去别的模块【非home模块】获取用户信息失败？

因为你去别的模块根本没有发请求获取用户信息，没办法展示用户信息了

怎么解决:
每一个组件都在mounted里面发起获取用户信息，进行展示（太麻烦）
残留的问题：用户在home模块刷新的时候，用户信息一直在展示（mounted执行的时候在向服务器发请求、获取用户信息展示）

home->search [用户信息刷新数据就没了，因为在search模块当中根本没有发请求获取用户信息]
search-detail [根本没有获取用户信息进行展示]

### 退出登录业务

发请求，需要通知服务器，把现在用户身份token【销毁】

```js
//退出登录业务
export const reqUserLogout = () => requests({url: "/user/passport/logout", method: "get"});
```

清除仓库数据+本地存储数据【都需要清理】

```js
CLEAR(state) {
    //清除仓库相关用户信息
    state.token = "";
    state.nickName = "";
    state.code = "";
    state.phone = "";
    localStorage.removeItem("TOKEN");  //本地存储令牌清空
  },
```



用户已经登录了，不应该在访问login？【通过什么条件能判断用户登录、未登录】
路由独享守卫：
针对某一个路由的守卫

组件内守卫：
也是负责某一个路由守卫

身份凭证?
以后登录：TOKEN身份为大

```js
//全局前置守卫
router.beforeEach(async (to, from, next) => {
  //to:去的那个路由的信息
  //from:从那个路由而来的信息
  //next:放行函数!!!!!! 
  //第一种：next(),放行函数，放行到它想去的路由！！！
  //第二种:next(path),守卫指定放行到那个路由去?

  //用户是否登录:取决于仓库里面是否有token！！！
  //每一次路由跳转之前需要用有用户信息在跳转,没有发请求获取用户信息在跳转！！！！
  //token
  let hasToken = store.state.user.token;
  // 用户信息
  let hasNickName = store.state.user.nickName;
  let hasPhone = store.state.user.phone;
  // 用户登录
  if (hasToken) {
    //用户登录了,不能去login
    if (to.path === "/login") {
      next("/home");
    } else {
        
      //用户登陆了,而且还有用户信息【去的并非是login】
      if (hasNickName || hasPhone) {
        next();
      } else {
        //用户登陆了,但是没有用户信息 
        try {
          //发请求获取用户信息以后在放行
          await store.dispatch("getUserInfo");
          next();
        } catch(error) {
          //用户没有信息，还携带token发请求获取用户信息【失败】
          //token【认证失效了】
          //token失效:本地清空数据、服务器的token通知服务器清除
          await store.dispatch("logout");
          //回到登录页，重新获取一个新的身份认证
          next("/login");
        }
      }
    }
  } else {
    //用户未登录||目前的判断都是放行.将来这里会'回手掏'增加一些判断
    //用户未登录:不能进入/trade、/pay、/paysuccess、/center、/center/myorder  /center/teamorder
    let toPath = to.path;
    const notAllowedPath = ["/trade", "/pay", "/paysuccess", "/center", "/center/myorder", "/center/teamorder"];
    // if (toPath.indexOf('trade') != -1 || toPath.indexOf('pay') != -1 || toPath.indexOf('center') != -1) {
    //   next("/login?redirect="+toPath);
    // }else {
    //   next();
    // }
    if (notAllowedPath.includes(toPath)) {
      next("/login?redirect="+toPath);
    } else {
      next();
    }
  }
});
```



-----











## 实现Home模块

### 拆分Home组件

静态页面（样式）

拆分静态组件

发请求获取服务器数据进行展示

开发动态业务

拆分组件：结构+样式+图片资源

一共要拆分为6个组件 + 三级联动组件

```vue
<template>
	<div>
		<!-- 首页路由组件 -->
    <!-- 商品分类子组件 -->
		<TypeNav></TypeNav>
		<ListContainer></ListContainer>
		<Recommned></Recommned>
		<Rank></Rank>
		<Like></Like>
		<!-- 
       Floor标签,通过v-for动态生成
       父子组件通信:props

       问题:VC[Home]身上的floorList这个属性的属性值有几种情况?

       仓库floorList:起始值 空数组
       仓库floorList:不是空数组,代表服务器数据回来了。v-for渲染子组件完毕。给组件的props,就是两个对象
    
    -->
		<Floor v-for="(floor, index) in floorList" :key="floor.id" :floor="floor"></Floor>
		<Brand></Brand>
	</div>
</template>

<script>
//局部组件:引入、注册、使用
//全局组件：只需要在入口文件定义一次,直接使用
import ListContainer from "./ListContainer";
import Recommned from "./Recommend";
import Rank from "./Rank";
import Like from "./Like";
import Floor from "./Floor";
import Brand from "./Brand";
import TypeNav from "@/components/TypeNav/index.vue";
import { mapState } from "vuex";
export default {
	name: "Home",
	components: {
    ListContainer,
    Recommned,
    Rank,
    Like,
    Floor,
    Brand,
    TypeNav,
	},
	//组件挂载完毕钩子
	mounted() {
		this.$store.dispatch("getFloorList");
	},
	computed: {
		...mapState({
			floorList: (state) => state.home.floorList,
		}),
	},
}
</script>

<style scoped lang="less">
	
</style>
```



### 商品分类三级联动展示动态数据

发请求操作如下：在组件的mounted中书写axios.get||post,获取到数据存储到组件的data当中进行使用

写项目的时候发请求在哪里发？
mounted|created:都可以

mounted：模板已经变为真是DOM【只不过没有数据，显示空白】，因为ajax是异步，需要时间的。

created：稍微好那么一丢丢（不算啥）

```vue
<template>
  <div class="type-nav">
    <div class="container">
      <!-- 事件的委派 -->
      <div @mouseleave="leaveHandler" @click="goSearch">
        <h2 class="all" @mouseenter="changeShow">全部商品分类</h2>
        <!-- 商品分类的地方 -->
        <transition name="sort">
          <div class="sort" v-show="show">
            <div class="all-sort-list2">
              <!-- 一级分类地盘 -->
              <div class="item" v-for="(c1, index) in category" :key="c1.categoryID">
                <h3 @mouseenter="enterHandler(index)" :class="{ active: currentIndex === index}">
                  <a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId">{{ c1.categoryName }}</a>
                </h3>
                <!-- 通过JS实现动态行内样式，进行二级、三级分类的显示与隐藏(display:none|block切换的) -->
                <div class="item-list clearfix" :style="{ display: currentIndex === index ? 'block' : 'none'}">
                  <!-- 二级分类 -->
                  <div class="subitem" v-for="(c2, index) in c1.categoryChild" :key="c2.categoryID">
                    <dl class="fore">
                      <dt>
                        <a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{ c2.categoryName }}</a>
                      </dt>
                      <dd>
                        <!-- 三级分类 -->
                        <em v-for="(c3, index) in c2.categoryChild">
                          <a :data-categoryName="c3.categoryName" :data-category3Id="c3.categoryId">{{ c3.categoryName }}</a>
                        </em>
                      </dd>
                    </dl>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </transition>
      </div>
      <nav class="nav">
        <a href="###">服装城</a>
        <a href="###">美妆馆</a>
        <a href="###">尚品汇超市</a>
        <a href="###">全球购</a>
        <a href="###">闪购</a>
        <a href="###">团购</a>
        <a href="###">有趣</a>
        <a href="###">秒杀</a>
      </nav>
    </div>
  </div>
</template>

<script>
  //利用辅助函数获取仓库state数据--->mapState
  //mapState辅助函数执行:数组、对象
  import { mapState } from 'vuex';

  //底下的这种写法:是将lodash全部API引入,将来项目打包的时候，体积会大一些
  // import _ from "lodash";
  //引入手段:按需引入
  import throttle from "lodash/throttle"

  export default {
    name: "TypeNav",
    data() {
      return {
        //利用响应式属性,将来存储用户鼠标进入哪一个一级分类的索引值
        currentIndex: -1,
        show: true,  // 默认显示
      };
    },
    methods: {
      //鼠标进入的方法
      enterHandler: throttle(function(index) {
        //修改响应式数据
        this.currentIndex = index;
        //鼠标进入事件,假如用户的行为过快,会导致项目业务丢失【里面业务有很多，可能出现卡顿现象】。
        //一句话：用户行为过快,浏览器反应不过来,导致业务丢失!!!!
        //函数的防抖与节流技术
        // console.log("处理业务" + index);
      }, 10),
      //鼠标移出事件
      leaveHandler() {
        //鼠标移出高亮的效果消失
        this.currentIndex = -1;
        //隐藏商品分类
        //鼠标离开:在search路由下,在修改数据
        if (this.$route.path !== "/home") {
          this.show = false;
        }
      },
      //全部商品分类鼠标进入
      changeShow() {
        //鼠标进入:在search路由下,在修改数据
        if (this.$route.path !== "/home") {
          this.show = true;
        }
      },
      //精益求精
      //将全部的子节点的事件委派给父节点->事件回调就一个
      goSearch(event) {
        //第一个问题:div父节点子元素太多【h3、h2、em、dt、dd、dl...a】？你怎么知道你点击的一定是a
        //第二个问题:要区分一级分类、二级分类、三级分类的a标签【category1Id|category2Id|category2Id】
        let targetNode = event.target;
        //获取触发事件节点的自定义属性【a:data-categoryName】
        let { categoryname, category1id, category2id, category3id } = targetNode.dataset;
        //判断点击的是a【不管是1|2|3】
        if (categoryname) {
          //点击只要是a,就是往search模块跳转
          let locations = {
            name: 'search',
            query: { categoryName: categoryname },
          };
          //一级分类的a
          if (category1id) {
            locations.query.category1Id = category1id;
          } else if (category2id) {
            locations.query.category2Id = category2id;
          } else if (category3id) {
            locations.query.category3Id = category3id;
          }
          //点击商品分类按钮的时候,如果路径当中携带params参数,需要合并携带给search模块
          if (this.$route.params.keyword) {
            locations.params = this.$route.params;
          }
          //目前商品分类这里携带参数只有query参数
          this.$router.push(locations);
        }
      },
    },

    //不管是Home|Search利用的都是全局组件TypeNav,TypeNav在Home路由与Search路由下状态不一样的。
    //VC身上有一个很值钱的东西$route,这玩意可以让你知道当前TypeNav处于那个路由下
    mounted() {
      //派发action
      //路由切换的时候,路由组件会被销毁重建【子组件不也是】
      if (this.$route.path !== "/home") {
        this.show = false;
      }
    },
    // 计算属性
    computed: {
      //数组的写法:目前书写的是大仓库state的K  ...mapState(['home'])
      ...mapState({
        //对象写法,对象的K,给VC新增的属性
        //新增的属性erha,右侧属性值为箭头函数返回的结果。作为新增属性的属性值
        //箭头函数执行，注入一个参数state->大仓库【包含小仓库】
        category: (state) => state.home.category,  //对象的简写形式
      }),
    },
  };
</script>
```

```js
//仓库存储数据的地方
let state = {
  //商品分类的数据,仓库里面数据起始数值不要瞎写【服务器返回的是啥】
  category: [],  //所有分类的数组
  bannerList:[],  //广告位轮播数据的数组
  floorList: [],  //所有楼层数据的数组
}
```



**优化**

按需加载

函数防抖与节流

按需加载:对于loadsh插件，它里面封装的函数功能很多

import _ from lodash 相当于把全部功能引入进来，但是我们只是需要节流。

```bash
cnpm i --save lodash
```



```js
  //底下的这种写法:是将lodash全部API引入,将来项目打包的时候，体积会大一些
  // import _ from "lodash";
  //引入手段:按需引入
  import throttle from "lodash/throttle"
```





函数防抖与节流 面试题

正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）

防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发

需要把防抖与节流的原理，通过JS实现【闭包 + 延迟器】



### Floor组件

开发Floor组件：Floor组件它被复用的（重复使用两次）

Floor组件获取mock数据，发请求的action书写在哪里?

派发action应该是在父组件的组件挂载完毕生命周期函数中书写，因为父组件需要通知Vuex发请求，父组件获取到mock数据，通过v-for遍历 生成多个floor组件，因此达到复用作用。

父组件派发action，通知Vuex发请求，Home父组件获取仓库的数据，通过v-for遍历出多个Floor组件

```vue
<!-- 
       Floor标签,通过v-for动态生成
       父子组件通信:props

       问题:VC[Home]身上的floorList这个属性的属性值有几种情况?

       仓库floorList:起始值 空数组
       仓库floorList:不是空数组,代表服务器数据回来了。v-for渲染子组件完毕。给组件的props,就是两个对象
    
    -->
		<Floor v-for="(floor, index) in floorList" :key="floor.id" :floor="floor"></Floor>
```



```js
	//组件挂载完毕钩子
	mounted() {
		this.$store.dispatch("getFloorList");
	},
	computed: {
		...mapState({
			floorList: (state) => state.home.floorList,
		}),
	},
```

v-for|v-show|v-if|这些指令可以在自定义标签（组件）的身上使用

```js
export default {
  name:"Floor",
  props: ["floor"],
    },
  watch: {
    //floor是父组件给与的props:它的props属性值从来没有变化过！！！！
    floor: {
      immediate: true,
      handler() {
        this.$nextTick(() => {
          //初始化Swiper类的实例
          var mySwiper = new Swiper(this.$refs.floor1Swiper, {
            direction: 'horizontal',  // 设置轮播图防线
            loop: true,  // 开启循环模式
            pagination: {
              // 如果需要分页器
              el: ".swiper-pagination",
              type: "bullets",  // 分页器类型
              clickable: true,  // 点击分页器，切换轮播
            },
            autoplay: { 
              //自动轮播
              delay: 2000,
              stopOnLastSlide: true,  // 如果设置为true，当切换到最后一个slide时停止自动切换
              disableOnInteraction: false,   //用户操作swiper之后，是否禁止autoplay
            },
            navigation: {
              // 如果需要前进后退按钮
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
            effect: "cube",  // 切换效果
          });
          //1:swiper插件,对外暴露一个Swiper构造函数
          //2:Swiper构造函数需要传递参数 1、结构总根节点CSS选择器|根节点真实DOM节点  2、轮播图配置项
          //鼠标进入停止轮播
          mySwiper.el.onmouseover = function() {
            mySwiper.autoplay.stop();
          };
          mySwiper.el.onmouseout = function() {
            mySwiper.autoplay.start();
          };
        });
      },
    },
  },
```



组件间通信 面试必问的东西
props:父子
插槽:父子
自定义事件:子父
全局事件总线$bus:万能
pubsub:万能
Vuex:万能
$ref:父子通信

为什么在Floor组件的mounted中初始化SWiper实例轮播图可以使用.

因为父组件的mounted发请求获取Floor组件，当父组件的mounted执行的时候。Floor组件结构可能没有完整，但是服务器的数据回来以后Floor组件结构就一定是完成的了，因此v-for在遍历来自于服务器的数据，如果服务器的数据有了，Floor结构一定的完整的。否则，你都看不见Floor组件



### mockjs模块实现模拟数据

---对于将来实际工作的时候，后台没有准备好接口（服务器没有开发出来），前端工程师可以利用mock技术，实现模拟数据，将来项目上线（后台真实接口）写好了，替换为真实接口即可。

---对于咱们而言，确实没有给首页中轮播这部分的接口，mock数据，你可以当中一个真实接口就行了。上线的时候，对于mock数据对于项目而言没有任何影响。

对于项目而言:真实的接口 /api/xxxx    模拟的数据/mock/xxxx

模拟数据JSON：没有空格，最好使用格式化插件进行格式化。



注意：mock（模拟数据）数据需要使用到mockjs模块，可以帮助我们模拟数据。
注意：mockjs【并非mock.js mock-js】
http://mockjs.com/  官方地址

```bash
cnpm i mockjs --save
```

第一步:安装依赖包mockjs

第二部：在src文件夹下创建一个文件夹，文件夹mock文件夹。

第三步:准备模拟的数据
把mock数据需要的图片放置于public文件夹中！ 比如:listContainer中的轮播图的数据

```js
[
   {id:1,imgUrl:'xxxxxxxxx'}, 
   {id:2,imgUrl:'xxxxxxxxx'}, 
   {id:3,imgUrl:'xxxxxxxxx'}, 
]
```

第四步：在mock文件夹中创建一个server.js文件

注意：在server.js文件当中对于banner.json||floor.json的数据没有暴露，但是可以在server模块中使用。
对于webpack当中一些模块：图片、json，不需要对外暴露，因为默认就是对外暴露。


第五步:  通过mock模块模拟出数据，通过Mock.mock方法进行模拟数据

第六步:回到入口文件，引入serve.js
mock需要的数据|相关mock代码页书写完毕，关于mock当中serve.js需要执行一次，如果不执行，和你没有书写一样的。

第七步:在API文件夹中创建mockRequest【axios实例：baseURL:'/mock'】 专门获取模拟数据用的axios实例。

在开发项目的时候：切记，单元测试，某一个功能完毕，一定要测试是否OK



### 轮播图swiper基本的使用

swiper可以在移动端使用？还是PC端使用？
答：swiper移动端可以使用，pc端也可以使用。

swiper常用于哪些场景？
常用的场景即为轮播图----【carousel:轮播图】
swiper最新版本为7版本的，项目当中使用的是5版本

提醒:当年学习过移动端视口、rem、高清图等等。
swiper插件：可以在移动端、PC端都可以使用，这个插件经常可以快速开发轮播图。
前端开发:轮播图、分页器、日历。

Swiper使用步骤：
第一步：引入依赖包【swiper.js|swiper.css】
第二步:静态页面中结构必须完整【container、wrap、slider】，类名不能瞎写
第三步:初始化swiper实例



https://www.swiper.com.cn/ 官网地址

```bash
cnpm i swiper@5 --save
```



swiper在Vue项目中使用 （开发ListContainer组件【首页banner图片】）
提示：卸载插件，你可以不用删除node_modules文件夹，可以使用npm uninstall xxxx进行卸载
1.1swiper安装到项目当中

1.2在相应的组件引入swiper.js|swiper.css 

但是需要注意，home模块很多组件都使用到swiper.css,没必要在每一个组件内部都引入样式一次，
只需要在入口文件引入一次即可。

1.3:初始化swiper实例在哪里书写?
初始化swiper实例之前，页面中的节点（结构）务必要有，
对于Vue一个组件而言，mounted[组件挂载完毕：相应的结构不就有了吗]
mounted-->组件挂载完毕

1.4动态效果为什么没有出来？
Swiper需要获取到轮播图的节点DOM，才能给swiper轮播添加动态效果，
因为没有获取到节点。

1.5第一种解决方案，延迟器（不是完美的解决方案）
同学的想法：都不是完美的【错误的想法】
created里面：created执行与mounted执行，时间差可能2ms，白扯
updated里面：如果组件有很多响应式（data），只要有一个属性值发生变化updated还会再次执行，再次初始化实例。

总结：第一种解决方案可以通过延迟器（异步）去解决问题，
但是这种解决方案存在风险（无法确定用户请求到底需要多长时间），因此没办法确定
延迟器时间。



2:Swiper在Vue项目中使用完美解决方案
第一种解决方案问题出现在哪里：v-for,在遍历来自于Vuex（数据:通过ajax向服务器发请求，存在异步）

watch:监听属性，watch可以检测到属性值的变化，当属性值发生变化的时候，可以出发一次。

Vuex当中的仓库数据bannerList（组件在使用）：
bannerList仓库数据有没有发生过变化？
一定是有的：bannerList初始值空数组，当服务器的数据返回以后，它的bannerList存储的属性值会发生变化【变为服务器返回的数据】
组件实例在使用仓库中的bannerList，组件的这个属性bannerList一定是发生过变化，watch可以监听到。


组件实例的一个方法:$nextTick
this.$nextTick(()=>{

})
nextTick官网解释:
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM。
注意：组件实例的$nextTick方法，在工作当中经常使用，经常结合第三方插件使用，获取更新后的DOM节点

总结:
1:Swiper插件工作的是很常用（今晚把API、基本使用方法）看看
2:组件实例的$nextTick方法。
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM

```vue
	<div class="swiper-container" ref="mySwiper">
          <!-- swiper-wrapper里面每一个slider即为一张图片 -->
          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(item, index) in bannerList" :key="item.id">
              <img :src="item.imgUrl"  />
            </div>
          </div>
          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
```

```vue
<script>
//辅助函数获取仓库的数据
import { mapState } from 'vuex';

//swiper使用步骤:
//第一步:引入依赖包、样式
import Swiper from "swiper";
import "swiper/css/swiper.min.css";

export default {
  name:"Brand",
  mounted() {
    //派发action,通知vuex发请求
    this.$store.dispatch("getBannerList");
  },
  computed: {
    ...mapState({
      bannerList: (state) => state.home.bannerList,
    })
  },
  watch:{
    bannerList() {
      //能在这里直接初始化Swiper类的实例吗?
      //不能在当前状态直接初始化Swiper类的实例,因为这里只能保证数据发生变化了[服务器数据回来了],
      //但是你不能保证v-for遍历的结构完事了.
      this.$nextTick(() => {
        // 初始化Swiper类的实例
        var mySwiper = new Swiper(this.$refs.mySwiper, {
          //设置轮播图防线
          direction: "horizontal",
          //开启循环模式
          loop: true,
          // 如果需要分页器
          pagination: {
            el: ".swiper-pagination",
            //分页器类型
            type: "bullets",
            //点击分页器，切换轮播
            clickable: true,
          },
          //自动轮播
          autoplay: {
            delay: 3000,
            //新版本的写法：目前是5版本
            // pauseOnMouseEnter: true,
            //如果设置为true，当切换到最后一个slide时停止自动切换
            stopOnLastSlide: true,
            //用户操作swiper之后，是否禁止autoplay
            disableOnInteraction: false,
          },
          // 如果需要前进后退按钮
          navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
          },
          //切换效果
          // effect: "cube",
        });
        //1:swiper插件,对外暴露一个Swiper构造函数
        //2:Swiper构造函数需要传递参数 1、结构总根节点CSS选择器|根节点真实DOM节点  2、轮播图配置项
        //鼠标进入停止轮播
        mySwiper.el.onmouseover = function () {
          mySwiper.autoplay.stop();
        };
        //鼠标离开开始轮播
        mySwiper.el.onmouseout = function () {
          mySwiper.autoplay.start();
        };
      });
    },
  },
}
</script>
```



-----

## 实现search模块



### search静态组件

搜索模块需要携带给接口的参数

```js
	data(){
			return {
				//Search模块搜索的条件
				searchParams: {
					keyword: "",  // 用户搜索的关键字
					category1Id: "",  // 一级分类的id
					category2Id: "",  // 二级分类的id
					category3Id: "",  // 三级分类的id
					categoryName: "",  // 商品的名字
					props: [],  // 商品属性的搜索条件
					trademark: "",  // 品牌的搜索条件
					order: "1:desc",  //排序的参数 【默认初始值:1:desc】
					pageNo: 1,  // 当前分页器的页码  【默认初始值:1】
					pageSize: 5, // 代表当前一页显示几条数据 【默认初始值:5】
				},
			}
		},
```

注意：搜索的接口，需要传递参数，至少是一个空对象（KV没有，但是至少给服务器一个对象）

### 获取search模块数据

```js
    //组件挂载完毕次钩子执行一次,发请求
    mounted(){
        //在发请求之前:整理用户搜索的参数
        //组件挂载完毕发一次请求
        //获取用户信息
        this.getData();
    },	
    //发请求,获取搜索模块的数据
    getData() {
        //通知Vuex发请求、仓库存储数据
        this.$store.dispatch("getSearchList", this.searchParams);
    },
```

```js
//搜索模块的请求接口函数:
//将来根据不同的搜索条件,需要给服务器携带不同的参数
//请求体携带搜索的参数
//搜索的条件:它应该是一个对象10K,可有可无，但是data至少是一个空对象
//没有发现:
//第一步:整理搜索的参数
//第二步：根据最新的搜索参数，获取最新的数据展示!!
export const reqSearchList = (data) => requests({url: "/list", method: "post", data});
```

```

```



### 展示商品列表数据



根据用户的搜索条件展示不同的数据。

根据前台传递参数决定的
根据不同条件，展示不同的数据。----->取决于后台返回的数据

1:发请求，获取搜索模块的数据
2:根据用户搜索的条件携带参数给服务器，展示用户搜索的内筒

```js
		//通过watch监听路由的变化
		watch: {
			//监听组件VC的$route属性
			//$route:{},应该用深度监听呀?
			//$route，是vue-router提供的
			$route() {
				//再次整理最新的商品名字参数
				//先把用户前面存储的1|2|3级别ID清除
				//发ajax的时候,属性值为undefind,甚至参数K都不携带了【10个搜索条件,可有可无的】
				this.searchParams.category1Id = undefined;
				this.searchParams.category2Id = undefined;
				this.searchParams.category3Id = undefined;
				//路由变化整理参数：手机最新的商品名字、商品1|2|3ID
				Object.assign(this.searchParams, this.$route.query, this.$route.params);
				console.log("getData");
				this.getData();
			},
		},
```



```vue
<!-- 商品展示区域 -->
    <div class="goods-list">
        <ul class="yui3-g">
            <li class="yui3-u-1-5" v-for="(good, index) in goodsList" :key="good.id">
                <div class="list-wrap">
                    <div class="p-img">
                        <!-- 商品展示区域 -->
                        <router-link :to=" `/detail/${good.id}` ">
                            <img :src="good.defaultImg" />
                        </router-link>
                    </div>
                    <div class="price">
                        <strong>
                            <em>￥</em>
                            <i>{{ good.price }}.00</i>
                        </strong>
                    </div>
                    <div class="attr">
                        <a :title="good.title">{{ good.title }}</a>
                    </div>
                    <div class="commit">
                        <i class="command">已有<span>{{ good.id }}人评价</span></i>
                    </div>
                    <div class="operate">
                        <a href="javascript:void(0);" class="sui-btn btn-bordered btn-danger">
                            加入购物车
                        </a>
                        <a href="javascript:void(0);" class="sui-btn btn-bordered">
                            收藏
                        </a>
                    </div>
                </div>
            </li>
        </ul>
    </div>
    <!-- 分页的地方 -->
    <div class="fr page">
        <Pagination 
            :total="total" 
            :pageSize="searchParams.pageSize" 
            :pageNo="searchParams.pageNo" 
            :pagerCount="5" 
            @currentPage="currentPage">
        </Pagination>
    </div>
</div>
```



开发遇见问题:用户条件可以发生多次变化，但是咱们的请求，只是会发一次【mounted中书写的】

请求的性能优化:
发一个请求，需要向服务器携带参数：带100个参数   带1参数  【消耗宽带】
对于给服务器携带的参数：如果数值为undefind，向服务器发请求的时候，参数步携带给服务器的



### 分页功能

第三方插件:elementUI实现超级简单
但是需要自己封装。也属于前台项目当中比较重要的一部分。

安装element-ui

```bash
cnpm i element-ui -S
```

```js
			currentPage(pageNo) {
				//父组件整理参数
				this.searchParams.pageNo = pageNo;
				this.getData();
			},
```



### 面包屑业务

```vue
<!-- 面包屑 -->
<div class="bread">
    <ul class="fl sui-breadcrumb">
        <li>
            <a href="#">全部结果</a>
        </li>
    </ul>
    <ul class="fl sui-tag">
        <!-- 商品的名字的面包屑的地方 -->
        <li class="with-x" v-show="searchParams.categoryName">
            {{ searchParams.categoryName }}
            <i @click="removeCategoryName">x</i>
        </li>
        <!-- 关键字面包屑的地方 -->
        <li class="with-x" v-show="searchParams.keyword">
            {{ searchParams.keyword }}
            <i @click="removeKeyword">x</i>
        </li>
        <!-- 品牌的面包屑 -->
        <li class="with-x" v-show="searchParams.trademark">
            {{ searchParams.trademark }}
            <i @click="removeTradeMark">x</i>
        </li>
        <!-- 商品属性值面包屑的地方 -->
        <li class="with-x" v-for="(attrValue, index) in searchParams.props" :key="index">
            {{ attrValue.split(":")[1] }}
            <i @click="removeAttr(index)">x</i>
        </li>
    </ul>
</div>
```

```js
		//清除面包屑-商品名字
			removeCategoryName() {
				//搜索条件商品名字清空
				this.searchParams.categoryName = "";
				// 路由自己跳自己
				// 为什么这里没有调用发请求函数？
				this.$router.push({ name: "search", params: this.$route.params});
			},
			//面包屑移出关键字的回调
			removeKeyword() {
				// 清空关键字
				this.searchParams.keyword = "";
				//修改URL
				this.$router.push({ name: "search", query: this.$route.query});
				//通知兄弟组件清除关键字
				this.$bus.$emit("clearKeyword");
			},
			//子组件给父组件传递数据的自定义事件的回调
			getTradeMark(tmId, tmName) {
				// console.log("父组件", tmId, tmName);
				//整理品牌相关的搜索条件
				this.searchParams.trademark = `${tmId}:${tmName}`;
				//再次发请求获取最新的数据展示
				this.getData();
			},
			//面包屑清除品牌回调
			removeTradeMark() {
				//清空品牌的搜索条件
				this.searchParams.trademark = "";
				//再次发请求获取最新的数据展示
				this.getData();
			},
```



### 放大镜的功能

----插件:插件解决可以【巧劲】

遮罩层为什么能动。
获取节点（DOM：必须要定位），通过JS动态修改left|top、定位元素才有left、top属性

```vue
<template>
	<div class="spec-preview">
		<img :src="bigObj.imgUrl" />
		<!-- 绑定鼠标移动事件 -->
		<div class="event" @mousemove="handler"></div>
		<div class="big">
			<img :src="bigObj.imgUrl" ref="big" />
		</div>
		<div class="mask" ref="mask"></div>
	</div>
</template>

<script>
	import { mapGetters } from 'vuex';

	export default {
		name: "Zoom",
		data() {
			return {
				index: 0
			}
		},
		computed: {
			...mapGetters(["skuInfo"]),
			// 服务器的数据没有回来,skuInfo空对象,如果空对象.skuImageList->undefined
			skuImageList() {
				return this.skuInfo.skuImageList || [];
			},
			bigObj() {
				return this.skuImageList[this.index] || {};
			},
		},
		mounted() {
			//接受兄弟组件传递过来的索引值
			this.$bus.$on("sendIndex", (index) => {
				this.index = index;
			})
		},
		methods: {
			handler(e) {
				//获取蒙板
				let mask = this.$refs.mask;
				let big = this.$refs.big;
				//计算蒙板的left|top数值
				let l = e.offsetX - mask.offsetWidth / 2;
				let t = e.offsetY - mask.offsetHeight / 2;
				//约束蒙板的上下左右范围
				if (l < 0) {
					l = 0;
				}
				if (l > mask.offsetWidth) {
					l = mask.offsetWidth;
				}
				if (t < 0) {
					t = 0;
				}
				if (t > mask.offsetHeight) {
					t = mask.offsetHeight;
				}
				mask.style.left = l + "px";
				mask.style.top = t + "px";
				big.style.left = -2 * l + "px";
				big.style.top = -2 * t + "px";
			},
		},
	}
</script>
```





-----

## 购物车业务

购物车项目第二个重要地方

购物车：每一个人都有属于自己的购物车，那为什么不同用户登录自己账号，可以看见属于自己产品一定是用户点击加入购物车，把你的产品信息提交给服务器进行保存，当你下次在进入购物车的时候，需要向服务器发请求，获取你购物车里面的信息展示

项目：点击加入购物车按钮的时候，以前经常进行路由跳转【调到另外一个路由】，但是你要注意，点击加入购物车这个按钮的时候，将用户选择产品，提交给服务器进行存储，如果服务器存储成功，之后在进行路由跳转



```bash
cnpm install uuid --save
```

```js
//游客身份--生成一个随机用户字符串ID
import { SET_USERID } from "@/utils/USER_ID";

//仓库存储数据的地方
let state = {
  // vuex仓库存储用户临时身份,vuex存储数据确实非持久化的，SET_USERID执行返回结果,可是本地存储获取的！！
  USER_ID: SET_USERID(),
  shopCartInfo: [],
}
```

```js
//利用uuid生成未登录用户临时标识符
import { v4 as uuidv4 } from "uuid";

//封装函数:只能生成一次用户临时身份
let userId;
export const SET_USERID = () => {
  userId = localStorage.getItem("USERTEMPID");
  if (!userId) {
    userId = uuidv4();
    // console.log(userId);
    localStorage.setItem("USERTEMPID", userId);
  }
  return userId;
}
```



### 加入购物车

```js
//加入购物车按钮
async addOrUpdateCart() {
    //派发action:携带的载荷，分别商品的id、商品个数
    //思考底下的这行代码实质做了一个什么事情?
    //实质就是调用了小仓库里面相应的这个函数->addOrUpdateCart,声明部分加上asyc,这个函数执行的结构一定是Promise
    //返回结果是一个Promise对象【三种状态:pending、成功、失败】，返回状态到底是什么，取决于这个函数addOrUpdateCart返回结果
    try {
        await this.$store.dispatch("addOrUpdateCart", {
            skuId: this.$route.params.skuId,
            skuNum: this.skuNum,
        });
        //路由跳转:携带参数,携带参数一般都是基本类型数据【字符串、数字等等】，引用类型数据白扯【传递过来路由获取不到】！！！
        //浏览器存储功能，在路由跳转在之前，存储到浏览器中
        sessionStorage.setItem("SKUINFO", JSON.stringify(this.skuInfo));
        // 路由跳转
        this.$router.push({
            path: "/addcartsuccess",
            query: { skuNum: this.skuNum},
        });
    } catch (error) {
        // 失败干什么
        alert("加入购物车失败");
    }
},
```



### 购物车数量的操作

修改购物车产品数量的时候，需要发请求的，通知服务器产品最新的个数【服务器需要保存】，
当你组件在获取购物车的数据时候，不就是最新的数值【用户刷新刷不掉】

产品个数变化接口参数：
skuID	string	Y	商品ID

skuNum：在修改产品个数的时候,需要给服务器传递的是【变化的数值】

```js
//加入购物车|将来修改商品个数的接口
export const reqAddOrUpdateCart = (skuId, skuNum) => requests({url: `/cart/addToCart/${skuId}/${skuNum}`, method: 'post'});

//获取用户购物车的数据接口
export const reqShopCart = () => requests({url: "/cart/cartList", method: "get"});

//删除某一个商品的接口
export const reqDeleteCart = (skuId) => requests({url: `/cart/deleteCart/${skuId}`, method: "delete"});

//修改某一个商品的勾选的状态
export const reqUpdateChecked = (skuId, isChecked) => requests({url: `/cart/checkCart/${skuId}/${isChecked}`, method: "get"});
```



```vue
<script>
	import { mapGetters } from 'vuex';
	//按需引入lodash节流函数
	import throttle from 'lodash/throttle';
	//按需引入lodash防抖函数
	import debounce from 'lodash/debounce';

	export default {
		name: "ShopCart",
		//组件挂载完毕,获取购物车的数据
		mounted() {
			this.getData();
		},
		computed: {
			...mapGetters(["CartInfo"]),
			//购物车的数据
			cartInfoList() {
				return this.CartInfo.cartInfoList || [];
			},
			//购物车商品总价
			totalPrice() {
				return this.cartInfoList.reduce((prev, curr) => prev + curr.skuPrice * curr.skuNum, 0);
			},
			isCartChecked() {
				//购物车里面的数据进行过滤(勾选)，如果勾选的商品与购物车商品总数相等。全选勾选！相反不够
				return this.cartInfoList.filter(item => item.isChecked == "1").length === this.cartInfoList.length;
			},
		},
		methods: {
			//获取购物车的数据请求函数
			getData() {
				this.$store.dispatch("getShopCart");
			},
			//修改商品数据->加的操作
			async addSkuNum(cart) {
        //整理参数
        let params = { skuId: cart.skuId, skuNum: 1 };
        //发请求:通知服务器修改当前商品的个数
        //再次获取购物车的最新的数据：保证这次修改数据完毕【成功以后在获取购物车数据】
        try {
          //修改商品个数成功
          await this.$store.dispatch("addOrUpdateCart", params);
          //再次获取最新的购物车的数据
          this.getData();
        } catch (error) {
          alert("修改数量失败");
        }
			},
			//修改商品数据-减的操作
			minusSkuNum: throttle(async function(cart) {
        if (cart.skuNum > 1) {
          //整理参数:至少加入购物车的数量最低1个
          let params = { skuId: cart.skuId, skuNum: -1 };
          //修改商品的数据
          try {
            //修改商品的个数、成功以后再次获取购物车的数据
            await this.$store.dispatch("addOrUpdateCart", params);
            //再次获取最新的购物车的数据
            this.getData();
          } catch (error) {
            alert("减少商品数量失败");
          }
        }
			}, 2000),
			//改变SkuNum
			changeSkuNum: debounce(async function(cart, e) {
        //整理参数
        let params = { skuId: cart.skuId};
        //计算出SkuNum携带的数据
        let userResultValue = e.target.value * 1;
        //用户输入完毕，最终结果【非法条件】
        if (isNaN(userResultValue) || userResultValue < 1) {
          params.skuNum = 0;
        } else {
          //正常情况
          params.skuNum = parseInt(userResultValue) - cart.skuNum;
        }
        //发请求：修改商品的个数
        try {
          //修改商品的个数、成功以后再次获取购物车的数据
          await this.$store.dispatch("addOrUpdateCart", params);
          this.getData();
        } catch (error) {
          alert("修改商品个数失败");
        }
			}, 500),
			//删除某一个商品
			async deleteCartById(cart) {
        //整理参数
        let skuId = cart.skuId;
        try {
          // 删除商品成功
          await this.$store.dispatch("deleteCartById", skuId);
          //再次获取购物车最新的数据
          this.getData();
        } catch (error) {
          alert("删除失败");
        }
			},
			//修改某一个商品的勾选的状态
      async changeChecked(cart, e) {
        //整理参数
        let params = {
          skuId: cart.skuId,
          isChecked: e.target.checked ? "1" : "0",
        };
        try {
          //发请求:修改商品的勾选的状态
          await this.$store.dispatch("changeChecked", params);
          //再次获取购物车最新的数据
          this.getData();
        } catch (error) {
          alert("修改商品的勾选的状态失败");
        }
      },
      //全选的业务
      async updateAllChecked(e) {
        //获取全选的复选框勾选的状态,接口需要的1|0
        let isChecked = e.target.checked ? "1" : "0";
        try {
          //await等待成功:购物车全部商品勾选状态成功以后
          await this.$store.dispatch("allUpdateChecked", isChecked);
          //再次获取购物车最新的数据
          this.getData();
        } catch (error) {
          alert("全选失败");
        }
      },
      //删除选中的商品
      async deleteAllCart() {
        try {
          //等待全部勾选商品删除以后
          await this.$store.dispatch("deleteAllCart");
          //再次获取购物车最新的数据
          this.getData();
        } catch (error) {
          alert("删除选中商品失败");
        }
      },
		},
	}
</script>
```



----



## 订单交易业务

### 获取用户地址信息

```vue
		<!-- 收件人信息地方 -->
			<h5 class="receive">收件人信息</h5>
			<div class="address clearFix" v-for="(user, index) in address" :key="user.id">
				<span class="username" :class="{ selected: user.isDefault == '1' }">{{ user.consignee }}</span>
				<p $click="changeDefault(user)">
					<span class="s1">{{ user.fullAddress }}</span>
					<span class="s2">{{ user.phoneNum }}</span>
					<span class="s3" v-show="user.isDefault == '1'">默认地址</span>
				</p>
			</div>
```



### 获取用户购物车清单信息

```js
//获取用户地址信息
export const reqAddressInfo = () => requests({url: "/user/userAddress/auth/findUserAddressList", method: "get"});

//获取商品清单数据
export const reqShopInfo = () => requests({url: "/order/auth/trade", method: "get"});

```



### 展示商品清单数据

```vue
<!-- 商品清单：购物车里面的数据 -->
    <div class="detail">
        <h5>商品清单</h5>
        <ul class="list clearFix" v-for="(shop, index) in tradeInfo.detailArrayList" :key="shop.skuId">
            <li>
                <img :src="shop.imgUrl" alt="" style="width: 100px;" />
            </li>
            <li>
                <p>{{ shop.skuName }}</p>
                <h4>7天无理由退货</h4>
            </li>
            <li>
                <h3>￥{{ shop.orderPrice }}.00</h3>
             </li>
              <li>X{{ shop.skuNum }}</li>
              <li>有货</li>
        </ul>
    </div>
```



### 提交订单业务

当用户点击提交订单按钮的时候，需要发请求的
提交订单的请求地址:/api/order/auth/submitOrder?tradeNo={tradeNo}

前台：需要告诉服务器：谁买的、买的啥、买几个、 支付多少钱、留言信息...
后台：订单号，这笔交易的一个标识符【支付的】

axios({url:'xxx',methods:'post',data:{a:1}})

```js

//提交订单接口
export const reqSubmitOrder = (tradeNo, data) => requests({url: `/order/auth/submitOrder?tradeNo=${tradeNo}`, method: "post", data});

```



```js
			//提交订单
			async submitInfo() {
				// 整理参数：交易编码
				let tradeNo = this.tradeInfo.tradeNo;
				let data = {
					consignee: this.defaultUser.consignee,  // 付款人的名字
					consigneeTel: this.defaultUser.phoneNum,  // 付款人的手机号
					deliveryAddress: this.defaultUser.fullAddress,  // 付款人收货地址
					paymentWay: "ONLINE",  // 支付方式都是在线支付
					orderComment: this.msg,  // 买家留言
					orderDetailList: this.tradeInfo.detailArrayList,  // 购物车商品信息
				};
				//发请求:提交订单
				try {
					await this.$store.dispatch("submitInfo", { tradeNo, data});
					//将来提交订单成功【订单ID生成】，路由跳转pay页面，进行支付
					this.$router.push({ path: "/pay", query: {orderId: this.orderId } });
				} catch (error) {
					alert(error.message);
				}
			},
```



### 订单支付

交易编码（服务器：字符串hash）
收件人名字
收件人手机号
收件的地址
买家留言信息
支付产品

```js
//获取支付信息接口
export const reqPayInfo = (orderId) => requests({url: `/payment/weixin/createNative/${orderId}`, method: "get"});

//查询支付结果
export const reqPayResult = (orderId) => requests({url: `/payment/weixin/queryPayStatus/${orderId}`, method: "get"});

// 获取我的订单
export const reqMyOrderList = (page, limit) => requests({url: `/order/auth/${page}/${limit}`, method: "get"});
```



支付业务【微信支付】

```bash
$ cnpm i qrcode --save

```

 this.$alert('<strong>这是 <i>HTML</i> 片段</strong>', 'HTML 片段', {dangerouslyUseHTMLString: true});
稍微把elementUI的组件都稍微看看。

使用messageBox显示弹框

展示二维码----qrcode插件

通过qrCode.toDataUrl方法，将字符串转换为加密的在线二维码链接，通过图片进行展示。

GET|POST：短轮询，请求发一次，服务器响应一次，完事。

第一种做法:前端开启定时器，一直找服务器要用户支付信息【定时器】

第二种做法:项目务必要上线 + 和后台紧密配合
**当用户支付成功以后，需要后台重定向到项目某一个路由中**，将支付情况通过URL参数形式传给前端，前端获取到服务器返回的参数，就可以判断了。



```vue
<script>
  //引入二维码插件
  import QRCode from "qrcode";

	export default {
		name: "Pay",
		data() {
			return {
				//支付相关信息:支付钱数、订单号、二维码地址
        payInfo: {},
        code: "",
        timer: null,
			}
		},
    //组件挂载完毕，获取支付相关信息
    mounted() {
      // 获取支付信息
      this.getPayInfo();
    },
		methods: {
			//获取支付信息
      async getPayInfo() {
        let result = await this.$http.reqPayInfo(this.$route.query.orderId);
        if (result.code === 200) {
          this.payInfo = result.data;
        }
      },
      // 立即支付按钮
      async open() {
        //生成一个二维码URL
        let url = await QRCode.toDataURL(this.payInfo.codeUrl);
        // console.log(url);
        //第一个参数:即为内容区域
        //第二个参数:标题
        //第三个参数:组件的配置项
        this.$alert(`<img src=${url} />`, "请你微信扫码支付", {
          dangerouslyUseHTMLString: true,  // //将字符串转换为标签
          center: true,  // 居中
          showClose: false,  // 右上角的关闭按钮不显示
          confirmButtonText: "支付成功",  // 确定按钮的文本
          showCancelButton: true,  // 显示取消按钮
          cancelButtonText: "取消支付",  // 取消按钮的文本
          closeOnClickModal: true,  // 点击遮罩层关闭messagebox
          beforeClose: (action, instance, done) => {  //在消息盒子关闭之前会触发
            //action参数:可以区分用户点击的是取消【cancel】、确定【confirm】
            //instance参数:当前消息框组件VC
            //done参数：是一个函数,函数可以关闭消息盒子
            if (action === "confirm" && this.code === 200) {
              //清除定时器
              clearInterval(this.timer);
              // 关闭盒子
              done();
              // 路由跳转
              this.$router.push("/paysuccess");
            } else if (action === "cancel" && this.code !== 200) {
              //清除定时器
              clearInterval(this.timer);
              // 关闭盒子
              done();
              this.$message.error("支付遇见问题请联系客服")
            }
          },
        });
        //查询支付结果,开启定时器每隔一段时间询问支付结果
        this.timer = setInterval(async () => {
          // 发请求获取支付结果
          let result = await this.$http.reqPayResult(this.payInfo.orderId);
          //返回数据当中：code=200代表支付成功  code=205未支付
          if (result.code === 200) {
            //支付成功了
            //存储一下支付成功的code数值，通过他判断支付是否成功
            this.code = result.code;
            //清除定时器
            clearInterval(this.timer);
            // 关闭messagebox
            this.$msgbox.close();
            // 跳转路由
            this.router.push("/paysuccess");
          } else {
            // 未支付
            this.code = result.code;
          }
        }, 1000);
      },
      
		},
	}
</script>
```



### 获取支付信息进行展示

```vue
<div class="paysuccess">
		<div class="success">
			<h3>
				<img src="./images/right.png" width="48" height="48" />恭喜您，支付成功啦！
			</h3>
			<div class="paydetail">
				<p class="button">
					<router-link to="/center" class="btn-look">查看订单</router-link>
					<router-link to="/" class="btn-goshop">继续购物</router-link>
				</p>
			</div>
		</div>
	</div>
```

element-ui官方UI组件库（插件）？

react框架:
UI组件库antd【蚂蚁金服旗下PC端UI组件库】
antd-mobile【蚂蚁金服旗下的移动端UI组件库】

Vue框架:
element-UI【饿了吗旗下的UI组件库，官方承认的PC组件库插件】
vant【Vue官方提供移动端UI组件库】



官网地址:https://element.eleme.cn/#/zh-CN
官网地址：https://youzan.github.io/vant/#/zh-CN/

第一步：项目中安装element-ui组件库 [2.15.6版本：Vue2]

```bash
cnpm i element-ui@2.15.6 --save
```

第二步：在入口文件引入elementUI组件库
第一种：全部引入【不采用：因为项目中只是用到一个组件，没必要全都引入进来】
第二种：按需引入【按照开发需求引入相应的组件，并非全部组件引入】

第三步：按需引入，安装相应的插件
cnpm install babel-plugin-component -D
文档中说的.babelrc文件，即为babel.config.js文件
修改完babel.config.js配置文件以后，项目重启


第四部：按照需求引入相应的组件即可

Vue.component();
Vue.prototype.$xxx = xxx;



-----

## 个人中心

### 个人订单查看

完成个人中心数据的展示【分页】

```vue
<!--展示订单的地方-->
			<div class="orders">
				<!--遍历我们的订单数据-->
				<table class="order-item" v-for="(order, index) in list" :key="order.id">
					<thead>
						<tr>
							<th colspan="5">
								<span class="ordertitle">
									{{ order.createTime }} 订单编号：{{ order.outTradeNo }}
									<span class="pull-right delete"><img src="../images/delete.png" /></span>
								</span>
							</th>
						</tr>
					</thead>
					<tbody>
						<!-- 每一笔订单展示购买商品的地方 -->
						<tr v-for="(cart, index) in order.orderDetailList" :key="index">
							<td width="60%">
								<div class="typographic">
									<img :src="cart.imgUrl" style="width:100px;height:100px" />
									<a class="block-text">{{ cart.skuName }}</a>
									<span>x{{ cart.skuNum }}</span>
									<a href="#" class="service">售后申请</a>
								</div>
							</td>
							<td :rowspan="order.orderDetailList.length" v-show="index==0" width="8%" class="center">{{order.consignee}}</td>
              <td :rowspan="order.orderDetailList.length" v-show="index==0" width="13%" class="center">
                <ul class="unstyled">
                  <li>总金额¥{{order.totalAmount}}.00</li>
                  <li>在线支付</li>
                </ul>
              </td>
              <td :rowspan="order.orderDetailList.length" v-show="index==0" width="8%" class="center">
                <a href="#" class="btn">{{order.orderStatusName}}</a>
              </td>
              <td :rowspan="order.orderDetailList.length"  v-show="index==0" width="13%" class="center">
                <ul class="unstyled">
                  <li>
                    <a href="#">评价|晒单</a>
                  </li>
                </ul>
              </td>
            </tr>
					</tbody>
				</table>
			</div>
			<div class="choose-order">
				<!-- 全局组件分页器：
					total:分页器一共要展示多少条数据
					pageSize:一页展示几条数据
					pageNo:当前页码
					pagerCount:连续页码数
					currentPage:自定义事件父组件获取分页器当前页码
				-->
				<Pagination 
					:total="total"
					:pageSize="limit"
					:pageNo="page"
					:pagerCount="9"
					@currentPage="currentPage"
				></Pagination>
			</div>
		</div>
```



```vue
<script>
import Pagination from '@/components/Pagination/index.vue';
	export default {
    //给组件起一个名字,开发者工具中显示这个组件的时候，显示的就是这个名字
    name: "Center",
    data() {
        return {
            page: 1,
            limit: 3,
            list: [],
            total: 0, // 分页器一共展示多少条数据
        };
    },
    mounted() {
        // 组件挂载完毕先获取一次我的订单的数据
        this.getData();
    },
    methods: {
        //获取我的订单数据的方法
        async getData() {
            const { page, limit } = this;
            let result = await this.$http.reqMyOrderList(page, limit);
            if (result.code == 200) {
                this.list = result.data.records;
                this.total = result.data.total;
            }
        },
        // 获取用户点击当前页码的自定义事件的回调
        currentPage(page) {
            // 修改参数
            this.page = page;
            this.getData();
        },
    },
    components: { Pagination }
}
</script>
```


2)未登录全局守卫的判断

在前面课程当中:导航守卫【导航:路由发生变化，守卫可以检测到，通过判断，确定这次路由跳转】

前置守卫：在路由跳转之前，进行判断
后置守卫:路由都已经跳转完毕才执行。


未登录的情况:
全局守卫:只要的项目当中任何某一个路由发生变化，就会出发。
项目守卫使用:一般有用前置全局守卫

用户登录:

用户未登录：点击购物车的结算按钮->交易页面【没有登录:去不了】
           未登录不能调到支付页面
           未登录不能调到支付成功页面
           未登录不能去个人中心【都不知道你是谁：展示谁的个人中心啊】




3)路由独享守卫
路由独享守卫：需要在配置路由的地方使用
导航守卫:全局守卫->项目当中有任何路由变化【a->b,b->d】触发。
        路由独享守卫：专门负责某一个路由

用户登陆了:
去交易页面:从购物车才能跳转到交易页面。

next():你本来想去哪里，我就放行，你就去完事了。

next('/login'):执行守卫放行到执行的路由。

next(false):路由跳转的时候，从哪里来回那里去。



4)组件内守卫---->一般很少用【全局 + 路由独享守卫】
组件内守卫：也是专门负责某一个路由【并非负责全部路由】，写法和路由独享守卫有区别？
组件内守卫需要书写在组件内部

beforeRouteEnter
beforeRouteUpdate (2.2 新增)
beforeRouteLeave



6)路由懒加载
面试【高频的面试】:项目的性能优化手段有哪些？
v-if|v-show:尽可能采用v-show
按需引入【lodash、elementUI】
防抖与节流
路由懒加载：当用户访问的时候，加载对应组件进行展示。



7)图片懒加载
vue-lazyload:图片懒加载
图片：比用用户网络不好，服务器的数据没有回来，
总不可能让用户看白色，至少有一个默认图片在展示。






8)表单验证【后台管理系统：大量使用elementUI】
以后工作的时候经常会进行表单验证【element-ui】进行表单验证，so 简单。
项目当中表单验证功能比较常见的。

8.1vee-validate插件：Vue官方提供的一个表单验证的插件【老师接下来的操作能大概看懂即可】
这个插件很难用：如果你翻看它的文档（看一个月：不保证能看懂），依赖文件很多（文档书写的很难理解）
花大量时间学习，很难搞懂。


8.2哪怕将来工作了，真的使用vee-valadiate【老师项目搞出来：改老师代码即可】

使用步骤：
1：安装vee-valadite，别安装最新版本@2
2：在plugins文件夹中创建一个validate.js[专门注册vee-valadite]
3:注册插件
4：注册插件的时候，用中文，以及需要验证的字段【用中文显示提示形式】
5：在入口文件需要引入执行一次
6:使用vee-valadiate插件

