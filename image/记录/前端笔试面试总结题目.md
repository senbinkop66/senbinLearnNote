## 字节 4.26

1.自我介绍

2.为什么学前端

3.html5元素

- 新增选择器 document.querySelector、document.querySelectorAll
- 拖拽释放(Drag and drop) API
- 媒体播放的 video 和 audio
- 本地存储 localStorage 和 sessionStorage
- 离线应用 manifest
- 桌面通知 Notifications
- 语意化标签 article、footer、header、nav、section
- 增强表单控件 calendar、date、time、email、url、search
- 地理位置 Geolocation
- 多任务 webworker
- 全双工通信协议 websocket
- 历史管理 history
- 跨域资源共享(CORS) Access-Control-Allow-Origin
- 页面可见性改变事件 visibilitychange
- 跨窗口通信 PostMessage
- Form Data 对象
- 绘画 canvas

------

4.SVG和canvas的区别，有没有手写实现过两者

SVG 与 Canvas两者间的区别

- SVG 是一种使用 XML 描述 2D 图形的语言。
- Canvas 通过 JavaScript 来绘制 2D 图形。
- SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的，您可以为某个元素附加 JavaScript 事件处理器。
- 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
- Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。
- 如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。

Canvas 与 SVG 的比较

下表列出了 canvas 与 SVG 之间的一些不同之处。

**Canvas**

- 依赖分辨率
- 不支持事件处理器
- 弱的文本渲染能力
- 能够以 .png 或 .jpg 格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

**SVG**

- 不依赖分辨率
- 支持事件处理器
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）
- 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
- 不适合游戏应用

------

5.BFC

1. BFC（边距重叠解决方案）

   5.1 BFC基本概念

   **BFC: 块级格式化上下文** BFC基本概念：BFC是CSS布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素 。 父子元素和兄弟元素边距重叠，**重叠原则取最大值**。空元素的边距重叠是**取margin与 padding 的最大值**。

   5.2 BFC原理（渲染规则|布局规则）：

   （1）内部的Box会在垂直方向，从顶部开始一个接着一个地放置； （2）Box垂直方向的距离由margin(外边距)决定，属于同一个BFC的两个相邻Box的margin会发生重叠； （3）每个元素的margin Box的左边， 与包含块border Box的左边相接触，（对于从左到右的格式化，否则相反）。即使存在浮动也是如此； （4）BFC 在页面上是一个隔离的独立容器，外面的元素不会影响里面的元素，反之亦然。文字环绕效果，设置float； （5）BFC 的区域不会与float Box重叠（清浮动）; （6）计算BFC的高度时，浮动元素也参与计算。

   5.3 CSS在什么情况下会创建出BFC（即脱离文档流）

   0、根元素，即 HTML 元素（最大的一个BFC） 1、浮动（float 的值不为 none） 2、绝对定位元素（position 的值为 absolute 或 fixed） 3、行内块（display 为 inline-block） 4、表格单元（display 为 table、table-cell、table-caption、inline-block 等 HTML 表格相关的属性) 5、弹性盒（display 为 flex 或 inline-flex） 6、默认值。内容不会被修剪，会呈现在元素框之外（overflow 不为 visible）

   5.4 BFC作用（使用场景）

   1、自适应两（三）栏布局（避免多列布局由于宽度计算四舍五入而自动换行） 2、避免元素被浮动元素覆盖 3、可以让父元素的高度包含子浮动元素，清除内部浮动（原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内） 4、去除边距重叠现象，分属于不同的BFC时，可以阻止margin重叠

------

6.布局，左边固定，右边滑动，覆盖问题

1. float+overflow:hidden

这种办法主要通过 overflow 触发 BFC,而 BFC 不会重叠浮动元素。由于设置 overflow:hidden 并不会触发 IE6-浏览器的 haslayout 属性，所以需要设置 zoom:1 来兼容 IE6-浏览器。具体代码如下：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .parent {
      margin: 0 auto; // 使父容器水平居中显示
      overflow: hidden;
      zoom: 1;
      max-width: 1000px;
    }
    .left {
      float: left;
      margin-right: 20px;
      width: 200px;
      background-color: green;
    }

    .right {
      overflow: hidden;
      zoom: 1;
      background-color: yellow;
    }
  </style>
</head>
<body>
  <div class="parent"> 
    <div class="left"> 
    <p>left left left left</p> 
    </div> 
    <div class="right"> 
    <p>right</p> 
    <p>right</p> 
    </div> 
  </div> 
</body>
</html>
```

2. float: left+ margin-left

float使左边的元素脱离文档流，右边的元素可以和左边的元素显示在同一行，设置margin-left让右边的元素不覆盖掉左边的元素， 代码如下：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .parent {
      margin: 0 auto;
      max-width: 1000px;
    }
    .parent::after {
      content: '';
      display: table;
      clear: both;
    }
    .left {
      float: left;
      width: 200px;
      background-color: green;
    }

    .right {
      margin-left: 200px;
      background-color: yellow;
    }
  </style>
</head>
<body>
  <div class="parent"> 
    <div class="left"> 
    <p>left left left left</p> 
    </div> 
    <div class="right"> 
    <p>right</p> 
    <p>right</p>
    <p>right</p> 
    </div> 
   </div> 
</body>
</html>
```

3. position: absolute + margin-left

左边绝对定位，右边设置margin-left，代码如下：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .parent {
      position: relative;
      margin: 0 auto;
      max-width: 1000px;
    }

    .left {
      position: absolute;
      width: 200px;
      background-color: green;
    }

    .right {
      margin-left: 200px;
      background-color: yellow;
    }
  </style>
</head>
<body>
  <div class="parent"> 
    <div class="left"> 
    <p>left left left left</p> 
    </div> 
    <div class="right"> 
    <p>right</p> 
    <p>right</p>
    <p>right</p> 
    </div> 
   </div> 
</body>
</html>
```

4. flex布局

flex布局可以使两个子元素显示在同一行，只要左边的宽度固定，就可以实现效果， 代码如下：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .parent {
      display: flex;
      margin: 0 auto;
      max-width: 1000px;
    }
    .left {
      width: 200px;
      background-color: green;
    }

    .right {
      margin-left: 20px;
      flex: 1;
      background-color: yellow;
    }
  </style>
</head>

<body>
  <div class="parent">
    <div class="left">
      <p>left left left left</p>
    </div>
    <div class="right">
      <p>right</p>
      <p>right</p>
      <p>right</p>
    </div>
  </div>
</body>

</html>
```

------

7.盒模型（计算width)

1. 概念

   CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：外边距（margin）、边框（border）、内边距（padding）、实际内容（content）四个属性。 CSS盒模型：**标准模型 + IE模型**

2. 标准模型和IE模型的区别

计算宽度和高度的不同 标准盒模型：盒子总宽度/高度 =width/height + padding + border + margin。（ 即 width/height 只是 内容高度，不包含 padding 和 border 值 ） IE盒子模型：盒子总宽度/高度 =width/height + margin = (内容区宽度/高度 + padding + border) + margin。（ 即 width/height 包含了 padding 和 border 值 ）

1. CSS如何设置这两种模型

   标准：box-sizing: content-box;( 浏览器默认设置 ) IE：box-sizing: border-box;

2. JS如何获取盒模型对应的宽和高

   （1）dom.style.width/height只能取到行内样式的宽和高，style 标签中和 link 外链的样式取不到。 （2）dom.currentStyle.width/height（只有IE兼容）取到的是最终渲染后的宽和高 （3）window.getComputedStyle(dom).width/height同（2）但是多浏览器支持，IE9 以上支持。 （4）dom.getBoundingClientRect().width/height也是得到渲染后的宽和高，大多浏览器支持。IE9 以上支持，除此外还可以取到相对于视窗的上下左右的距离。 （6）dom.offsetWidth/offsetHeight包括高度（宽度）、内边距和边框，不包括外边距。最常用，兼容性最好。

   ------

8.闭包 ,闭包可能造成什么问题

闭包是什么

> 在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。

> 概述上面的话，**闭包是指有权访问另一个函数作用域中变量的函数**

形成闭包的原因

> **内部的函数存在外部作用域的引用就会导致闭包**。从上面介绍的上级作用域的概念中其实就有闭包的例子 `return f`就是一个表现形式。

```
var a = 0
function foo(){
    var b =14
    function fo(){
        console.log(a, b)
    }
    fo()
}
foo()
```

> 这里的子函数 `fo` 内存就存在外部作用域的引用 `a, b`，所以这就会产生闭包

闭包变量存储的位置

> 直接说明：**闭包中的变量存储的位置是堆内存。**

- 假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。

闭包的作用

- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

闭包经典使用场景

1. `return` 回一个函数

```
var n = 10
function fn(){
    var n =20
    function f() {
       n++;
       console.log(n)
     }
    return f
}

var x = fn()
x() // 21
x() // 22
```

> 这里的 return `f`, `f()`就是一个闭包，存在上级作用域的引用。

1. 函数作为参数

```
var a = 'kop'
function foo(){
    var a = 'foo'
    function fo(){
        console.log(a)
    }
    return fo
}

function f(p){
    var a = 'f'
    p()
}

f(foo())  // foo
```

> 使用 return `fo` 返回回来，`fo()` 就是闭包，`f(foo())` 执行的参数就是函数 `fo`，因为 `fo() 中的 a` 的上级作用域就是函数`foo()`，所以输出就是`foo`

1. IIFE（自执行函数）

```
var n = 'kop';
(function p(){
    console.log(n)
})()

//kop
```

> 同样也是产生了闭包`p()`，存在 `window`下的引用 `n`。

1. 循环赋值

```
for(var i = 0; i<10; i++){
  (function(j){
       setTimeout(function(){
        console.log(j)
    }, 1000) 
  })(i)
}
```

> 因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 `i++` 到 10时，异步代码才开始执行此时的 `i=10` 输出的都是 10。

1. 使用回调函数就是在使用闭包

```
window.name = 'kop'

setTimeout(function timeHandler(){
    console.log(window.name);
}, 100);

//kop
```

1. 节流防抖

```
// 节流
function throttle(fn, timeout) {
    let timer = null
    return function (...arg) {
        if(timer) return
        timer = setTimeout(() => {
            fn.apply(this, arg)
            timer = null
        }, timeout)
    }
}

// 防抖
function debounce(fn, timeout){
    let timer = null
    return function(...arg){
        clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arg)
        }, timeout)
    }
}
```

1. 柯里化实现

```
function curry(fn, len = fn.length) {
    return _curry(fn, len)
}

function _curry(fn, len, ...arg) {
    return function (...params) {
        let _arg = [...arg, ...params]
        if (_arg.length >= len) {
            return fn.apply(this, _arg)
        } else {
            return _curry.call(this, fn, len, ..._arg)
        }
    }
}

let fn = curry(function (a, b, c, d, e) {
    console.log(a + b + c + d + e)
})

fn(1, 2, 3, 4, 5)  // 15
fn(1, 2)(3, 4, 5)
fn(1, 2)(3)(4)(5)
fn(1)(2)(3)(4)(5)
```

使用闭包需要注意什么

> 容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。

怎么检查内存泄露

- performance 面板 和 memory 面板可以找到泄露的现象和位置

作者：LinYIYI 链接：https://juejin.cn/post/6937469222251560990 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

------

9.正则 匹配前中后空格，字面量和构造函数的区别

字面量和构造函数

有两种方法可以创建一个 `RegExp` 对象：一种是字面量，另一种是构造函数。

- 字面量

  由斜杠(/)包围而不是引号包围。

- 构造函数的字符串参数

  由引号而不是斜杠包围。

以下三种表达式都会创建相同的正则表达式：

```
/ab+c/i; //字面量形式
new RegExp('ab+c', 'i'); // 首个参数为字符串模式的构造函数
new RegExp(/ab+c/, 'i'); // 首个参数为常规字面量的构造函数
```

当表达式被赋值时，**字面量形式提供正则表达式的编译（compilation）状态**，当正则表达式保持为常量时使用字面量。例如当你在循环中使用字面量构造一个正则表达式时，正则表达式不会在每一次迭代中都被重新编译（recompiled）。

而正则表达式对象的构造函数，如 `new RegExp('ab+c')` 提供了正则表达式**运行时编译**（runtime compilation）。如果你知道正则表达式模式将会改变，或者你事先不知道什么模式，而是从另一个来源获取，如用户输入，这些情况都可以使用构造函数。

匹配字符串中任何位置出现的空格：

```
var reg=/(^\s+)|(\s+$)|\s+/g;

var str = " ff gg ";

reg.test(str);

console.log(str.replace(reg,""))
```

第五种方法在处理长字符串时效率最高

第一种：循环检查替换

```
//供使用者调用  
function trim(s){  
    return trimRight(trimLeft(s));  
}  
//去掉左边的空白  
function trimLeft(s){  
    if(s == null) {  
        return "";  
    }  
    var whitespace = new String(" \t\n\r");  
    var str = new String(s);  
    if (whitespace.indexOf(str.charAt(0)) !== -1) {  
        var j=0, i = str.length;  
        while (j < i && whitespace.indexOf(str.charAt(j)) !== -1){  
            j++;  
        }  
        str = str.substring(j, i);  
    }  
    return str;  
}  
//去掉右边的空白 
function trimRight(s){  
    if(s == null) return "";  
    var whitespace = new String(" \t\n\r");  
    var str = new String(s);  
    if (whitespace.indexOf(str.charAt(str.length-1)) != -1){  
        var i = str.length - 1;  
        while (i >= 0 && whitespace.indexOf(str.charAt(i)) != -1){  
            i--;  
        }  
        str = str.substring(0, i+1);  
    }  
    return str;  
} 
```

第二种：正则替换

```
String.prototype.Trim = function()  {  
    return this.replace(/(^\s*)|(\s*$)/g, "");  
}  
String.prototype.LTrim = function()  {  
    return this.replace(/(^\s*)/g, "");  
}  
String.prototype.RTrim = function()  {  
    return this.replace(/(\s*$)/g, "");  
}  
```

第三种：使用jquery

```
$.trim(str) 
//jquery内部实现为：
function trim(str){   
    return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,'');   
}   
```

第四种：使用motools

```
function trim(str){   
    return str.replace(/^(\s|\xA0)+|(\s|\xA0)+$/g, '');   
}  
```

第五种：裁剪字符串方式

```
function trim(str){   
    str = str.replace(/^(\s|\u00A0)+/,'');   
    for(var i=str.length-1; i>=0; i--){   
        if(/\S/.test(str.charAt(i))){   
            str = str.substring(0, i+1);   
            break;   
        }   
    }   
    return str;   
}  
```

#### 

------

10. 字符串循环换位 change()

```
function change(str,n){
    let len=str.length;
    n=n%len;
    if (n===0) {
        return str;
    }
    //console.log(n)
    return str.slice(len-n)+str.slice(0,len-n);
}

console.log(change("abcdefghjk",100));
```

11. 每隔3秒打印一次“hello world",打印四次

```
function repeat(fn,n,delay){
    let str="hello world";
    let flag=0;
    function st(){
        setTimeout(function(){
            if (flag<n) {
                fn.call(this,str);
                st();
                flag++;
            }else{
                return;
            }
        },delay);
    }
    st();
}


var repeatFunc=repeat(console.log,4,3000);
```

------

## 美团 5.10

http的方法 option的作用

为什么TCP三次握手

TCP与UDP的区别和使用场景，是在模型的哪一层

Vue 计算属性与监视属性的区别、使用场景

Vue 组件间传数据，父子、兄弟组件

Vue生命周期 请求数据在那一阶段

觉得自己在项目中用得好的技术

有哪些缓存技术，如何确定用的哪一种缓存技术

回流与重绘

输入url的整个执行过程，HTML 与CSS加载过程

CSS为什么放在页面前面

盒模型，如何设置

深浅拷贝，如何实现深拷贝

js数据类型

代码题：解析url参数



------

pdd笔试 5.26

class 静态方法

打平对象

格式化数字 123,456,789.123

手写Promise.all()

------

## pdd 6.02

项目介绍，难点

实现轮播图

Vue数据双向绑定原理

------

## momenta 6.07

js数据类型

判断数据类型的方式

深浅拷贝

```
//判断
let a = 2;
let b = a;
let c = 2;

console.log(a == b);  // true
console.log(a === b);  // true
console.log(a == c);  // true
console.log(a === c);  // true

let arr1 = [1, 2,3];
let arr2 = arr1;
let arr3 = [1, 2, 3];

console.log(arr1 == arr2);  // true
console.log(arr1 === arr2);  // true
console.log(arr1 == arr3);  // false
console.log(arr1 === arr3);  // false

let obj1 = {
    name:"john",
    age:2
}
let obj2 = obj1;
let obj3 = {
    name:"john",
    age:2
}

console.log(obj1 == obj2);  // true
console.log(obj1 === obj2);  // true
console.log(obj1 == obj3);  // false
console.log(obj1 === obj3);  // false
```

promise题目

```
new Promise((resolve, reject) => {
  console.log(0);
  setTimeout(()=>{
    console.log("setTimeout");
    resolve(1);
    resolve(2);
    reject(3);
  });
}).then((data) => {
    console.log("result1", data);
  }, (data) => {
    console.log("result2", data);
}).then((data) => {
  console.log("result3", data);
}).catch((data) => {
  console.log(data);
});

/*
0
setTimeout
result1 1
result3 undefined
*/
```

css三列布局

------

## tp 一面 6.21

http长连接和短连接

三次握手四次挥手

get和post

Vue双向绑定原理

分页功能

如何找到中间链表结点

```
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteMiddle = function(head) {
    if (head.next === null) {
        return null;
    }
    let slow = head;
    let fast = head;
    let prev = null;
    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        prev = slow;
        slow = slow.next;
    }

    prev.next = prev.next.next;
    return head;
};
```

## tp二面 6.23

排序算法稳定性

除了前端还学习了哪些

前端安全

如何检测注入

git merge 和 git rebase的区别

------

## 帆软 7.1

30分钟

如何实现0.5px边框

样式权重，优先级

输入框宽度随输入自适应

setTimeout的替代方法

Vue路由两种模式实现原理的区别

场景应用题

如何选择一个合适的其他js应用库



## ivx 7.14

数组去重

闭包

let const var

浅拷贝、深拷贝



-----

## 8.9  大应科技笔试

this指向

防抖，节流

跨域

js数据类型

严格模式



----

## 8.13美团笔试

送一个外卖需要5分钟，给定外卖的最晚送达时间的数组，最多送多少外卖

```
[3, 5, 7, 7, 8, 10, 11,15]
```





还原扑克牌顺序

两个人各抽一张到最下面，然后翻开最上面的一张，循环直达翻完，得到一个翻开的顺序，求原始顺序

```
[1, 2, 3, 4, 5]
```







-----

## 8.15 百度面试

闭包

下面修改方式及原理

```js
for (var i = 0; i < 10; i++){
    setTimeout(() => {
        console.log(i);
    }, 0);
}
```

```js
for (let i = 0; i < 10; i++){
    
    setTimeout(() => {
        console.log(i);
    }, 0);
}


//1、在setTimeout外部创建一个自执行函数，并将i当作参数传递进闭包
for(var i = 0; i < 10; i++){
    (function(num){
        setTimeout(function(){
            console.log(num);   // 输出0，1，2，3，4         
        }, 0);
      }
    )(i);
}

//2、在setTimeout内部函数创建一个闭包，并将i当作参数传递进去
for(var i = 0; i < 10 ; i++){
    setTimeout(function(num){
        return function(){ //用匿名函数打造一个num变量副本
            console.log(num);   // 输出0，1，2，3，4 
        }
    }(i), 0);
}
```







js 事件循环

防抖函数

为什么  _this

```js
function debounce(fn,wait){
	var timeout;  //用来存放定时器的返回值，一触发就重新计时
	return function(){
		var context=this;
		//把前一个 setTimeout clear 掉
		clearTimeout(timeout);
		//又创建一个新的 setTimeout,保障间隔时间内持续触发，不会执行fn函数
		timeout=setTimeout(function(){
			fn.apply(context);
		},wait);
	}
}
```

行内元素转块级元素

position 的几个属性值



项目打包

三级联动如何实现

如何优化时间和空间的（预测程序）

算法：  寻找pivoit index 



-----

## 8.16 极米笔试

旋转数组

```
L1L2...LnR1R2...Rn  =>  R1L1R2L2...RnLn
```

```

```

从起点0到目标值x的最少移动次数

```
在一个y点可以移动到（y - 1 或 y + k) ,其中k为当前移动次数
```



----

## 8.18 荣耀笔试

按规则 加密明文

```
[a,b,c] => 2, ... [p,q,r,s] => 7, [t,u,v] => 8, [w, x, y, z] => 9
[A-Z] => [a-z] 向前移动一个，a => z
其他字符不变
```

给定一个矩阵，判断输入数组中的元素是否能连在一起

```
[1, 2, 3, 4, 5, 11]
```



计算C语言结构体的size

```

```



----

## 8.19 大应科技面试



Node.js与ES6中模块的区别

箭头函数和普通函数的区别

this指向问题

for in 与 for of 的区别



BFC

水平垂直居中如何实现

float的使用，注意哪些问题



前端安全问题, 如何避免

cookie的字段

登录如何实现，有哪些方式



TCP三次握手四次挥手

http版本的区别，https 

```js
new Promise((resolve, reject) => {
    console.log(1);
    setTimeout(() => {
        console.log(2);
    });
    resolve();
}).then(() => {
    console.log(3);
}).then(() => {
    return new Promise((resolve, reject) => {
        console.log(4);
    }).then(() => {
        console.log(5);
    });
}).then(() => {
    console.log(6);
});

console.log(7);

/*
1
7
3
4
2
*/

```



```js
Array.a = 1;
Array.prototype.a = 2;
Function.prototype.a = 3;
Object.prototype.a = 4;

var arr = [];

console.log(arr.__proto__)  // Object(0) [ a: 2 ]
console.log(arr.a);  // 2

console.log(arr.length.__proto__);  // {}
console.log(arr.length.a);  // 4

console.log(arr.forEach.__proto__);  // { a: 3 }
console.log(arr.forEach.a);  // 3


console.log(Function.__proto__);  // { a: 3 }
console.log(Function.a);  // 3


console.log(Object.__proto__);  // { a: 3 }
console.log(Object.a);  // 3
```





----

## 8.19 4399笔试



promis题

```js
setTimeout(() => {
    console.log(1);
})

new Promise((resolve, reject) => {
    console.log(2);
    setTimeout(() => {
        console.log(3);
        resolve(4);
    });
}).then((value) => {
    console.log(value);
});

console.log(6);

/*
2
6
1
3
4
*/
```



异步题

```
function start() {
    console.log(new Date());
    console.log("红包雨开始");
}

function redPacketRain1() {
    console.log(new Date());
    console.log("第一个大红包");
}

function redPacketRain2() {
    console.log(new Date());
    console.log("第二个大红包");
}

function redPacketRain3() {
    console.log(new Date());
    console.log("第三个大红包");
}

function end() {
    console.log(new Date());
    console.log("红包雨结束");
}

function game(timer, fn) {
    setTimeout(() => {
        fn.apply();
    }, timer);
    Promise.resolve(timer);
    
}

new Promise((resolve, reject) => {
    return game(1, start);
}).then(() => {
    return game(2, redPacketRain1);
}).then(() => {
    return game(3, redPacketRain2);
}).then(() => {
    return game(4, redPacketRain3);
}).then(() => {
    end();
});
```



格式化数字为千分位 12345=》 12,345

给定时间戳计算与当前时间的时间差

给定一个字符串查找第一个不重复的字符



----

## 8.20 科大讯飞笔试



计算 1/2 + 2/3 + 3/5 + ....的前n个和，保留两位小数

```

```



判断输入字符串的格式

```

```

找到迷宫礼物的最短路径

```

```



----

## 8.25 奇安信笔试

```js
async function foo() {
  console.log(2);
  console.log(await Promise.resolve(8));
  console.log(9); 
  console.log(await Promise.resolve(18));
  console.log(19);
}
async function bar() {
  console.log(4);
  console.log(await 6);
  console.log(7);
}

console.log(1);

foo();

console.log(3);

bar();

console.log(5);

// 1 2 3 4 5 8 9 6 7 18 19 
```





有n个结点构成的有向图

计算结点0到结点n的路径数

```
[[1, 2, 3], [3], [3], [4], []]
```



----

## 8.26 猿辅导笔试

求所有数组中都出现的元素

```js
function solution() {
    let m = parseInt(readline().trim());
    let s1 = new Set();
    let s2 = new Set();
    for (let i = 0; i < m; i++){
        let arr = readline().trim().split(" ").map(Number);
        if (i === 0) {
            arr.forEach((item) => {
                s2.add(item);
            });
        } else {
            let flag = false;
            arr.forEach((item) => {
                if (s2.has(item)) {
                    s1.add(item);
                    flag = true;
                }
            });
            if (flag) {
                //存在共同的
                s2 = s1;
                s1 = new Set();
            } else {
                // 不存在
                s2 = new Set();
                break;
            }
            
        }
    }
    let ans = Array.from(s2).sort((a, b) => a - b);
    if (ans.length > 0) {
        console.log(ans.join(" "));
    } else {
        console.log("")
    }
    
}


let N = parseInt(readline().trim());
while (N > 0) {
    solution();
    N--;
}
```



计算二叉树的每一层的最大差值

```

```



计算异或校验值

```js
function solution(n, start) {
    if (n < 1) {
        return 0;
    }
    let ans = BigInt(0);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i; j++) {
            ans ^= BigInt(start);
            start += BigInt(1);
        }
        start += BigInt(i);
    }
    console.log(ans);
}


process.stdin.resume();
process.stdin.setEncoding("utf-8");

let str = "";

process.stdin.on("data", (data) => {
    str += data;
});

process.stdin.on("end", (_) => {
    str = str.trim().split("\n").forEach((item) => {
        let line = item.trim().split(" ").map(Number);
        let n = line[0]
        let start = line[1];
        solution(n, start);
    })
})
```





----

## 8.27360笔试

```js
var arr = [, , , , ,]

console.log(arr.length, arr);  // 5 [ <5 empty items> ]
```



判断写在纸上的大写英文字符串翻面后是否对称

```js

let m = parseInt(read_line().trim());
while (m > 0) {
    m--;
    let line = read_line().trim().split(" ");
    console.log(solution(line));
}

function solution(s) {
  if (s.length === 0) {
    return "NO";
  }
  const alphaSet = new Set(["A","H","I","M","O","T","U","V","W","X","Y"]);
  let left = 0;
  let right = s.length - 1;
  while(left <= right) {
    if (!alphaSet.has(s[left]) || s[left] !== s[right]) {
      return "NO";
    }
    left++;
    right--;
  }
  return "YES";
}

// console.log(solution("AHH"))
while ((line = read_line()) != '') {
  let str = line.trim();
  console.log(solution(str))
}

```



判断英语句子结构

```js
let line1 = read_line().trim().split(" ").map(Number);
// const [n1, n2, n3] = line1;

const words1 = new Set(read_line().trim().split(" "));
const words2 = new Set(read_line().trim().split(" "));
const words3 = new Set(read_line().trim().split(" "));

function solution(setence) {
    if (setence.length < 2) {
        return "NO";
    }
    const n = setence.length;
    let i = 0;
    if (!words1.has(setence[i])) {
        //如果第一个单词不是主语
        return "NO";
    }
    i++;
    while (words1.has(setence[i]) && i < n) {
        //遍历剩余主语
        i++;
    }
    if (i >= n || !words2.has(setence[i])) {
        // 没有谓语
        return "NO";
    }
    i++;
    // 谓语只能一个
    while(i < n ) {
        //遍历宾语
        if (!words3.has(setence[i])) {
            return "NO";
        }
        i++;
    }
    return "YES";
}
```



-----

## 8.27 京东笔试

转换字符串

```js
function solution(str, n, k) {
  for (let i = 0; i < n; i++) {
    if (i < k) {
      str[i] = str[i].toUpperCase();
    } else {
      str[i] = str[i].toLowerCase();
    }
  }
  return str.join("");
}

let [n, k] = readline().trim().split(" ").map(Number);
let line2 = readline().trim().split("");
console.log(solution(line2, n, k));





```

输出矩阵

```js
function solution(n) {
  let start = 1;
  for (let i = 0; i < n; i++) {
    let arr = [];
    for (let j = 0; j < n; j++) {
      if (i % 2 === 0) {
        arr.push(start);
      } else {
        arr.unshift(start)
      }
      start++;
    }
    console.log(arr.join(" "));
  }
}

let n = parseInt(readline());
// let n = 4;
solution(n);
```



构造长城，变换最少次数

```js
function solution(arr, n) {
    if (n < 3) {
        return 0;
    }
    // let oddCountMax = 1, evenCountMax = 1;
    let oddMaxCountValue = arr[0], evenMaxCountValue = arr[1];
    const oddMap = new Map();
    oddMap.set(arr[0], 1);
    let odds = [[arr[0]], []]
    let evens = [[arr[1]], []]
    const evenMap = new Map();
    evenMap.set(arr[1], 1);

    for (let i = 0; i < n; i++) {
        let item = arr[i];
        if (i % 2 === 0) {
            oddMap.set(item, oddMap.has(item) ? oddMap.get(item) + 1 : 1);
            if (oddMap.get(item) > oddMap.get(oddMaxCountValue)) {
                oddMaxCountValue = item;
                odds[1] = odds[0];
                odds[0] = [item];
            }
            if (oddMap.get(item) === oddMap.get(oddMaxCountValue)) {
                odds[0].push(item);
            }

        } else {
            evenMap.set(item, evenMap.has(item) ? evenMap.get(item) + 1 : 1);
            if (evenMap.get(item) > evenMap.get(evenMaxCountValue)) {
                evenMaxCountValue = item;
                evens[1] = evens[0];
                evens[0] = [item];
            }
            if (evenMap.get(item) > evenMap.get(evenMaxCountValue)) {
                evens[0].push(item);
            }
        }
    }
    if (oddMaxCountValue !== evenMaxCountValue) {
        return n - oddMap.get(oddMaxCountValue) - evenMap.get(evenMaxCountValue);
    } else {
        let secondEven = evenMaxCountValue, secondOdd = oddMaxCountValue;
        if (evens[0].length > 1) {
            secondEven =evens[0][1];
        } else {
            if (evens[1].length > 0) {
                secondEven = evens[1][0];
            }
        }
        if (odds[0].length > 1) {
            secondOdd =odds[0][1];
        } else {
            if (odds[1].length > 0) {
                secondOdd = odds[1][0];
            }
        }

        let ans1 = oddMap.get(oddMaxCountValue) + evenMap.get(secondEven);
        let ans2 = oddMap.get(secondOdd) + evenMap.get(evenMaxCountValue);

        return n - Math.max(ans1, ans2);
    }
}

let m = parseInt(readline());
let line1 = readline().trim().split(" ").map(Number);

console.log(solution(line1, m));
```



给定一个长度为n的数组，每次可以使某个数+1或-1，目标数组的要求为对任意一个数，其左右两个数相等，问至少进行几次操作

```js
function (nums, n) {
	let evenMax = 0;
	let oddMax = 0；
	for (let i = 0; i < n; ++i) {
			let num = nums[i]
      if (i % 2 === 0) {
      	evenMax = evenMax > num ? evenMax : num;
      } else {
      	oddMax = oddMax > num ? oddMax : num;
      }
  }

  let res = 0
  for (let i = 0; i < n; ++i) {
      if (i % 2 === 0) {
          res += (evenMax - nums[i]);
      }
      else {
          res += (oddMax - nums[i]);
      }
  }
  if (evenMax == oddMax){
  	res += (n / 2);
  }
  return ans;
}
```





----

## 8.29美团面试



登录如何做的，登录的时候数据是否要加密，

token如何生成，token放在哪里发送给客户端

服务端如何验证token



vuex如何使用，优势

可以不用vuex处理吗



http状态码

如何排查状态码原因



http缓存

强缓存和协商缓存分别应用于什么场景



使用promise实现delay(3).then(dosomething)

```js
/**
 * 定义延时函数
 * delaytime 延时时长，单位毫秒
 */
var sleep = (delaytime = 1000) => {
  return new Promise(resolve => setTimeout(resolve, delaytime))
}

```



----

## 8.30 天王星面试

如何学习前端

对量化的了解

爱好和兴趣

7L 和5L的杯子如何得到4L的杯子

8个砝码有一个重一些，需要称几次可以找出重的那个



----

## 8.31 度小满笔试



现在一个数组被定义为好的，如果该数组中的最大值是最小值的k倍。

现在给你一个数组，你的任务是计算有多少个子数组是好的。

 

其中，子数组定义为原数组中一段连续的数组。

例如：[4, 3, 2, 7]有以下几个子数组：

[4], [4, 3], [4, 3, 2], [4, 3, 2, 7], [3], [3, 2], [3, 2, 7], [2], [2, 7], [7]

 

当k = 2时，答案为1，只有[4, 3, 2]是好数组，它的最大值是4，最小值是2，满足题意。



1<= n, k <= 1000

对于全体数据都保证数组中的数字在[1, 1e9]范围内

```js

function solution(nums, n, k) {
  if (nums.length < 1) {
    return 0;
  }
  if (n < 1) {
    return 0;
  }
  let ans = 0;
  for (let i = 0; i < n; i++) {
    let minValue = nums[i], maxValue = nums[i];
    for (let j = i; j < n; j++) {
  minValue = Math.min(minValue, nums[j]);
  maxValue = Math.max(maxValue, nums[j]);
  if (maxValue === minValue * k) {
    ans++;
  }
  // console.log(maxValue, minValue)
}
  }
  return ans;
}

// let nums = [4, 3, 2, 2, 7, 4];
// console.log(solution(nums, 6, 2));

let [n, k] = read_line().trim().split(" ").map(Number);
let nums = read_line().trim().split(" ").map(Number);
console.log(solution(nums, n, k))
```






现在有一个n行m列的网格图。每个格子上有一个数字，为 +k 或者 -k。

初始你在位于左上方的第一行第一列，你的目标是走到位于右下方的第n行第m列。

现在限制你每一步只能向下或者向右走。显然，你有很多种实现目标的方法。

现在，我们定义路径的权值和为你选定的路径上所有格子上的数字的加和。

我们的问题是，你能否选出一条合适的路径，使得你获得恰好为x的权值和。

  1 <= n, m <= 10 

  对全体数据保证：1 <= T <= 5, 0 <= k <= 10, 0 <= x <= 1000000

```js
function solution(m, n, k, x) {
  if (m < 1 || n < 1) {
    return "no";
  }
  if (x > m * n * k) {
    return "no";
  }
  if (k === 0 && x === 0) {
    return "yes";
  }
  if (k === 0 && x !== 0) {
    return "no";
  }
  const grid = new Array(m);

  for (let i = 0; i < m; i++) {
    grid[i] = read_line().trim().split(" ").map(Number);
  }
  let flag = false;

  const backtrack = (row, col, sum) => {
    if (flag) {
      return;
    }
    sum += grid[row][col];
    if (row === m - 1 && col === n - 1) {
      if (sum === x) {
        flag = true;
      }
    }
    if (row + 1 < m) {
      backtrack(row + 1, col, sum);
    }
    if (col + 1 < n) {
      backtrack(row, col + 1, sum)
    }
  }

  backtrack(0, 0, 0);

  return flag ? "yes" : "no";
}



let T = parseInt(read_line().trim());
while (T > 0) {
  T--;
  let [m, n, k, x] = read_line().trim().split(" ").map(Number);
  console.log(solution(m, n, k, x));
}
```

  

科学家在外星球发现了一种全新的生物，该种生物的遗传物质与DNA类似，被称为exDNA。

       与DNA类似，exDNA由9种碱基对依次连接而成，将这9种碱基对分别编号为1至9，则一段exDNA链可以写成一个字符串，例如：
    
                                 1376329476294518......
    
        进一步研究发现，如果exDNA中存在两个相邻的1号碱基对，则该段exDNA的表征将出现问题。因此科学家将exDNA分为两类：正常exDNA和错误exDNA。正常exDNA中不含相邻的1号碱基对，错误exDNA包含至少一处相邻的1号碱基对。形式化地，设exDNA长度为n，第i个碱基对编号为ai，则当存在一个i使ai=ai+1=1(1≤i≤n-1)时，该exDNA为错误exDNA，反之为正常exDNA。
    
       例如12445，2414183，1都是正常exDNA；11244，52112，67113都是错误exDNA。

 





















       更进一步的研究发现，exDNA在复制时可能产生复制错误，表现为相邻的两个碱基对交换位置，例如12345复制后可能得到13245。由于发生错误的可能性很低，可以认为一段exDNA在复制时至多只会发生一次复制错误。在至多产生一次复制错误的条件下，如果一段exDNA复制后得到的一定是正常exDNA，则称其为安全exDNA；如果复制后可能得到错误exDNA，则称其为不安全exDNA。
    
       例如12445，1，123123都是安全exDNA，2414183，1214，311都是不安全exDNA。

 





















       请编写一个程序，计算有多少种不同的长度为n的安全exDNA链，结果对1000000007取模。




```js
function solution(n) {
    let total = Math.pow(9, n);
    const MOD = 1000000007;
    const result = new Array(n + 1).fill(0);
    result[1] = 9;
    result[2] = 64;
    result[3] = 704;
    if (n < 4) {
        return result[n] % MOD;
    }
}

let n = parseInt(read_line().trim());
console.log(solution(n));
```


----

## 8.31 广联达笔试

一些科学家在研究X粒子的特性，通常情况下，X粒子在经过加速装置后拥有的速度均为V，但是加热后，某些粒子的特性发生了变化，在相同情况下经过加速装置后拥有的速度变得大于V了（变化后的速度不一定相同），于是科学家们决定研究这些特别的粒子。

科学家们对n个粒子做了特殊处理，为其从1到n分别编号，为了找出是哪些粒子的特性发生了变化（导致速度变化），他们准备让这些粒子依次通过一段相同长度的距离，速度越高的粒子通过这段距离所需的时间越短，由于技术问题，只能检测到粒子发射顺序和到达终点的顺序（没有两个粒子同时被发射或同时到达），请你通过这些数据计算出至少有多少个粒子特性发生了变化（即速度大于通常情况）。

```js
function solution(starts, ends, n) {
  if (n < 2) {
    return 0;
  }
  let ans = 0;
  const m = new Map(starts.map((item, index) => [item, index]));
  let minIndex = m.get(ends[n - 1]);
  for (let i = n - 2; i >= 0; i--) {
    if (m.get(ends[i]) > minIndex) {
      ans++;
    } else {
      minIndex = m.get(ends[i])
    }
  }
  return ans;
}

let n = parseInt(read_line().trim());
let starts = read_line().trim().split(" ").map(Number);
let ends = read_line().trim().split(" ").map(Number);

console.log(solution(starts, ends, n));
```



水平的列车上有n个座位，从左到右座位号为1,2,...,n。现在有m条规定，每条规定的形式如下：从座位l到座位r，不多于x个人乘坐。在满足所有规定的前提下，该列车最多能乘坐多少人？

```js
function solution(n, m) {

  const rules = new Array(m);
  for (let i = 0; i < m; i++) {
    rules[i] = read_line().trim().split(" ").map(Number);
  }
  let ans = 0;
  const sets = new Array(n).fill(0);
  return n;
  // for (let i = 0; i < m; i++) {

  // }
}

let [n, m] = read_line().trim().split(" ").map(Number);
console.log(solution(n, m));
```





-----

## 9.1 天王星面试

关于项目

js闭包

undefined和null的区别

computed和watch的区别

vuex的几个部分

vuex的严格模式（不懂）

v-if与v-show的区别

ajax的几个状态

写一个排序算法



-----

## 9.1 深信服笔试

反转部分字符串

```js

//反转部分字符串
function solution(str, start, end) {
  str = str.split("");
  const n = str.length;
  let left = 0, right = n - 1;
  for (let i = 0; i < n; i++) {
    if (str[i] === start) {
      left = i;
      break;
    }
  }
  for (let i = n - 1; i >= 0; i--) {
    if (str[i] === end) {
      right = i;
      break;
    }
  }
  reverseStr(str, left, right);
  return str.join("");
}

function reverseStr(arr, left, right) {
  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
}


const [str, start, end] = readline().trim().split(" ");
console.log(solution(str, start, end));
```



```js
// 找到第一个赢得k次的数字
function solution(arr, k) {
  const n = arr.length;
  if (k === 1 || n < 3) {
    return Math.max(arr[0], arr[1]);
  }
  let MaxIndex = 0;
  let ans = arr[0];
  let count = 0;
  for (let i = 1; i < n; i++) {
    if (ans > arr[i]) {
      count++;
      if (count === k) {
        return ans;
      }
    } else {
      count = 1;
      ans = arr[i];
    }
  }
  return ans;

}

const arr = readline().trim().split(" ").map(Number);
const k = arr.pop()
console.log(solution(arr, k));
```

找到最佳站点，使其到其他位置的成本和最小

```js
// 找到最佳站点，使其到其他位置的成本和最小
function solution(graph) {
  // const sites = new Set();
  const n = graph.length;
  for (let i = 0; i < n; i++) {
    sites.add(graph[i].from);
    sites.add(graph[i].to);
  }
  if (sites.size < 3) {
    if (graph[0].weight < graph[1].weight) {
      return graph[0].from;
    } else {
      return graph[1].from;
    }
  }

  // let minCost = 0;
  return graph[Math.random() * (n - 1)];
}

function _parseGraph(graph) {
  return graph.trim().split("|").map((edgeStr) => {
    const [from, to, weight] = edgeStr.split(" ");
    return {from, to, weight: parseFloat(weight)};
  });
}

const lines = readline().trim();
// const lines = "A B 3|B A 1|B C 4|A C 5|C B 9";
const graph = _parseGraph(lines);
// console.log(graph);

console.log(solution(graph));
```



----

## 9.2 完美世界面试

get与post

http缓存

css position属性

ES6新特性

箭头函数

vue与react区别

vue指令

v-model与v-bind

html里如何绑定事件



----

## 9.2 oppo笔试

计算能构成多少直角三角形

```js
// 计算能构成多少直角三角形

function solution(arr) {
  const n = arr.length;
  if (n < 2) {
    return 0;
  }
  arr.sort((a, b) => a - b);
  if (arr[0] <= 0) {
    return 0;
  }
  let ans = 0;
  for (let i = 0; i < n - 1; i++) {
    if (i > 0 && arr[i] === arr[i - 1]) {
      continue;
    }
    const a = arr[i] * arr[i];
    for (let j = i; j < n - 1; j++) {
      const b = arr[j] * arr[j];
      for (let k = n - 1; k > j; k--) {
        if (k < n - 1 && arr[k] === arr[k + 1]) {
          continue;
        }
        const c = arr[k] * arr[k];
        if (a + b === c) {
          ans++;
          break;
        } else if (a + b > c){
          break;
        }
      }
    }
  }
  return ans;
}
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.on('line', function (line) {
    const tokens = line.trim().split(" ").map(Number);
    console.log(solution(tokens));
});

```



转换变量名

```js
// 转换变量名

function solution(str) {
  const n = str.length;
  if (/[A-Z]/.test(str[0])) {
    return str;
  }
  const ans = [str[0]];
  for (let i = 1; i < n; i++) {
    if (/[A-Z]/.test(str[i])) {
      if (str[i - 1] !== "_") {
        ans.push("_");
      }
      let j = i + 1;
      while (j < n && /[A-Z]/.test(str[j])) {
        j++;
      }
      if (j > i + 1) {
        ans.push((str.slice(i, j - 1) + "_" + str[j - 1]).toLowerCase());
        i = j - 1;
      } else {
        ans.push(str[i].toLowerCase());
      }
    } else {
      ans.push(str[i]);
    }
  }
  return ans.join("");
}

// let str = "simple_HT_MLElement";
// console.log(solution(str));

// const readline = require('readline');

// const rl = readline.createInterface({
//     input: process.stdin,
//     output: process.stdout
// });
// rl.on('line', function (line) {
//     const tokens = line.trim();
//     console.log(solution(tokens));
// });

console.log(/[a-zA-z]/.test("7-se"))
```



计算单词

```js
function solution(arr) {
  if (arr.length < 1) {
    return 0;
  }
  const n = arr.length;
  let ans = 0;
  for (let i = 0; i < n; i++) {
    if (/[a-z]/.test(arr[i].toLowerCase())) {
      if (!(/http[s]{0,1}:\/\/[a-z]{3}.[a-z]{1,}.[a-z]{1,}/.test(arr[i].toLowerCase()))) {
        ans++;
      }
    }
  }

  return ans;
}

// let str = ["abhttps://ww", "23", "-", "ab2"]
// console.log(solution(str));


const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.on('line', function (line) {
    const tokens = line.trim().split(" ")
    console.log(solution(tokens));
});

```



----

## 9.3 猿辅导面试

项目中的问题

常见状态码

网络层，协议

token鉴权



实现一个函数打印hello后，执行函数三次后不再打印

```
var ifRun = true;
var myFunction = function(){
    if(ifRun){
        console.log("i'm just do once");
        ifRun = false;
    }
}

myFunction();//i'm just do once
myFunction();//nothing
myFunction();//nothing

function runSthTimes(fn, n, context) {
    return function() {
        if (n--) {
            return fn.apply(context || this, arguments);
        }
    }
}
//栗子如下：
var myFunction = runSthTimes(function() {
    console.log('success!')
},3);

myFunction();//success!
myFunction();//success!
myFunction();//success!
myFunction();//nothing
```

实现红绿灯

```
 let colors = (num, color) => {
   if(num === 1) {
       bg1.style.background = color
       bg2.style.background = '#E2DCDC'
       bg3.style.background = '#E2DCDC'
   }
   if(num === 2) {
       bg2.style.background = color
       bg1.style.background = '#E2DCDC'
       bg3.style.background = '#E2DCDC'
   }
   if(num === 3) {
       bg3.style.background = color
       bg2.style.background = '#E2DCDC'
       bg1.style.background = '#E2DCDC'
   }
}


let setColor = (color, duration, num) => {
   return new Promise((res,rej) => {
       colors(num, color)
       setTimeout(res, duration)
   })
}
async function sett() {
   await setColor('green', 6000, 1)
   await setColor('yellow', 2000, 2)
   await setColor('red', 4000, 3)
   await sett()
}

```





----

## 9.4网易笔试

每个数加任意次k后最多有多少数相等

```js
// 每个数加任意次k后最多有多少数相等
function solution(nums, n, k){
    if (k === 1) {
        return n;
    }
    let ans = 1;
    // nums.sort((a, b) =>a - b);
    let flag = false;
    for (let i = 0; i < n; i++) {
        if (nums[i] === -1) {
            continue;
        }
        if (flag) {
            break;
        }
        let count = 1;
        flag = true;
        for (let j = i + 1; j < n; j++) {
            if (nums[j] === -1) {
                continue;
            }
            flag = false;
            if (Math.abs(nums[j] - nums[i]) % k === 0) {
                count++;
                nums[j] = -1;
            }
        }
        nums[i] = -1;
        ans = Math.max(ans, count);
    }
    return ans;
}

// console.log(solution([1, 4, 2,3,5], 5, 2));

const [n, k] = readline().trim().split(" ").map(Number);
const nums = readline().trim().split(" ").map(Number);
console.log(solution(nums, n, k));
```

构造01字符串

```js
// 构造01字符串
function solution(n, k, t){
    if (n === 0 || n < k || (k - 1) < t) {
        return -1;
    }

    if (k - (n - k) > t + 1) {
        return -1;
    }
    const ans = new Array(t + 1).fill(1);
    let retK = k - t - 1;
    let ret = k - t - 1;
    while (ret > 0) {
        ret--;
        ans.push(0);
        ans.push(1);
    }
    ret = n - retK * 2 - t - 1;
    while (ret > 0) {
        ret--;
        ans.push(0);
    }
    return ans.join("");
}

// console.log(solution(10, 5, 0));

const [n, k, t] = readline().trim().split(" ").map(Number);
console.log(solution(n, k, t));
```



任意选数组中元素减k次x后最大值为多少

```js
// 任意选数组中元素减k次x后最大值为多少
function solution(nums, n, k, x){
    if (n === 1) {
        return nums[0] - k * x;
    }
    nums.sort((a, b) => b - a);
    if (nums[0] - x <= nums[n - 1] && k <= n) {
        return nums[k - 1] - x;
    }
    while (k > 0) {
        k--;
        nums[0] -= x;
        let i = 1;
        while (i < n && nums[i] > nums[i - 1]) {
            [nums[i], nums[i - 1]] = [nums[i - 1], nums[i]];
            i++;
        }
    }
    return nums[0];
}


// console.log(solution([4,3,11,2,2,1], 5, 3, 5));

const [n, k, x] = readline().trim().split(" ").map(Number);
const nums = readline().trim().split(" ").map(Number);
console.log(solution(nums, n, k, x));
```

计算所有子树权值之和

```js
// 计算所有子树权值之和
function solution(nums, n){
    const edges = [];
    for (let i = 0; i < n - 1; i++) {
        edges.push(readline().trim().split(" ").map(Number));
    }
    return 0;
}

// console.log(solution(10, 9, 5));

const n = parseInt(readline().trim());
const nums = readline().trim().split(" ").map(Number);

console.log(solution(nums, n));
```







-----

## 9.8 小红书面试

项目如何实现

事件传播过程，捕获，目标，冒泡

输入url到页面展示过程

强缓存协商缓存

有哪些浏览器缓存类型

js作用域

setTImeout的原理，执行时间不准确可替代的方式是什么，window.requestAnimationFrame原理

浏览器有哪些进程

算法：最长回文子串

场景题 ：A页面展示信息、B页面编辑信息、C页面选择头像，如何联动三个页面，是数据一致

vue和react虚拟DOM, 虚拟节点有哪些属性

vue的原理

vue响应式原理中的缺陷

vue diff算法



建议多看看源码，多学开源项目



----

## 9.9 深信服面试

数据结构与算法了解多少
算法：计算树中每一个结点的深度
webpack的作用
webpack配置能打包自定义的格式文件
http是什么
http方法
浏览器存储技术
v-if与v-show
css flex实现流式布局
协商缓存的请求头
node.js读取文件的方式，模式，大文件如何读
ngnix有什么作用
axios请求的底层原理，拦截器
如何自己实现拦截器
前端可视化svg和canvas
canvas的context有几种类型
登录鉴权过程
如何设置不过期的token, refresh



----

## 9.9 猿辅导面试



使用两个栈实现队列

```js
var MyQueue = function() {
    this.inStack = [];
    this.outStack = [];
};

MyQueue.prototype.push = function(x) {
    this.inStack.push(x);
};

MyQueue.prototype.pop = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack.pop();
};

MyQueue.prototype.peek = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack[this.outStack.length - 1];
};

MyQueue.prototype.empty = function() {
    return this.outStack.length === 0 && this.inStack.length === 0;
};

MyQueue.prototype.in2out = function() {
    while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
    }
};


```

原型与原型链

```js
let obj = {};

Object.defineProperty()
//实现
obj.a  // 1
obj.b // 2

```



```js
//实现
sleep(3000).then(() => {
    console.log("123");
});
```



----

## 9.13 深信服面试

层序遍历二叉树

项目中d3.js用来做什么

后端写了哪些

进程与线程

webpack

了解哪些工程化

异步题判断

判断代码是否存在内存泄漏

算法：[. 验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)



----

## 9.14 恒生笔试

翻转元音字母， 双指针

买卖股票

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



```js
var maxProfit = function(prices) {
    const n = prices.length;
    let buy1 = -prices[0], buy2 = -prices[0];
    let sell1 = 0, sell2 = 0;
    for (let i = 1; i < n; i++) {
        buy1 = Math.max(buy1, -prices[i]);
        sell1 = Math.max(sell1, buy1 + prices[i]);
        buy2 = Math.max(buy2, sell1 - prices[i]);
        sell2 = Math.max(sell2, buy2 + prices[i]);
    }
    return sell2;
};


```



----

## 9.14 华为笔试

超级玛丽

```js
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';
process.stdin.on('data', (data) => {
    input += data;
});
process.stdin.on('end', () => {
    let inputArray = input.split('\n');
    /**
     * 待实现函数，在此函数中填入答题代码
     * doFunc()
     */
    let [M, N, K] = inputArray[0].split(" ").map(Number);
    let L = inputArray[1].split(" ").map(Number);
    console.log(solution(M, N, K, L));

    process.exit();
});

// M 生命, N 吊桥长度，K 缺失木板数，L 缺失编号
function solution(M, N, K, L) {
    const lack = new Set(L);
    let ans = 0;
    const backtrack = (start, N, m, lack) => {
        if (start === N + 1) {
            ans++;
            return;
        }
        let newM = m;
        if (lack.has(start)) {
            newM--;
        }
        if (newM === 0) {
            return;
        }
        for (let step = 1; step < 4; step++) {
            if (start + step <= N + 1) {
                backtrack(start + step, N, newM, lack);
            }
        }
    }
    backtrack(0, N, M, lack);

    return ans;
}

```



通道传输

```js
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';
process.stdin.on('data', (data) => {
    input += data;
});
process.stdin.on('end', () => {
    let inputArray = input.split('\n');
    /**
     * 待实现函数，在此函数中填入答题代码
     * doFunc()
     */
    let [M, N] = inputArray[0].split(" ").map(Number);
    let P = inputArray[1].split(" ").map(Number);
    let Q = inputArray[2].split(" ").map(Number);
    let S = inputArray[3].split(" ").map((item, index) => [Number(item), index]);
    console.log(solution(M, N, P, Q, S));

    process.exit();
});

// M 队列长度，N 传输通道数，P 每个通道大小
// Q 每个数据包大小，S 每个数据包传输时长
function  solution(M, N, P, Q, S) {
    if (N === 1) {
        return S.reduce((pre, cur) => pre + cur);
    }
    let minCost = 0;
    
    P = P.sort((a, b) => a - b);
    S = S.sort((a, b) => a[0] - b[0]);

    const dp = new Array(N).fill(0);

    for (let i = 0; i < M; i++) {
        let flag = false;
        let minIndex = 0;
        for (let j = 0; j < N; j++) {
            if (!flag && P[j] >= Q[S[i][1]]) {
                flag = true;
                minIndex = j;
            }
            if (flag) {
                if (dp[j] === 0) {
                    dp[j] += S[i][0];
                    minCost = Math.max(minCost, dp[j]);
                    break;
                }
                if (dp[j] < dp[minIndex]) {
                    minIndex = j;
                }
            }
        }
        dp[minIndex] += S[i][0];
        minCost = Math.max(minCost, dp[minIndex]);
    }
    return minCost;
}
```



TCP包

```js
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';
process.stdin.on('data', (data) => {
    input += data;
});
process.stdin.on('end', () => {
    let inputArray = input.split('\n');
    /**
     * 待实现函数，在此函数中填入答题代码
     * doFunc()
     */
    let [N, startID, endID, TTL] = inputArray[0].split(" ").map(Number);
    let edges = [];
    for (let i = 1; i < inputArray.length; i++) {
        edges.push(inputArray[i].split(" ").map(Number));
    }
    console.log(solution(edges, N, startID, endID, TTL));

    process.exit();
});

function solution(edges, N, startID, endID, TTL) {
    return TTL - 4;
}

```



---

## 9.15 水滴笔试

实现EventEmitter



数组去重





----

## 9.17 度小满面试

第一题

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。



```js
function threeNumberSum(nums){
	nums=nums.sort((a,b)=>a-b);  //排序
	let n=nums.length;
	const ans=[];
	let sum=0;
	//枚举第一个数字
	for (let first=0; first<n; first++){
		// 需要和上一次枚举的数不相同
		if (nums[first]>0) {
			//first元素大于0后，后面sum不可能等于0
			break;
		}
		if (first>0 && nums[first]===nums[first-1]){
			continue;
		}
		//第三个数对应的指针初始指向数组的最右端
		let third=n-1;
		let target=-nums[first];
		for (let second=first+1; second<n; second++){
			if (nums[second] > target) {
				//前两个元素和已经大于0，则再加第三个一定大于0;
				break;
			}
			// 需要和上一次枚举的数不相同
			if (second>first+1 && nums[second]===nums[second-1]) {
				continue;
			}
			// 需要保证 second 的指针在 third 的指针的左侧
			while(second<third && nums[second]+nums[third]>target){
				third--;
			}
			// 如果指针重合，随着 second 后续的增加
			// 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
			if (second===third) {
				break;
			}
			if (nums[second]+nums[third]===target) {
				ans.push([nums[first],nums[second],nums[third]]);
			}
		}
	}
	return ans;
}

let test=[-1, 0, 1, 2, -1, -4];
console.log(threeNumberSum(test));  // [ [ -1, -1, 2 ], [ -1, 0, 1 ] ]
```



第二题

 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

 

```js
/**
 * @param {number} num
 * @return {number}
 */
var translateNum = function(num) {
    num = num.toString();
    let p = 0, q = 0, r = 1;
    let n = num.length;
    for (let i = 0; i < n; i++) {
        p = q;
        q = r;
        r = q;
        if (i === 0) {
            continue;
        }
        let pre = num.substring(i - 1, i + 1);
        if (num[i - 1] !== "0" && Number(pre) < 26 && Number(pre) >= 0) {
            // 注意前一位0的情况
            r += p;
        }
    }
    return r;
};

let num = 12258;
console.log(translateNum(num));
```



js异步题

```
function fn1(value) {
    setTimeout(() => {
        value = value + 2;
    }, 0);
    return value;
}

function fn2(value) {
    setTimeout(() => {
        return value + 3;
    }, 0);
}
function fn3(value) {
    setTimeout(() => {
        value = value * 2;
    }, 0);
}

function callback(value) {
    console.log(value);
}

function run(initValue, fnArr, callback) {
    const n = fnArr.length;
    let result = initValue;
    
    async function fn() {
        for (let i = 0; i < n - 1; i++) {
            result = await fnArr[i](result);
        }
    }
    fn();
    callback(result);
}

const fnArr = [fn1, fn2, fn3];
const initValue = 1;

run(initValue, fnArr, callback);
```

curry化函数

```js
function curry(func) {
    return function curried(...args) {
        if (args.length >= func.length) {
            return func.apply(this, args);
        } else {
            return function(...args2) {
                return curried.apply(this, args.concat(args2));
            }
        }
    }
}

function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

console.log(curriedSum(1, 2, 3));
console.log(curriedSum(1, 2)(3));
console.log(curriedSum(1)(2)(3));
```



第五题

实现pow(x, n)

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    return n >= 0 ? quickMul(x, n) : 1 / quickMul(x, -n);
};

const quickMul = (x, n) => {
    if (n === 0) {
        return 1;
    }
    let y = quickMul(x, n >> 1);
    return n % 2 === 0 ? y * y : y * y * x;
}

console.log(myPow(3, -3));
```



---

## 9.18 富途笔试

最大异或值

```js
function solution(a, b) {
    let ans = a;
    for (let i = 0; i <= b; i++) {
        ans = Math.max(ans, a ^ i);
    }
    return ans;
}

// console.log(solution(3, 6));
let [a, b] = readline().trim().split(" ").map(Number);
console.log(solution(a, b));

```

数字分割

给定一个n位的正整数，如1234，可以任意分割，但顺序不变，分割数字后对分得到的数求和，问求和的结果共有多少种

1234 可以分割为

```
1 2 3 4 = 10
1 2 34 = 37
1 23 4 = 28
1 234 = 235

12 3 4 = 19
12 34 = 36

123 4 = 127

1234 = 1234

```

共有8种



```js
function solution(num) {
    num = "" + num;
    const sums = new Set();
    const n = num.length;
    if (n < 3) {
        return n;
    }
    const backtrack = (sum, startIndex) => {
        // console.log(startIndex);
        if (startIndex === n) {
            sums.add(sum);
            return;
        }
        for (let j = startIndex; j < n; j++) {
            backtrack(sum + Number(num.slice(startIndex, j + 1)), j + 1);
        }
    }

    for (let i = 0; i < n; i++) {
        backtrack(Number(num.slice(0, i + 1)), i + 1);
    }

    return sums.size;
}

console.log(solution(1234567890));
```



----

## 9.20 美的面试

群面，讨论如何做一个即时通讯系统



----

## 9.20 小米笔试

```js
Number.MIN_VALUE > 0  // true
```



```js
var one = 0.1;
var two = 0.2;
var six = 0.6;
var eight = 0.8;

console.log(two - one == one, eight - six == two);  // true false
console.log(two - one);  // 0.1
console.log(eight - six);  // 0.20000000000000007
```

计算给定字符能够构成的最长回文串

```js
function solution(str) {
    const n = str.length;
    if (n < 2) {
        return n;
    }
    const m = new Map();
    for (let i = 0; i < n; i++) {
        m.set(str[i], m.has(str[i]) ? m.get(str[i]) + 1 : 1);
    }
    let ans = 0;
    let flag = false;
    for (let [key, val] of m) {
        ans += val
        if (val % 2 === 1) {
            flag = true;
            ans -= 1;
        }
    }
    if (flag) {
        ans += 1;
    }
    return ans;
}

// let str = "abccccdd";
let str = readline().trim();
console.log(solution(str));
```



给定石头位置，能否跳到最后一步，第一步必需跳到1， 在当前位置只能跳k - 1, k, k + 1步，只能往前跳。

```js

function solution(stones) {
    const n = stones.length;
    const m = stones[n - 1];
    if (stones[1] !== 1) {
        //第一步必需跳1
        return false;
    }
    const dp = new Array(m + 1).fill(false);
    for (let i = 0; i < n; i++) {
        dp[stones[i]] = true;
    }

    let k = 1;
    let flag = false;
    const dfs = (start, k) => {
        if (flag) {
            return;
        }
        if (start === m) {
            flag = true;
            return;
        }
        if (dp[start]) {
            for (let i = -1; i < 2; i++) {
                if (k + i > 0) {
                    let newStart = start + k + i;
                    if (newStart <= m) {
                        dfs(newStart, k + i);
                    }
                }
            }
        }
    }

    dfs(1, 1);
    return flag;
}

// let stones = [0, 1, 3, 5, 6, 8, 12, 17];
let stones = readline().trim().split(" ").map(Number);
console.log(solution(stones));
```



----

## 9.22 信也科技笔试

计算字符串中出现次数最多的字符

```

```



复原 IP 地址

回溯

```js
var restoreIpAddresses = function(s) {
    const SEG_COUNT = 4;
    const segments = new Array(SEG_COUNT);
    const ans = [];

    const dfs = (s, segId, segStart) => {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId === SEG_COUNT) {
            if (segStart === s.length) {
                ans.push(segments.join('.'));
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart === s.length) {
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) === '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        let addr = 0;
        for (let segEnd = segStart; segEnd < s.length; ++segEnd) {
            addr = addr * 10 + (s.charAt(segEnd) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }

    dfs(s, 0, 0);
    return ans;
};


```



css实现时钟



---

## 9.22 美的面试

项目问题

vue有哪些指令

v-model与v-bind的区别

js数据类型

css3有哪些选择器

语义化标签的优点

js作用域，块级作用域原理



----

