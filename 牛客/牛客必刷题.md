## **BM1** **反转链表**

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

**思路**

如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表



首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。



#### 迭代

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
    return pre;
}
module.exports = {
    ReverseList : ReverseList
};
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)。



#### 递归

递归版本稍微复杂一些，其关键在于反向工作。

递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // 和双指针法初始化是一样的逻辑
        // let cur = head;
        // let pre = NULL;
    return reverse(null, pHead);

}

const reverse = (pre, cur) => {
    if (!cur) {
        return pre;
    }
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
    return reverse(pre, temp);
}

module.exports = {
    ReverseList : ReverseList
};
```

我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // 边缘条件判断
    if (pHead === null) return null;
    if (pHead.next === null) return pHead;

    // 递归调用，翻转第二个节点开始往后的链表
    let last = ReverseList(pHead.next);
    // 翻转头节点与第二个节点的指向
    pHead.next.next = pHead;
    // 此时的 head 节点为尾节点，next 需要指向 NULL
    pHead.next = null;
    return last;
}

module.exports = {
    ReverseList : ReverseList
};
```

复杂度分析

时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。

空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。



----

## **BM2** **链表内指定区间反转**

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

 提示：

链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。

思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。

#### 穿针引线

![反转链表2](E:\pogject\学习笔记\image\niuke\反转链表2.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param m int整型 
  * @param n int整型 
  * @return ListNode类
  */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;

    return dummyNode.next;
}

function reverseLinkedList(pHead){
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
}


module.exports = {
    reverseBetween : reverseBetween
};
```

**复杂度分析**

- 时间复杂度：*O*(*N*)，其中 *N* 是链表总节点数。最坏情况下，需要遍历整个链表。
- 空间复杂度：*O*(1)。只使用到常数个变量。



#### 一次遍历「穿针引线」（头插法）

方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。

整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。

![反转链表2_2](E:\pogject\学习笔记\image\niuke\反转链表2_2.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; i++) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}



module.exports = {
    reverseBetween : reverseBetween
};
```

复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 是链表总节点数。最多只遍历了链表一次，就完成了反转。

空间复杂度：O(1)O(1)。只使用到常数个变量。



----

## **BM3** **链表中的节点每k个一组翻转**

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`



我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。

接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。

因此，在翻转子链表的时候，我们不仅需要子链表头节点 `head`，还需要有 `head` 的上一个节点 `pre`，以便翻转完后把子链表再接回 `pre`。

但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。

反复移动指针 `head` 与 `pre`，对 `head` 所指向的子链表进行翻转，直到结尾，我们就得到了答案。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    const dummyHead = new ListNode(-1);  // 哑结点
    dummyHead.next = head;

    let pre = dummyHead;

    while (head) {
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i < k; i++) {
            tail = tail.next;
            if (!tail) {
                return dummyHead.next;
            }
        }
        const next = tail.next;
        [head, tail] = myReverse(head, tail);
        
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = next;
        pre = tail;
        head = tail.next;
    }
    return dummyHead.next;
};

const myReverse = (head, tail) => {
    let prev = tail.next;
    let p = head;
    while (prev !== tail) {
        const next = p.next;
        p.next = prev;
        prev = p;
        p = next;
    }
    return [tail, head];
}

module.exports = {
    reverseKGroup : reverseKGroup
};
```





----

## **BM4** **合并两个排序的链表**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列



#### 递归

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function Merge(pHead1, pHead2)
{
    if (pHead1 === null) {
        return pHead2;
    } else if (pHead2 === null) {
        return pHead1;
    } else if (pHead1.val < pHead2.val) {
        pHead1.next = Merge(pHead1.next, pHead2);
        return pHead1;
    } else {
        pHead2.next = Merge(pHead1, pHead2.next);
        return pHead2;
    }
}
module.exports = {
    Merge : Merge
};
```



#### 迭代

```js
function ListNode(x){
    this.val = x;
    this.next = null;
}

function Merge(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}
module.exports = {
    Merge : Merge
};
```



----

## **BM5** **合并k个已排序的链表**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

要求：时间复杂度 O(nlogk)



#### 顺序合并

我们可以想到一种最朴素的方法：用一个变量ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和ans 合并，答案保存到 ans 中。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    let ans = null, n = lists.length;
    for (let i = 0; i < n; i++) {
        ans = MergeTwoLists(ans, lists[i]);
    }
    return ans;
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 分治合并

![合并k个链表](E:\pogject\学习笔记\image\niuke\合并k个链表.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

function merge(lists, left, right) {
    if (left === right) {
        return lists[left];
    }
    if (left > right) {
        return null;
    }
    const mid = (left + right) >> 1;
    return MergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));
}
/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    return merge(lists, 0, lists.length - 1);
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 使用优先队列合并

这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，kk 个链表就最多有 kk 个满足这样条件的元素，每次在这些元素里面选取 \textit{val}val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

思路：新建小顶堆，小顶堆的大小是k，不断从每个链表的头节点开始不断加入小顶堆中，然后取出堆顶值，也就是最小值，然后继续往小顶堆中插入这个最小值在链表的next节点
复杂度：时间复杂度O(kn * logk)，优先队列的大小是k，每次插入和删除是O(logk)，总共k * n的节点个数，每个节点插入删除一次，所以总的复杂度是O(kn*logk)。空间复杂度是O(k)，即优先队列的大小

```js
class Heap {
    constructor(comparator = (a, b) => a - b, data = []) {
        this.data = data;
        this.comparator = comparator;  // 比较器
        this.heapify();  // 堆化
    }

    heapify() {
        if (this.size() < 2) {
            return;
        }
        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i--) {
            this.bubbleDowm(i);  // bubbleDown操作
        }
    }

    peek() {
        if (this.size() === 0) {
            return null;
        }
        return this.data[0];  // 查看堆顶
    }

    offer(value) {
        this.data.push(value);  // 加入数组
        this.bubbleUp(this.size() - 1);  //调整加入的元素在小顶堆中的位置
    }

    poll() {
        if (this.size() === 0) {
            return null;
        }
        const result = this.data[0];
        const last = this.data.pop();
        if (this.size() !== 0) {
            this.data[0] = last;  // 交换第一个元素和最后一个元素
            this.bubbleDowm(0);  // bubbleDown操作
        }
        return result;
    }

    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = (index - 1) >> 1;  // 父节点的位置
            //如果当前元素比父节点的元素小，就交换当前节点和父节点的位置
            if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {
                this.swap(index, parentIndex);  //交换自己和父节点的位置
                index = parentIndex;
            } else {
                break;  //如果当前元素比父节点的元素大，不需要处理
            }
        }
    }

    bubbleDowm(index) {
        const lastIndex = this.size() - 1;  // 最后一个节点的位置
        while (true) {
            const leftIndex = index * 2 + 1;  //左节点的位置
            const rightIndex = index * 2 + 2;  //右节点的位置
            let findIndex = index;  //bubbleDown节点的位置
            //找出左右节点中value小的节点
            if (leftIndex <= lastIndex && this.comparator(this.data[leftIndex], this.data[findIndex]) < 0) {
                findIndex = leftIndex;
            }
            if (rightIndex <= lastIndex && this.comparator(this.data[rightIndex], this.data[findIndex]) < 0) {
                finished = rightIndex;
            }
            if (index !== findIndex) {
                this.swap(index, findIndex);  //交换当前元素和左右节点中value小的
                index = findIndex;
            } else {
                break;
            }
        }
    }

    swap(index1, index2) {
        [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]]
    }

    size() {
        return this.data.length;
    }
}


/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function mergeKLists(lists){
    const res = new ListNode(-1);

    let prev = res;

    const h = new Heap(comparator = (a, b) => a.val - b.val);

    lists.forEach(list => {
        //插入每个链表的第一个节点
        if (list) {
            h.offer(list);
        }
    });
    while (h.size()) {
       const n = h.poll();  //取出最小值
       prev.next = n;  //最小值加入p的next后
       prev = prev.next;  // 移动节点
       if (n.next) {
        h.offer(n.next);  //插入最小节点的后一个节点
       }
    }

    return res.next;
}


module.exports = {
    mergeKLists : mergeKLists
};
```



----

## **BM6** **判断链表中是否有环**

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

#### **哈希表**

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    const visited = new Set();
    while(head !== null) {
        if (visited.has(head)) {
            return true;
        }
        visited.add(head);
        head = head.next;
    }
    return false;
}
module.exports = {
    hasCycle : hasCycle
};
```



#### **快慢指针**

具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    if (head === null || head.next === null) {
        return false;
    }
    let slow = head;
    let fast = head.next;
    while(slow !== fast) {
        if (fast === null || fast.next === null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;;
}
module.exports = {
    hasCycle : hasCycle
};
```



----

## **BM7** **链表中环的入口结点**

#### 哈希表

一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(pHead)
{
    // write code here
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



#### 快慢指针

![环形链表入口节点](E:\pogject\学习笔记\image\niuke\环形链表入口节点.png)

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(head)
{
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;

    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



----

## **BM8** **链表中倒数最后k个结点**

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

#### 顺序查找

思路与算法

最简单直接的方法即为顺序查找，假设当前链表的长度为 nn，则我们知道链表的倒数第 kk 个节点即为正数第 n - kn−k 个节点，此时我们只需要顺序遍历到链表的第 n - kn−k 个节点即为倒数第 kk 个节点。

我们首先求出链表的长度 nn，然后顺序遍历到链表的第 n - kn−k 个节点返回即可。

```go
func getKthFromEnd(head *ListNode, k int) (kth *ListNode) {
    n := 0
    for node := head; node != nil; node = node.Next {
        n++
    }
    for kth = head; n > k; n-- {
        kth = kth.Next
    }
    return
}

```

#### 双指针

快慢指针的思想。我们将第一个指针 \textit{fast}fast 指向链表的第 k + 1k+1 个节点，第二个指针 \textit{slow}slow 指向链表的第一个节点，此时指针 \textit{fast}fast 与 \textit{slow}slow 二者之间刚好间隔 kk 个节点。此时两个指针同步向后走，当第一个指针 \textit{fast}fast 走到链表的尾部空节点时，则此时 \textit{slow}slow 指针刚好指向链表的倒数第kk个节点。

我们首先将 \textit{fast}fast 指向链表的头节点，然后向后走 kk 步，则此时 \textit{fast}fast 指针刚好指向链表的第 k + 1k+1 个节点。

我们首先将 \textit{slow}slow 指向链表的头节点，同时 \textit{slow}slow 与 \textit{fast}fast 同步向后走，当 \textit{fast}fast 指针指向链表的尾部空节点时，则此时返回 \textit{slow}slow 所指向的节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */
function FindKthToTail( head ,  k ) {
    // write code here
    let fast = head, slow = head;

    while (fast && k > 0) {
        [fast, k] = [fast.next, k - 1];
    }
    if (k > 0) {
        return null;
    }
    while (fast) {
        [fast, slow] = [fast.next, slow.next];
    }
    return slow;
}
module.exports = {
    FindKthToTail : FindKthToTail
};
```



----

## **BM9** **删除链表的倒数第n个节点**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。



在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 \textit{next}next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。

例如，在本题中，如果我们要删除节点 yy，我们需要知道节点 yy 的前驱节点 xx，并将 xx 的指针指向 yy 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。

特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。

#### 计算链表长度

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。

为了方便删除操作，我们可以从哑节点开始遍历 L-n+1L−n+1 个节点。当遍历到第 L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const len = getLength(head);
    let cur =dummyNode;
    for (let i = 1; i < len - n + 1; i++) {
        cur = cur.next;
    }
    cur.next = cur.next.next;

    return dummyNode.next;
}

function getLength(head) {
    let len = 0;
    while (head !== null) {
        len++;
        head = head.next;
    }
    return len;
}
module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const stack = [];

    let cur =dummyNode;
    while (cur !== null) {
        stack.push(cur);
        cur= cur.next;
    }
    for (let i = 0; i < n; i++) {
        stack.pop();
    }
    let prev = stack[stack.length - 1];
    prev.next = prev.next.next;

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 双指针

由于我们需要找到倒数第 nn 个节点，因此我们可以使用两个指针 \textit{first}first 和 \textit{second}second 同时对链表进行遍历，并且 \textit{first}first 比 \textit{second}second 超前 nn 个节点。当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 就恰好处于倒数第 nn 个节点。

根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 \textit{second}second 指向哑节点，其余的操作步骤不变。这样一来，当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 的下一个节点就是我们需要删除的节点。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let first = head, second = dummyNode;

    for (let i = 0; i < n; i++) {
        first = first.next;
    }
    while (first !== null) {
        first = first.next;
        second = second.next;
    }
    
    second.next = second.next.next;  // 删除结点

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



----

## **BM10** **两个链表的第一个公共结点**

#### 哈希集合

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都是两个链表的公共节点，因此在链表 \textit{headB}headB 中遍历到的第一个在哈希集合中的节点就是两个链表的第一个公共节点，返回该节点。

如果链表 \textit{headB}headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 \text{null}null。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    vis := map[*ListNode]bool{}
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        vis[tmp] = true
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if vis[tmp] {
            return tmp
        }
    }
    return nil
}


```



#### 双指针

使用双指针的方法，可以将空间复杂度降至 O(1)O(1)。

只有当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，两个链表才可能相交。因此首先判断链表 \textit{headA}headA 和 \textit{headB}headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 \text{null}null。

当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，创建两个指针 \textit{pA}pA 和 \textit{pB}pB，初始时分别指向两个链表的头节点 \textit{headA}headA 和 \textit{headB}headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

- 每步操作需要同时更新指针 \textit{pA}pA 和 \textit{pB}pB。

- 如果指针 \textit{pA}pA 不为空，则将指针 \textit{pA}pA 移到下一个节点；如果指针 \textit{pB}pB 不为空，则将指针 \textit{pB}pB 移到下一个节点。

- 如果指针 \textit{pA}pA 为空，则将指针 \textit{pA}pA 移到链表 \textit{headB}headB 的头节点；如果指针 \textit{pB}pB 为空，则将指针 \textit{pB}pB 移到链表 \textit{headA}headA 的头节点。

- 当指针 \textit{pA}pA 和 \textit{pB}pB 指向同一个节点或者都为空时，返回它们指向的节点或者 \text{null}null。


```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    if (pHead1 === null || pHead2 === null) {
        return null;
    }
    let p1 = pHead1, p2 = pHead2;
    while (p1 !== p2) {
        p1 = p1 === null ? pHead2 : p1.next;
        p2 = p2 === null ? pHead1 : p2.next;
    }
    return p1;
}
module.exports = {
    FindFirstCommonNode : FindFirstCommonNode
};
```

复杂度分析

时间复杂度：O(m+n)O(m+n)，其中 mm 和 nn 是分别是链表 \textit{headA}headA 和 \textit{headB}headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。

空间复杂度：O(1)O(1)。



----

## **BM11** **链表中的两数相加**

给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

提示：

链表的长度范围为 [1, 100]
0 <= node.val <= 9
输入数据保证链表代表的数字无前导 0


进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。



#### 栈

本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head1 ListNode类 
 * @param head2 ListNode类 
 * @return ListNode类
 */
function addInList( head1 ,  head2 ) {
    // write code here
    let stack1 = [], stack2 = [];
    while (head1 !== null) {
        stack1.push(head1.val);
        head1 = head1.next;
    }
    while (head2 !== null) {
        stack2.push(head2.val);
        head2 = head2.next;
    }

    let carry = 0;
    let ans = null;
    while (stack1.length !== 0 || stack2.length !== 0 || carry !== 0) {
        let a = stack1.length ? stack1.pop() : 0;
        let b = stack2.length ? stack2.pop() : 0;
        let cur = a + b + carry;
        carry = cur > 9 ? 1 : 0;
        cur %= 10;
        let curNode = new ListNode(cur);
        curNode.next = ans;
        ans = curNode;
    }
    return ans;
}
module.exports = {
    addInList : addInList
};
```



#### 反转链表+双指针求和

先把l1和l2都进行反转
然后通过双指针进行求和
最后把结果再进行反转即可了

```js
var addTwoNumbers = function(l1, l2) {
    // 反转链表
    function reverse(head) {
        var pre = null;
        var cur = head;
        while (cur) {
            var next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    // 进行两数想加
    var reverseL1 = reverse(l1);
    var reverseL2 = reverse(l2);
    var res = null;
    var carry = 0;
    var tail = res;
    while (reverseL1 || reverseL2) {
        const x = reverseL1 ? reverseL1.val - '0' : 0;
        const y = reverseL2 ? reverseL2.val - '0' : 0;
        const sum = x + y + carry;
        if (!res) {
            res = tail = new ListNode(sum % 10);
        } else {
            tail.next = new ListNode(sum % 10);
            tail = tail.next;
        }
        carry = Math.floor(sum / 10);
        if(reverseL1) reverseL1 = reverseL1.next;
        if(reverseL2) reverseL2 = reverseL2.next;
    }
    if (carry) tail.next = new ListNode(carry);

    // 最后再反转链表=
    return reverse(res);
};

```



-----

## **BM12** **单链表的排序**

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

要求使用插入排序的方法对链表进行排序，插入排序的时间复杂度是 O(n^2)O(n 2 )，其中 nn 是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 O(n \log n)O(nlogn) 的时间复杂度和 O(1)O(1) 的空间复杂度，时间复杂度是 O(n \log n)O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)O(n 2 )），其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(\log n)O(logn)。如果要达到 O(1)O(1) 的空间复杂度，则需要使用自底向上的实现方式。

#### 自顶向下归并排序

对链表自顶向下归并排序的过程如下。

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22 步，慢指针每次移动 11 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 11，即当链表为空或者链表只包含 11 个节点时，不需要对链表进行拆分和排序。



```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head node
 * @return ListNode类
 */
function sortInList( head ) {
    // write code here
    return toSortList(head, null);
};

const toSortList = (head, tail) => {
    if (head === null) {
        return head;
    }
    if (head.next === tail) {
        head.next = null;
        return head;
    }
    let slow = head, fast = head;
    while (fast !== tail) {
        slow = slow.next;
        fast = fast.next;
        if (fast !== tail) {
            fast = fast.next;
        }
    }
    const mid = slow;
    return merge(toSortList(head, mid), toSortList(mid, tail));
}

const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}

module.exports = {
    sortInList : sortInList
};
```

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，其中 nn 是链表的长度。

空间复杂度：O(\log n)O(logn)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间。



#### 自底向上归并排序

![自底向上归并排序链表](E:\pogject\学习笔记\image\niuke\自底向上归并排序链表.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head === null) {
        return head;
    }
    let len = 0;
    let node = head;
    while (node !== null) {
        len++;
        node = node.next;
    }

    const dummyNode = new ListNode(-1, head);

    for (let subLen = 1; subLen < len; subLen <<= 1) {
        let prev = dummyNode, curr = dummyNode.next;
        while (curr !== null) {
            let head1 = curr;
            for (let i = 1; i < subLen && curr.next !== null; i++) {
                curr = curr.next;
            }
            let head2 = curr.next;
            curr.next = null;
            curr = head2;
            for (let i = 1; i < subLen && curr !== null && curr.next !== null; i++) {
                curr = curr.next;
            }
            let next = null;
            if (curr !== null) {
                next = curr.next;
                curr.next = null;
            }
            const merged = merge(head1, head2);
            prev.next = merged;
            while (prev.next !== null) {
                prev = prev.next;
            }
            curr = next;
        }
    }
    return dummyNode.next;
};


const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}
```

**复杂度分析**

- 时间复杂度：O(n \log n)*O*(*n*log*n*)，其中 n*n* 是链表的长度。
- 空间复杂度：O(1)*O*(1)。



----

## **BM13** **判断一个链表是否为回文结构**

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？



#### 将值复制到数组中后用双指针法

一共为两个步骤：

1. 复制链表值到数组列表中。
2. 使用双指针法判断是否为回文。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
    const nodes = [];
    while (head !== null) {
        nodes.push(head.val);
        head = head.next;
    }
    let left = 0, right = nodes.length - 1;
    while (left < right) {
        if (nodes[left++] !== nodes[right--]) {
            return false;
        }
    }
    return true;

}
module.exports = {
    isPail : isPail
};
```

时间复杂度：O(n)O(n)，其中 nn 指的是链表的元素个数。
第一步： 遍历链表并将值复制到数组中，O(n)O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2)O(n/2) 次的判断，即 O(n)O(n)。
总的时间复杂度：O(2n) = O(n)O(2n)=O(n)。
空间复杂度：O(n)O(n)，其中 nn 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。



#### 递归

为了想出使用空间复杂度为 O(1)*O*(1) 的算法，你可能想过使用递归来解决，但是这仍然需要 O(n)*O*(*n*) 的空间复杂度。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
    let p = null;
    const recursivelyCheck = (currentNode) => {
        if (currentNode !== null) {
            if (!recursivelyCheck(currentNode.next)) {
                return false;
            }
            if (currentNode.val !== p.val) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    p = head;
    return recursivelyCheck(head);

}
module.exports = {
    isPail : isPail
};
```

这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。



#### 快慢指针

避免使用 O(n)O(n) 额外空间的方法就是改变输入。

我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。

该方法虽然可以将空间复杂度降到 O(1)O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。

整个流程可以分为以下五个步骤：

1. 找到前半部分链表的尾节点。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    if (head === null) {
        return true;
    }

    // 找到前半部分链表的尾节点并反转后半部分链表
    const fisrtHalfEnd = endOfFirstHalf(head);
    const secondHalfStart = reverseList(fisrtHalfEnd.next);

    // 判断是否回文
    let p1 = head;
    let p2 = secondHalfStart;
    let result = true;
    while (result && p2 !== null) {
        if (p1.val !== p2.val) {
            result = false;
        }
        p1 = p1.next;
        p2 = p2.next;
    }
    // 还原链表并返回结果
    fisrtHalfEnd.next = reverseList(secondHalfStart);

    return result;
}

const reverseList = (head) => {
    let prev = null;
    let curr = head;
    while (curr !== null) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

const endOfFirstHalf = (head) => {
    let slow = head;
    let fast = head;
    while (fast.next !== null && fast.next.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

module.exports = {
    isPail : isPail
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。

空间复杂度：O(1)O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)O(1)。



----

## **BM14** **链表的奇偶重排**

给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。

#### 分离节点后合并

原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead = head.next，则 evenHead 是偶数链表的头节点。

维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd = head，even = evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。

更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next = even.next，然后令 odd = odd.next，此时 odd 变成 even 的后一个节点。

更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next = odd.next，然后令 even = even.next，此时 even 变成 odd 的后一个节点。

在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。

最后令 odd.next = evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param head ListNode类 
 * @return ListNode类
 */
function oddEvenList( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    let odd = head;
    let even = head.next;
    let evenHead = head.next;
    while (even !== null && even.next !== null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;

    return head;
}
module.exports = {
    oddEvenList : oddEvenList
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。

空间复杂度：O(1)O(1)。只需要维护有限的指针。



----

## **BM15** **删除有序链表中重复的元素-I**

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

#### 一次遍历

由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。

具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。

当遍历完整个链表之后，我们返回链表的头节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @return ListNode类
  */
function deleteDuplicates( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    let curr = head;
    let prev = head;
    while (curr.next !== null) {
        if (curr.val === curr.next.val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }
    return head;
}
module.exports = {
    deleteDuplicates : deleteDuplicates
};
```



----

## **BM16** **删除有序链表中重复的元素-II**

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。

具体地，我们从指针 \textit{cur}cur 指向链表的哑节点，随后开始对链表进行遍历。如果当前 \textit{cur.next}cur.next 与 \textit{cur.next.next}cur.next.next 对应的元素相同，那么我们就需要将 \textit{cur.next}cur.next 以及所有后面拥有相同元素值的链表节点全部删除。我们记下这个元素值 xx，随后不断将 \textit{cur.next}cur.next 从链表中移除，直到 \textit{cur.next}cur.next 为空节点或者其元素值不等于 xx 为止。此时，我们将链表中所有元素值为 xx 的节点全部删除。

如果当前 \textit{cur.next}cur.next 与 \textit{cur.next.next}cur.next.next 对应的元素不相同，那么说明链表中只有一个元素值为 \textit{cur.next}cur.next 的节点，那么我们就可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。

当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 \textit{dummy.next}dummy.next 即可。

细节

需要注意 \textit{cur.next}cur.next 以及 \textit{cur.next.next}cur.next.next 可能为空节点，如果不加以判断，可能会产生运行错误。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @return ListNode类
  */
function deleteDuplicates( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let curr = dummyNode;
    
    while (curr.next && curr.next.next) {
        if (curr.next.val === curr.next.next.val) {
            const x = curr.next.val;
            while (curr.next !== null && curr.next.val === x) {
                curr.next = curr.next.next;
            }
        } else {
            curr = curr.next;
        }
    }
    return dummyNode.next;
}

module.exports = {
    deleteDuplicates : deleteDuplicates
};
```



-----

## **BM17** **二分查找-I**

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

二分查找的做法是，定义查找的范围 [\textit{left}, \textit{right}][left,right]，初始查找范围是整个数组。每次取查找范围的中点 \textit{mid}mid，比较 \textit{nums}[\textit{mid}]nums[mid] 和 \textit{target}target 的大小，如果相等则 \textit{mid}mid 即为要寻找的下标，如果不相等则根据 \textit{nums}[\textit{mid}]nums[mid] 和 \textit{target}target 的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(\log n)O(logn)，其中 nn 是数组的长度。

二分查找的条件是查找范围不为空，即 \textit{left} \le \textit{right}left≤right。如果 \textit{target}target 在数组中，二分查找可以保证找到 \textit{target}target，返回 \textit{target}target 在数组中的下标。如果 \textit{target}target 不在数组中，则当 \textit{left} > \textit{right}left>right 时结束查找，返回 -1−1。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @param target int整型 
 * @return int整型
 */
function search( nums ,  target ) {
    // write code here
    let left = 0, right = nums.length - 1;
    let mid;
    while (left <= right) {
        mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}

// let nums = [-1,0,3,5,9,12], target = 9;
// console.log(search(nums, target))

module.exports = {
    search : search
};
```

**复杂度分析**

- 时间复杂度：O(\log n)*O*(log*n*)，其中 n*n* 是数组的长度。
- 空间复杂度：O(1)*O*(1)。



-----

## **BM18** **二维数组中的查找**

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

### 线性查找

由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

- 若数组为空，返回 false

- 初始化行下标为 0，列下标为二维数组的列数减 1
- 重复下列步骤，直到行下标或列下标超出边界
- - 获得当前下标位置的元素 num
  - 如果 num 和 target 相等，返回 true
  - 如果 num 大于 target，列下标减 1
  - 如果 num 小于 target，行下标加 1
- 循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false`



```js
function Find(target, array){
    // write code here
    if (array === null || array.length === 0 || array[0].length === 0) {
        return false;
    }
    let m = array.length;
    let n = array[0].length;
    let row = 0;
    let col = n - 1;
    while (row < m && col >= 0) {
        if (array[row][col] < target) {
            row++;
        } else if (array[row][col] > target) {
            col--;
        } else {
            return true;
        }
    }
    return false;
}
module.exports = {
    Find : Find
};
```

复杂度分析

时间复杂度：O(n+m)O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。
空间复杂度：O(1)O(1)。



----

## **BM19** **寻找峰值**

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]

#### 寻找最大值

由于题目保证了 \textit{nums}[i] \neq \textit{nums}[i+1]nums[i]  =nums[i+1]，那么数组 \textit{nums}nums 中最大值两侧的元素一定严格小于最大值本身。因此，最大值所在的位置就是一个可行的峰值位置。

我们对数组 \textit{nums}nums 进行一次遍历，找到最大值对应的位置即可。

```js
var findPeakElement = function(nums) {
    let idx = 0;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] > nums[idx]) {
            idx = i;
        }
    }
    return idx;
};

```



#### 迭代爬坡

俗话说「人往高处走，水往低处流」。如果我们从一个位置开始，不断地向高处走，那么最终一定可以到达一个峰值位置。

因此，我们首先在 [0, n)[0,n) 的范围内随机一个初始位置 ii，随后根据nums[i−1],nums[i],nums[i+1] 三者的关系决定向哪个方向走：

如果 nums[i−1]<nums[i]>nums[i+1]，那么位置 ii 就是峰值位置，我们可以直接返回 ii 作为答案；

如果nums[i−1]<nums[i]<nums[i+1]，那么位置 ii 处于上坡，我们需要往右走，即 i \leftarrow i+1i←i+1；

如果nums[i−1]>nums[i]>nums[i+1]，那么位置 ii 处于下坡，我们需要往左走，即 i \leftarrow i-1i←i−1；

如果nums[i−1]>nums[i]<nums[i+1]，那么位置 ii 位于山谷，两侧都是上坡，我们可以朝任意方向走。

如果我们规定对于最后一种情况往右走，那么当位置 ii 不是峰值位置时：

如果nums[i]<nums[i+1]，那么我们往右走；

如果 nums[i]>nums[i+1]，那么我们往左走。

```js
var findPeakElement = function(nums) {
    const n = nums.length;
    let idx = parseInt(Math.random() * n);

    while (!(compare(nums, idx - 1, idx) < 0 && compare(nums, idx, idx + 1) > 0)) {
        if (compare(nums, idx, idx + 1) < 0) {
            idx += 1;
        } else {
            idx -= 1;
        }
    }
    
    return idx;
}

// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
// 方便处理 nums[-1] 以及 nums[n] 的边界情况
const get = (nums, idx) => {
    if (idx === -1 || idx === nums.length) {
        return [0, 0];
    }
    return [1, nums[idx]];
}

const compare = (nums, idx1, idx2) => {
    const num1 = get(nums, idx1);
    const num2 = get(nums, idx2);
    if (num1[0] !== num2[0]) {
        return num1[0] > num2[0] ? 1 : -1;
    }
    if (num1[1] === num2[1]) {
        return 0;
    }
    return num1[1] > num2[1] ? 1 : -1;
}


```



#### 二分查找优化

我们可以发现，如果 nums[i]<nums[i+1]，并且我们从位置 ii 向右走到了位置 i+1i+1，那么位置 ii 左侧的所有位置是不可能在后续的迭代中走到的。

这是因为我们每次向左或向右移动一个位置，要想「折返」到位置 ii 以及其左侧的位置，我们首先需要在位置 i+1i+1 向左走到位置 ii，但这是不可能的。

并且根据方法二，我们知道位置 i+1i+1 以及其右侧的位置中一定有一个峰值，因此我们可以设计出如下的一个算法：

对于当前可行的下标范围 [l, r][l,r]，我们随机一个下标 ii；

如果下标 ii 是峰值，我们返回 ii 作为答案；

如果nums[i]<nums[i+1]，那么我们抛弃 [l, i][l,i] 的范围，在剩余 [i+1, r][i+1,r] 的范围内继续随机选取下标；

如果 nums[i]>nums[i+1]，那么我们抛弃 [i, r][i,r] 的范围，在剩余 [l, i-1][l,i−1] 的范围内继续随机选取下标。

在上述算法中，如果我们固定选取 ii 为 [l, r][l,r] 的中点，那么每次可行的下标范围会减少一半，成为一个类似二分查找的方法，时间复杂度为 O(\log n)O(logn)。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @return int整型
 */
function findPeakElement( nums ) {
    // write code here
    const n = nums.length;
    let left =0, right = n - 1;
    let ans = -1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (compare(nums, mid - 1, mid) < 0 && compare(nums, mid, mid + 1) > 0) {
            ans = mid;
            break;
        }
        if (compare(nums, mid, mid + 1) < 0) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
// 方便处理 nums[-1] 以及 nums[n] 的边界情况
const get = (nums, idx) => {
    if (idx === -1 || idx === nums.length) {
        return[0, 0];
    }
    return [1, nums[idx]];
}

const compare = (nums, idx1, idx2) => {
    const num1 = get(nums, idx1);
    const num2 = get(nums, idx2);
    if (num1[0] !== num2[0]) {
        return num1[0] > num2[0] ? 1 : -1;
    }
    if (num1[1] === num2[1]) {
        return 0;
    }
    return num1[1] > num2[1] ? 1 : -1;
}

module.exports = {
    findPeakElement : findPeakElement
};
```

**复杂度分析**

- 时间复杂度：O(\log n)*O*(log*n*)，其中 n*n* 是数组 \textit{nums}*nums* 的长度。
- 空间复杂度：O(1)*O*(1)。



----

## **BM20** **数组中的逆序对**

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数P。

并将P对1000000007取模的结果输出。 即输出P mod 1000000007

要求：空间复杂度 O(n)，时间复杂度 O(nlogn)



#### 归并排序

![求逆序对](E:\pogject\学习笔记\image\niuke\求逆序对.png)

```js
function InversePairs(nums){
    // write code here
    const n = nums.length;
    if (n < 2) {
        return 0;
    }
    const copy = [...nums];
    const temp = new Array(n);
    const ans = dfs(copy, 0, n - 1, temp);
    const MOD = 1000000007;
    return ans % MOD;
}

const dfs = (nums, left, right, temp) => {
    if (left === right) {
        return 0;
    }
    let mid = left + Math.floor((right - left) / 2);
    let leftPairs = dfs(nums, left, mid, temp);
    let rightPairs = dfs(nums, mid + 1, right, temp);

    if (nums[mid] <= nums[mid + 1]) {
        return leftPairs + rightPairs;
    }

    let crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
}

const mergeAndCount = (nums, left, mid, right, temp) => {
    for (let i = left; i <= right; i++) {
        temp[i] = nums[i];
    }
    let i = left;
    let j = mid + 1;
    let count = 0;
    for (let k = left; k <= right; k++) {
        if (i === mid + 1) {
            nums[k] = temp[j];
            j++;
        } else if (j === right + 1) {
            nums[k] = temp[i];
            i++;
        } else if (temp[i] <= temp[j]) {
            nums[k] = temp[i];
            i++;
        } else {
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        }
    }
    return count;
}

// let nums = [1,2,3,4,5,6,7,0];
// console.log(InversePairs(nums));

module.exports = {
    InversePairs : InversePairs
};
```



----

## **BM21** **旋转数组的最小数字**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

 

提示：

n == numbers.length
1 <= n <= 5000
-5000 <= numbers[i] <= 5000
numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

要求：空间复杂度：O(1)*O*(1) ，时间复杂度：O(logn)*O*(*l**o**g**n*)



#### 二分查找

我们考虑数组中的最后一个元素 xx：在最小值右侧的元素，它们的值一定都小于等于 xx；而在最小值左侧的元素，它们的值一定都大于等于 xx。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

```js
function minNumberInRotateArray(nums)
{
    // write code here
    let low = 0;
    let high = nums.length - 1;
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        if (nums[mid] < nums[high]) {
            high = mid;
        } else if (nums[mid] > nums[high]) {
            low = mid + 1;
        } else {
            high -= 1;
        }
    }
    return nums[low];
}
module.exports = {
    minNumberInRotateArray : minNumberInRotateArray
};
```

时间复杂度：平均时间复杂度为 O(\log n)O(logn)，其中 nn 是数组 \it numbersnumbers 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 \texttt{while}while 循环就需要执行 nn 次，每次忽略区间的右端点，时间复杂度为 O(n)O(n)。

空间复杂度：O(1)O(1)。



```js
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function(numbers) {
    let n = numbers.length;
    let left = 0;
    let right = n - 1;
    let mid = 0;
    while(numbers[left] >= numbers[right]) {
        if (right - left === 1) {
            mid = right;
            break;
        }
        mid = left + Math.floor((right - left) / 2);
        // 如果left,right, mid指向的三个数字相等，只能顺序查找
        if (numbers[left] === numbers[right] && numbers[left] === numbers[mid]) {
            return minInOrder(numbers, left, right);
        }

        if (numbers[mid] >= numbers[left]) {
            left = mid;
        } else if (numbers[mid] <= numbers[right]) {
            right = mid;
        }
    }
    return numbers[mid];
}

const minInOrder = (numbers, left, right) => {
    let result = numbers[left];
    for (let i = left + 1; i <= right; ++i) {
        if (result > numbers[i]) {
            result = numbers[i];
        }
    }
    return result;
}

let numbers = [1, 0, 1, 1, 1];
// let numbers = [3, 4, 5, 1, 2];
console.log(minArray(numbers, 5));
```



----

## **BM22** **比较版本号**

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：

如果 version1 > version2 返回 1，
如果 version1 < version2 返回 -1，
除此之外返回 0。

提示：

1 <= version1.length, version2.length <= 500
version1 和 version2 仅包含数字和 '.'
version1 和 version2 都是 有效版本号
version1 和 version2 的所有修订号都可以存储在 32 位整数 中

#### 字符串分割

我们可以将版本号按照点号分割成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0。

```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
	const v1 = version1.split(".");
	const v2 = version2.split(".");
	for (let i = 0; i < v1.length || i < v2.length; i++) {
		let x = 0, y = 0;
		if (i < v1.length) {
			x = parseInt(v1[i]);
		}
		if (i < v2.length) {
			y = parseInt(v2[i]);
		}
		if (x > y) {
			return 1;
		}
		if (x < y) {
			return -1;
		}
	}
	return 0;
};

let version1 = "1.01", version2 = "1.001";
console.log(compareVersion(version1, version2));
```

时间复杂度：O(n+m)O(n+m)（或 O(\max(n,m))O(max(n,m))，这是等价的），其中 nn 是字符串 \textit{version1}version1 的长度，mm 是字符串 \textit{version2}version2 的长度。

空间复杂度：O(n+m)O(n+m)，我们需要 O(n+m)O(n+m) 的空间存储分割后的修订号列表。



#### 双指针

方法一需要存储分割后的修订号，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 比较版本号
 * @param version1 string字符串 
 * @param version2 string字符串 
 * @return int整型
 */
function compare( version1 ,  version2 ) {
    // write code here
    const n = version1.length, m = version2.length;
    let i = 0, j = 0;
    while (i < n || j < m) {
        let x = 0;
        for (; i < n && version1[i] !== "."; i++) {
            x = x * 10 + version1[i].charCodeAt() - '0'.charCodeAt();
        }
        ++i;  // 跳过点号
        let y = 0;
        for (; j < m && version2[j] !== "."; j++) {
            y = y * 10 + version2[j].charCodeAt() - '0'.charCodeAt();
        }
        ++j;  // 跳过点号
        if (x !== y) {
            return x > y ? 1 : -1;
        }
    }
    return 0;
}

module.exports = {
    compare : compare
};
```

复杂度分析

时间复杂度：O(n+m)O(n+m)，其中 nn 是字符串 \textit{version1}version1 的长度，mm 是字符串 \textit{version2}version2 的长度。

空间复杂度：O(1)O(1)，我们只需要常数的空间保存若干变量。



----

## **BM23** **二叉树的前序遍历**





----

## **BM42** **用两个栈实现队列**

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

要求：存储n个元素的空间复杂度为 O(n)*O*(*n*) ，插入与删除的时间复杂度都是 O(1)*O*(1)

```js
var MyQueue = function() {
    this.inStack = [];
    this.outStack = [];
};

MyQueue.prototype.push = function(x) {
    this.inStack.push(x);
};

MyQueue.prototype.pop = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack.pop();
};

MyQueue.prototype.peek = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack[this.outStack.length - 1];
};

MyQueue.prototype.empty = function() {
    return this.outStack.length === 0 && this.inStack.length === 0;
};

MyQueue.prototype.in2out = function() {
    while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
    }
};


```



----

## **BM43** **包含min函数的栈**

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

#### 辅助栈

按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。

当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；

当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；

在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。

```js
var MinStack = function() {
    this.x_stack = [];
    this.min_stack = [Infinity];
};

MinStack.prototype.push = function(x) {
    this.x_stack.push(x);
    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));
};

MinStack.prototype.pop = function() {
    this.x_stack.pop();
    this.min_stack.pop();
};

MinStack.prototype.top = function() {
    return this.x_stack[this.x_stack.length - 1];
};

MinStack.prototype.getMin = function() {
    return this.min_stack[this.min_stack.length - 1];
};

```



----

## **BM44** **有效括号序列**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

#### 栈

判断括号的有效性可以使用「栈」这一数据结构来解决。

我们遍历给定的字符串 ss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。

当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 ss 无效，返回 \text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。

在遍历结束后，如果栈中没有左括号，说明我们将字符串 ss 中的所有左括号闭合，返回 \text{True}True，否则返回 \text{False}False。

注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 \text{False}False，省去后续的遍历判断过程。

```js
var isValid = function(s) {
    const n = s.length;
    if (n % 2 === 1) {
        return false;
    }
    const pairs = new Map([
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    const stk = [];
    for (let ch of s){
        if (pairs.has(ch)) {
            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
                return false;
            }
            stk.pop();
        } 
        else {
            stk.push(ch);
        }
    };
    return !stk.length;
};

```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是字符串 ss 的长度。

空间复杂度：O(n + |\Sigma|)O(n+∣Σ∣)，其中 \SigmaΣ 表示字符集，本题中字符串只包含 66 种括号，|\Sigma| = 6∣Σ∣=6。栈中的字符数量为 O(n)O(n)，而哈希表使用的空间为 O(|\Sigma|)O(∣Σ∣)，相加即可得到总空间复杂度。



#### 用repace方法

第一种：用repace方法，闭合才有效，也就是最里边的也要闭合，那就把最里边的括号取代为空

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    while(s.length){
        let len = s.length;
        // s = s.replace(/\(\)/g, "");
        // s = s.replace(/\[\]/g, "");
        // s = s.replace(/\{\}/g, "");
        s = s.replace(/\(\)|\[\]|\{\}/g, "");
        
        if (len === s.length) {
            // 没有匹配到则无效
            // console.log(s)
            return false;
        }
    }
    console.log(s)
    return true;
};

let s = "(()[[]]{[]()[]})";
console.log(isValid(s));
```



----

## **BM45** **滑动窗口的最大值**

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。



#### **双端队列**

我们可以顺着方法一的思路继续进行优化。

由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 ii 和 jj，其中 ii 在 jj 的左侧（i < ji<j），并且 ii 对应的元素不大于 jj 对应的元素（\textit{nums}[i] \leq \textit{nums}[j]nums[i]≤nums[j]），那么会发生什么呢？

当滑动窗口向右移动时，只要 ii 还在窗口中，那么 jj 一定也还在窗口中，这是 ii 在 jj 的左侧所保证的。因此，由于 \textit{nums}[j]nums[j] 的存在，\textit{nums}[i]nums[i] 一定不会是滑动窗口中的最大值了，我们可以将 \textit{nums}[i]nums[i] 永久地移除。

因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 \textit{nums}nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 ii，后者为 jj，就对应了上面所说的情况，即 \textit{nums}[i]nums[i] 会被移除，这就产生了矛盾。

当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。

由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。

为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。



```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    const ans = [];
    const queue = [];
    const n = nums.length;
    for (let i = 0; i < k; i++) {
        while (queue.length && nums[i] >= nums[queue[queue.length - 1]]) {
            queue.pop();
        }
        queue.push(i);
    }
    ans.push(nums[queue[0]]);
    for (let i = k; i < n; i++) {
        /*为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，
        那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。*/
        while (queue.length && nums[i] >= nums[queue[queue.length - 1]]) {
            queue.pop();
        }
        // 当滑动窗口向右移动时，我们需要把一个新的元素放入队列中
        queue.push(i);
        /* 但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，
        它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。*/
        while (queue[0] <= i - k) {
            queue.shift();
        }
        // 由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。
        ans.push(nums[queue[0]]);
    }
    return ans;
};

let nums = [1,3,-1,-3,5,3,6,7], k = 3;
console.log(maxSlidingWindow(nums, k));
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)O(n)。

空间复杂度：O(k)O(k)。与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1k+1 个元素，因此队列使用的空间为 O(k)O(k)。



#### 分块 + 预处理



```js
function maxInWindows(nums, k)
{
    // write code here
    const n = nums.length;
    const prefixMax = new Array(n).fill(0);
    const suffixMax = new Array(n).fill(0);

    for (let i = 0; i < n; i++) {
    	if (i % k === 0) {
    		prefixMax[i] = nums[i];
    	} else {
    		prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);
    	}
    }
    for (let i = n - 1; i >= 0; i--) {
    	if (i === n || (i + 1) % k === 0) {
    		suffixMax[i] = nums[i];
    	} else {
    		suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);
    	}
    }

    const ans = [];
    for (let i = 0; i < n - k + 1; i++) {
    	ans.push(Math.max(suffixMax[i], prefixMax[i + k - 1]));
    }
    return ans;
}
module.exports = {
    maxInWindows : maxInWindows
};
```



----

## **BM46** **最小的K个数**

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

#### 排序



```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function(arr, k) {
    if (k === 0 || arr.length === 0) {
        return [];
    }
    arr.sort((a, b) => a - b);
    return arr.slice(0, k);
};
```

复杂度分析

时间复杂度：O(n\log n)O(nlogn)，其中 nn 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(\log n)O(logn)，排序所需额外的空间复杂度为 O(\log n)O(logn)。



#### 堆

我们用一个大根堆实时维护数组的前 kk 小值。首先将前 kk 个数插入大根堆中，随后从第 k+1k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。而 Python 语言中的堆为小根堆，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 kk 小值。

```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function(arr, k) {
    if (k === 0 || arr.length === 0) {
        return [];
    }

    let maxHeap = [Infinity];  // 最大堆
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let item = arr[i];
        if (maxHeap.length - 1 < k) {
            // 构造最大堆
            insert(item, maxHeap);
        } else {
            // 如果当前元素比最大堆的最大值小，则将堆的最大值替换成此元素，然后再重新构造成最大堆
            if (item < maxHeap[1]) {
                addToTop(item, maxHeap);
            }
        }
    }

    function insert(item, heap) {
        heap.push(item);
        let index = heap.length - 1;
        while (heap[index] > heap[parseInt(index / 2)]) {
            let temp = heap[index];
            heap[index] = heap[parseInt(index / 2)];
            heap[parseInt(index / 2)] = temp;
            index = parseInt(index / 2);
        }
    }

    function addToTop(item, heap) {
        heap[1] = item;
        let index = 1;
        while (true) {
            if (heap[2 * index] === undefined) {
                break;
            }
            if (heap[2 * index + 1] === undefined) {
                if (heap[2 * index] < heap[index]) {
                    break;
                }
                let temp = heap[2 * index];
                heap[2 * index] = heap[index];
                heap[index] = temp;
                index = 2 * index;
            } else {
                if (heap[2 * index] < heap[index] && heap[2 * index + 1] < heap[index]) {
                    break;
                }
                if (heap[2 * index] > heap[2 * index + 1]) {
                    let temp = heap[2 * index];
                    heap[2 * index] = heap[index];
                    heap[index] = temp;
                    index = 2 * index;
                } else {
                    let temp = heap[2 * index + 1];
                    heap[2 * index + 1] = heap[index];
                    heap[index] = temp;
                    index = 2 * index + 1;
                }
            }
        }
    }
    maxHeap.shift();
    return maxHeap;
};
```

复杂度分析

时间复杂度：O(n\log k)O(nlogk)，其中 nn 是数组 arr 的长度。由于大根堆实时维护前 kk 小值，所以插入删除都是 O(\log k)O(logk) 的时间复杂度，最坏情况下数组里 nn 个数都会插入，所以一共需要 O(n\log k)O(nlogk) 的时间复杂度。

空间复杂度：O(k)O(k)，因为大根堆里最多 kk 个数。



#### 快排思想

我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。

我们定义函数 randomized_selected(arr, l, r, k) 表示划分数组 arr 的 [l,r] 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：

如果 pos - l + 1 == k，表示 pivot 就是第 kk 小的数，直接返回即可；

如果 pos - l + 1 < k，表示第 kk 小的数在 pivot 的右侧，因此递归调用 randomized_selected(arr, pos + 1, r, k - (pos - l + 1))；

如果 pos - l + 1 > k，表示第 kk 小的数在 pivot 的左侧，递归调用 randomized_selected(arr, l, pos - 1, k)。

函数递归入口为 randomized_selected(arr, 0, arr.length - 1, k)。在函数返回后，将前 k 个数放入答案数组返回即可。



```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        randomizedSelected(arr, 0, arr.length - 1, k);
        int[] vec = new int[k];
        for (int i = 0; i < k; ++i) {
            vec[i] = arr[i];
        }
        return vec;
    }

    private void randomizedSelected(int[] arr, int l, int r, int k) {
        if (l >= r) {
            return;
        }
        int pos = randomizedPartition(arr, l, r);
        int num = pos - l + 1;
        if (k == num) {
            return;
        } else if (k < num) {
            randomizedSelected(arr, l, pos - 1, k);
        } else {
            randomizedSelected(arr, pos + 1, r, k - num);
        }
    }

    // 基于随机的划分
    private int randomizedPartition(int[] nums, int l, int r) {
        int i = new Random().nextInt(r - l + 1) + l;
        swap(nums, r, i);
        return partition(nums, l, r);
    }

    private int partition(int[] nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums, i, j);
            }
        }
        swap(nums, i + 1, r);
        return i + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```



---

## **BM47** **寻找第K大**

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

#### 基于快速排序的选择方法



![基于快速排序的选择方法寻找第K大](E:\pogject\学习笔记\image\niuke\基于快速排序的选择方法寻找第K大.png)

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    // write code here
    const n = nums.length;
    return quickSelect(nums, 0, n - 1, n - k);
}

const quickSelect = (nums, left, right, index) => {
    const q = randomPartition(nums, left, right);
    // console.log(q, nums)
    if (q === index) {
        // 我们会对子数组进行划分，如果划分得到的 qq 正好就是我们需要的下标，就直接返回 a[q]a[q]
        return nums[q];
    } else if (q < index){
        // 否则，如果 qq 比目标下标小，就递归右子区间
        return quickSelect(nums, q + 1, right, index);
    } else {
        // 否则递归左子区间
        return quickSelect(nums, left, q - 1, index);
    }
}

const randomPartition = (nums, left, right) => {
    const randomIndex = left + Math.floor(Math.random() * (right - left));
    swap(nums, randomIndex, right);
    return partition(nums, left, right);
}

const partition = (nums, left, right) => {
    const x = nums[right];
    let i = left - 1;
    for (let j = left; j < right; j++) {
        if (nums[j] <= x) {
            // 把小于等基准值的移到左边
            swap(nums, ++i, j);
        }
    }
    swap(nums, i + 1, right);
    return i + 1;
}

const swap = (nums, i, j) => {
    [nums[i], nums[j]] = [nums[j], nums[i]];
}

let nums = [3,2,1,5,6,4], k = 2;
console.log(findKthLargest(nums, k));

```

复杂度分析

时间复杂度：O(n)O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。
空间复杂度：O(\log n)O(logn)，递归使用栈空间的空间代价的期望为 O(\log n)O(logn)。





#### 基于堆排序的选择方法

我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k - 1*k*−1 次删除操作后堆顶元素就是我们要找的答案。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
*/
var findKthLargest = function(nums, k) {
	//从nums中取出前k个数，构建一个小顶锥
	let heapSize = nums.length;
	bulidMaxHeap(nums, heapSize);
	for (let i = nums.length - 1; i >= nums.length - k + 1; i--){
		swap(nums, 0, i);
		heapSize--;
		maxHeapify(nums,0,heapSize);
	}
	return nums[0];  //返回堆顶元素
};

// 原地建堆，从后往前，自上而下式建小顶堆
var bulidMaxHeap = (arr, heapSize)=>{
	for (let i=Math.floor(heapSize/2); i >= 0; i--){
		maxHeapify(arr,i,heapSize);
	}
}

//堆化
var maxHeapify = (arr, i, heapSize)=>{
	let left = i*2 + 1;
	let right = i*2 + 2;
	let largest = i;
	if (left < heapSize && arr[left] > arr[largest]) {
		largest = left;
	}
	if (right < heapSize && arr[right] > arr[largest]) {
		largest = right;
	}

	if (largest !== i) {
		swap(arr, i, largest);
		maxHeapify(arr, largest, heapSize);
	}
}

//交换元素
var swap=(arr,i,j)=>{
	let temp=arr[i];
	arr[i]=arr[j];
	arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，建堆的时间代价是 O(n)O(n)，删除的总代价是 O(k \log n)O(klogn)，因为 k < nk<n，故渐进时间复杂为 O(n + k \log n) = O(n \log n)O(n+klogn)=O(nlogn)。
空间复杂度：O(\log n)O(logn)，即递归使用栈空间的空间代价。



----

## **BM48** **数据流中的中位数**

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

进阶:

如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

进阶： 空间复杂度 O(n) \*O*(*n*) ， 时间复杂度 O(nlogn) \*O*(*n**l**o**g**n*) 



#### 优先队列

我们用两个优先队列 \textit{queMax}queMax 和 \textit{queMin}queMin 分别记录大于中位数的数和小于等于中位数的数。当累计添加的数的数量为奇数时，\textit{queMin}queMin 中的数的数量比 \textit{queMax}queMax 多一个，此时中位数为 \textit{queMin}queMin 的队头。当累计添加的数的数量为偶数时，两个优先队列中的数的数量相同，此时中位数为它们的队头的平均值。

当我们尝试添加一个数 \textit{num}num 到数据结构中，我们需要分情况讨论：

\textit{num} \leq \max \{\textit{queMin}\}num≤max{queMin}

此时 \textit{num}num 小于等于中位数，我们需要将该数添加到 \textit{queMin}queMin 中。新的中位数将小于等于原来的中位数，因此我们可能需要将 \textit{queMin}queMin 中最大的数移动到 \textit{queMax}queMax 中。

\textit{num} > \max \{\textit{queMin}\}num>max{queMin}

此时 \textit{num}num 大于中位数，我们需要将该数添加到 \textit{queMin}queMin 中。新的中位数将大于等于原来的中位数，因此我们可能需要将 \textit{queMax}queMax 中最小的数移动到 \textit{queMin}queMin 中。

特别地，当累计添加的数的数量为 00 时，我们将 \textit{num}num 添加到 \textit{queMin}queMin 中。

为了方便维护数组的顺序，很明显需要利用堆来存储，而要找到中位数，需要构造两个堆：一个最大堆存储较小的部分，一个最小堆存储较大的部分。如此一来，只需读取堆顶元素就能获得中位数。维护两个堆的方式也很简单，就是保持最大堆的长度与最小堆的长度之差在1以内，封装成优先队列的形式控制元素的压入与推出。



```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
    this.max_queue = new max_priority_queue();
    this.min_queue = new min_priority_queue();
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    this.max_queue.enqueue(num);
    if (this.max_queue.head() === num || this.max_queue.size() - this.min_queue.size() > 1) {
        this.min_queue.enqueue(this.max_queue.dequeue());
    }
    if (this.max_queue.size() - this.min_queue.size() < 0) {
        this.max_queue.enqueue(this.min_queue.dequeue());
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    return this.max_queue.size() > this.min_queue.size() ? this.max_queue.head() : (this.max_queue.head() + this.min_queue.head()) / 2;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

// 构造最大堆
class MaxHeap {
    constructor(array = []) {
        this.A = array;
    }
    size() {
        return this.A.length;
    }
    head() {
        return this.isEmpty() ? null : this.A[0];
    }
    left(i) {
        return 2 * i + 1;
    }
    right(i) {
        return 2 * i + 2;
    }
    parent(i) {
        return i > 0 ? (i - 1) >>> 1 : -1;
    }
    isEmpty() {
        return this.size() === 0;
    }
    heapifyDown(i, size = this.size()) {
        let p = i;
        const l = this.left(i), r = this.right(i);
        if (l < size && this.compare(l, p)) {
            p = l;
        }
        if (r < size && this.compare(r, p)) {
            p = r;
        }
        if (p !== i) {
            this.exchange(i, p);
            this.heapifyDown(p, size);
        }
    }
    heapifyUp(i) {
        const p = this.parent(i);
        if (p >= 0 && this.compare(i, p)) {
            this.exchange(i, p);
            this.heapifyUp(p);
        }
    }
    exchange(x, y) {
        const temp = this.A[x];
        this.A[x] = this.A[y];
        this.A[y] = temp;
    }
    compare(a, b) {
        if (this.A[a] - this.A[b] > 0) {
            return true;
        } else {
            return false;
        }
    }
}

// 优先队列
class max_priority_queue extends MaxHeap {
    enqueue(node) {
        this.A.push(node);
        this.heapifyUp(this.size() - 1);
    }
    dequeue() {
        const first = this.A[0];
        const last = this.A.pop();
        if (first !== last) {
            this.A[0] = last;
            this.heapifyDown(0);
        }
        return first;
    }
}

class min_priority_queue extends max_priority_queue {
    compare(a, b) {
        if (this.A[a] - this.A[b] < 0) {
            return true;
        } else {
            return false;
        }
    }
}
```



#### 有序集合 + 双指针

我们也可以使用有序集合维护这些数。我们把有序集合看作自动排序的数组，使用双指针指向有序集合中的中位数元素即可。当累计添加的数的数量为奇数时，双指针指向同一个元素。当累计添加的数的数量为偶数时，双指针分别指向构成中位数的两个数。

当我们尝试添加一个数 \textit{num}num 到数据结构中，我们需要分情况讨论：

初始有序集合为空时，我们直接让左右指针指向 \textit{num}num 所在的位置。

有序集合为中元素为奇数时，\textit{left}left 和 \textit{right}right 同时指向中位数。如果 \textit{num}num 大于等于中位数，那么只要让 \textit{left}left 左移，否则让 \textit{right}right 右移即可。

有序集合为中元素为偶数时，\textit{left}left 和 \textit{right}right 分别指向构成中位数的两个数。

当 \textit{num}num 成为新的唯一的中位数，那么我们让 \textit{left}left 右移，\textit{right}right 左移，这样它们即可指向 \textit{num}num 所在的位置；
当 \textit{num}num 大于等于 \textit{right}right，那么我们让 \textit{left}left 右移即可；
当 \textit{num}num 小于 \textit{right}right 指向的值，那么我们让 \textit{right}right 左移，注意到如果 \textit{num}num 恰等于 \textit{left}left 指向的值，那么 \textit{num}num 将被插入到 \textit{left}left 右侧，使得 \textit{left}left 和 \textit{right}right 间距增大，所以我们还需要额外让 \textit{left}left 指向移动后的 \textit{right}right。

**代码有问题**

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
    this.queue = [];
    // 用两个指针维护中位数
    this.left = -1;
    this.right = -1;
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    // 第一个数加进来
    if (this.left === -1) {
        this.left++;
        this.right++;
    } else {
        //  加入num后队列长度变为偶数，中位数由两个(下标)不同的数计算得出
        if (this.left === this.right) {
            this.right++;
        } else {
            this.left++;
        }
    }
    this.queue.push(num);
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    if (!this.queue.length) {
        return null;
    }
    this.queue.sort((a, b) => a - b);
    return (this.queue[this.left] + this.queue[this.right]) / 2;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

```



----

## **BM49** **表达式求值**

请写一个整数计算器，支持加减乘三种运算和括号。

数据范围：0\le |s| \le 1000≤∣*s*∣≤100，保证计算结果始终在整型范围内

要求：空间复杂度： O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)



#### eval

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 返回表达式的值
 * @param s string字符串 待计算的表达式
 * @return int整型
 */
function solve( s ) {
    // write code here
    return eval(s);
}
module.exports = {
    solve : solve
};
```

#### 转为逆波兰表达式

将中缀表达式化为逆波兰表达式

借助两个栈，一个存放数字，一个存放操作符

思路：

**初始化：**

- 将运算符加入到map里面，设定优先级，注意`(`的优先级最低
- 将字符串的空格删除

**遍历字符串：**

- 数字：加入数组，注意数字可能占多位
- 左括号：直接`push`到`ops`栈
- 右括号：从nums栈pop两个数字，进行运算，运算的结果push回nums栈，直至碰到`(`
- 其他运算符：
  1. 如果当前运算符的优先级≤\leq≤ops的最后一个，一直运算(例子：5*2+3，碰到+的时候计算5*2)
  2. 如果当前运算符的>>>ops的最后一个，将运算符push到ops(例子：5+2*3，碰到*的时候将`*`push到ops栈)

