## **BM1** **反转链表**

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

**思路**

如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表



首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。



#### 迭代

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
    return pre;
}
module.exports = {
    ReverseList : ReverseList
};
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)。



#### 递归

递归版本稍微复杂一些，其关键在于反向工作。

递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // 和双指针法初始化是一样的逻辑
        // let cur = head;
        // let pre = NULL;
    return reverse(null, pHead);

}

const reverse = (pre, cur) => {
    if (!cur) {
        return pre;
    }
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
    return reverse(pre, temp);
}

module.exports = {
    ReverseList : ReverseList
};
```

我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // 边缘条件判断
    if (pHead === null) return null;
    if (pHead.next === null) return pHead;

    // 递归调用，翻转第二个节点开始往后的链表
    let last = ReverseList(pHead.next);
    // 翻转头节点与第二个节点的指向
    pHead.next.next = pHead;
    // 此时的 head 节点为尾节点，next 需要指向 NULL
    pHead.next = null;
    return last;
}

module.exports = {
    ReverseList : ReverseList
};
```

复杂度分析

时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。

空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。



----

## **BM2** **链表内指定区间反转**

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

 提示：

链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。

思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。

#### 穿针引线

![反转链表2](E:\pogject\学习笔记\image\niuke\反转链表2.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param m int整型 
  * @param n int整型 
  * @return ListNode类
  */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;

    return dummyNode.next;
}

function reverseLinkedList(pHead){
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
}


module.exports = {
    reverseBetween : reverseBetween
};
```

**复杂度分析**

- 时间复杂度：*O*(*N*)，其中 *N* 是链表总节点数。最坏情况下，需要遍历整个链表。
- 空间复杂度：*O*(1)。只使用到常数个变量。



#### 一次遍历「穿针引线」（头插法）

方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。

整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。

![反转链表2_2](E:\pogject\学习笔记\image\niuke\反转链表2_2.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; i++) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}



module.exports = {
    reverseBetween : reverseBetween
};
```

复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 是链表总节点数。最多只遍历了链表一次，就完成了反转。

空间复杂度：O(1)O(1)。只使用到常数个变量。



----

## **BM3** **链表中的节点每k个一组翻转**

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`



我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。

接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。

因此，在翻转子链表的时候，我们不仅需要子链表头节点 `head`，还需要有 `head` 的上一个节点 `pre`，以便翻转完后把子链表再接回 `pre`。

但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。

反复移动指针 `head` 与 `pre`，对 `head` 所指向的子链表进行翻转，直到结尾，我们就得到了答案。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    const dummyHead = new ListNode(-1);  // 哑结点
    dummyHead.next = head;

    let pre = dummyHead;

    while (head) {
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i < k; i++) {
            tail = tail.next;
            if (!tail) {
                return dummyHead.next;
            }
        }
        const next = tail.next;
        [head, tail] = myReverse(head, tail);
        
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = next;
        pre = tail;
        head = tail.next;
    }
    return dummyHead.next;
};

const myReverse = (head, tail) => {
    let prev = tail.next;
    let p = head;
    while (prev !== tail) {
        const next = p.next;
        p.next = prev;
        prev = p;
        p = next;
    }
    return [tail, head];
}

module.exports = {
    reverseKGroup : reverseKGroup
};
```





----

## **BM4** **合并两个排序的链表**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列



#### 递归

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function Merge(pHead1, pHead2)
{
    if (pHead1 === null) {
        return pHead2;
    } else if (pHead2 === null) {
        return pHead1;
    } else if (pHead1.val < pHead2.val) {
        pHead1.next = Merge(pHead1.next, pHead2);
        return pHead1;
    } else {
        pHead2.next = Merge(pHead1, pHead2.next);
        return pHead2;
    }
}
module.exports = {
    Merge : Merge
};
```



#### 迭代

```js
function ListNode(x){
    this.val = x;
    this.next = null;
}

function Merge(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}
module.exports = {
    Merge : Merge
};
```



----

## **BM5** **合并k个已排序的链表**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

要求：时间复杂度 O(nlogk)



#### 顺序合并

我们可以想到一种最朴素的方法：用一个变量ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和ans 合并，答案保存到 ans 中。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    let ans = null, n = lists.length;
    for (let i = 0; i < n; i++) {
        ans = MergeTwoLists(ans, lists[i]);
    }
    return ans;
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 分治合并

![合并k个链表](E:\pogject\学习笔记\image\niuke\合并k个链表.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

function merge(lists, left, right) {
    if (left === right) {
        return lists[left];
    }
    if (left > right) {
        return null;
    }
    const mid = (left + right) >> 1;
    return MergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));
}
/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    return merge(lists, 0, lists.length - 1);
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 使用优先队列合并

这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，kk 个链表就最多有 kk 个满足这样条件的元素，每次在这些元素里面选取 \textit{val}val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

思路：新建小顶堆，小顶堆的大小是k，不断从每个链表的头节点开始不断加入小顶堆中，然后取出堆顶值，也就是最小值，然后继续往小顶堆中插入这个最小值在链表的next节点
复杂度：时间复杂度O(kn * logk)，优先队列的大小是k，每次插入和删除是O(logk)，总共k * n的节点个数，每个节点插入删除一次，所以总的复杂度是O(kn*logk)。空间复杂度是O(k)，即优先队列的大小

```js
class Heap {
    constructor(comparator = (a, b) => a - b, data = []) {
        this.data = data;
        this.comparator = comparator;  // 比较器
        this.heapify();  // 堆化
    }

    heapify() {
        if (this.size() < 2) {
            return;
        }
        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i--) {
            this.bubbleDowm(i);  // bubbleDown操作
        }
    }

    peek() {
        if (this.size() === 0) {
            return null;
        }
        return this.data[0];  // 查看堆顶
    }

    offer(value) {
        this.data.push(value);  // 加入数组
        this.bubbleUp(this.size() - 1);  //调整加入的元素在小顶堆中的位置
    }

    poll() {
        if (this.size() === 0) {
            return null;
        }
        const result = this.data[0];
        const last = this.data.pop();
        if (this.size() !== 0) {
            this.data[0] = last;  // 交换第一个元素和最后一个元素
            this.bubbleDowm(0);  // bubbleDown操作
        }
        return result;
    }

    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = (index - 1) >> 1;  // 父节点的位置
            //如果当前元素比父节点的元素小，就交换当前节点和父节点的位置
            if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {
                this.swap(index, parentIndex);  //交换自己和父节点的位置
                index = parentIndex;
            } else {
                break;  //如果当前元素比父节点的元素大，不需要处理
            }
        }
    }

    bubbleDowm(index) {
        const lastIndex = this.size() - 1;  // 最后一个节点的位置
        while (true) {
            const leftIndex = index * 2 + 1;  //左节点的位置
            const rightIndex = index * 2 + 2;  //右节点的位置
            let findIndex = index;  //bubbleDown节点的位置
            //找出左右节点中value小的节点
            if (leftIndex <= lastIndex && this.comparator(this.data[leftIndex], this.data[findIndex]) < 0) {
                findIndex = leftIndex;
            }
            if (rightIndex <= lastIndex && this.comparator(this.data[rightIndex], this.data[findIndex]) < 0) {
                finished = rightIndex;
            }
            if (index !== findIndex) {
                this.swap(index, findIndex);  //交换当前元素和左右节点中value小的
                index = findIndex;
            } else {
                break;
            }
        }
    }

    swap(index1, index2) {
        [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]]
    }

    size() {
        return this.data.length;
    }
}


/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function mergeKLists(lists){
    const res = new ListNode(-1);

    let prev = res;

    const h = new Heap(comparator = (a, b) => a.val - b.val);

    lists.forEach(list => {
        //插入每个链表的第一个节点
        if (list) {
            h.offer(list);
        }
    });
    while (h.size()) {
       const n = h.poll();  //取出最小值
       prev.next = n;  //最小值加入p的next后
       prev = prev.next;  // 移动节点
       if (n.next) {
        h.offer(n.next);  //插入最小节点的后一个节点
       }
    }

    return res.next;
}


module.exports = {
    mergeKLists : mergeKLists
};
```



----

## **BM6** **判断链表中是否有环**

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

#### **哈希表**

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    const visited = new Set();
    while(head !== null) {
        if (visited.has(head)) {
            return true;
        }
        visited.add(head);
        head = head.next;
    }
    return false;
}
module.exports = {
    hasCycle : hasCycle
};
```



#### **快慢指针**

具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    if (head === null || head.next === null) {
        return false;
    }
    let slow = head;
    let fast = head.next;
    while(slow !== fast) {
        if (fast === null || fast.next === null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;;
}
module.exports = {
    hasCycle : hasCycle
};
```



----

## **BM7** **链表中环的入口结点**

#### 哈希表

一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(pHead)
{
    // write code here
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



#### 快慢指针

![环形链表入口节点](E:\pogject\学习笔记\image\niuke\环形链表入口节点.png)

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(head)
{
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;

    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



----

## **BM8** **链表中倒数最后k个结点**

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

#### 顺序查找

思路与算法

最简单直接的方法即为顺序查找，假设当前链表的长度为 nn，则我们知道链表的倒数第 kk 个节点即为正数第 n - kn−k 个节点，此时我们只需要顺序遍历到链表的第 n - kn−k 个节点即为倒数第 kk 个节点。

我们首先求出链表的长度 nn，然后顺序遍历到链表的第 n - kn−k 个节点返回即可。

```go
func getKthFromEnd(head *ListNode, k int) (kth *ListNode) {
    n := 0
    for node := head; node != nil; node = node.Next {
        n++
    }
    for kth = head; n > k; n-- {
        kth = kth.Next
    }
    return
}

```

#### 双指针

快慢指针的思想。我们将第一个指针 \textit{fast}fast 指向链表的第 k + 1k+1 个节点，第二个指针 \textit{slow}slow 指向链表的第一个节点，此时指针 \textit{fast}fast 与 \textit{slow}slow 二者之间刚好间隔 kk 个节点。此时两个指针同步向后走，当第一个指针 \textit{fast}fast 走到链表的尾部空节点时，则此时 \textit{slow}slow 指针刚好指向链表的倒数第kk个节点。

我们首先将 \textit{fast}fast 指向链表的头节点，然后向后走 kk 步，则此时 \textit{fast}fast 指针刚好指向链表的第 k + 1k+1 个节点。

我们首先将 \textit{slow}slow 指向链表的头节点，同时 \textit{slow}slow 与 \textit{fast}fast 同步向后走，当 \textit{fast}fast 指针指向链表的尾部空节点时，则此时返回 \textit{slow}slow 所指向的节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */
function FindKthToTail( head ,  k ) {
    // write code here
    let fast = head, slow = head;

    while (fast && k > 0) {
        [fast, k] = [fast.next, k - 1];
    }
    if (k > 0) {
        return null;
    }
    while (fast) {
        [fast, slow] = [fast.next, slow.next];
    }
    return slow;
}
module.exports = {
    FindKthToTail : FindKthToTail
};
```



----

## **BM9** **删除链表的倒数第n个节点**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。



在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 \textit{next}next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。

例如，在本题中，如果我们要删除节点 yy，我们需要知道节点 yy 的前驱节点 xx，并将 xx 的指针指向 yy 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。

特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。

#### 计算链表长度

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。

为了方便删除操作，我们可以从哑节点开始遍历 L-n+1L−n+1 个节点。当遍历到第 L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const len = getLength(head);
    let cur =dummyNode;
    for (let i = 1; i < len - n + 1; i++) {
        cur = cur.next;
    }
    cur.next = cur.next.next;

    return dummyNode.next;
}

function getLength(head) {
    let len = 0;
    while (head !== null) {
        len++;
        head = head.next;
    }
    return len;
}
module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const stack = [];

    let cur =dummyNode;
    while (cur !== null) {
        stack.push(cur);
        cur= cur.next;
    }
    for (let i = 0; i < n; i++) {
        stack.pop();
    }
    let prev = stack[stack.length - 1];
    prev.next = prev.next.next;

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 双指针

由于我们需要找到倒数第 nn 个节点，因此我们可以使用两个指针 \textit{first}first 和 \textit{second}second 同时对链表进行遍历，并且 \textit{first}first 比 \textit{second}second 超前 nn 个节点。当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 就恰好处于倒数第 nn 个节点。

根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 \textit{second}second 指向哑节点，其余的操作步骤不变。这样一来，当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 的下一个节点就是我们需要删除的节点。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let first = head, second = dummyNode;

    for (let i = 0; i < n; i++) {
        first = first.next;
    }
    while (first !== null) {
        first = first.next;
        second = second.next;
    }
    
    second.next = second.next.next;  // 删除结点

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



----

## **BM10** **两个链表的第一个公共结点**

#### 哈希集合

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都是两个链表的公共节点，因此在链表 \textit{headB}headB 中遍历到的第一个在哈希集合中的节点就是两个链表的第一个公共节点，返回该节点。

如果链表 \textit{headB}headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 \text{null}null。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    vis := map[*ListNode]bool{}
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        vis[tmp] = true
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if vis[tmp] {
            return tmp
        }
    }
    return nil
}


```



#### 双指针

使用双指针的方法，可以将空间复杂度降至 O(1)O(1)。

只有当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，两个链表才可能相交。因此首先判断链表 \textit{headA}headA 和 \textit{headB}headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 \text{null}null。

当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，创建两个指针 \textit{pA}pA 和 \textit{pB}pB，初始时分别指向两个链表的头节点 \textit{headA}headA 和 \textit{headB}headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

- 每步操作需要同时更新指针 \textit{pA}pA 和 \textit{pB}pB。

- 如果指针 \textit{pA}pA 不为空，则将指针 \textit{pA}pA 移到下一个节点；如果指针 \textit{pB}pB 不为空，则将指针 \textit{pB}pB 移到下一个节点。

- 如果指针 \textit{pA}pA 为空，则将指针 \textit{pA}pA 移到链表 \textit{headB}headB 的头节点；如果指针 \textit{pB}pB 为空，则将指针 \textit{pB}pB 移到链表 \textit{headA}headA 的头节点。

- 当指针 \textit{pA}pA 和 \textit{pB}pB 指向同一个节点或者都为空时，返回它们指向的节点或者 \text{null}null。


```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    if (pHead1 === null || pHead2 === null) {
        return null;
    }
    let p1 = pHead1, p2 = pHead2;
    while (p1 !== p2) {
        p1 = p1 === null ? pHead2 : p1.next;
        p2 = p2 === null ? pHead1 : p2.next;
    }
    return p1;
}
module.exports = {
    FindFirstCommonNode : FindFirstCommonNode
};
```

复杂度分析

时间复杂度：O(m+n)O(m+n)，其中 mm 和 nn 是分别是链表 \textit{headA}headA 和 \textit{headB}headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。

空间复杂度：O(1)O(1)。



----

## **BM11** **链表中的两数相加**

给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

提示：

链表的长度范围为 [1, 100]
0 <= node.val <= 9
输入数据保证链表代表的数字无前导 0


进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。



#### 栈

本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head1 ListNode类 
 * @param head2 ListNode类 
 * @return ListNode类
 */
function addInList( head1 ,  head2 ) {
    // write code here
    let stack1 = [], stack2 = [];
    while (head1 !== null) {
        stack1.push(head1.val);
        head1 = head1.next;
    }
    while (head2 !== null) {
        stack2.push(head2.val);
        head2 = head2.next;
    }

    let carry = 0;
    let ans = null;
    while (stack1.length !== 0 || stack2.length !== 0 || carry !== 0) {
        let a = stack1.length ? stack1.pop() : 0;
        let b = stack2.length ? stack2.pop() : 0;
        let cur = a + b + carry;
        carry = cur > 9 ? 1 : 0;
        cur %= 10;
        let curNode = new ListNode(cur);
        curNode.next = ans;
        ans = curNode;
    }
    return ans;
}
module.exports = {
    addInList : addInList
};
```



#### 反转链表+双指针求和

先把l1和l2都进行反转
然后通过双指针进行求和
最后把结果再进行反转即可了

```js
var addTwoNumbers = function(l1, l2) {
    // 反转链表
    function reverse(head) {
        var pre = null;
        var cur = head;
        while (cur) {
            var next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    // 进行两数想加
    var reverseL1 = reverse(l1);
    var reverseL2 = reverse(l2);
    var res = null;
    var carry = 0;
    var tail = res;
    while (reverseL1 || reverseL2) {
        const x = reverseL1 ? reverseL1.val - '0' : 0;
        const y = reverseL2 ? reverseL2.val - '0' : 0;
        const sum = x + y + carry;
        if (!res) {
            res = tail = new ListNode(sum % 10);
        } else {
            tail.next = new ListNode(sum % 10);
            tail = tail.next;
        }
        carry = Math.floor(sum / 10);
        if(reverseL1) reverseL1 = reverseL1.next;
        if(reverseL2) reverseL2 = reverseL2.next;
    }
    if (carry) tail.next = new ListNode(carry);

    // 最后再反转链表=
    return reverse(res);
};

```



-----

## **BM12** **单链表的排序**

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

要求使用插入排序的方法对链表进行排序，插入排序的时间复杂度是 O(n^2)O(n 2 )，其中 nn 是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 O(n \log n)O(nlogn) 的时间复杂度和 O(1)O(1) 的空间复杂度，时间复杂度是 O(n \log n)O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)O(n 2 )），其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(\log n)O(logn)。如果要达到 O(1)O(1) 的空间复杂度，则需要使用自底向上的实现方式。

#### 自顶向下归并排序

对链表自顶向下归并排序的过程如下。

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22 步，慢指针每次移动 11 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 11，即当链表为空或者链表只包含 11 个节点时，不需要对链表进行拆分和排序。



```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head node
 * @return ListNode类
 */
function sortInList( head ) {
    // write code here
    return toSortList(head, null);
};

const toSortList = (head, tail) => {
    if (head === null) {
        return head;
    }
    if (head.next === tail) {
        head.next = null;
        return head;
    }
    let slow = head, fast = head;
    while (fast !== tail) {
        slow = slow.next;
        fast = fast.next;
        if (fast !== tail) {
            fast = fast.next;
        }
    }
    const mid = slow;
    return merge(toSortList(head, mid), toSortList(mid, tail));
}

const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}

module.exports = {
    sortInList : sortInList
};
```

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，其中 nn 是链表的长度。

空间复杂度：O(\log n)O(logn)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间。



#### 自底向上归并排序

![自底向上归并排序链表](E:\pogject\学习笔记\image\niuke\自底向上归并排序链表.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head === null) {
        return head;
    }
    let len = 0;
    let node = head;
    while (node !== null) {
        len++;
        node = node.next;
    }

    const dummyNode = new ListNode(-1, head);

    for (let subLen = 1; subLen < len; subLen <<= 1) {
        let prev = dummyNode, curr = dummyNode.next;
        while (curr !== null) {
            let head1 = curr;
            for (let i = 1; i < subLen && curr.next !== null; i++) {
                curr = curr.next;
            }
            let head2 = curr.next;
            curr.next = null;
            curr = head2;
            for (let i = 1; i < subLen && curr !== null && curr.next !== null; i++) {
                curr = curr.next;
            }
            let next = null;
            if (curr !== null) {
                next = curr.next;
                curr.next = null;
            }
            const merged = merge(head1, head2);
            prev.next = merged;
            while (prev.next !== null) {
                prev = prev.next;
            }
            curr = next;
        }
    }
    return dummyNode.next;
};


const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}
```

**复杂度分析**

- 时间复杂度：O(n \log n)*O*(*n*log*n*)，其中 n*n* 是链表的长度。
- 空间复杂度：O(1)*O*(1)。



----

## **BM13** **判断一个链表是否为回文结构**

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？



#### 将值复制到数组中后用双指针法

一共为两个步骤：

1. 复制链表值到数组列表中。
2. 使用双指针法判断是否为回文。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
    const nodes = [];
    while (head !== null) {
        nodes.push(head.val);
        head = head.next;
    }
    let left = 0, right = nodes.length - 1;
    while (left < right) {
        if (nodes[left++] !== nodes[right--]) {
            return false;
        }
    }
    return true;

}
module.exports = {
    isPail : isPail
};
```

时间复杂度：O(n)O(n)，其中 nn 指的是链表的元素个数。
第一步： 遍历链表并将值复制到数组中，O(n)O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2)O(n/2) 次的判断，即 O(n)O(n)。
总的时间复杂度：O(2n) = O(n)O(2n)=O(n)。
空间复杂度：O(n)O(n)，其中 nn 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。



#### 递归

为了想出使用空间复杂度为 O(1)*O*(1) 的算法，你可能想过使用递归来解决，但是这仍然需要 O(n)*O*(*n*) 的空间复杂度。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
    let p = null;
    const recursivelyCheck = (currentNode) => {
        if (currentNode !== null) {
            if (!recursivelyCheck(currentNode.next)) {
                return false;
            }
            if (currentNode.val !== p.val) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    p = head;
    return recursivelyCheck(head);

}
module.exports = {
    isPail : isPail
};
```

这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。



#### 快慢指针

避免使用 O(n)O(n) 额外空间的方法就是改变输入。

我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。

该方法虽然可以将空间复杂度降到 O(1)O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。

整个流程可以分为以下五个步骤：

1. 找到前半部分链表的尾节点。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    if (head === null) {
        return true;
    }

    // 找到前半部分链表的尾节点并反转后半部分链表
    const fisrtHalfEnd = endOfFirstHalf(head);
    const secondHalfStart = reverseList(fisrtHalfEnd.next);

    // 判断是否回文
    let p1 = head;
    let p2 = secondHalfStart;
    let result = true;
    while (result && p2 !== null) {
        if (p1.val !== p2.val) {
            result = false;
        }
        p1 = p1.next;
        p2 = p2.next;
    }
    // 还原链表并返回结果
    fisrtHalfEnd.next = reverseList(secondHalfStart);

    return result;
}

const reverseList = (head) => {
    let prev = null;
    let curr = head;
    while (curr !== null) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

const endOfFirstHalf = (head) => {
    let slow = head;
    let fast = head;
    while (fast.next !== null && fast.next.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

module.exports = {
    isPail : isPail
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。

空间复杂度：O(1)O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)O(1)。



----

## **BM14** **链表的奇偶重排**

给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。

#### 分离节点后合并

原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead = head.next，则 evenHead 是偶数链表的头节点。

维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd = head，even = evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。

更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next = even.next，然后令 odd = odd.next，此时 odd 变成 even 的后一个节点。

更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next = odd.next，然后令 even = even.next，此时 even 变成 odd 的后一个节点。

在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。

最后令 odd.next = evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param head ListNode类 
 * @return ListNode类
 */
function oddEvenList( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    let odd = head;
    let even = head.next;
    let evenHead = head.next;
    while (even !== null && even.next !== null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;

    return head;
}
module.exports = {
    oddEvenList : oddEvenList
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。

空间复杂度：O(1)O(1)。只需要维护有限的指针。



----

## **BM15** **删除有序链表中重复的元素-I**

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

#### 一次遍历

由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。

具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。

当遍历完整个链表之后，我们返回链表的头节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @return ListNode类
  */
function deleteDuplicates( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    let curr = head;
    let prev = head;
    while (curr.next !== null) {
        if (curr.val === curr.next.val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }
    return head;
}
module.exports = {
    deleteDuplicates : deleteDuplicates
};
```



----

## **BM16** **删除有序链表中重复的元素-II**

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。

具体地，我们从指针 \textit{cur}cur 指向链表的哑节点，随后开始对链表进行遍历。如果当前 \textit{cur.next}cur.next 与 \textit{cur.next.next}cur.next.next 对应的元素相同，那么我们就需要将 \textit{cur.next}cur.next 以及所有后面拥有相同元素值的链表节点全部删除。我们记下这个元素值 xx，随后不断将 \textit{cur.next}cur.next 从链表中移除，直到 \textit{cur.next}cur.next 为空节点或者其元素值不等于 xx 为止。此时，我们将链表中所有元素值为 xx 的节点全部删除。

如果当前 \textit{cur.next}cur.next 与 \textit{cur.next.next}cur.next.next 对应的元素不相同，那么说明链表中只有一个元素值为 \textit{cur.next}cur.next 的节点，那么我们就可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。

当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 \textit{dummy.next}dummy.next 即可。

细节

需要注意 \textit{cur.next}cur.next 以及 \textit{cur.next.next}cur.next.next 可能为空节点，如果不加以判断，可能会产生运行错误。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @return ListNode类
  */
function deleteDuplicates( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let curr = dummyNode;
    
    while (curr.next && curr.next.next) {
        if (curr.next.val === curr.next.next.val) {
            const x = curr.next.val;
            while (curr.next !== null && curr.next.val === x) {
                curr.next = curr.next.next;
            }
        } else {
            curr = curr.next;
        }
    }
    return dummyNode.next;
}

module.exports = {
    deleteDuplicates : deleteDuplicates
};
```



-----

## **BM17** **二分查找-I**

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

二分查找的做法是，定义查找的范围 [\textit{left}, \textit{right}][left,right]，初始查找范围是整个数组。每次取查找范围的中点 \textit{mid}mid，比较 \textit{nums}[\textit{mid}]nums[mid] 和 \textit{target}target 的大小，如果相等则 \textit{mid}mid 即为要寻找的下标，如果不相等则根据 \textit{nums}[\textit{mid}]nums[mid] 和 \textit{target}target 的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(\log n)O(logn)，其中 nn 是数组的长度。

二分查找的条件是查找范围不为空，即 \textit{left} \le \textit{right}left≤right。如果 \textit{target}target 在数组中，二分查找可以保证找到 \textit{target}target，返回 \textit{target}target 在数组中的下标。如果 \textit{target}target 不在数组中，则当 \textit{left} > \textit{right}left>right 时结束查找，返回 -1−1。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @param target int整型 
 * @return int整型
 */
function search( nums ,  target ) {
    // write code here
    let left = 0, right = nums.length - 1;
    let mid;
    while (left <= right) {
        mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}

// let nums = [-1,0,3,5,9,12], target = 9;
// console.log(search(nums, target))

module.exports = {
    search : search
};
```

**复杂度分析**

- 时间复杂度：O(\log n)*O*(log*n*)，其中 n*n* 是数组的长度。
- 空间复杂度：O(1)*O*(1)。



-----

## **BM18** **二维数组中的查找**

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

### 线性查找

由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

- 若数组为空，返回 false

- 初始化行下标为 0，列下标为二维数组的列数减 1
- 重复下列步骤，直到行下标或列下标超出边界
- - 获得当前下标位置的元素 num
  - 如果 num 和 target 相等，返回 true
  - 如果 num 大于 target，列下标减 1
  - 如果 num 小于 target，行下标加 1
- 循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false`



```js
function Find(target, array){
    // write code here
    if (array === null || array.length === 0 || array[0].length === 0) {
        return false;
    }
    let m = array.length;
    let n = array[0].length;
    let row = 0;
    let col = n - 1;
    while (row < m && col >= 0) {
        if (array[row][col] < target) {
            row++;
        } else if (array[row][col] > target) {
            col--;
        } else {
            return true;
        }
    }
    return false;
}
module.exports = {
    Find : Find
};
```

复杂度分析

时间复杂度：O(n+m)O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。
空间复杂度：O(1)O(1)。



----

## **BM19** **寻找峰值**

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]

#### 寻找最大值

由于题目保证了 \textit{nums}[i] \neq \textit{nums}[i+1]nums[i]  =nums[i+1]，那么数组 \textit{nums}nums 中最大值两侧的元素一定严格小于最大值本身。因此，最大值所在的位置就是一个可行的峰值位置。

我们对数组 \textit{nums}nums 进行一次遍历，找到最大值对应的位置即可。

```js
var findPeakElement = function(nums) {
    let idx = 0;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] > nums[idx]) {
            idx = i;
        }
    }
    return idx;
};

```



#### 迭代爬坡

俗话说「人往高处走，水往低处流」。如果我们从一个位置开始，不断地向高处走，那么最终一定可以到达一个峰值位置。

因此，我们首先在 [0, n)[0,n) 的范围内随机一个初始位置 ii，随后根据nums[i−1],nums[i],nums[i+1] 三者的关系决定向哪个方向走：

如果 nums[i−1]<nums[i]>nums[i+1]，那么位置 ii 就是峰值位置，我们可以直接返回 ii 作为答案；

如果nums[i−1]<nums[i]<nums[i+1]，那么位置 ii 处于上坡，我们需要往右走，即 i \leftarrow i+1i←i+1；

如果nums[i−1]>nums[i]>nums[i+1]，那么位置 ii 处于下坡，我们需要往左走，即 i \leftarrow i-1i←i−1；

如果nums[i−1]>nums[i]<nums[i+1]，那么位置 ii 位于山谷，两侧都是上坡，我们可以朝任意方向走。

如果我们规定对于最后一种情况往右走，那么当位置 ii 不是峰值位置时：

如果nums[i]<nums[i+1]，那么我们往右走；

如果 nums[i]>nums[i+1]，那么我们往左走。

```js
var findPeakElement = function(nums) {
    const n = nums.length;
    let idx = parseInt(Math.random() * n);

    while (!(compare(nums, idx - 1, idx) < 0 && compare(nums, idx, idx + 1) > 0)) {
        if (compare(nums, idx, idx + 1) < 0) {
            idx += 1;
        } else {
            idx -= 1;
        }
    }
    
    return idx;
}

// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
// 方便处理 nums[-1] 以及 nums[n] 的边界情况
const get = (nums, idx) => {
    if (idx === -1 || idx === nums.length) {
        return [0, 0];
    }
    return [1, nums[idx]];
}

const compare = (nums, idx1, idx2) => {
    const num1 = get(nums, idx1);
    const num2 = get(nums, idx2);
    if (num1[0] !== num2[0]) {
        return num1[0] > num2[0] ? 1 : -1;
    }
    if (num1[1] === num2[1]) {
        return 0;
    }
    return num1[1] > num2[1] ? 1 : -1;
}


```



#### 二分查找优化

我们可以发现，如果 nums[i]<nums[i+1]，并且我们从位置 ii 向右走到了位置 i+1i+1，那么位置 ii 左侧的所有位置是不可能在后续的迭代中走到的。

这是因为我们每次向左或向右移动一个位置，要想「折返」到位置 ii 以及其左侧的位置，我们首先需要在位置 i+1i+1 向左走到位置 ii，但这是不可能的。

并且根据方法二，我们知道位置 i+1i+1 以及其右侧的位置中一定有一个峰值，因此我们可以设计出如下的一个算法：

对于当前可行的下标范围 [l, r][l,r]，我们随机一个下标 ii；

如果下标 ii 是峰值，我们返回 ii 作为答案；

如果nums[i]<nums[i+1]，那么我们抛弃 [l, i][l,i] 的范围，在剩余 [i+1, r][i+1,r] 的范围内继续随机选取下标；

如果 nums[i]>nums[i+1]，那么我们抛弃 [i, r][i,r] 的范围，在剩余 [l, i-1][l,i−1] 的范围内继续随机选取下标。

在上述算法中，如果我们固定选取 ii 为 [l, r][l,r] 的中点，那么每次可行的下标范围会减少一半，成为一个类似二分查找的方法，时间复杂度为 O(\log n)O(logn)。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @return int整型
 */
function findPeakElement( nums ) {
    // write code here
    const n = nums.length;
    let left =0, right = n - 1;
    let ans = -1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (compare(nums, mid - 1, mid) < 0 && compare(nums, mid, mid + 1) > 0) {
            ans = mid;
            break;
        }
        if (compare(nums, mid, mid + 1) < 0) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
// 方便处理 nums[-1] 以及 nums[n] 的边界情况
const get = (nums, idx) => {
    if (idx === -1 || idx === nums.length) {
        return[0, 0];
    }
    return [1, nums[idx]];
}

const compare = (nums, idx1, idx2) => {
    const num1 = get(nums, idx1);
    const num2 = get(nums, idx2);
    if (num1[0] !== num2[0]) {
        return num1[0] > num2[0] ? 1 : -1;
    }
    if (num1[1] === num2[1]) {
        return 0;
    }
    return num1[1] > num2[1] ? 1 : -1;
}

module.exports = {
    findPeakElement : findPeakElement
};
```

**复杂度分析**

- 时间复杂度：O(\log n)*O*(log*n*)，其中 n*n* 是数组 \textit{nums}*nums* 的长度。
- 空间复杂度：O(1)*O*(1)。



----

## **BM20** **数组中的逆序对**

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数P。

并将P对1000000007取模的结果输出。 即输出P mod 1000000007

要求：空间复杂度 O(n)，时间复杂度 O(nlogn)



#### 归并排序

![求逆序对](E:\pogject\学习笔记\image\niuke\求逆序对.png)

```js
function InversePairs(nums){
    // write code here
    const n = nums.length;
    if (n < 2) {
        return 0;
    }
    const copy = [...nums];
    const temp = new Array(n);
    const ans = dfs(copy, 0, n - 1, temp);
    const MOD = 1000000007;
    return ans % MOD;
}

const dfs = (nums, left, right, temp) => {
    if (left === right) {
        return 0;
    }
    let mid = left + Math.floor((right - left) / 2);
    let leftPairs = dfs(nums, left, mid, temp);
    let rightPairs = dfs(nums, mid + 1, right, temp);

    if (nums[mid] <= nums[mid + 1]) {
        return leftPairs + rightPairs;
    }

    let crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
}

const mergeAndCount = (nums, left, mid, right, temp) => {
    for (let i = left; i <= right; i++) {
        temp[i] = nums[i];
    }
    let i = left;
    let j = mid + 1;
    let count = 0;
    for (let k = left; k <= right; k++) {
        if (i === mid + 1) {
            nums[k] = temp[j];
            j++;
        } else if (j === right + 1) {
            nums[k] = temp[i];
            i++;
        } else if (temp[i] <= temp[j]) {
            nums[k] = temp[i];
            i++;
        } else {
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        }
    }
    return count;
}

// let nums = [1,2,3,4,5,6,7,0];
// console.log(InversePairs(nums));

module.exports = {
    InversePairs : InversePairs
};
```



----

## **BM21** **旋转数组的最小数字**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

 

提示：

n == numbers.length
1 <= n <= 5000
-5000 <= numbers[i] <= 5000
numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

要求：空间复杂度：O(1)*O*(1) ，时间复杂度：O(logn)*O*(*l**o**g**n*)



#### 二分查找

我们考虑数组中的最后一个元素 xx：在最小值右侧的元素，它们的值一定都小于等于 xx；而在最小值左侧的元素，它们的值一定都大于等于 xx。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

```js
function minNumberInRotateArray(nums)
{
    // write code here
    let low = 0;
    let high = nums.length - 1;
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        if (nums[mid] < nums[high]) {
            high = mid;
        } else if (nums[mid] > nums[high]) {
            low = mid + 1;
        } else {
            high -= 1;
        }
    }
    return nums[low];
}
module.exports = {
    minNumberInRotateArray : minNumberInRotateArray
};
```

时间复杂度：平均时间复杂度为 O(\log n)O(logn)，其中 nn 是数组 \it numbersnumbers 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 \texttt{while}while 循环就需要执行 nn 次，每次忽略区间的右端点，时间复杂度为 O(n)O(n)。

空间复杂度：O(1)O(1)。



```js
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function(numbers) {
    let n = numbers.length;
    let left = 0;
    let right = n - 1;
    let mid = 0;
    while(numbers[left] >= numbers[right]) {
        if (right - left === 1) {
            mid = right;
            break;
        }
        mid = left + Math.floor((right - left) / 2);
        // 如果left,right, mid指向的三个数字相等，只能顺序查找
        if (numbers[left] === numbers[right] && numbers[left] === numbers[mid]) {
            return minInOrder(numbers, left, right);
        }

        if (numbers[mid] >= numbers[left]) {
            left = mid;
        } else if (numbers[mid] <= numbers[right]) {
            right = mid;
        }
    }
    return numbers[mid];
}

const minInOrder = (numbers, left, right) => {
    let result = numbers[left];
    for (let i = left + 1; i <= right; ++i) {
        if (result > numbers[i]) {
            result = numbers[i];
        }
    }
    return result;
}

let numbers = [1, 0, 1, 1, 1];
// let numbers = [3, 4, 5, 1, 2];
console.log(minArray(numbers, 5));
```



----

## **BM22** **比较版本号**

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：

如果 version1 > version2 返回 1，
如果 version1 < version2 返回 -1，
除此之外返回 0。

提示：

1 <= version1.length, version2.length <= 500
version1 和 version2 仅包含数字和 '.'
version1 和 version2 都是 有效版本号
version1 和 version2 的所有修订号都可以存储在 32 位整数 中

#### 字符串分割

我们可以将版本号按照点号分割成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0。

```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
	const v1 = version1.split(".");
	const v2 = version2.split(".");
	for (let i = 0; i < v1.length || i < v2.length; i++) {
		let x = 0, y = 0;
		if (i < v1.length) {
			x = parseInt(v1[i]);
		}
		if (i < v2.length) {
			y = parseInt(v2[i]);
		}
		if (x > y) {
			return 1;
		}
		if (x < y) {
			return -1;
		}
	}
	return 0;
};

let version1 = "1.01", version2 = "1.001";
console.log(compareVersion(version1, version2));
```

时间复杂度：O(n+m)O(n+m)（或 O(\max(n,m))O(max(n,m))，这是等价的），其中 nn 是字符串 \textit{version1}version1 的长度，mm 是字符串 \textit{version2}version2 的长度。

空间复杂度：O(n+m)O(n+m)，我们需要 O(n+m)O(n+m) 的空间存储分割后的修订号列表。



#### 双指针

方法一需要存储分割后的修订号，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 比较版本号
 * @param version1 string字符串 
 * @param version2 string字符串 
 * @return int整型
 */
function compare( version1 ,  version2 ) {
    // write code here
    const n = version1.length, m = version2.length;
    let i = 0, j = 0;
    while (i < n || j < m) {
        let x = 0;
        for (; i < n && version1[i] !== "."; i++) {
            x = x * 10 + version1[i].charCodeAt() - '0'.charCodeAt();
        }
        ++i;  // 跳过点号
        let y = 0;
        for (; j < m && version2[j] !== "."; j++) {
            y = y * 10 + version2[j].charCodeAt() - '0'.charCodeAt();
        }
        ++j;  // 跳过点号
        if (x !== y) {
            return x > y ? 1 : -1;
        }
    }
    return 0;
}

module.exports = {
    compare : compare
};
```

复杂度分析

时间复杂度：O(n+m)O(n+m)，其中 nn 是字符串 \textit{version1}version1 的长度，mm 是字符串 \textit{version2}version2 的长度。

空间复杂度：O(1)O(1)，我们只需要常数的空间保存若干变量。



----

## **BM23** **二叉树的前序遍历**
