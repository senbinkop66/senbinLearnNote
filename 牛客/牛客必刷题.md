## **BM1** **反转链表**

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

**思路**

如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表



首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。



#### 迭代

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
    return pre;
}
module.exports = {
    ReverseList : ReverseList
};
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)。



#### 递归

递归版本稍微复杂一些，其关键在于反向工作。

递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // 和双指针法初始化是一样的逻辑
        // let cur = head;
        // let pre = NULL;
    return reverse(null, pHead);

}

const reverse = (pre, cur) => {
    if (!cur) {
        return pre;
    }
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
    return reverse(pre, temp);
}

module.exports = {
    ReverseList : ReverseList
};
```

我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // 边缘条件判断
    if (pHead === null) return null;
    if (pHead.next === null) return pHead;

    // 递归调用，翻转第二个节点开始往后的链表
    let last = ReverseList(pHead.next);
    // 翻转头节点与第二个节点的指向
    pHead.next.next = pHead;
    // 此时的 head 节点为尾节点，next 需要指向 NULL
    pHead.next = null;
    return last;
}

module.exports = {
    ReverseList : ReverseList
};
```

复杂度分析

时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。

空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。



----

## **BM2** **链表内指定区间反转**

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

 提示：

链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。

思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。

#### 穿针引线

![反转链表2](E:\pogject\学习笔记\image\niuke\反转链表2.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param m int整型 
  * @param n int整型 
  * @return ListNode类
  */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;

    return dummyNode.next;
}

function reverseLinkedList(pHead){
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
}


module.exports = {
    reverseBetween : reverseBetween
};
```

**复杂度分析**

- 时间复杂度：*O*(*N*)，其中 *N* 是链表总节点数。最坏情况下，需要遍历整个链表。
- 空间复杂度：*O*(1)。只使用到常数个变量。



#### 一次遍历「穿针引线」（头插法）

方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。

整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。

![反转链表2_2](E:\pogject\学习笔记\image\niuke\反转链表2_2.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; i++) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}



module.exports = {
    reverseBetween : reverseBetween
};
```

复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 是链表总节点数。最多只遍历了链表一次，就完成了反转。

空间复杂度：O(1)O(1)。只使用到常数个变量。



----

## **BM3** **链表中的节点每k个一组翻转**

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`



我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。

接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。

因此，在翻转子链表的时候，我们不仅需要子链表头节点 `head`，还需要有 `head` 的上一个节点 `pre`，以便翻转完后把子链表再接回 `pre`。

但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。

反复移动指针 `head` 与 `pre`，对 `head` 所指向的子链表进行翻转，直到结尾，我们就得到了答案。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    const dummyHead = new ListNode(-1);  // 哑结点
    dummyHead.next = head;

    let pre = dummyHead;

    while (head) {
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i < k; i++) {
            tail = tail.next;
            if (!tail) {
                return dummyHead.next;
            }
        }
        const next = tail.next;
        [head, tail] = myReverse(head, tail);
        
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = next;
        pre = tail;
        head = tail.next;
    }
    return dummyHead.next;
};

const myReverse = (head, tail) => {
    let prev = tail.next;
    let p = head;
    while (prev !== tail) {
        const next = p.next;
        p.next = prev;
        prev = p;
        p = next;
    }
    return [tail, head];
}

module.exports = {
    reverseKGroup : reverseKGroup
};
```





----

## **BM4** **合并两个排序的链表**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列



#### 递归

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function Merge(pHead1, pHead2)
{
    if (pHead1 === null) {
        return pHead2;
    } else if (pHead2 === null) {
        return pHead1;
    } else if (pHead1.val < pHead2.val) {
        pHead1.next = Merge(pHead1.next, pHead2);
        return pHead1;
    } else {
        pHead2.next = Merge(pHead1, pHead2.next);
        return pHead2;
    }
}
module.exports = {
    Merge : Merge
};
```



#### 迭代

```js
function ListNode(x){
    this.val = x;
    this.next = null;
}

function Merge(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}
module.exports = {
    Merge : Merge
};
```



----

## **BM5** **合并k个已排序的链表**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

要求：时间复杂度 O(nlogk)



#### 顺序合并

我们可以想到一种最朴素的方法：用一个变量ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和ans 合并，答案保存到 ans 中。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    let ans = null, n = lists.length;
    for (let i = 0; i < n; i++) {
        ans = MergeTwoLists(ans, lists[i]);
    }
    return ans;
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 分治合并

![合并k个链表](E:\pogject\学习笔记\image\niuke\合并k个链表.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

function merge(lists, left, right) {
    if (left === right) {
        return lists[left];
    }
    if (left > right) {
        return null;
    }
    const mid = (left + right) >> 1;
    return MergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));
}
/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    return merge(lists, 0, lists.length - 1);
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 使用优先队列合并

这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，kk 个链表就最多有 kk 个满足这样条件的元素，每次在这些元素里面选取 \textit{val}val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

思路：新建小顶堆，小顶堆的大小是k，不断从每个链表的头节点开始不断加入小顶堆中，然后取出堆顶值，也就是最小值，然后继续往小顶堆中插入这个最小值在链表的next节点
复杂度：时间复杂度O(kn * logk)，优先队列的大小是k，每次插入和删除是O(logk)，总共k * n的节点个数，每个节点插入删除一次，所以总的复杂度是O(kn*logk)。空间复杂度是O(k)，即优先队列的大小

```js
class Heap {
    constructor(comparator = (a, b) => a - b, data = []) {
        this.data = data;
        this.comparator = comparator;  // 比较器
        this.heapify();  // 堆化
    }

    heapify() {
        if (this.size() < 2) {
            return;
        }
        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i--) {
            this.bubbleDowm(i);  // bubbleDown操作
        }
    }

    peek() {
        if (this.size() === 0) {
            return null;
        }
        return this.data[0];  // 查看堆顶
    }

    offer(value) {
        this.data.push(value);  // 加入数组
        this.bubbleUp(this.size() - 1);  //调整加入的元素在小顶堆中的位置
    }

    poll() {
        if (this.size() === 0) {
            return null;
        }
        const result = this.data[0];
        const last = this.data.pop();
        if (this.size() !== 0) {
            this.data[0] = last;  // 交换第一个元素和最后一个元素
            this.bubbleDowm(0);  // bubbleDown操作
        }
        return result;
    }

    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = (index - 1) >> 1;  // 父节点的位置
            //如果当前元素比父节点的元素小，就交换当前节点和父节点的位置
            if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {
                this.swap(index, parentIndex);  //交换自己和父节点的位置
                index = parentIndex;
            } else {
                break;  //如果当前元素比父节点的元素大，不需要处理
            }
        }
    }

    bubbleDowm(index) {
        const lastIndex = this.size() - 1;  // 最后一个节点的位置
        while (true) {
            const leftIndex = index * 2 + 1;  //左节点的位置
            const rightIndex = index * 2 + 2;  //右节点的位置
            let findIndex = index;  //bubbleDown节点的位置
            //找出左右节点中value小的节点
            if (leftIndex <= lastIndex && this.comparator(this.data[leftIndex], this.data[findIndex]) < 0) {
                findIndex = leftIndex;
            }
            if (rightIndex <= lastIndex && this.comparator(this.data[rightIndex], this.data[findIndex]) < 0) {
                finished = rightIndex;
            }
            if (index !== findIndex) {
                this.swap(index, findIndex);  //交换当前元素和左右节点中value小的
                index = findIndex;
            } else {
                break;
            }
        }
    }

    swap(index1, index2) {
        [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]]
    }

    size() {
        return this.data.length;
    }
}


/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function mergeKLists(lists){
    const res = new ListNode(-1);

    let prev = res;

    const h = new Heap(comparator = (a, b) => a.val - b.val);

    lists.forEach(list => {
        //插入每个链表的第一个节点
        if (list) {
            h.offer(list);
        }
    });
    while (h.size()) {
       const n = h.poll();  //取出最小值
       prev.next = n;  //最小值加入p的next后
       prev = prev.next;  // 移动节点
       if (n.next) {
        h.offer(n.next);  //插入最小节点的后一个节点
       }
    }

    return res.next;
}


module.exports = {
    mergeKLists : mergeKLists
};
```



----

## **BM6** **判断链表中是否有环**

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

#### **哈希表**

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    const visited = new Set();
    while(head !== null) {
        if (visited.has(head)) {
            return true;
        }
        visited.add(head);
        head = head.next;
    }
    return false;
}
module.exports = {
    hasCycle : hasCycle
};
```



#### **快慢指针**

具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    if (head === null || head.next === null) {
        return false;
    }
    let slow = head;
    let fast = head.next;
    while(slow !== fast) {
        if (fast === null || fast.next === null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;;
}
module.exports = {
    hasCycle : hasCycle
};
```



----

## **BM7** **链表中环的入口结点**

#### 哈希表

一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(pHead)
{
    // write code here
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



#### 快慢指针

![环形链表入口节点](E:\pogject\学习笔记\image\niuke\环形链表入口节点.png)

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(head)
{
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;

    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



----

## **BM8** **链表中倒数最后k个结点**

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

#### 顺序查找

思路与算法

最简单直接的方法即为顺序查找，假设当前链表的长度为 nn，则我们知道链表的倒数第 kk 个节点即为正数第 n - kn−k 个节点，此时我们只需要顺序遍历到链表的第 n - kn−k 个节点即为倒数第 kk 个节点。

我们首先求出链表的长度 nn，然后顺序遍历到链表的第 n - kn−k 个节点返回即可。

```go
func getKthFromEnd(head *ListNode, k int) (kth *ListNode) {
    n := 0
    for node := head; node != nil; node = node.Next {
        n++
    }
    for kth = head; n > k; n-- {
        kth = kth.Next
    }
    return
}

```

#### 双指针

快慢指针的思想。我们将第一个指针 \textit{fast}fast 指向链表的第 k + 1k+1 个节点，第二个指针 \textit{slow}slow 指向链表的第一个节点，此时指针 \textit{fast}fast 与 \textit{slow}slow 二者之间刚好间隔 kk 个节点。此时两个指针同步向后走，当第一个指针 \textit{fast}fast 走到链表的尾部空节点时，则此时 \textit{slow}slow 指针刚好指向链表的倒数第kk个节点。

我们首先将 \textit{fast}fast 指向链表的头节点，然后向后走 kk 步，则此时 \textit{fast}fast 指针刚好指向链表的第 k + 1k+1 个节点。

我们首先将 \textit{slow}slow 指向链表的头节点，同时 \textit{slow}slow 与 \textit{fast}fast 同步向后走，当 \textit{fast}fast 指针指向链表的尾部空节点时，则此时返回 \textit{slow}slow 所指向的节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */
function FindKthToTail( head ,  k ) {
    // write code here
    let fast = head, slow = head;

    while (fast && k > 0) {
        [fast, k] = [fast.next, k - 1];
    }
    if (k > 0) {
        return null;
    }
    while (fast) {
        [fast, slow] = [fast.next, slow.next];
    }
    return slow;
}
module.exports = {
    FindKthToTail : FindKthToTail
};
```



----

## **BM9** **删除链表的倒数第n个节点**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。



在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 \textit{next}next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。

例如，在本题中，如果我们要删除节点 yy，我们需要知道节点 yy 的前驱节点 xx，并将 xx 的指针指向 yy 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。

特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。

#### 计算链表长度

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。

为了方便删除操作，我们可以从哑节点开始遍历 L-n+1L−n+1 个节点。当遍历到第 L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const len = getLength(head);
    let cur =dummyNode;
    for (let i = 1; i < len - n + 1; i++) {
        cur = cur.next;
    }
    cur.next = cur.next.next;

    return dummyNode.next;
}

function getLength(head) {
    let len = 0;
    while (head !== null) {
        len++;
        head = head.next;
    }
    return len;
}
module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const stack = [];

    let cur =dummyNode;
    while (cur !== null) {
        stack.push(cur);
        cur= cur.next;
    }
    for (let i = 0; i < n; i++) {
        stack.pop();
    }
    let prev = stack[stack.length - 1];
    prev.next = prev.next.next;

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 双指针

由于我们需要找到倒数第 nn 个节点，因此我们可以使用两个指针 \textit{first}first 和 \textit{second}second 同时对链表进行遍历，并且 \textit{first}first 比 \textit{second}second 超前 nn 个节点。当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 就恰好处于倒数第 nn 个节点。

根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 \textit{second}second 指向哑节点，其余的操作步骤不变。这样一来，当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 的下一个节点就是我们需要删除的节点。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let first = head, second = dummyNode;

    for (let i = 0; i < n; i++) {
        first = first.next;
    }
    while (first !== null) {
        first = first.next;
        second = second.next;
    }
    
    second.next = second.next.next;  // 删除结点

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



----

## **BM10** **两个链表的第一个公共结点**

#### 哈希集合

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都是两个链表的公共节点，因此在链表 \textit{headB}headB 中遍历到的第一个在哈希集合中的节点就是两个链表的第一个公共节点，返回该节点。

如果链表 \textit{headB}headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 \text{null}null。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    vis := map[*ListNode]bool{}
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        vis[tmp] = true
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if vis[tmp] {
            return tmp
        }
    }
    return nil
}


```



#### 双指针

使用双指针的方法，可以将空间复杂度降至 O(1)O(1)。

只有当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，两个链表才可能相交。因此首先判断链表 \textit{headA}headA 和 \textit{headB}headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 \text{null}null。

当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，创建两个指针 \textit{pA}pA 和 \textit{pB}pB，初始时分别指向两个链表的头节点 \textit{headA}headA 和 \textit{headB}headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

- 每步操作需要同时更新指针 \textit{pA}pA 和 \textit{pB}pB。

- 如果指针 \textit{pA}pA 不为空，则将指针 \textit{pA}pA 移到下一个节点；如果指针 \textit{pB}pB 不为空，则将指针 \textit{pB}pB 移到下一个节点。

- 如果指针 \textit{pA}pA 为空，则将指针 \textit{pA}pA 移到链表 \textit{headB}headB 的头节点；如果指针 \textit{pB}pB 为空，则将指针 \textit{pB}pB 移到链表 \textit{headA}headA 的头节点。

- 当指针 \textit{pA}pA 和 \textit{pB}pB 指向同一个节点或者都为空时，返回它们指向的节点或者 \text{null}null。


```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    if (pHead1 === null || pHead2 === null) {
        return null;
    }
    let p1 = pHead1, p2 = pHead2;
    while (p1 !== p2) {
        p1 = p1 === null ? pHead2 : p1.next;
        p2 = p2 === null ? pHead1 : p2.next;
    }
    return p1;
}
module.exports = {
    FindFirstCommonNode : FindFirstCommonNode
};
```

复杂度分析

时间复杂度：O(m+n)O(m+n)，其中 mm 和 nn 是分别是链表 \textit{headA}headA 和 \textit{headB}headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。

空间复杂度：O(1)O(1)。



----

## **BM11** **链表中的两数相加**

给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

提示：

链表的长度范围为 [1, 100]
0 <= node.val <= 9
输入数据保证链表代表的数字无前导 0


进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。



#### 栈

本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head1 ListNode类 
 * @param head2 ListNode类 
 * @return ListNode类
 */
function addInList( head1 ,  head2 ) {
    // write code here
    let stack1 = [], stack2 = [];
    while (head1 !== null) {
        stack1.push(head1.val);
        head1 = head1.next;
    }
    while (head2 !== null) {
        stack2.push(head2.val);
        head2 = head2.next;
    }

    let carry = 0;
    let ans = null;
    while (stack1.length !== 0 || stack2.length !== 0 || carry !== 0) {
        let a = stack1.length ? stack1.pop() : 0;
        let b = stack2.length ? stack2.pop() : 0;
        let cur = a + b + carry;
        carry = cur > 9 ? 1 : 0;
        cur %= 10;
        let curNode = new ListNode(cur);
        curNode.next = ans;
        ans = curNode;
    }
    return ans;
}
module.exports = {
    addInList : addInList
};
```



#### 反转链表+双指针求和

先把l1和l2都进行反转
然后通过双指针进行求和
最后把结果再进行反转即可了

```js
var addTwoNumbers = function(l1, l2) {
    // 反转链表
    function reverse(head) {
        var pre = null;
        var cur = head;
        while (cur) {
            var next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    // 进行两数想加
    var reverseL1 = reverse(l1);
    var reverseL2 = reverse(l2);
    var res = null;
    var carry = 0;
    var tail = res;
    while (reverseL1 || reverseL2) {
        const x = reverseL1 ? reverseL1.val - '0' : 0;
        const y = reverseL2 ? reverseL2.val - '0' : 0;
        const sum = x + y + carry;
        if (!res) {
            res = tail = new ListNode(sum % 10);
        } else {
            tail.next = new ListNode(sum % 10);
            tail = tail.next;
        }
        carry = Math.floor(sum / 10);
        if(reverseL1) reverseL1 = reverseL1.next;
        if(reverseL2) reverseL2 = reverseL2.next;
    }
    if (carry) tail.next = new ListNode(carry);

    // 最后再反转链表=
    return reverse(res);
};

```



-----

## **BM12** **单链表的排序**

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

要求使用插入排序的方法对链表进行排序，插入排序的时间复杂度是 O(n^2)O(n 2 )，其中 nn 是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 O(n \log n)O(nlogn) 的时间复杂度和 O(1)O(1) 的空间复杂度，时间复杂度是 O(n \log n)O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)O(n 2 )），其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(\log n)O(logn)。如果要达到 O(1)O(1) 的空间复杂度，则需要使用自底向上的实现方式。

#### 自顶向下归并排序

对链表自顶向下归并排序的过程如下。

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22 步，慢指针每次移动 11 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 11，即当链表为空或者链表只包含 11 个节点时，不需要对链表进行拆分和排序。



```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head node
 * @return ListNode类
 */
function sortInList( head ) {
    // write code here
    return toSortList(head, null);
};

const toSortList = (head, tail) => {
    if (head === null) {
        return head;
    }
    if (head.next === tail) {
        head.next = null;
        return head;
    }
    let slow = head, fast = head;
    while (fast !== tail) {
        slow = slow.next;
        fast = fast.next;
        if (fast !== tail) {
            fast = fast.next;
        }
    }
    const mid = slow;
    return merge(toSortList(head, mid), toSortList(mid, tail));
}

const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}

module.exports = {
    sortInList : sortInList
};
```

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，其中 nn 是链表的长度。

空间复杂度：O(\log n)O(logn)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间。



#### 自底向上归并排序

![自底向上归并排序链表](E:\pogject\学习笔记\image\niuke\自底向上归并排序链表.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head === null) {
        return head;
    }
    let len = 0;
    let node = head;
    while (node !== null) {
        len++;
        node = node.next;
    }

    const dummyNode = new ListNode(-1, head);

    for (let subLen = 1; subLen < len; subLen <<= 1) {
        let prev = dummyNode, curr = dummyNode.next;
        while (curr !== null) {
            let head1 = curr;
            for (let i = 1; i < subLen && curr.next !== null; i++) {
                curr = curr.next;
            }
            let head2 = curr.next;
            curr.next = null;
            curr = head2;
            for (let i = 1; i < subLen && curr !== null && curr.next !== null; i++) {
                curr = curr.next;
            }
            let next = null;
            if (curr !== null) {
                next = curr.next;
                curr.next = null;
            }
            const merged = merge(head1, head2);
            prev.next = merged;
            while (prev.next !== null) {
                prev = prev.next;
            }
            curr = next;
        }
    }
    return dummyNode.next;
};


const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}
```

**复杂度分析**

- 时间复杂度：O(n \log n)*O*(*n*log*n*)，其中 n*n* 是链表的长度。
- 空间复杂度：O(1)*O*(1)。



----

