## **BM1** **反转链表**

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

**思路**

如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表



首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。



#### 迭代

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead) {
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
    return pre;
}

```

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)。



#### 递归

递归版本稍微复杂一些，其关键在于反向工作。

递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead) {
    // 和双指针法初始化是一样的逻辑
        // let cur = head;
        // let pre = NULL;
    return reverse(null, pHead);

}

const reverse = (pre, cur) => {
    if (!cur) {
        return pre;
    }
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
    return reverse(pre, temp);
}
```

我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead) {
    // 边缘条件判断
    if (pHead === null) return null;
    if (pHead.next === null) return pHead;

    // 递归调用，翻转第二个节点开始往后的链表
    let last = ReverseList(pHead.next);
    // 翻转头节点与第二个节点的指向
    pHead.next.next = pHead;
    // 此时的 head 节点为尾节点，next 需要指向 NULL
    pHead.next = null;
    return last;
}
```

复杂度分析

时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。

空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。



----

## **BM2** **链表内指定区间反转**

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

 提示：

链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。

思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。

#### 穿针引线

![反转链表2](E:\pogject\学习笔记\image\niuke\反转链表2.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param m int整型 
  * @param n int整型 
  * @return ListNode类
  */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;

    return dummyNode.next;
}

function reverseLinkedList(pHead){
    // write code here
    let temp;  // 保存cur的下一个节点
    let cur = pHead;
    let pre = null;
    while (cur !== null) {
        temp = cur.next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
        cur.next = pre;  // 翻转操作
        // 更新pre 和 cur指针
        pre = cur;
        cur = temp;
    }
}


```

**复杂度分析**

- 时间复杂度：*O*(*N*)，其中 *N* 是链表总节点数。最坏情况下，需要遍历整个链表。
- 空间复杂度：*O*(1)。只使用到常数个变量。



#### 一次遍历「穿针引线」（头插法）

方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。

整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。

![反转链表2_2](E:\pogject\学习笔记\image\niuke\反转链表2_2.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
function reverseBetween(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; i++) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }

    return dummyNode.next;
}

```

复杂度分析：

时间复杂度：O(N)，其中 NN 是链表总节点数。最多只遍历了链表一次，就完成了反转。

空间复杂度：O(1)。只使用到常数个变量。



----

## **BM3** **链表中的节点每k个一组翻转**

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`



我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。

接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。

因此，在翻转子链表的时候，我们不仅需要子链表头节点 `head`，还需要有 `head` 的上一个节点 `pre`，以便翻转完后把子链表再接回 `pre`。

但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。

反复移动指针 `head` 与 `pre`，对 `head` 所指向的子链表进行翻转，直到结尾，我们就得到了答案。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    const dummyHead = new ListNode(-1);  // 哑结点
    dummyHead.next = head;

    let pre = dummyHead;

    while (head) {
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i < k; i++) {
            tail = tail.next;
            if (!tail) {
                return dummyHead.next;
            }
        }
        const next = tail.next;
        [head, tail] = myReverse(head, tail);
        
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = next;
        pre = tail;
        head = tail.next;
    }
    return dummyHead.next;
};

const myReverse = (head, tail) => {
    let prev = tail.next;
    let p = head;
    while (prev !== tail) {
        const next = p.next;
        p.next = prev;
        prev = p;
        p = next;
    }
    return [tail, head];
}

module.exports = {
    reverseKGroup : reverseKGroup
};
```





----

## **BM4** **合并两个排序的链表**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列



#### 递归

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function Merge(pHead1, pHead2)
{
    if (pHead1 === null) {
        return pHead2;
    } else if (pHead2 === null) {
        return pHead1;
    } else if (pHead1.val < pHead2.val) {
        pHead1.next = Merge(pHead1.next, pHead2);
        return pHead1;
    } else {
        pHead2.next = Merge(pHead1, pHead2.next);
        return pHead2;
    }
}
module.exports = {
    Merge : Merge
};
```



#### 迭代

```js
function ListNode(x){
    this.val = x;
    this.next = null;
}

function Merge(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}
module.exports = {
    Merge : Merge
};
```



----

## **BM5** **合并k个已排序的链表**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

要求：时间复杂度 O(nlogk)



#### 顺序合并

我们可以想到一种最朴素的方法：用一个变量ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和ans 合并，答案保存到 ans 中。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    let ans = null, n = lists.length;
    for (let i = 0; i < n; i++) {
        ans = MergeTwoLists(ans, lists[i]);
    }
    return ans;
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 分治合并

![合并k个链表](E:\pogject\学习笔记\image\niuke\合并k个链表.png)

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function MergeTwoLists(pHead1, pHead2){
     if (pHead1 === null) {
        return pHead2;
    }
    if (pHead2 === null) {
        return pHead1;
    }
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (pHead1 !== null && pHead2 !== null) {
        if (pHead1.val <= pHead2.val) {
            prev.next = pHead1;
            pHead1 = pHead1.next;
        } else {
            prev.next = pHead2;
            pHead2 = pHead2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = pHead1 === null ? pHead2 : pHead1;

    return preHead.next;
}

function merge(lists, left, right) {
    if (left === right) {
        return lists[left];
    }
    if (left > right) {
        return null;
    }
    const mid = (left + right) >> 1;
    return MergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));
}
/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    return merge(lists, 0, lists.length - 1);
}

module.exports = {
    mergeKLists : mergeKLists
};
```



#### 使用优先队列合并

这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，kk 个链表就最多有 kk 个满足这样条件的元素，每次在这些元素里面选取 \textit{val}val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

思路：新建小顶堆，小顶堆的大小是k，不断从每个链表的头节点开始不断加入小顶堆中，然后取出堆顶值，也就是最小值，然后继续往小顶堆中插入这个最小值在链表的next节点
复杂度：时间复杂度O(kn * logk)，优先队列的大小是k，每次插入和删除是O(logk)，总共k * n的节点个数，每个节点插入删除一次，所以总的复杂度是O(kn*logk)。空间复杂度是O(k)，即优先队列的大小

```js
class Heap {
    constructor(comparator = (a, b) => a - b, data = []) {
        this.data = data;
        this.comparator = comparator;  // 比较器
        this.heapify();  // 堆化
    }

    heapify() {
        if (this.size() < 2) {
            return;
        }
        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i--) {
            this.bubbleDowm(i);  // bubbleDown操作
        }
    }

    peek() {
        if (this.size() === 0) {
            return null;
        }
        return this.data[0];  // 查看堆顶
    }

    offer(value) {
        this.data.push(value);  // 加入数组
        this.bubbleUp(this.size() - 1);  //调整加入的元素在小顶堆中的位置
    }

    poll() {
        if (this.size() === 0) {
            return null;
        }
        const result = this.data[0];
        const last = this.data.pop();
        if (this.size() !== 0) {
            this.data[0] = last;  // 交换第一个元素和最后一个元素
            this.bubbleDowm(0);  // bubbleDown操作
        }
        return result;
    }

    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = (index - 1) >> 1;  // 父节点的位置
            //如果当前元素比父节点的元素小，就交换当前节点和父节点的位置
            if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {
                this.swap(index, parentIndex);  //交换自己和父节点的位置
                index = parentIndex;
            } else {
                break;  //如果当前元素比父节点的元素大，不需要处理
            }
        }
    }

    bubbleDowm(index) {
        const lastIndex = this.size() - 1;  // 最后一个节点的位置
        while (true) {
            const leftIndex = index * 2 + 1;  //左节点的位置
            const rightIndex = index * 2 + 2;  //右节点的位置
            let findIndex = index;  //bubbleDown节点的位置
            //找出左右节点中value小的节点
            if (leftIndex <= lastIndex && this.comparator(this.data[leftIndex], this.data[findIndex]) < 0) {
                findIndex = leftIndex;
            }
            if (rightIndex <= lastIndex && this.comparator(this.data[rightIndex], this.data[findIndex]) < 0) {
                finished = rightIndex;
            }
            if (index !== findIndex) {
                this.swap(index, findIndex);  //交换当前元素和左右节点中value小的
                index = findIndex;
            } else {
                break;
            }
        }
    }

    swap(index1, index2) {
        [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]]
    }

    size() {
        return this.data.length;
    }
}


/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

function mergeKLists(lists){
    const res = new ListNode(-1);

    let prev = res;

    const h = new Heap(comparator = (a, b) => a.val - b.val);

    lists.forEach(list => {
        //插入每个链表的第一个节点
        if (list) {
            h.offer(list);
        }
    });
    while (h.size()) {
       const n = h.poll();  //取出最小值
       prev.next = n;  //最小值加入p的next后
       prev = prev.next;  // 移动节点
       if (n.next) {
        h.offer(n.next);  //插入最小节点的后一个节点
       }
    }

    return res.next;
}


module.exports = {
    mergeKLists : mergeKLists
};
```



----

## **BM6** **判断链表中是否有环**

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

#### **哈希表**

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    const visited = new Set();
    while(head !== null) {
        if (visited.has(head)) {
            return true;
        }
        visited.add(head);
        head = head.next;
    }
    return false;
}
module.exports = {
    hasCycle : hasCycle
};
```



#### **快慢指针**

具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    if (head === null || head.next === null) {
        return false;
    }
    let slow = head;
    let fast = head.next;
    while(slow !== fast) {
        if (fast === null || fast.next === null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;;
}
module.exports = {
    hasCycle : hasCycle
};
```



----

## **BM7** **链表中环的入口结点**

#### 哈希表

一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(pHead)
{
    // write code here
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



#### 快慢指针

![环形链表入口节点](E:\pogject\学习笔记\image\niuke\环形链表入口节点.png)

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function EntryNodeOfLoop(head)
{
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;

    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
}
module.exports = {
    EntryNodeOfLoop : EntryNodeOfLoop
};
```



----

## **BM8** **链表中倒数最后k个结点**

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

#### 顺序查找

思路与算法

最简单直接的方法即为顺序查找，假设当前链表的长度为 nn，则我们知道链表的倒数第 kk 个节点即为正数第 n - kn−k 个节点，此时我们只需要顺序遍历到链表的第 n - kn−k 个节点即为倒数第 kk 个节点。

我们首先求出链表的长度 nn，然后顺序遍历到链表的第 n - kn−k 个节点返回即可。

```go
func getKthFromEnd(head *ListNode, k int) (kth *ListNode) {
    n := 0
    for node := head; node != nil; node = node.Next {
        n++
    }
    for kth = head; n > k; n-- {
        kth = kth.Next
    }
    return
}

```

#### 双指针

快慢指针的思想。我们将第一个指针 \textit{fast}fast 指向链表的第 k + 1k+1 个节点，第二个指针 \textit{slow}slow 指向链表的第一个节点，此时指针 \textit{fast}fast 与 \textit{slow}slow 二者之间刚好间隔 kk 个节点。此时两个指针同步向后走，当第一个指针 \textit{fast}fast 走到链表的尾部空节点时，则此时 \textit{slow}slow 指针刚好指向链表的倒数第kk个节点。

我们首先将 \textit{fast}fast 指向链表的头节点，然后向后走 kk 步，则此时 \textit{fast}fast 指针刚好指向链表的第 k + 1k+1 个节点。

我们首先将 \textit{slow}slow 指向链表的头节点，同时 \textit{slow}slow 与 \textit{fast}fast 同步向后走，当 \textit{fast}fast 指针指向链表的尾部空节点时，则此时返回 \textit{slow}slow 所指向的节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead ListNode类 
 * @param k int整型 
 * @return ListNode类
 */
function FindKthToTail( head ,  k ) {
    // write code here
    let fast = head, slow = head;

    while (fast && k > 0) {
        [fast, k] = [fast.next, k - 1];
    }
    if (k > 0) {
        return null;
    }
    while (fast) {
        [fast, slow] = [fast.next, slow.next];
    }
    return slow;
}
module.exports = {
    FindKthToTail : FindKthToTail
};
```



----

## **BM9** **删除链表的倒数第n个节点**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。



在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 \textit{next}next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。

例如，在本题中，如果我们要删除节点 yy，我们需要知道节点 yy 的前驱节点 xx，并将 xx 的指针指向 yy 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。

特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。

#### 计算链表长度

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。

为了方便删除操作，我们可以从哑节点开始遍历 L-n+1L−n+1 个节点。当遍历到第 L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const len = getLength(head);
    let cur =dummyNode;
    for (let i = 1; i < len - n + 1; i++) {
        cur = cur.next;
    }
    cur.next = cur.next.next;

    return dummyNode.next;
}

function getLength(head) {
    let len = 0;
    while (head !== null) {
        len++;
        head = head.next;
    }
    return len;
}
module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    const stack = [];

    let cur =dummyNode;
    while (cur !== null) {
        stack.push(cur);
        cur= cur.next;
    }
    for (let i = 0; i < n; i++) {
        stack.pop();
    }
    let prev = stack[stack.length - 1];
    prev.next = prev.next.next;

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



#### 双指针

由于我们需要找到倒数第 nn 个节点，因此我们可以使用两个指针 \textit{first}first 和 \textit{second}second 同时对链表进行遍历，并且 \textit{first}first 比 \textit{second}second 超前 nn 个节点。当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 就恰好处于倒数第 nn 个节点。

根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 \textit{second}second 指向哑节点，其余的操作步骤不变。这样一来，当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 的下一个节点就是我们需要删除的节点。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param n int整型 
  * @return ListNode类
  */
function removeNthFromEnd( head ,  n ) {
    // write code here
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let first = head, second = dummyNode;

    for (let i = 0; i < n; i++) {
        first = first.next;
    }
    while (first !== null) {
        first = first.next;
        second = second.next;
    }
    
    second.next = second.next.next;  // 删除结点

    return dummyNode.next;
}

module.exports = {
    removeNthFromEnd : removeNthFromEnd
};
```



----

## **BM10** **两个链表的第一个公共结点**

#### 哈希集合

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都是两个链表的公共节点，因此在链表 \textit{headB}headB 中遍历到的第一个在哈希集合中的节点就是两个链表的第一个公共节点，返回该节点。

如果链表 \textit{headB}headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 \text{null}null。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    vis := map[*ListNode]bool{}
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        vis[tmp] = true
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if vis[tmp] {
            return tmp
        }
    }
    return nil
}


```



#### 双指针

使用双指针的方法，可以将空间复杂度降至 O(1)O(1)。

只有当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，两个链表才可能相交。因此首先判断链表 \textit{headA}headA 和 \textit{headB}headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 \text{null}null。

当链表 \textit{headA}headA 和 \textit{headB}headB 都不为空时，创建两个指针 \textit{pA}pA 和 \textit{pB}pB，初始时分别指向两个链表的头节点 \textit{headA}headA 和 \textit{headB}headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

- 每步操作需要同时更新指针 \textit{pA}pA 和 \textit{pB}pB。

- 如果指针 \textit{pA}pA 不为空，则将指针 \textit{pA}pA 移到下一个节点；如果指针 \textit{pB}pB 不为空，则将指针 \textit{pB}pB 移到下一个节点。

- 如果指针 \textit{pA}pA 为空，则将指针 \textit{pA}pA 移到链表 \textit{headB}headB 的头节点；如果指针 \textit{pB}pB 为空，则将指针 \textit{pB}pB 移到链表 \textit{headA}headA 的头节点。

- 当指针 \textit{pA}pA 和 \textit{pB}pB 指向同一个节点或者都为空时，返回它们指向的节点或者 \text{null}null。


```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    if (pHead1 === null || pHead2 === null) {
        return null;
    }
    let p1 = pHead1, p2 = pHead2;
    while (p1 !== p2) {
        p1 = p1 === null ? pHead2 : p1.next;
        p2 = p2 === null ? pHead1 : p2.next;
    }
    return p1;
}
module.exports = {
    FindFirstCommonNode : FindFirstCommonNode
};
```

复杂度分析

时间复杂度：O(m+n)O(m+n)，其中 mm 和 nn 是分别是链表 \textit{headA}headA 和 \textit{headB}headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。

空间复杂度：O(1)O(1)。



----

## **BM11** **链表中的两数相加**

给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

提示：

链表的长度范围为 [1, 100]
0 <= node.val <= 9
输入数据保证链表代表的数字无前导 0


进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。



#### 栈

本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head1 ListNode类 
 * @param head2 ListNode类 
 * @return ListNode类
 */
function addInList( head1 ,  head2 ) {
    // write code here
    let stack1 = [], stack2 = [];
    while (head1 !== null) {
        stack1.push(head1.val);
        head1 = head1.next;
    }
    while (head2 !== null) {
        stack2.push(head2.val);
        head2 = head2.next;
    }

    let carry = 0;
    let ans = null;
    while (stack1.length !== 0 || stack2.length !== 0 || carry !== 0) {
        let a = stack1.length ? stack1.pop() : 0;
        let b = stack2.length ? stack2.pop() : 0;
        let cur = a + b + carry;
        carry = cur > 9 ? 1 : 0;
        cur %= 10;
        let curNode = new ListNode(cur);
        curNode.next = ans;
        ans = curNode;
    }
    return ans;
}
module.exports = {
    addInList : addInList
};
```



#### 反转链表+双指针求和

先把l1和l2都进行反转
然后通过双指针进行求和
最后把结果再进行反转即可了

```js
var addTwoNumbers = function(l1, l2) {
    // 反转链表
    function reverse(head) {
        var pre = null;
        var cur = head;
        while (cur) {
            var next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    // 进行两数想加
    var reverseL1 = reverse(l1);
    var reverseL2 = reverse(l2);
    var res = null;
    var carry = 0;
    var tail = res;
    while (reverseL1 || reverseL2) {
        const x = reverseL1 ? reverseL1.val - '0' : 0;
        const y = reverseL2 ? reverseL2.val - '0' : 0;
        const sum = x + y + carry;
        if (!res) {
            res = tail = new ListNode(sum % 10);
        } else {
            tail.next = new ListNode(sum % 10);
            tail = tail.next;
        }
        carry = Math.floor(sum / 10);
        if(reverseL1) reverseL1 = reverseL1.next;
        if(reverseL2) reverseL2 = reverseL2.next;
    }
    if (carry) tail.next = new ListNode(carry);

    // 最后再反转链表=
    return reverse(res);
};

```



-----

## **BM12** **单链表的排序**

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

要求使用插入排序的方法对链表进行排序，插入排序的时间复杂度是 O(n^2)O(n 2 )，其中 nn 是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 O(n \log n)O(nlogn) 的时间复杂度和 O(1)O(1) 的空间复杂度，时间复杂度是 O(n \log n)O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)O(n 2 )），其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(\log n)O(logn)。如果要达到 O(1)O(1) 的空间复杂度，则需要使用自底向上的实现方式。

#### 自顶向下归并排序

对链表自顶向下归并排序的过程如下。

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22 步，慢指针每次移动 11 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

对两个子链表分别排序。

将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 11，即当链表为空或者链表只包含 11 个节点时，不需要对链表进行拆分和排序。



```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head node
 * @return ListNode类
 */
function sortInList( head ) {
    // write code here
    return toSortList(head, null);
};

const toSortList = (head, tail) => {
    if (head === null) {
        return head;
    }
    if (head.next === tail) {
        head.next = null;
        return head;
    }
    let slow = head, fast = head;
    while (fast !== tail) {
        slow = slow.next;
        fast = fast.next;
        if (fast !== tail) {
            fast = fast.next;
        }
    }
    const mid = slow;
    return merge(toSortList(head, mid), toSortList(mid, tail));
}

const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}

module.exports = {
    sortInList : sortInList
};
```

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，其中 nn 是链表的长度。

空间复杂度：O(\log n)O(logn)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间。



#### 自底向上归并排序

![自底向上归并排序链表](E:\pogject\学习笔记\image\niuke\自底向上归并排序链表.png)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head === null) {
        return head;
    }
    let len = 0;
    let node = head;
    while (node !== null) {
        len++;
        node = node.next;
    }

    const dummyNode = new ListNode(-1, head);

    for (let subLen = 1; subLen < len; subLen <<= 1) {
        let prev = dummyNode, curr = dummyNode.next;
        while (curr !== null) {
            let head1 = curr;
            for (let i = 1; i < subLen && curr.next !== null; i++) {
                curr = curr.next;
            }
            let head2 = curr.next;
            curr.next = null;
            curr = head2;
            for (let i = 1; i < subLen && curr !== null && curr.next !== null; i++) {
                curr = curr.next;
            }
            let next = null;
            if (curr !== null) {
                next = curr.next;
                curr.next = null;
            }
            const merged = merge(head1, head2);
            prev.next = merged;
            while (prev.next !== null) {
                prev = prev.next;
            }
            curr = next;
        }
    }
    return dummyNode.next;
};


const merge = (head1, head2) => {
    if (head1 === null) {
        return head2;
    }
    if (head2 === null) {
        return head1;
    }

    const dummyNode = new ListNode(-1);
    let pre = dummyNode;
    while (head1 !== null && head2 !== null) {
        if (head1.val <= head2.val) {
            pre.next = head1;
            head1 = head1.next;
        } else {
            pre.next = head2;
            head2 = head2.next;
        }
        pre = pre.next;
    }
    pre.next = head1 === null ? head2 : head1;

    return dummyNode.next;
}
```

**复杂度分析**

- 时间复杂度：O(n \log n)*O*(*n*log*n*)，其中 n*n* 是链表的长度。
- 空间复杂度：O(1)*O*(1)。



----

## **BM13** **判断一个链表是否为回文结构**

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？



#### 将值复制到数组中后用双指针法

一共为两个步骤：

1. 复制链表值到数组列表中。
2. 使用双指针法判断是否为回文。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
    const nodes = [];
    while (head !== null) {
        nodes.push(head.val);
        head = head.next;
    }
    let left = 0, right = nodes.length - 1;
    while (left < right) {
        if (nodes[left++] !== nodes[right--]) {
            return false;
        }
    }
    return true;

}
module.exports = {
    isPail : isPail
};
```

时间复杂度：O(n)O(n)，其中 nn 指的是链表的元素个数。
第一步： 遍历链表并将值复制到数组中，O(n)O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2)O(n/2) 次的判断，即 O(n)O(n)。
总的时间复杂度：O(2n) = O(n)O(2n)=O(n)。
空间复杂度：O(n)O(n)，其中 nn 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。



#### 递归

为了想出使用空间复杂度为 O(1)*O*(1) 的算法，你可能想过使用递归来解决，但是这仍然需要 O(n)*O*(*n*) 的空间复杂度。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
    let p = null;
    const recursivelyCheck = (currentNode) => {
        if (currentNode !== null) {
            if (!recursivelyCheck(currentNode.next)) {
                return false;
            }
            if (currentNode.val !== p.val) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    p = head;
    return recursivelyCheck(head);

}
module.exports = {
    isPail : isPail
};
```

这种方法不仅使用了 O(n)O(n) 的空间，且比第一种方法更差，因为在许多语言中，堆栈帧的开销很大（如 Python），并且最大的运行时堆栈深度为 1000（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。



#### 快慢指针

避免使用 O(n)O(n) 额外空间的方法就是改变输入。

我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。

该方法虽然可以将空间复杂度降到 O(1)O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。

整个流程可以分为以下五个步骤：

1. 找到前半部分链表的尾节点。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    if (head === null) {
        return true;
    }

    // 找到前半部分链表的尾节点并反转后半部分链表
    const fisrtHalfEnd = endOfFirstHalf(head);
    const secondHalfStart = reverseList(fisrtHalfEnd.next);

    // 判断是否回文
    let p1 = head;
    let p2 = secondHalfStart;
    let result = true;
    while (result && p2 !== null) {
        if (p1.val !== p2.val) {
            result = false;
        }
        p1 = p1.next;
        p2 = p2.next;
    }
    // 还原链表并返回结果
    fisrtHalfEnd.next = reverseList(secondHalfStart);

    return result;
}

const reverseList = (head) => {
    let prev = null;
    let curr = head;
    while (curr !== null) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

const endOfFirstHalf = (head) => {
    let slow = head;
    let fast = head;
    while (fast.next !== null && fast.next.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

module.exports = {
    isPail : isPail
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 指的是链表的大小。

空间复杂度：O(1)O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)O(1)。



----

## **BM14** **链表的奇偶重排**

给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。

#### 分离节点后合并

原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead = head.next，则 evenHead 是偶数链表的头节点。

维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd = head，even = evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。

更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next = even.next，然后令 odd = odd.next，此时 odd 变成 even 的后一个节点。

更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next = odd.next，然后令 even = even.next，此时 even 变成 odd 的后一个节点。

在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。

最后令 odd.next = evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param head ListNode类 
 * @return ListNode类
 */
function oddEvenList( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    let odd = head;
    let even = head.next;
    let evenHead = head.next;
    while (even !== null && even.next !== null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;

    return head;
}
module.exports = {
    oddEvenList : oddEvenList
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。

空间复杂度：O(1)O(1)。只需要维护有限的指针。



----

## **BM15** **删除有序链表中重复的元素-I**

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

#### 一次遍历

由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。

具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。

当遍历完整个链表之后，我们返回链表的头节点即可。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @return ListNode类
  */
function deleteDuplicates( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    let curr = head;
    let prev = head;
    while (curr.next !== null) {
        if (curr.val === curr.next.val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }
    return head;
}
module.exports = {
    deleteDuplicates : deleteDuplicates
};
```



----

## **BM16** **删除有序链表中重复的元素-II**

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。

具体地，我们从指针 \textit{cur}cur 指向链表的哑节点，随后开始对链表进行遍历。如果当前 \textit{cur.next}cur.next 与 \textit{cur.next.next}cur.next.next 对应的元素相同，那么我们就需要将 \textit{cur.next}cur.next 以及所有后面拥有相同元素值的链表节点全部删除。我们记下这个元素值 xx，随后不断将 \textit{cur.next}cur.next 从链表中移除，直到 \textit{cur.next}cur.next 为空节点或者其元素值不等于 xx 为止。此时，我们将链表中所有元素值为 xx 的节点全部删除。

如果当前 \textit{cur.next}cur.next 与 \textit{cur.next.next}cur.next.next 对应的元素不相同，那么说明链表中只有一个元素值为 \textit{cur.next}cur.next 的节点，那么我们就可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。

当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 \textit{dummy.next}dummy.next 即可。

细节

需要注意 \textit{cur.next}cur.next 以及 \textit{cur.next.next}cur.next.next 可能为空节点，如果不加以判断，可能会产生运行错误。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @return ListNode类
  */
function deleteDuplicates( head ) {
    // write code here
    if (head === null || head.next === null) {
        return head;
    }
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let curr = dummyNode;
    
    while (curr.next && curr.next.next) {
        if (curr.next.val === curr.next.next.val) {
            const x = curr.next.val;
            while (curr.next !== null && curr.next.val === x) {
                curr.next = curr.next.next;
            }
        } else {
            curr = curr.next;
        }
    }
    return dummyNode.next;
}

module.exports = {
    deleteDuplicates : deleteDuplicates
};
```



-----

## **BM17** **二分查找-I**

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

二分查找的做法是，定义查找的范围 [\textit{left}, \textit{right}][left,right]，初始查找范围是整个数组。每次取查找范围的中点 \textit{mid}mid，比较 \textit{nums}[\textit{mid}]nums[mid] 和 \textit{target}target 的大小，如果相等则 \textit{mid}mid 即为要寻找的下标，如果不相等则根据 \textit{nums}[\textit{mid}]nums[mid] 和 \textit{target}target 的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(\log n)O(logn)，其中 nn 是数组的长度。

二分查找的条件是查找范围不为空，即 \textit{left} \le \textit{right}left≤right。如果 \textit{target}target 在数组中，二分查找可以保证找到 \textit{target}target，返回 \textit{target}target 在数组中的下标。如果 \textit{target}target 不在数组中，则当 \textit{left} > \textit{right}left>right 时结束查找，返回 -1−1。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @param target int整型 
 * @return int整型
 */
function search( nums ,  target ) {
    // write code here
    let left = 0, right = nums.length - 1;
    let mid;
    while (left <= right) {
        mid = left + Math.floor((right - left) / 2);
        if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}

// let nums = [-1,0,3,5,9,12], target = 9;
// console.log(search(nums, target))

module.exports = {
    search : search
};
```

**复杂度分析**

- 时间复杂度：O(\log n)*O*(log*n*)，其中 n*n* 是数组的长度。
- 空间复杂度：O(1)*O*(1)。



-----

## **BM18** **二维数组中的查找**

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

### 线性查找

由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

- 若数组为空，返回 false

- 初始化行下标为 0，列下标为二维数组的列数减 1
- 重复下列步骤，直到行下标或列下标超出边界
- - 获得当前下标位置的元素 num
  - 如果 num 和 target 相等，返回 true
  - 如果 num 大于 target，列下标减 1
  - 如果 num 小于 target，行下标加 1
- 循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false`



```js
function Find(target, array){
    // write code here
    if (array === null || array.length === 0 || array[0].length === 0) {
        return false;
    }
    let m = array.length;
    let n = array[0].length;
    let row = 0;
    let col = n - 1;
    while (row < m && col >= 0) {
        if (array[row][col] < target) {
            row++;
        } else if (array[row][col] > target) {
            col--;
        } else {
            return true;
        }
    }
    return false;
}
module.exports = {
    Find : Find
};
```

复杂度分析

时间复杂度：O(n+m)O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。
空间复杂度：O(1)O(1)。



----

## **BM19** **寻找峰值**

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

提示：

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
对于所有有效的 i 都有 nums[i] != nums[i + 1]

#### 寻找最大值

由于题目保证了 \textit{nums}[i] \neq \textit{nums}[i+1]nums[i]  =nums[i+1]，那么数组 \textit{nums}nums 中最大值两侧的元素一定严格小于最大值本身。因此，最大值所在的位置就是一个可行的峰值位置。

我们对数组 \textit{nums}nums 进行一次遍历，找到最大值对应的位置即可。

```js
var findPeakElement = function(nums) {
    let idx = 0;
    for (let i = 1; i < nums.length; ++i) {
        if (nums[i] > nums[idx]) {
            idx = i;
        }
    }
    return idx;
};

```



#### 迭代爬坡

俗话说「人往高处走，水往低处流」。如果我们从一个位置开始，不断地向高处走，那么最终一定可以到达一个峰值位置。

因此，我们首先在 [0, n)[0,n) 的范围内随机一个初始位置 ii，随后根据nums[i−1],nums[i],nums[i+1] 三者的关系决定向哪个方向走：

如果 nums[i−1]<nums[i]>nums[i+1]，那么位置 ii 就是峰值位置，我们可以直接返回 ii 作为答案；

如果nums[i−1]<nums[i]<nums[i+1]，那么位置 ii 处于上坡，我们需要往右走，即 i \leftarrow i+1i←i+1；

如果nums[i−1]>nums[i]>nums[i+1]，那么位置 ii 处于下坡，我们需要往左走，即 i \leftarrow i-1i←i−1；

如果nums[i−1]>nums[i]<nums[i+1]，那么位置 ii 位于山谷，两侧都是上坡，我们可以朝任意方向走。

如果我们规定对于最后一种情况往右走，那么当位置 ii 不是峰值位置时：

如果nums[i]<nums[i+1]，那么我们往右走；

如果 nums[i]>nums[i+1]，那么我们往左走。

```js
var findPeakElement = function(nums) {
    const n = nums.length;
    let idx = parseInt(Math.random() * n);

    while (!(compare(nums, idx - 1, idx) < 0 && compare(nums, idx, idx + 1) > 0)) {
        if (compare(nums, idx, idx + 1) < 0) {
            idx += 1;
        } else {
            idx -= 1;
        }
    }
    
    return idx;
}

// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
// 方便处理 nums[-1] 以及 nums[n] 的边界情况
const get = (nums, idx) => {
    if (idx === -1 || idx === nums.length) {
        return [0, 0];
    }
    return [1, nums[idx]];
}

const compare = (nums, idx1, idx2) => {
    const num1 = get(nums, idx1);
    const num2 = get(nums, idx2);
    if (num1[0] !== num2[0]) {
        return num1[0] > num2[0] ? 1 : -1;
    }
    if (num1[1] === num2[1]) {
        return 0;
    }
    return num1[1] > num2[1] ? 1 : -1;
}


```



#### 二分查找优化

我们可以发现，如果 nums[i]<nums[i+1]，并且我们从位置 ii 向右走到了位置 i+1i+1，那么位置 ii 左侧的所有位置是不可能在后续的迭代中走到的。

这是因为我们每次向左或向右移动一个位置，要想「折返」到位置 ii 以及其左侧的位置，我们首先需要在位置 i+1i+1 向左走到位置 ii，但这是不可能的。

并且根据方法二，我们知道位置 i+1i+1 以及其右侧的位置中一定有一个峰值，因此我们可以设计出如下的一个算法：

对于当前可行的下标范围 [l, r][l,r]，我们随机一个下标 ii；

如果下标 ii 是峰值，我们返回 ii 作为答案；

如果nums[i]<nums[i+1]，那么我们抛弃 [l, i][l,i] 的范围，在剩余 [i+1, r][i+1,r] 的范围内继续随机选取下标；

如果 nums[i]>nums[i+1]，那么我们抛弃 [i, r][i,r] 的范围，在剩余 [l, i-1][l,i−1] 的范围内继续随机选取下标。

在上述算法中，如果我们固定选取 ii 为 [l, r][l,r] 的中点，那么每次可行的下标范围会减少一半，成为一个类似二分查找的方法，时间复杂度为 O(\log n)O(logn)。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @return int整型
 */
function findPeakElement( nums ) {
    // write code here
    const n = nums.length;
    let left =0, right = n - 1;
    let ans = -1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (compare(nums, mid - 1, mid) < 0 && compare(nums, mid, mid + 1) > 0) {
            ans = mid;
            break;
        }
        if (compare(nums, mid, mid + 1) < 0) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
// 方便处理 nums[-1] 以及 nums[n] 的边界情况
const get = (nums, idx) => {
    if (idx === -1 || idx === nums.length) {
        return[0, 0];
    }
    return [1, nums[idx]];
}

const compare = (nums, idx1, idx2) => {
    const num1 = get(nums, idx1);
    const num2 = get(nums, idx2);
    if (num1[0] !== num2[0]) {
        return num1[0] > num2[0] ? 1 : -1;
    }
    if (num1[1] === num2[1]) {
        return 0;
    }
    return num1[1] > num2[1] ? 1 : -1;
}

module.exports = {
    findPeakElement : findPeakElement
};
```

**复杂度分析**

- 时间复杂度：O(\log n)*O*(log*n*)，其中 n*n* 是数组 \textit{nums}*nums* 的长度。
- 空间复杂度：O(1)*O*(1)。



----

## **BM20** **数组中的逆序对**

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数P。

并将P对1000000007取模的结果输出。 即输出P mod 1000000007

要求：空间复杂度 O(n)，时间复杂度 O(nlogn)



#### 归并排序

![求逆序对](E:\pogject\学习笔记\image\niuke\求逆序对.png)

```js
function InversePairs(nums){
    // write code here
    const n = nums.length;
    if (n < 2) {
        return 0;
    }
    const copy = [...nums];
    const temp = new Array(n);
    const ans = dfs(copy, 0, n - 1, temp);
    const MOD = 1000000007;
    return ans % MOD;
}

const dfs = (nums, left, right, temp) => {
    if (left === right) {
        return 0;
    }
    let mid = left + Math.floor((right - left) / 2);
    let leftPairs = dfs(nums, left, mid, temp);
    let rightPairs = dfs(nums, mid + 1, right, temp);

    if (nums[mid] <= nums[mid + 1]) {
        return leftPairs + rightPairs;
    }

    let crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
}

const mergeAndCount = (nums, left, mid, right, temp) => {
    for (let i = left; i <= right; i++) {
        temp[i] = nums[i];
    }
    let i = left;
    let j = mid + 1;
    let count = 0;
    for (let k = left; k <= right; k++) {
        if (i === mid + 1) {
            nums[k] = temp[j];
            j++;
        } else if (j === right + 1) {
            nums[k] = temp[i];
            i++;
        } else if (temp[i] <= temp[j]) {
            nums[k] = temp[i];
            i++;
        } else {
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        }
    }
    return count;
}

// let nums = [1,2,3,4,5,6,7,0];
// console.log(InversePairs(nums));

module.exports = {
    InversePairs : InversePairs
};
```



----

## **BM21** **旋转数组的最小数字**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

 

提示：

n == numbers.length
1 <= n <= 5000
-5000 <= numbers[i] <= 5000
numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

要求：空间复杂度：O(1)*O*(1) ，时间复杂度：O(logn)*O*(*l**o**g**n*)



#### 二分查找

我们考虑数组中的最后一个元素 xx：在最小值右侧的元素，它们的值一定都小于等于 xx；而在最小值左侧的元素，它们的值一定都大于等于 xx。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

```js
function minNumberInRotateArray(nums)
{
    // write code here
    let low = 0;
    let high = nums.length - 1;
    while (low < high) {
        let mid = low + Math.floor((high - low) / 2);
        if (nums[mid] < nums[high]) {
            high = mid;
        } else if (nums[mid] > nums[high]) {
            low = mid + 1;
        } else {
            high -= 1;
        }
    }
    return nums[low];
}
module.exports = {
    minNumberInRotateArray : minNumberInRotateArray
};
```

时间复杂度：平均时间复杂度为 O(\log n)O(logn)，其中 nn 是数组 \it numbersnumbers 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 \texttt{while}while 循环就需要执行 nn 次，每次忽略区间的右端点，时间复杂度为 O(n)O(n)。

空间复杂度：O(1)O(1)。



```js
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function(numbers) {
    let n = numbers.length;
    let left = 0;
    let right = n - 1;
    let mid = 0;
    while(numbers[left] >= numbers[right]) {
        if (right - left === 1) {
            mid = right;
            break;
        }
        mid = left + Math.floor((right - left) / 2);
        // 如果left,right, mid指向的三个数字相等，只能顺序查找
        if (numbers[left] === numbers[right] && numbers[left] === numbers[mid]) {
            return minInOrder(numbers, left, right);
        }

        if (numbers[mid] >= numbers[left]) {
            left = mid;
        } else if (numbers[mid] <= numbers[right]) {
            right = mid;
        }
    }
    return numbers[mid];
}

const minInOrder = (numbers, left, right) => {
    let result = numbers[left];
    for (let i = left + 1; i <= right; ++i) {
        if (result > numbers[i]) {
            result = numbers[i];
        }
    }
    return result;
}

let numbers = [1, 0, 1, 1, 1];
// let numbers = [3, 4, 5, 1, 2];
console.log(minArray(numbers, 5));
```



----

## **BM22** **比较版本号**

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：

如果 version1 > version2 返回 1，
如果 version1 < version2 返回 -1，
除此之外返回 0。

提示：

1 <= version1.length, version2.length <= 500
version1 和 version2 仅包含数字和 '.'
version1 和 version2 都是 有效版本号
version1 和 version2 的所有修订号都可以存储在 32 位整数 中

#### 字符串分割

我们可以将版本号按照点号分割成修订号，然后从左到右比较两个版本号的相同下标的修订号。在比较修订号时，需要将字符串转换成整数进行比较。注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0。

```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
	const v1 = version1.split(".");
	const v2 = version2.split(".");
	for (let i = 0; i < v1.length || i < v2.length; i++) {
		let x = 0, y = 0;
		if (i < v1.length) {
			x = parseInt(v1[i]);
		}
		if (i < v2.length) {
			y = parseInt(v2[i]);
		}
		if (x > y) {
			return 1;
		}
		if (x < y) {
			return -1;
		}
	}
	return 0;
};

let version1 = "1.01", version2 = "1.001";
console.log(compareVersion(version1, version2));
```

时间复杂度：O(n+m)O(n+m)（或 O(\max(n,m))O(max(n,m))，这是等价的），其中 nn 是字符串 \textit{version1}version1 的长度，mm 是字符串 \textit{version2}version2 的长度。

空间复杂度：O(n+m)O(n+m)，我们需要 O(n+m)O(n+m) 的空间存储分割后的修订号列表。



#### 双指针

方法一需要存储分割后的修订号，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 比较版本号
 * @param version1 string字符串 
 * @param version2 string字符串 
 * @return int整型
 */
function compare( version1 ,  version2 ) {
    // write code here
    const n = version1.length, m = version2.length;
    let i = 0, j = 0;
    while (i < n || j < m) {
        let x = 0;
        for (; i < n && version1[i] !== "."; i++) {
            x = x * 10 + version1[i].charCodeAt() - '0'.charCodeAt();
        }
        ++i;  // 跳过点号
        let y = 0;
        for (; j < m && version2[j] !== "."; j++) {
            y = y * 10 + version2[j].charCodeAt() - '0'.charCodeAt();
        }
        ++j;  // 跳过点号
        if (x !== y) {
            return x > y ? 1 : -1;
        }
    }
    return 0;
}

module.exports = {
    compare : compare
};
```

复杂度分析

时间复杂度：O(n+m)O(n+m)，其中 nn 是字符串 \textit{version1}version1 的长度，mm 是字符串 \textit{version2}version2 的长度。

空间复杂度：O(1)O(1)，我们只需要常数的空间保存若干变量。



----

## **BM23** **二叉树的前序遍历**

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

#### 递归

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[root.val];
    //递归
    result=result.concat(preorderTraversal(root.left));
    result=result.concat(preorderTraversal(root.right));
    return result;
};
```



#### 迭代

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //迭代
        let node=arr.pop();
        result.push(node.val);  //出栈
        if (node.right!==null) {
            //右子树先入栈确保后访问右子树
            arr.push(node.right);
        }
        if (node.left!==null) {
            arr.push(node.left);
        }

    }
    return result;
};
```



----

## **BM24** **二叉树的中序遍历**

#### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
function TreeNode(val,left,right){
    this.val=(val===undefined ? 0 : val);
    this.left=(left===undefined ? null : left);
    this.right=(right===undefined ? null : right);
}
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    
    if (root===null) {
        return [];
    }
    let result=[];

    result=result.concat(inorderTraversal(root.left));
    result.push(root.val);
    result=result.concat(inorderTraversal(root.right));
    return result;
};

let test =[1,null,2,3];

let root=new TreeNode(test[0]);
let result=inorderTraversal(test);
console.log(result);


```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

#### 迭代

方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。

```js
var inorderTraversal = function(root) {
    let result=[];
    let stack=[];

    while(root || stack.length){
        while(root){
            stack.push(root);
            root=root.left;
        }
        root=stack.pop();
        result.push(root.val);
        root=root.right;
    }
    return result;
};
```

#### Morris 中序遍历

![Morris 中序遍历二叉树](E:\pogject\学习笔记\image\leetcode\Morris 中序遍历二叉树.png)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let result=[];
    let predecessor=null;

    while(root){
        if (root.left) {
            //predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
            predecessor=root.left;
            while(predecessor.right && predecessor.right!==root){
                predecessor=predecessor.right;
            }
            // 让 predecessor 的右指针指向 root，继续遍历左子树
            if (!predecessor.right) {
                predecessor.right=root;
                root=root.left;
            }else{
                //说明左子树已经访问完了，我们需要断开链接
                result.push(root.val);
                predecessor.right=null;
                root=root.right;
            }
        }else{
            //如果没有左孩子，则直接访问右孩子
            result.push(root.val);
            root=root.right;
        }

    }
    return result;
};
```




---

## **BM25** **二叉树的后序遍历**

#### 递归

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let result=[];
    //递归
    result=result.concat(postorderTraversal(root.left));
    result=result.concat(postorderTraversal(root.right));
    result.push(root.val);
    return result;
};
```

#### 迭代

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if (root===null) {
        return [];
    }
    let arr=[root];  //栈
    let result=[];
    while(arr.length>0){
        //反向迭代
        let node=arr.pop();  //出栈
        result.unshift(node.val);  //从数组前面进入队列
        if (node.left!==null) {
            //左子树先入栈确保先访问右子树
            arr.push(node.left);
        }
        if (node.right!==null) {
            //后入栈，先访问
            arr.push(node.right);
        }
        
    }
    return result;
};
```



----

## **BM26** **求二叉树的层序遍历**

#### 广度优先搜索

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (root === null) {
        return [];
    }
    const ans = [];

    let arr = [root];
    let node = null;
    let n = 0;  //每一层的结点数
    while (arr.length > 0){
        n=arr.length;
        let temp = [];
        while (n > 0){
            node = arr.shift();
            temp.push(node.val);
            if (node.left) {
                arr.push(node.left);
            }
            if (node.right) {
                arr.push(node.right);
            }
            n--;
        }
        ans.push(temp);
    }

    return ans;
};
```



----

## **BM27** **按之字形顺序打印二叉树**

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

#### 广度优先遍历

为了满足题目要求的返回值为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。

双端队列是一个可以在队列任意一端插入元素的队列。在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 isOrderLeft 记录是从左至右还是从右至左的：

- 如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。

- 如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。


当遍历结束的时候我们就得到了答案数组。



```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
    if (root === null) {
        return [];
    }
    const ans = [];
    const queue = [root];
    let isOrderLeft = true;
    while (queue.length) {
        let n = queue.length;
        const temp = [];
        while (n > 0) {
            n--;
            let node = queue.shift();
            
            if (isOrderLeft) {
                temp.push(node.val);
            } else {
                temp.unshift(node.val);
            }
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }
        ans.push(temp);
        isOrderLeft = !isOrderLeft;
    }
    return ans;
};
```



----

## **BM28** **二叉树的最大深度**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

#### 深度优先搜索

如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1

而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }else{
        return 1+ Math.max(maxDepth(root.left), maxDepth(root.right));
    }
};
```



#### 广度优先搜索

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的**队列里存放的是「当前层的所有节点」**。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们**需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展**，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。

```js
var maxDepth = function(root) {
    if (root===null) { return 0; }
    if (root.left===null && root.right===null) {
        return 1;
    }
    let arr=[root];
    let count=0;
    while(arr.length>0){
        let len=arr.length;
        while(len>0){
            //需要将队列里的所有节点都拿出来进行拓展
            node=arr.shift();
            if (node.left!==null) {
                //加入的这层在下一次外循环拿出判断
                arr.push(node.left);
            }
            if (node.right!==null) {
                arr.push(node.right);
            }
            len--;
        }
        count++;
    }
    return count;
};
```





----

## **BM29** **二叉树中和为某一值的路径(一)**

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

#### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {number[][]}
 */
var pathSum = function(root, target) {
    const ans = [];
    const path = [];

    const dfs = (root, res) => {
        if (root === null) {
            return;
        }
        path.push(root.val);
        res -= root.val;
        if (root.left === null && root.right === null && res === 0) {
            ans.push([...path]); // 这里记得解构，不然传入的是地址
        }
        dfs(root.left, res);
        dfs(root.right, res);
        path.pop();
    }
    dfs(root, target);
    return ans;
};

```



----

## **BM30** **二叉搜索树与双向链表**

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

二叉搜索树的中序遍历为 **递增序列** 。

![二叉搜索树与双向链表](E:\pogject\学习笔记\image\niuke\二叉搜索树与双向链表.png)

```js
/**
 * // Definition for a Node.
 * function Node(val,left,right) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
var treeToDoublyList = function(root) {
    if (root === null) {
        return null;
    }
    let tail = null, head = null;
    dfs(root);
    // 头尾指针
    head.left = tail;
    tail.right = head;

    return head;

    function dfs(curr){
        if (curr === null) {
            return;
        }
        dfs(curr.left);
        if (tail === null) {
            head = curr;
        } else {
            tail.right = curr;
            curr.left = tail;
        }
        tail = curr;
        dfs(curr.right);
    }
};
```



----

## **BM31** **对称的二叉树**

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root, root);
};

const check = (p, q) => {
    if (p === null && q === null) {
        return true;
    }
    if (p === null || q === null) {
        return false;
    }
    return p.val === q.val && check(p.left, q.right) && check(p.right, q.left);
}
```

用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return check(root, root);
};

const check = (p, q) => {
    const arr = [];
    arr.push(p);
    arr.push(q);

    while (arr.length) {
        let u = arr.shift();
        let v = arr.shift();
        if (u === null && v === null) {
            continue;
        }
        if ((u === null || v === null) || (u.val !== v.val)) {
            return false;
        }
        arr.push(u.left);
        arr.push(v.right);
        arr.push(u.right);
        arr.push(v.left);
    }
    return true;
}
```



----

## **BM32** **合并二叉树**

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

提示：

两棵树中的节点数目在范围 [0, 2000] 内
-104 <= Node.val <= 104

**深度优先搜索（递归）**

```js
function TreeNode(val, left, right){
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */

var mergeTrees = function(root1, root2) {
    if (root1 == null){
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    root1.val = root1.val + root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
};

let nums=[2,7,9,3,1];
let result=rob(nums);
console.log(result);
```

时间复杂度：O(min(m,n))，对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。

空间复杂度：O(min(m,n))，空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。

**广度优先搜索**

```js
function TreeNode(val, left, right){
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */

var mergeTrees = function(root1, root2) {
    if (root1 == null){
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    const root3 = new TreeNode(root1.val + root2.val);
    const queue1 = [root1];
    const queue2 = [root2];
    const queue3 = [root3];

    while (queue1.length > 0 && queue2.length > 0){
        let node3 = queue3.pop();
        let node1 = queue1.pop();
        let node2 = queue2.pop();
        if (node1.left !== null || node2.left !== null) {
            if (node1.left !== null && node2.left !== null) {
                node3.left = new TreeNode(node1.left.val + node2.left.val);
                queue1.push(node1.left);
                queue2.push(node2.left);
                queue3.push(node3.left);
            }else if (node1.left !== null){
                node3.left = node1.left;
            }else if (node2.left !== null){
                node3.left = node2.left;
            }
        }
        if (node1.right !== null || node2.right !== null) {
            if (node1.right !== null && node2.right !== null) {
                node3.right = new TreeNode(node1.right.val + node2.right.val);
                queue1.push(node1.right);
                queue2.push(node2.right);
                queue3.push(node3.right);
            }else if (node1.right !== null){
                node3.right = node1.right;
            }else if (node2.right !== null){
                node3.right = node2.right;
            }
        }
    }
    return root3;
};

```



-----

## **BM33** **二叉树的镜像**

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

#### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var mirrorTree = function(root) {
    if (root === null) {
        return null;
    }
    const left = mirrorTree(root.left);
    const right = mirrorTree(root.right);
    root.left = right;
    root.right = left;
    return root;
};
```

#### 迭代

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var mirrorTree = function(root) {
    if (root === null) {
        return null;
    }
    let arr = [root];
    while (arr.length) {
        let n = arr.length;
        while (n > 0) {
            n--;
            let node = arr.shift();
            let temp = node.left;
            node.left = node.right;
            node.right = temp;
            if (node.left !== null) {
                arr.push(node.left);
            }
            if (node.right !== null) {
                arr.push(node.right);
            }
        }
    }
    return root;
};
```



----

## **BM34** **判断是不是二叉搜索树**

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

- 节点的左子树只包含 小于 当前节点的数。

- 节点的右子树只包含 大于 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。



#### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    return dfs(root, -Infinity, Infinity)
};

const dfs = (root, lower, upper) => {
    if (root === null) {
        return true;
    }
    if (root.val <= lower || root.val >= upper) {
        return false;
    }
    return dfs(root.left, lower, root.val) && dfs(root.right, root.val, upper);
}
```



#### 中序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    const stack = [];
    let inorder = -Infinity;

    while (stack.length || root !== null) {
        while (root !== null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
        if (root.val <= inorder) {
            return false;
        }
        inorder = root.val;
        root = root.right;
    }
    return true;
};

```



----

**BM35** **判断是不是完全二叉树**

给定一个二叉树，确定他是否是一个完全二叉树。

完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

基本思路就是，将每层的节点以层序遍历的方式全部放入队列中（包括null） 如果是完全二叉树，在我们取出节点的时候，应该是直到整棵树遍历完毕才会遇到null。 所以当我们按层序遍历的方式，遇到null，但是队列中仍然存在节点，则代表不是完全二叉树；否则，是完全二叉树。

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param root TreeNode类 
 * @return bool布尔型
 */
function isCompleteTree( root ) {
    // write code here
    if (root === null) {
        return true;
    }
    const arr = [root];
    let flag = false;
    while (arr.length) {
        const node = arr.shift();
        if (node === null) {
            flag = true;
        } else {
            if (flag && arr.length) {
                return false;
            }
            arr.push(node.left);
            arr.push(node.right);
        }
    }
    return true;
}
module.exports = {
    isCompleteTree : isCompleteTree
};
```



----

## **BM36** **判断是不是平衡二叉树**

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

  **自底向上的递归**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    return getHeight(root) >= 0;

};

const getHeight = (root) => {
    if (root === null) {
        return 0;
    }
    let leftHeight = getHeight(root.left);
    let rightHeight = getHeight(root.right);
    // 如果存在一棵子树不平衡，则整个二叉树一定不平衡。
    if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    } else {
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```



----

## **BM37** **二叉搜索树的最近公共祖先**

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。

![二叉搜索树的最近公共祖先（两次遍历）](E:\pogject\学习笔记\image\leetcode\二叉搜索树的最近公共祖先（两次遍历）.png)

#### 一次遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    //注意是二叉搜索
    if (root.val<p.val && root.val<q.val) {
        return lowestCommonAncestor(root.right,p,q);
    }else if(root.val>p.val && root.val>q.val) {
        return lowestCommonAncestor(root.left,p,q);
    }else{
        //返回的是结点
        return root;
    }
};
```



----

## **BM38** **在二叉树中找到两个节点的最近公共祖先**

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

提示：

树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。



#### 递归

![在二叉树中找到两个节点的最近公共祖先](E:\pogject\学习笔记\image\niuke\在二叉树中找到两个节点的最近公共祖先.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    let ans = null;
    const dfs = (root, p, q) => {
        if (root === null) {
            return false;
        }
        const leftSon = dfs(root.left, p, q);
        const rightSon = dfs(root.right, p, q);
        if ((leftSon && rightSon) || ((root.val === p.val || root.val === q.val) && (leftSon || rightSon))) {
            ans = root;
        }
        return leftSon || rightSon || (root.val === p.val || root.val === q.val);
    }
    dfs(root, p, q);
    return ans;
};
```



#### 存储父节点

我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。

算法

1. 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。

2. 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。
3. 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root === null) {
        return null;
    }
    const parent = new Map();
    const visited = new Set();

    const dfs = (root) => {
        if (root.left) {
            parent.set(root.left, root);
            dfs(root.left);
        }
        if (root.right) {
            parent.set(root.right, root);
            dfs(root.right);
        }
    }
    dfs(root);
    while (p) {
        visited.add(p);
        p = parent.get(p);
    }
    while (q) {
        if (visited.has(q)) {
            return q;
        }
        q = parent.get(q);
    }
    return null;
};
```



-----

## **BM39** **序列化二叉树**

请实现两个函数，分别用来序列化和反序列化二叉树。

你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

#### 先序遍历+深度优先搜索

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    return rserialize(root, "");
};

const rserialize = (root, str) => {
    if (root === null) {
        str += "$,";
    } else {
        str += root.val + ",";
        str = rserialize(root.left, str);
        str = rserialize(root.right, str);
    }
    return str;
}

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    const dataArray = data.split(",");
    return rdeserialize(dataArray);
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */

const rdeserialize = (dataList) => {
    if (dataList[0] === "$") {
        dataList.shift();
        return null;
    }
    const root = new TreeNode(parseInt(dataList[0]));
    dataList.shift();
    root.left = rdeserialize(dataList);
    root.right = rdeserialize(dataList);

    return root;
}
```



----

## **BM40** **重建二叉树**

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorderorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    let n = preorder.length;
    return buildTreeCore(preorder, inorder, 0, n - 1, 0, n - 1);
};

const buildTreeCore = (preorder, inorder, preorder_left, preorder_right, inorder_left, inorder_right) => {
    if (preorder_left > preorder_right) {
        return null;
    }
    // 前序遍历中的第一个节点就是根节点
    let preorder_root = preorder_left;
    // 在中序遍历中定位根节点
    let inorder_root = inorder.indexOf(preorder[preorder_root]);
    // 先把根节点建立出来
    let root = new TreeNode(preorder[preorder_root]);
    // 得到左子树中的节点数目
    let size_left_subtree = inorder_root - inorder_left;
    // 递归地构造左子树，并连接到根节点
    // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
    root.left = buildTreeCore(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
    // 递归地构造右子树，并连接到根节点
    // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
    root.right = buildTreeCore(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
    return root;
}
```

迭代

```
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        stack.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.length; i++) {
            int preorderVal = preorder[i];
            TreeNode node = stack.peek();
            if (node.val != inorder[inorderIndex]) {
                node.left = new TreeNode(preorderVal);
                stack.push(node.left);
            } else {
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    inorderIndex++;
                }
                node.right = new TreeNode(preorderVal);
                stack.push(node.right);
            }
        }
        return root;
    }
}


```



----

## **BM41** **输出二叉树的右视图**

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

#### 深度优先搜索

我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。

这样一来，我们可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
  if(!root) return []
  let arr = []
  dfs(root, 0, arr)
  return arr
};
function dfs (root, step, res) {
  if(root){
    if(res.length === step){
      res.push(root.val)           // 当数组长度等于当前 深度 时, 把当前的值加入数组
    }
    // console.log(step, '-------', res)
    dfs(root.right, step + 1, res) // 先从右边开始, 当右边没了, 再轮到左边
    dfs(root.left, step + 1, res)
  }
}
```



#### 广度优先搜索

我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if (!root) return [];
    const q = [root];
    const res = [];
    while (q.length) {
        let len = q.length;
        while (len--) {
            const x = q.shift();
            if (len === 0) res.push(x.val);
            x.left && q.push(x.left);
            x.right && q.push(x.right);
        }
    }
    return res;
};
```



----

## **BM42** **用两个栈实现队列**

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

要求：存储n个元素的空间复杂度为 O(n)*O*(*n*) ，插入与删除的时间复杂度都是 O(1)*O*(1)

```js
var MyQueue = function() {
    this.inStack = [];
    this.outStack = [];
};

MyQueue.prototype.push = function(x) {
    this.inStack.push(x);
};

MyQueue.prototype.pop = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack.pop();
};

MyQueue.prototype.peek = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack[this.outStack.length - 1];
};

MyQueue.prototype.empty = function() {
    return this.outStack.length === 0 && this.inStack.length === 0;
};

MyQueue.prototype.in2out = function() {
    while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
    }
};


```



----

## **BM43** **包含min函数的栈**

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

#### 辅助栈

按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。

当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；

当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；

在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。

```js
var MinStack = function() {
    this.x_stack = [];
    this.min_stack = [Infinity];
};

MinStack.prototype.push = function(x) {
    this.x_stack.push(x);
    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));
};

MinStack.prototype.pop = function() {
    this.x_stack.pop();
    this.min_stack.pop();
};

MinStack.prototype.top = function() {
    return this.x_stack[this.x_stack.length - 1];
};

MinStack.prototype.getMin = function() {
    return this.min_stack[this.min_stack.length - 1];
};

```



----

## **BM44** **有效括号序列**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

#### 栈

判断括号的有效性可以使用「栈」这一数据结构来解决。

我们遍历给定的字符串 ss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。

当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 ss 无效，返回 \text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。

在遍历结束后，如果栈中没有左括号，说明我们将字符串 ss 中的所有左括号闭合，返回 \text{True}True，否则返回 \text{False}False。

注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 \text{False}False，省去后续的遍历判断过程。

```js
var isValid = function(s) {
    const n = s.length;
    if (n % 2 === 1) {
        return false;
    }
    const pairs = new Map([
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    const stk = [];
    for (let ch of s){
        if (pairs.has(ch)) {
            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
                return false;
            }
            stk.pop();
        } 
        else {
            stk.push(ch);
        }
    };
    return !stk.length;
};

```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是字符串 ss 的长度。

空间复杂度：O(n + |\Sigma|)O(n+∣Σ∣)，其中 \SigmaΣ 表示字符集，本题中字符串只包含 66 种括号，|\Sigma| = 6∣Σ∣=6。栈中的字符数量为 O(n)O(n)，而哈希表使用的空间为 O(|\Sigma|)O(∣Σ∣)，相加即可得到总空间复杂度。



#### 用repace方法

第一种：用repace方法，闭合才有效，也就是最里边的也要闭合，那就把最里边的括号取代为空

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    while(s.length){
        let len = s.length;
        // s = s.replace(/\(\)/g, "");
        // s = s.replace(/\[\]/g, "");
        // s = s.replace(/\{\}/g, "");
        s = s.replace(/\(\)|\[\]|\{\}/g, "");
        
        if (len === s.length) {
            // 没有匹配到则无效
            // console.log(s)
            return false;
        }
    }
    console.log(s)
    return true;
};

let s = "(()[[]]{[]()[]})";
console.log(isValid(s));
```



----

## **BM45** **滑动窗口的最大值**

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。



#### **双端队列**

我们可以顺着方法一的思路继续进行优化。

由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 ii 和 jj，其中 ii 在 jj 的左侧（i < ji<j），并且 ii 对应的元素不大于 jj 对应的元素（\textit{nums}[i] \leq \textit{nums}[j]nums[i]≤nums[j]），那么会发生什么呢？

当滑动窗口向右移动时，只要 ii 还在窗口中，那么 jj 一定也还在窗口中，这是 ii 在 jj 的左侧所保证的。因此，由于 \textit{nums}[j]nums[j] 的存在，\textit{nums}[i]nums[i] 一定不会是滑动窗口中的最大值了，我们可以将 \textit{nums}[i]nums[i] 永久地移除。

因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 \textit{nums}nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 ii，后者为 jj，就对应了上面所说的情况，即 \textit{nums}[i]nums[i] 会被移除，这就产生了矛盾。

当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。

由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。

为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。



```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    const ans = [];
    const queue = [];
    const n = nums.length;
    for (let i = 0; i < k; i++) {
        while (queue.length && nums[i] >= nums[queue[queue.length - 1]]) {
            queue.pop();
        }
        queue.push(i);
    }
    ans.push(nums[queue[0]]);
    for (let i = k; i < n; i++) {
        /*为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，
        那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。*/
        while (queue.length && nums[i] >= nums[queue[queue.length - 1]]) {
            queue.pop();
        }
        // 当滑动窗口向右移动时，我们需要把一个新的元素放入队列中
        queue.push(i);
        /* 但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，
        它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。*/
        while (queue[0] <= i - k) {
            queue.shift();
        }
        // 由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。
        ans.push(nums[queue[0]]);
    }
    return ans;
};

let nums = [1,3,-1,-3,5,3,6,7], k = 3;
console.log(maxSlidingWindow(nums, k));
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)O(n)。

空间复杂度：O(k)O(k)。与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1k+1 个元素，因此队列使用的空间为 O(k)O(k)。



#### 分块 + 预处理



```js
function maxInWindows(nums, k)
{
    // write code here
    const n = nums.length;
    const prefixMax = new Array(n).fill(0);
    const suffixMax = new Array(n).fill(0);

    for (let i = 0; i < n; i++) {
    	if (i % k === 0) {
    		prefixMax[i] = nums[i];
    	} else {
    		prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);
    	}
    }
    for (let i = n - 1; i >= 0; i--) {
    	if (i === n || (i + 1) % k === 0) {
    		suffixMax[i] = nums[i];
    	} else {
    		suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);
    	}
    }

    const ans = [];
    for (let i = 0; i < n - k + 1; i++) {
    	ans.push(Math.max(suffixMax[i], prefixMax[i + k - 1]));
    }
    return ans;
}
module.exports = {
    maxInWindows : maxInWindows
};
```



----

## **BM46** **最小的K个数**

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

#### 排序



```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function(arr, k) {
    if (k === 0 || arr.length === 0) {
        return [];
    }
    arr.sort((a, b) => a - b);
    return arr.slice(0, k);
};
```

复杂度分析

时间复杂度：O(n\log n)O(nlogn)，其中 nn 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(\log n)O(logn)，排序所需额外的空间复杂度为 O(\log n)O(logn)。



#### 堆

我们用一个大根堆实时维护数组的前 kk 小值。首先将前 kk 个数插入大根堆中，随后从第 k+1k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。而 Python 语言中的堆为小根堆，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 kk 小值。

```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function(arr, k) {
    if (k === 0 || arr.length === 0) {
        return [];
    }

    let maxHeap = [Infinity];  // 最大堆
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let item = arr[i];
        if (maxHeap.length - 1 < k) {
            // 构造最大堆
            insert(item, maxHeap);
        } else {
            // 如果当前元素比最大堆的最大值小，则将堆的最大值替换成此元素，然后再重新构造成最大堆
            if (item < maxHeap[1]) {
                addToTop(item, maxHeap);
            }
        }
    }

    function insert(item, heap) {
        heap.push(item);
        let index = heap.length - 1;
        while (heap[index] > heap[parseInt(index / 2)]) {
            let temp = heap[index];
            heap[index] = heap[parseInt(index / 2)];
            heap[parseInt(index / 2)] = temp;
            index = parseInt(index / 2);
        }
    }

    function addToTop(item, heap) {
        heap[1] = item;
        let index = 1;
        while (true) {
            if (heap[2 * index] === undefined) {
                break;
            }
            if (heap[2 * index + 1] === undefined) {
                if (heap[2 * index] < heap[index]) {
                    break;
                }
                let temp = heap[2 * index];
                heap[2 * index] = heap[index];
                heap[index] = temp;
                index = 2 * index;
            } else {
                if (heap[2 * index] < heap[index] && heap[2 * index + 1] < heap[index]) {
                    break;
                }
                if (heap[2 * index] > heap[2 * index + 1]) {
                    let temp = heap[2 * index];
                    heap[2 * index] = heap[index];
                    heap[index] = temp;
                    index = 2 * index;
                } else {
                    let temp = heap[2 * index + 1];
                    heap[2 * index + 1] = heap[index];
                    heap[index] = temp;
                    index = 2 * index + 1;
                }
            }
        }
    }
    maxHeap.shift();
    return maxHeap;
};
```

复杂度分析

时间复杂度：O(n\log k)O(nlogk)，其中 nn 是数组 arr 的长度。由于大根堆实时维护前 kk 小值，所以插入删除都是 O(\log k)O(logk) 的时间复杂度，最坏情况下数组里 nn 个数都会插入，所以一共需要 O(n\log k)O(nlogk) 的时间复杂度。

空间复杂度：O(k)O(k)，因为大根堆里最多 kk 个数。



#### 快排思想

我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。

我们定义函数 randomized_selected(arr, l, r, k) 表示划分数组 arr 的 [l,r] 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：

如果 pos - l + 1 == k，表示 pivot 就是第 kk 小的数，直接返回即可；

如果 pos - l + 1 < k，表示第 kk 小的数在 pivot 的右侧，因此递归调用 randomized_selected(arr, pos + 1, r, k - (pos - l + 1))；

如果 pos - l + 1 > k，表示第 kk 小的数在 pivot 的左侧，递归调用 randomized_selected(arr, l, pos - 1, k)。

函数递归入口为 randomized_selected(arr, 0, arr.length - 1, k)。在函数返回后，将前 k 个数放入答案数组返回即可。



```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        randomizedSelected(arr, 0, arr.length - 1, k);
        int[] vec = new int[k];
        for (int i = 0; i < k; ++i) {
            vec[i] = arr[i];
        }
        return vec;
    }

    private void randomizedSelected(int[] arr, int l, int r, int k) {
        if (l >= r) {
            return;
        }
        int pos = randomizedPartition(arr, l, r);
        int num = pos - l + 1;
        if (k == num) {
            return;
        } else if (k < num) {
            randomizedSelected(arr, l, pos - 1, k);
        } else {
            randomizedSelected(arr, pos + 1, r, k - num);
        }
    }

    // 基于随机的划分
    private int randomizedPartition(int[] nums, int l, int r) {
        int i = new Random().nextInt(r - l + 1) + l;
        swap(nums, r, i);
        return partition(nums, l, r);
    }

    private int partition(int[] nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums, i, j);
            }
        }
        swap(nums, i + 1, r);
        return i + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```



---

## **BM47** **寻找第K大**

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

#### 基于快速排序的选择方法



![基于快速排序的选择方法寻找第K大](E:\pogject\学习笔记\image\niuke\基于快速排序的选择方法寻找第K大.png)

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    // write code here
    const n = nums.length;
    return quickSelect(nums, 0, n - 1, n - k);
}

const quickSelect = (nums, left, right, index) => {
    const q = randomPartition(nums, left, right);
    // console.log(q, nums)
    if (q === index) {
        // 我们会对子数组进行划分，如果划分得到的 qq 正好就是我们需要的下标，就直接返回 a[q]a[q]
        return nums[q];
    } else if (q < index){
        // 否则，如果 qq 比目标下标小，就递归右子区间
        return quickSelect(nums, q + 1, right, index);
    } else {
        // 否则递归左子区间
        return quickSelect(nums, left, q - 1, index);
    }
}

const randomPartition = (nums, left, right) => {
    const randomIndex = left + Math.floor(Math.random() * (right - left));
    swap(nums, randomIndex, right);
    return partition(nums, left, right);
}

const partition = (nums, left, right) => {
    const x = nums[right];
    let i = left - 1;
    for (let j = left; j < right; j++) {
        if (nums[j] <= x) {
            // 把小于等基准值的移到左边
            swap(nums, ++i, j);
        }
    }
    swap(nums, i + 1, right);
    return i + 1;
}

const swap = (nums, i, j) => {
    [nums[i], nums[j]] = [nums[j], nums[i]];
}

let nums = [3,2,1,5,6,4], k = 2;
console.log(findKthLargest(nums, k));

```

复杂度分析

时间复杂度：O(n)O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。
空间复杂度：O(\log n)O(logn)，递归使用栈空间的空间代价的期望为 O(\log n)O(logn)。





#### 基于堆排序的选择方法

我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k - 1*k*−1 次删除操作后堆顶元素就是我们要找的答案。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
*/
var findKthLargest = function(nums, k) {
	//从nums中取出前k个数，构建一个小顶锥
	let heapSize = nums.length;
	bulidMaxHeap(nums, heapSize);
	for (let i = nums.length - 1; i >= nums.length - k + 1; i--){
		swap(nums, 0, i);
		heapSize--;
		maxHeapify(nums,0,heapSize);
	}
	return nums[0];  //返回堆顶元素
};

// 原地建堆，从后往前，自上而下式建小顶堆
var bulidMaxHeap = (arr, heapSize)=>{
	for (let i=Math.floor(heapSize/2); i >= 0; i--){
		maxHeapify(arr,i,heapSize);
	}
}

//堆化
var maxHeapify = (arr, i, heapSize)=>{
	let left = i*2 + 1;
	let right = i*2 + 2;
	let largest = i;
	if (left < heapSize && arr[left] > arr[largest]) {
		largest = left;
	}
	if (right < heapSize && arr[right] > arr[largest]) {
		largest = right;
	}

	if (largest !== i) {
		swap(arr, i, largest);
		maxHeapify(arr, largest, heapSize);
	}
}

//交换元素
var swap=(arr,i,j)=>{
	let temp=arr[i];
	arr[i]=arr[j];
	arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，建堆的时间代价是 O(n)O(n)，删除的总代价是 O(k \log n)O(klogn)，因为 k < nk<n，故渐进时间复杂为 O(n + k \log n) = O(n \log n)O(n+klogn)=O(nlogn)。
空间复杂度：O(\log n)O(logn)，即递归使用栈空间的空间代价。



----

## **BM48** **数据流中的中位数**

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

进阶:

如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

进阶： 空间复杂度 O(n) \*O*(*n*) ， 时间复杂度 O(nlogn) \*O*(*n**l**o**g**n*) 



#### 优先队列

我们用两个优先队列 \textit{queMax}queMax 和 \textit{queMin}queMin 分别记录大于中位数的数和小于等于中位数的数。当累计添加的数的数量为奇数时，\textit{queMin}queMin 中的数的数量比 \textit{queMax}queMax 多一个，此时中位数为 \textit{queMin}queMin 的队头。当累计添加的数的数量为偶数时，两个优先队列中的数的数量相同，此时中位数为它们的队头的平均值。

当我们尝试添加一个数 \textit{num}num 到数据结构中，我们需要分情况讨论：

\textit{num} \leq \max \{\textit{queMin}\}num≤max{queMin}

此时 \textit{num}num 小于等于中位数，我们需要将该数添加到 \textit{queMin}queMin 中。新的中位数将小于等于原来的中位数，因此我们可能需要将 \textit{queMin}queMin 中最大的数移动到 \textit{queMax}queMax 中。

\textit{num} > \max \{\textit{queMin}\}num>max{queMin}

此时 \textit{num}num 大于中位数，我们需要将该数添加到 \textit{queMin}queMin 中。新的中位数将大于等于原来的中位数，因此我们可能需要将 \textit{queMax}queMax 中最小的数移动到 \textit{queMin}queMin 中。

特别地，当累计添加的数的数量为 00 时，我们将 \textit{num}num 添加到 \textit{queMin}queMin 中。

为了方便维护数组的顺序，很明显需要利用堆来存储，而要找到中位数，需要构造两个堆：一个最大堆存储较小的部分，一个最小堆存储较大的部分。如此一来，只需读取堆顶元素就能获得中位数。维护两个堆的方式也很简单，就是保持最大堆的长度与最小堆的长度之差在1以内，封装成优先队列的形式控制元素的压入与推出。



```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
    this.max_queue = new max_priority_queue();
    this.min_queue = new min_priority_queue();
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    this.max_queue.enqueue(num);
    if (this.max_queue.head() === num || this.max_queue.size() - this.min_queue.size() > 1) {
        this.min_queue.enqueue(this.max_queue.dequeue());
    }
    if (this.max_queue.size() - this.min_queue.size() < 0) {
        this.max_queue.enqueue(this.min_queue.dequeue());
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    return this.max_queue.size() > this.min_queue.size() ? this.max_queue.head() : (this.max_queue.head() + this.min_queue.head()) / 2;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

// 构造最大堆
class MaxHeap {
    constructor(array = []) {
        this.A = array;
    }
    size() {
        return this.A.length;
    }
    head() {
        return this.isEmpty() ? null : this.A[0];
    }
    left(i) {
        return 2 * i + 1;
    }
    right(i) {
        return 2 * i + 2;
    }
    parent(i) {
        return i > 0 ? (i - 1) >>> 1 : -1;
    }
    isEmpty() {
        return this.size() === 0;
    }
    heapifyDown(i, size = this.size()) {
        let p = i;
        const l = this.left(i), r = this.right(i);
        if (l < size && this.compare(l, p)) {
            p = l;
        }
        if (r < size && this.compare(r, p)) {
            p = r;
        }
        if (p !== i) {
            this.exchange(i, p);
            this.heapifyDown(p, size);
        }
    }
    heapifyUp(i) {
        const p = this.parent(i);
        if (p >= 0 && this.compare(i, p)) {
            this.exchange(i, p);
            this.heapifyUp(p);
        }
    }
    exchange(x, y) {
        const temp = this.A[x];
        this.A[x] = this.A[y];
        this.A[y] = temp;
    }
    compare(a, b) {
        if (this.A[a] - this.A[b] > 0) {
            return true;
        } else {
            return false;
        }
    }
}

// 优先队列
class max_priority_queue extends MaxHeap {
    enqueue(node) {
        this.A.push(node);
        this.heapifyUp(this.size() - 1);
    }
    dequeue() {
        const first = this.A[0];
        const last = this.A.pop();
        if (first !== last) {
            this.A[0] = last;
            this.heapifyDown(0);
        }
        return first;
    }
}

class min_priority_queue extends max_priority_queue {
    compare(a, b) {
        if (this.A[a] - this.A[b] < 0) {
            return true;
        } else {
            return false;
        }
    }
}
```



#### 有序集合 + 双指针

我们也可以使用有序集合维护这些数。我们把有序集合看作自动排序的数组，使用双指针指向有序集合中的中位数元素即可。当累计添加的数的数量为奇数时，双指针指向同一个元素。当累计添加的数的数量为偶数时，双指针分别指向构成中位数的两个数。

当我们尝试添加一个数 \textit{num}num 到数据结构中，我们需要分情况讨论：

初始有序集合为空时，我们直接让左右指针指向 \textit{num}num 所在的位置。

有序集合为中元素为奇数时，\textit{left}left 和 \textit{right}right 同时指向中位数。如果 \textit{num}num 大于等于中位数，那么只要让 \textit{left}left 左移，否则让 \textit{right}right 右移即可。

有序集合为中元素为偶数时，\textit{left}left 和 \textit{right}right 分别指向构成中位数的两个数。

当 \textit{num}num 成为新的唯一的中位数，那么我们让 \textit{left}left 右移，\textit{right}right 左移，这样它们即可指向 \textit{num}num 所在的位置；
当 \textit{num}num 大于等于 \textit{right}right，那么我们让 \textit{left}left 右移即可；
当 \textit{num}num 小于 \textit{right}right 指向的值，那么我们让 \textit{right}right 左移，注意到如果 \textit{num}num 恰等于 \textit{left}left 指向的值，那么 \textit{num}num 将被插入到 \textit{left}left 右侧，使得 \textit{left}left 和 \textit{right}right 间距增大，所以我们还需要额外让 \textit{left}left 指向移动后的 \textit{right}right。

**代码有问题**

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
    this.queue = [];
    // 用两个指针维护中位数
    this.left = -1;
    this.right = -1;
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    // 第一个数加进来
    if (this.left === -1) {
        this.left++;
        this.right++;
    } else {
        //  加入num后队列长度变为偶数，中位数由两个(下标)不同的数计算得出
        if (this.left === this.right) {
            this.right++;
        } else {
            this.left++;
        }
    }
    this.queue.push(num);
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    if (!this.queue.length) {
        return null;
    }
    this.queue.sort((a, b) => a - b);
    return (this.queue[this.left] + this.queue[this.right]) / 2;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

```



----

## **BM49** **表达式求值**

请写一个整数计算器，支持加减乘三种运算和括号。

数据范围：0\le |s| \le 1000≤∣*s*∣≤100，保证计算结果始终在整型范围内

要求：空间复杂度： O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)



#### eval

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 返回表达式的值
 * @param s string字符串 待计算的表达式
 * @return int整型
 */
function solve( s ) {
    // write code here
    return eval(s);
}
module.exports = {
    solve : solve
};
```

#### 转为逆波兰表达式

将中缀表达式化为逆波兰表达式

借助两个栈，一个存放数字，一个存放操作符

思路：

**初始化：**

- 将运算符加入到map里面，设定优先级，注意`(`的优先级最低
- 将字符串的空格删除

**遍历字符串：**

- 数字：加入数组，注意数字可能占多位
- 左括号：直接`push`到`ops`栈
- 右括号：从nums栈pop两个数字，进行运算，运算的结果push回nums栈，直至碰到`(`
- 其他运算符：
  1. 如果当前运算符的优先级≤\leq≤ops的最后一个，一直运算(例子：5*2+3，碰到+的时候计算5*2)
  2. 如果当前运算符的>>>ops的最后一个，将运算符push到ops(例子：5+2*3，碰到*的时候将`*`push到ops栈)

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 返回表达式的值
 * @param s string字符串 待计算的表达式
 * @return int整型
 */
function solve( s ) {
    // write code here
    s = s.replace(/\s/, "");
    const nums = [];
    const ops = [];
    //设定运算符优先级
    const m = new Map([["(", -1], ["+", 1], ["-", 1], ["*", 2]]);
    
    function calc() {
        let right = nums.pop();
        let left = nums.pop();
        let sign = ops.pop();

        switch(sign) {
            case "+": 
                nums.push(left + right);
                break;
            case "-":
                nums.push(left - right);
                break;
            case "*":
                nums.push(left * right);
                break;
            case "/":
                nums.push(left / right);
                break;
        }
    }
    let i = 0;
    let n = s.length;
    while (i < n) {
        if (/[0-9]/.test(s[i])) {
            //处理数字
            let value = 0;
            while (/[0-9]/.test(s[i])) {
                value = value * 10 + parseInt(s[i]);
                i++;
            }
            nums.push(value);
        } else if (s[i] === "(") {
            // 遇到左括号进栈
            ops.push(s[i]);
            i++;
        } else if (s[i] === ")") {
            // 计算到最近一个左括号为止
            while (ops[ops.length - 1] !== "(") {
                calc();
            }
            ops.pop();  // 弹出左括号
            i++;
        } else {
            // 运算符
            if (ops.length === 0) {
                // 栈为空时，遇到运算符直接进栈
                ops.push(s[i]);
            } else if (m.get(s[i]) > m.get(ops[ops.length - 1])) {
                //当前运算符优先级高于之前的  5+2*3
                ops.push(s[i]);
            } else {
                // 当前运算符优先级<=之前的  5*2-3
                do {
                    calc();
                } while (m.get(s[i]) <= m.get(ops[ops.length - 1]));
                ops.push(s[i]);
            }
            i++;
        }
    }
    while (ops.length) {
        calc();
    }
    return nums[0];
}

// let s = "(2*(3-4))*5";
// console.log(solve(s));

module.exports = {
    solve : solve
};
```



----

## **BM50** **两数之和**

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

要求：空间复杂度 O(n)，时间复杂度 O(nlogn)



#### 暴力枚举

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums,target){
			len_nums=nums.length;
			for (let i=0; i<len_nums-1; i++){
				for (let j=i+1; j<len_nums; j++){
					if (nums[i]+nums[j]==target) {
						var result=[i,j];
						return result;
					}
				}
			}
		};
```

复杂度分析

时间复杂度：O(N^2)O(N 2 )，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。

空间复杂度：O(1)O(1)。



#### 哈希表

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```js
/**
  * 
  * @param numbers int整型一维数组 
  * @param target int整型 
  * @return int整型一维数组
  */
function twoSum( numbers ,  target ) {
    // write code here
    const m = new Map();
    const n = numbers.length;
    for (let i = 0; i < n; i++) {
        if (m.has(target - numbers[i])) {
            return [m.get(target - numbers[i]), i];
        }
        m.set(numbers[i], i);
    }
}
module.exports = {
    twoSum : twoSum
};
```

时间复杂度：O(N)O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。

空间复杂度：O(N)O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。



----

## **BM51** **数组中出现次数超过一半的数字**

#### 方法一：哈希表

我们知道出现次数最多的元素大于Math.floor(n / 2)次，所以可以用哈希表来快速统计每个元素出现的次数。

```js
function MoreThanHalfNum_Solution(numbers)
{
    // write code here
    let n = numbers.length;
    const m = new Map();
    let ans = 0;
    for (let i = 0; i < n; i++) {
        let item = numbers[i];
        m.set(item, m.has(item) ? m.get(item) + 1 : 1);
        ans = Math.max(ans, m.get(item));
        if (ans > Math.floor(n / 2)) {
            return item;
        }
    }
}
module.exports = {
    MoreThanHalfNum_Solution : MoreThanHalfNum_Solution
};
```



#### 排序

如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为Math.floor(n / 2) 的元素（下标从 0 开始）一定是众数。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    nums.sort((a, b) => a - b);
    return nums[nums.length >> 1];
};

```



#### Boyer-Moore 投票算法

如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。

Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    if (nums.length === 0) {
        return false;
    }
    let count = 0;
    let ans;
    let n = nums.length;
    for (let i = 0; i < n; i++) {
        if (count === 0) {
            ans = nums[i];
            count++;
        } else {
            if (nums[i] === ans) {
                count++;
            } else {
                count--;
            }
        }
    }
    return ans;
};
```



----

## **BM52** **数组中只出现一次的两个数字**

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。



**限制：**

- `2 <= nums.length <= 10000`

#### **分组异或**

![数组中只出现一次的两个数字](E:\pogject\学习笔记\image\niuke\数组中只出现一次的两个数字.png)

先对所有数字进行一次异或，得到两个出现一次的数字的异或值。

在异或结果中找到任意为 1 的位。

根据这一位对所有的数字进行分组。

在每个组内进行异或操作，得到两个数字。



```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumbers = function(nums) {
    let ret = 0;
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        ret ^= nums[i];
    }
    let div = 1;
    while ((div & ret) === 0) {
        // 找到第一个 二进制位 1
        div <<= 1;
    }
    let a = 0, b = 0;
    for (let i = 0; i < n; i++) {
        if ((div & nums[i]) !== 0) {
            a ^= nums[i];
        } else {
            b ^= nums[i];
        }
    }
    return [a, b];
};

let nums = [4,1,4,6];
console.log(singleNumbers(nums));
```



----

## **BM53** **缺失的第一个正整数**

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。



如果本题没有额外的时空复杂度要求，那么就很容易实现：

我们可以将数组所有的数放入哈希表，随后从 11 开始依次枚举正整数，并判断其是否在哈希表中；

我们可以从 11 开始依次枚举正整数，并遍历数组，判断其是否在数组中。

如果数组的长度为 NN，那么第一种做法的时间复杂度为 O(N)O(N)，空间复杂度为 O(N)O(N)；第二种做法的时间复杂度为 O(N^2)O(N 
2
 )，空间复杂度为 O(1)O(1)。但它们都不满足时间复杂度为 O(N)O(N) 且空间复杂度为 O(1)O(1)。

「真正」满足时间复杂度为 O(N)O(N) 且空间复杂度为 O(1)O(1) 的算法是不存在的，但是我们可以退而求其次：利用给定数组中的空间来存储一些状态。也就是说，如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。

#### 数组模拟哈希表

![缺失的第一个正整数](E:\pogject\学习笔记\image\niuke\缺失的第一个正整数.png)

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param nums int整型一维数组 
 * @return int整型
 */
function minNumberDisappeared( nums ) {
    // write code here
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        // 将非负正数变为  n + 1
        if (nums[i] <= 0) {
            nums[i] = n + 1;
        }
    }
    for (let i = 0; i < n; i++) {
        let num = Math.abs(nums[i]);
        if (num <= n) {
            // 将小于等于n的元素对应的位置变为负数
            nums[num - 1] = - Math.abs(nums[num - 1]);
        }
    }
    for (let i = 0; i < n; i++) {
        // 返回第一个大于0的元素的下标 + 1
        if (nums[i] > 0) {
            return i + 1;
        }
    }
    return n + 1;
}
module.exports = {
    minNumberDisappeared : minNumberDisappeared
};
```

**复杂度分析**

- 时间复杂度：O(N)*O*(*N*)，其中 N*N* 是数组的长度。
- 空间复杂度：O(1)*O*(1)。

#### 置换

除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：

如果数组中包含 x \in [1, N]x∈[1,N]，那么恢复后，数组的第 x - 1x−1 个元素为 xx。

在恢复后，数组应当有 [1, 2, ..., N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 22。

那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数 x = \textit{nums}[i]x=nums[i]，如果 x \in [1, N]x∈[1,N]，我们就知道 xx 应当出现在数组中的 x - 1x−1 的位置，因此交换 \textit{nums}[i]nums[i] 和 \textit{nums}[x - 1]nums[x−1]，这样 xx 就出现在了正确的位置。在完成交换后，新的 \textit{nums}[i]nums[i] 可能还在 [1, N][1,N] 的范围内，我们需要继续进行交换操作，直到 x \notin [1, N]x∈  [1,N]。

注意到上面的方法可能会陷入死循环。如果 \textit{nums}[i]nums[i] 恰好与 \textit{nums}[x - 1]nums[x−1] 相等，那么就会无限交换下去。此时我们有 \textit{nums}[i] = x = \textit{nums}[x - 1]nums[i]=x=nums[x−1]，说明 xx 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。

由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 NN，整个方法的时间复杂度为 O(N)O(N)。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
	const n = nums.length;
	for (let i = 0; i < n; i++) {
		while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {
			// 把1-n的元素放到对应的位置
			let temp = nums[nums[i] - 1];
			nums[nums[i] - 1] = nums[i];
			nums[i] = temp;
		}
	}

	for (let i = 0; i < n; i++) {
		if (nums[i] !== i + 1) {
			return i + 1;
		}
	}
	return n + 1;
};

let nums = [3,4,-1,1];
console.log(firstMissingPositive(nums));
```





----

## **BM54** **三数之和**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

####  排序 + 双指针

```js
/**
 * 
 * @param num int整型一维数组 
 * @return int整型二维数组
 */
function threeSum( nums ) {
    nums = nums.sort((a, b) => a - b);  //排序
    let n = nums.length;
    const ans = [];
    let sum = 0;
    //枚举第一个数字
    for (let first = 0; first < n; first++){
        // 需要和上一次枚举的数不相同
        if (nums[first] > 0) {
            //first元素大于0后，后面sum不可能等于0
            break;
        }
        if (first > 0 && nums[first] === nums[first - 1]){
            continue;
        }
        //第三个数对应的指针初始指向数组的最右端
        let third = n - 1;
        let target = -nums[first];
        for (let second = first + 1; second < n; second++){
            if (nums[second] > target) {
                //前两个元素和已经大于0，则再加第三个一定大于0;
                break;
            }
            // 需要和上一次枚举的数不相同
            if (second > first + 1 && nums[second] === nums[second - 1]) {
                continue;
            }
            // 需要保证 second 的指针在 third 的指针的左侧
            while(second < third && nums[second] + nums[third] > target){
                third--;
            }
            // 如果指针重合，随着 second 后续的增加
            // 就不会有满足 a+b+c = 0 并且 b<c 的 c 了，可以退出循环
            if (second === third) {
                break;
            }
            if (nums[second] + nums[third] === target) {
                ans.push([nums[first], nums[second], nums[third]]);
            }
        }
    }
    return ans;
}
module.exports  =  {
    threeSum : threeSum
};
```



----

## **BM55** **没有重复项数字的全排列**

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。



回溯法：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。

#### 回溯

![没有重复项数字的全排列](E:\pogject\学习笔记\image\niuke\没有重复项数字的全排列.png)

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
	const n = nums.length;
	const ans = [];
	const backtrack = (first) => {
		// 所有数都填完了
		if (first === n) {
			ans.push([...nums]);
		}
		for (let i = first; i < n; i++) {
			// 动态维护数组
			[nums[first], nums[i]] = [nums[i], nums[first]];
			// 继续递归填下一个数
			backtrack(first + 1);
			// 撤销操作
			[nums[i], nums[first]] = [nums[first], nums[i]];
		}
	}
	backtrack(0);

	return ans;
};

let nums = [3,4,-1,1];
console.log(permute(nums));
```





----

## **BM56** **有重复项数字的全排列**

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

#### 排序后回溯

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
	nums.sort((a, b) => a -b);  // 排序
	const n = nums.length;
	const ans = [];
	const visited = new Array(n).fill(false);

	const backtrack = (idx, perm) => {
		// 所有数都填完了
		if (idx === n) {
			ans.push([...perm]);
			return;
		}
		for (let i = 0; i < n; i++) {
			if (visited[i] || (i > 0 && nums[i] === nums[i -1] && !visited[i - 1])) {
				continue;
			}
			perm.push(nums[i]);
			visited[i] = true;
			// 继续递归填下一个数
			backtrack(idx + 1, perm);
			// 撤销操作
			visited[i] = false;
			perm.pop();
		}
	}
	backtrack(0, []);

	return ans;
};

let nums = [3,4,1,1];
console.log(permute(nums));
```



----

## **BM57** **岛屿数量**

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

提示：

- m == grid.length

- n == grid[i].length
- 1 <= m, n <= 300
- grid[i][j] 的值为 '0' 或 '1'

#### 深度优先搜索

我们可以将二维网格看成一个无向图，竖直或水平相邻的 11 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。

最终岛屿的数量就是我们进行深度优先搜索的次数。

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
	if (grid === null || grid.length === 0 || grid[0].length === 0) {
		return 0;
	}
	const m = grid.length;
	const n = grid[0].length;
	let ans = 0;
	for (let row = 0; row < m; row++) {
		for (let col = 0; col < n; col++) {
			if (grid[row][col] === "1") {
				ans++;
				dfs(grid, row, col, m, n);
			}
		}
	}
	return ans;
};

const dfs = (grid, row, col, m, n) => {
	if (row >= 0 && row < m && col >= 0 && col < n && grid[row][col] === "1") {
		grid[row][col] = "0";
		dfs(grid, row - 1, col, m, n);
		dfs(grid, row + 1, col, m, n);
		dfs(grid, row, col - 1, m, n);
		dfs(grid, row, col + 1, m, n);
	}
}

let grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
];

console.log(numIslands(grid));
```

复杂度分析

时间复杂度：O(MN)O(MN)，其中 MM 和 NN 分别为行数和列数。

空间复杂度：O(MN)O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 M NMN。



#### 广度优先搜索

同样地，我们也可以使用广度优先搜索代替深度优先搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。直到队列为空，搜索结束。

最终岛屿的数量就是我们进行广度优先搜索的次数。

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
	if (grid === null || grid.length === 0 || grid[0].length === 0) {
		return 0;
	}
	const m = grid.length;
	const n = grid[0].length;
	let neighbors = [];
	let ans = 0;

	for (let row = 0; row < m; row++) {
		for (let col = 0; col < n; col++) {
			if (grid[row][col] === "1") {
				ans++;
				grid[row][col] = "0";  //做标记，避免重复遍历
				neighbors.push([row, col]);  // 加入队列
				turnZero(grid, neighbors, m, n);
			}
		}
	}
	return ans;
};

const turnZero = (grid, neighbors, m, n) => {
	const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];
	while (neighbors.length > 0) {
		// 当队列中还有元素的时候 
		const cur = neighbors.shift();  //取出队首元素
		for (let dir of dirs) {
			const row = cur[0] + dir[0];
			const col = cur[1] + dir[1];
			if (row >= 0 && row < m && col >= 0 && col < n && grid[row][col] === "1") {
				//检查坐标合法性
				grid[row][col] = "0";  //沉没陆地
				neighbors.push([row, col]);  //四周的节点加入队列
			}
		}
	}
}

let grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
];

console.log(numIslands(grid));
```

复杂度分析

时间复杂度：O(MN)O(MN)，其中 MM 和 NN 分别为行数和列数。

空间复杂度：O(\min(M, N))O(min(M,N))，在最坏情况下，整个网格均为陆地，队列的大小可以达到 \min(M, N)min(M,N)。



#### 并查集

同样地，我们也可以使用并查集代替搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其与相邻四个方向上的 11 在并查集中进行合并。

最终岛屿的数量就是并查集中连通分量的数目。

```js
class UnionFind {
    constructor(n) { //构造一个节点数为n的集合
        this.count = n //并查集总数
        this.parent = new Array(n)
        this.size = new Array(n)  // size数组记录着每棵树的重量
        for (let i = 0; i < n; i++) {
            this.parent[i] = i; // 自己是自己的parent
            this.size[i] = 1;	//每个集合上节点的数量
        }
    }

    union(p, q) { //连通结点p和结点q, p和q都是索引
        let rootP = this.find(p);
        let rootQ = this.find(q);
        if (rootP === rootQ) return
        // 元素数量小的接到数量多的下面，这样比较平衡
        if (this.size[rootP] > this.size[rootQ]) {
            this.parent[rootQ] = rootP;
            this.size[rootP] += this.size[rootQ];
        } else {
            this.parent[rootP] = rootQ;
            this.size[rootQ] += this.size[rootP];
        }
        this.count--;
    }

    isConnected(p, q) { //判断p,q是否连通
        return this.find(p) === this.find(q)
    }

    find(x) { //找到x结点的root
        while (this.parent[x] != x) {
            // 进行路径压缩
            this.parent[x] = this.parent[this.parent[x]];
            x = this.parent[x];
        }
        return x;
    }

    getCount() { //返回子集个数
        return this.count;
    }

}

var numIslands = function (grid) {
    let m = grid.length
    if (m === 0) return 0
    let n = grid[0].length
    const dummy = -1
    const dirs = [[1, 0], [0, 1]]//方向数组 向右 向下
    const uf = new UnionFind(m * n)
    for (let x = 0; x < m; x++) {
        for (let y = 0; y < n; y++)
            if (grid[x][y] === '0') {//如果网格是0，则和dummy合并
                uf.union(n * x + y, dummy) 
            }
            else if (grid[x][y] === '1') {//如果网格是1，则向右 向下尝试
                for (let d of dirs) {
                    let r = x + d[0]
                    let c = y + d[1]
                    if (r >= m || c >= n) continue //坐标合法性
                    if (grid[r][c] === '1') { //当前网格的右边 下面如果是1，则和当前网格合并
                        uf.union(n * x + y, n * r + c)
                    }
                }
            }
    }
    return uf.getCount()  //返回并查集的个数减一就行
};


let grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
];

console.log(numIslands(grid));
```

复杂度分析

时间复杂度：O(MN \times \alpha(MN))O(MN×α(MN))，其中 MM 和 NN 分别为行数和列数。注意当使用路径压缩（见 find 函数）和按秩合并（见数组 rank）实现并查集时，单次操作的时间复杂度为 \alpha(MN)α(MN)，其中 \alpha(x)α(x) 为反阿克曼函数，当自变量 xx 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 \alpha(x)α(x) 的值不会超过 55，因此也可以看成是常数时间复杂度。

空间复杂度：O(MN)O(MN)，这是并查集需要使用的空间。



----

## **BM58** **字符串的排列**

输入一个字符串，打印出该字符串中字符的所有排列。

 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

#### 回溯

但是该递归函数并没有满足「全排列不重复」的要求，在重复的字符较多的情况下，该递归函数会生成大量重复的排列。对于任意一个空位，如果存在重复的字符，该递归函数会将它们重复填上去并继续尝试导致最后答案的重复。

解决该问题的一种较为直观的思路是，我们首先生成所有的排列，然后进行去重。而另一种思路是我们通过修改递归函数，使得该递归函数只会生成不重复的序列。

具体地，我们只要在递归函数中设定一个规则，保证在填每一个空位的时候重复字符只会被填入一次。具体地，我们首先对原字符串排序，保证相同的字符都相邻，在递归函数中，我们限制每次填入的字符一定是这个字符所在重复字符集合中从左往右第一个未被填入的字符。

```js
var permutation = function(s) {
    const n = s.length;
    const ans = [];
    const visited = new Array(n).fill(false);

    const arr = Array.from(s).sort();  //首先对原字符串排序，保证相同的字符都相邻
    const perm = [];

    const backtrack = (arr, i, n, perm) => {
        if (i === n) {
            ans.push(perm.join(""));
            return;
        }
        for (let j = 0; j < n; j++) {
            if (visited[j] || (j > 0 && !visited[j - 1] && arr[j - 1] === arr[j])) {
                continue;  // 避免重复
            }
            visited[j] = true;
            perm.push(arr[j]);
            backtrack(arr, i + 1, n, perm);
            perm.pop();
            visited[j] = false;
        }
    }
    backtrack(arr, 0, n, perm);
    const size = ans.length;
    return ans;
}

let s = "abc";
console.log(permutation(s))
```

复杂度分析

时间复杂度：O(n \times n!)O(n×n!)，其中 nn 为给定字符串的长度。这些字符的全部排列有 O(n!)O(n!) 个，每个排列平均需要 O(n)O(n) 的时间来生成。

空间复杂度：O(n)O(n)。我们需要 O(n)O(n) 的栈空间进行回溯，注意返回值不计入空间复杂度。

#### 下一个排列

具体地，我们首先对给定的字符串中的字符进行排序，即可得到当前字符串的第一个排列，然后我们不断地计算当前字符串的字典序中下一个更大的排列，直到不存在更大的排列为止即可。

这个方案的优秀之处在于，我们得到的所有排列都不可能重复，这样我们就无需进行去重的操作。同时因为无需使用回溯法，没有栈的开销，算法时间复杂度的常数较小。



```js
var permutation = function(s) {
    const ret = [];
    const arr = Array.from(s).sort();

    const nextPermutation = (arr) => {
        let i = arr.length - 2;
        while (i >= 0 && arr[i] >= arr[i + 1]) {
            i--;
        }
        if (i < 0) {
            return false;
        }
        let j = arr.length - 1;
        while (j >= 0 && arr[i] >= arr[j]) {
            j--;
        }
        swap(arr, i, j);
        reverse(arr, i + 1);
        return true;
    }

    const swap = (arr, i, j) => {
        const temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    const reverse = (arr, start) => {
        let left = start, right = arr.length - 1;
        while (left < right) {
            swap(arr, left, right);
            left++;
            right--;
        }
    }

    do {
        ret.push(arr.join(''));
    } while (nextPermutation(arr));
    const size = ret.length;
    const retArr = new Array(size).fill(0);
    for (let i = 0; i < size; i++) {
        retArr[i] = ret[i];
    }
    return retArr;
};
```



-----

## **BM59** **N皇后问题**

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。


数据范围: 1≤*n*≤9

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n!)*O*(*n*!)



皇后的走法是：可以横直斜走，格数不限。因此要求皇后彼此之间不能相互攻击，等价于要求任何两个皇后都不能在同一行、同一列以及同一条斜线上。

直观的做法是暴力枚举将 NN 个皇后放置在 N \times NN×N 的棋盘上的所有可能的情况，并对每一种情况判断是否满足皇后彼此之间不相互攻击。暴力枚举的时间复杂度是非常高的，因此必须利用限制条件加以优化。

显然，每个皇后必须位于不同行和不同列，因此将 NN 个皇后放置在 N \times NN×N 的棋盘上，一定是每一行有且仅有一个皇后，每一列有且仅有一个皇后，且任何两个皇后都不能在同一条斜线上。基于上述发现，可以通过回溯的方式寻找可能的解。

回溯的具体做法是：使用一个数组记录每行放置的皇后的列下标，依次在每一行放置一个皇后。每次新放置的皇后都不能和已经放置的皇后之间有攻击：即新放置的皇后不能和任何一个已经放置的皇后在同一列以及同一条斜线上，并更新数组中的当前行的皇后列下标。当 NN 个皇后都放置完毕，则找到一个可能的解。当找到一个可能的解之后，将数组转换成表示棋盘状态的列表，并将该棋盘状态的列表加入返回列表。

由于每个皇后必须位于不同列，因此已经放置的皇后所在的列不能放置别的皇后。第一个皇后有 NN 列可以选择，第二个皇后最多有 N-1N−1 列可以选择，第三个皇后最多有 N-2N−2 列可以选择（如果考虑到不能在同一条斜线上，可能的选择数量更少），因此所有可能的情况不会超过 N!N! 种，遍历这些情况的时间复杂度是 O(N!)O(N!)。

为了降低总时间复杂度，每次放置皇后时需要快速判断每个位置是否可以放置皇后，显然，最理想的情况是在 O(1)O(1) 的时间内判断该位置所在的列和两条斜线上是否已经有皇后。

以下两种方法分别使用集合和位运算对皇后的放置位置进行判断，都可以在 O(1)O(1) 的时间内判断一个位置是否可以放置皇后，算法的总时间复杂度都是 O(N!)O(N!)。



#### 基于集合的回溯

为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合columns、diagonals1  和 diagonals2

  分别记录每一列以及两个方向的每条斜线上是否有皇后。

列的表示法很直观，一共有 NN 列，每一列的下标范围从 00 到 N-1N−1，使用列的下标即可明确表示每一列。

如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。

方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足行下标与列下标之差相等，例如 (0,0)(0,0) 和 (3,3)(3,3) 在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。

每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。

```js
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
	const queens = new Array(n).fill(-1);
	const ans = [];
	// 分别记录每一列以及两个方向的每条斜线上是否有皇后
	const columns = new Set();
	const diagons1 = new Set();
	const diagons2 = new Set();

	backtrack(ans, queens, n, 0, columns, diagons1, diagons2);
	return ans;
};

const backtrack = (ans, queens, n, row, columns, diagons1, diagons2) => {
	if (row === n) {
		const board = generateBoard(queens, n);
		ans.push(board);
	} else {
		for (let i = 0; i < n; i++) {
			if (columns.has(i)) {
				continue;
			}
			let diagon1 = row - i;
			if (diagons1.has(diagon1)) {
				continue;
			}
			let diagon2 = row + i;
			if (diagons2.has(diagon2)) {
				continue;
			}

			queens[row] = i;
			columns.add(i);
			diagons1.add(diagon1);
			diagons2.add(diagon2);
			//回溯
			backtrack(ans, queens, n, row + 1, columns, diagons1, diagons2);
			//撤销
			queens[row] = -1;
			columns.delete(i);
			diagons1.delete(diagon1);
			diagons2.delete(diagon2);
		}
	}
}

const generateBoard = (queens, n) => {
	const board = [];
	for (let i = 0; i < n; i++) {
		const arr = new Array(n).fill(".");
		arr[queens[i]] = "Q";
		board.push(arr.join(""));
	}
	return board;
}

let n = 4;
console.log(solveNQueens(n));
```

时间复杂度：O(N!)O(N!)，其中 NN 是皇后数量。

空间复杂度：O(N)O(N)，其中 NN 是皇后数量。空间复杂度主要取决于递归调用层数、记录每行放置的皇后的列下标的数组以及三个集合，递归调用层数不会超过 NN，数组的长度为 NN，每个集合的元素个数都不会超过 NN。



#### 基于位运算的回溯

方法一使用三个集合记录分别记录每一列以及两个方向的每条斜线上是否有皇后，每个集合最多包含 NN 个元素，因此集合的空间复杂度是 O(N)O(N)。如果利用位运算记录皇后的信息，就可以将记录皇后信息的空间复杂度从 O(N)O(N) 降到 O(1)O(1)。

具体做法是，使用三个整数 \textit{columns}columns、\textit{diagonals}_1diagonals 1  和 \textit{diagonals}_2diagonals 2  分别记录每一列以及两个方向的每条斜线上是否有皇后，每个整数有 NN 个二进制位。棋盘的每一列对应每个整数的二进制表示中的一个数位，其中棋盘的最左列对应每个整数的最低二进制位，最右列对应每个整数的最高二进制位。

```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        List<List<String>> solutions = new ArrayList<List<String>>();
        solve(solutions, queens, n, 0, 0, 0, 0);
        return solutions;
    }

    public void solve(List<List<String>> solutions, int[] queens, int n, int row, int columns, int diagonals1, int diagonals2) {
        if (row == n) {
            List<String> board = generateBoard(queens, n);
            solutions.add(board);
        } else {
            int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));
            while (availablePositions != 0) {
                int position = availablePositions & (-availablePositions);
                availablePositions = availablePositions & (availablePositions - 1);
                int column = Integer.bitCount(position - 1);
                queens[row] = column;
                solve(solutions, queens, n, row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1);
                queens[row] = -1;
            }
        }
    }

    public List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<String>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
}


```

复杂度分析

时间复杂度：O(N!)O(N!)，其中 NN 是皇后数量。

空间复杂度：O(N)O(N)，其中 NN 是皇后数量。由于使用位运算表示，因此存储皇后信息的空间复杂度是 O(1)O(1)，空间复杂度主要取决于递归调用层数和记录每行放置的皇后的列下标的数组，递归调用层数不会超过 NN，数组的长度为 NN。







----

## **BM60** **括号生成**

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

数据范围：0≤*n*≤10

要求：空间复杂度 O(n)，时间复杂度 O(2^n)

#### 回溯法

方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 '('或 ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，

如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
	const ans = [];
	backtrack(ans, [], 0, 0, n);
	return ans;
};

const backtrack = (ans, cur, open, close, max) => {
	if (cur.length === max * 2) {
		ans.push(cur.join(""));
	}
	if (open < max) {
		cur.push("(");
		backtrack(ans, cur, open + 1, close, max);
		cur.pop();
	}
	if (close < open) {
		cur.push(")");
		backtrack(ans, cur, open, close + 1, max);
		cur.pop();
	}
}

console.log(generateParenthesis(4))
```



#### 按括号序列的长度递归

![按括号序列的长度递归](E:\pogject\学习笔记\image\niuke\按括号序列的长度递归.png)

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
	const cache = new Array();

	const generate = (n) => {
		if (cache[n]) {
			return cache[n];
		}
		const ans = [];
		if (n === 0) {
			ans.push("");
		} else {
			for (let c = 0; c < n; c++) {
				for (let left of generate(c)) {
					for (let right of generate(n - 1 - c)) {
						ans.push("(" + left + ")" + right);
					}
				}
			}
		}
		cache[n] = ans;
		return ans;
	}

	return generate(n);
};

console.log(generateParenthesis(4))
```



----

## **BM61** **矩阵最长递增路径**

给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。



进阶：空间复杂度 O(nm) ，时间复杂度 O(nm)*O*(*n**m*)



#### 记忆化深度优先搜索

将矩阵看成一个有向图，每个单元格对应图中的一个节点，如果相邻的两个单元格的值不相等，则在相邻的两个单元格之间存在一条从较小值指向较大值的有向边。问题转化成在有向图中寻找最长路径。

深度优先搜索是非常直观的方法。从一个单元格开始进行深度优先搜索，即可找到从该单元格开始的最长递增路径。对每个单元格分别进行深度优先搜索之后，即可得到矩阵中的最长递增路径的长度。

但是如果使用朴素深度优先搜索，时间复杂度是指数级，会超出时间限制，因此必须加以优化。

朴素深度优先搜索的时间复杂度过高的原因是进行了大量的重复计算，同一个单元格会被访问多次，每次访问都要重新计算。**由于同一个单元格对应的最长递增路径的长度是固定不变的，因此可以使用记忆化的方法进行优化**。用矩阵memo 作为缓存矩阵，已经计算过的单元格的结果存储到缓存矩阵中。

使用记忆化深度优先搜索，当访问到一个单元格 (i,j) 时，如果`memo[i][j] !=0`，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果`memo[i][j] = 0`，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。

遍历完矩阵中的所有单元格之后，即可得到矩阵中的最长递增路径的长度。

```js
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
	if (matrix === null || matrix.length === 0 || matrix[0].length === 0) {
		return 0;
	}

	const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
	const m = matrix.length, n = matrix[0].length;

	const memo = new Array(m).fill(0).map(() => new Array(n).fill(0));

	let ans = 0;

	const dfs = (row, col) => {
		if (memo[row][col] !== 0) {
			return memo[row][col];
		}
		++memo[row][col];
		for (const dir of dirs) {
			const x = row + dir[0], y = col + dir[1];
			if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[row][col]) {
				memo[row][col] = Math.max(memo[row][col], dfs(x, y) + 1);
			}
		}
		return memo[row][col];
	}

	for (let i = 0; i < m; i++) {
		for (let j = 0; j < n; j++) {
			ans = Math.max(ans, dfs(i, j));
		}
	}

	return ans;
};

let matrix = [[9,9,4],[6,6,8],[2,1,1]];
console.log(longestIncreasingPath(matrix));
```



#### 拓扑排序

从方法一可以看到，每个单元格对应的最长递增路径的结果只和相邻单元格的结果有关，那么是否可以使用动态规划求解？

根据方法一的分析，动态规划的状态定义和状态转移方程都很容易得到。方法一中使用的缓存矩阵}memo 即为状态值，状态转移方程如下：

```js
memo[i][j]=max{memo[x][y]}+1  //其中 (x,y) 与 (i,j) 在矩阵中相邻，并且 matrix[x][y] > matrix[i][j]
```

动态规划除了状态定义和状态转移方程，还需要考虑边界情况。这里的边界情况是什么呢？

如果一个单元格的值比它的所有相邻单元格的值都要大，那么这个单元格对应的最长递增路径是 1，这就是边界条件。这个边界条件并不直观，而是需要根据矩阵中的每个单元格的值找到作为边界条件的单元格。

仍然使用方法一的思想，将矩阵看成一个有向图，计算每个单元格对应的出度，即有多少条边从该单元格出发。对于作为边界条件的单元格，该单元格的值比所有的相邻单元格的值都要大，因此作为边界条件的单元格的出度都是 0。

基于出度的概念，可以使用拓扑排序求解。从所有出度为 0 的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为 0 的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。

```js
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
	if (matrix === null || matrix.length === 0 || matrix[0].length === 0) {
		return 0;
	}

	const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
	const m = matrix.length, n = matrix[0].length;

	const outdegrees = new Array(m).fill(0).map(() => new Array(n).fill(0));

	for (let row = 0; row < m; row++) {
		for (let col = 0; col < n; col++) {
			for (const dir of dirs) {
				const x = row + dir[0], y = col + dir[1];
				if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[row][col]) {
					++outdegrees[row][col];
				}
			}
		}
	}

	const queue = [];
	for (let row = 0; row < m; row++) {
		for (let col = 0; col < n; col++) {
			if (outdegrees[row][col] === 0) {
				queue.push([row, col]);
			}
		}
	}

	let ans = 0;

	while (queue.length){
		ans++;
		let size = queue.length;
		for (let i = 0; i < size; i++) {
			const [row, col] = queue.shift();
			for (const dir of dirs) {
				const x = row + dir[0], y = col + dir[1];
				if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] < matrix[row][col]) {
					--outdegrees[x][y];
					if (outdegrees[x][y] === 0) {
						queue.push([x, y]);
					}
				}
			}
		}
	}

	return ans;
};

let matrix = [[9,9,4],[6,6,8],[2,1,1]];
console.log(longestIncreasingPath(matrix));
```

时间复杂度：O(mn)O(mn)，其中 mm 和 nn 分别是矩阵的行数和列数。拓扑排序的时间复杂度是 O(V+E)O(V+E)，其中 VV 是节点数，EE 是边数。在矩阵中，O(V)=O(mn)O(V)=O(mn)，O(E)\approx O(4mn) = O(mn)O(E)≈O(4mn)=O(mn)。

空间复杂度：O(mn)O(mn)，其中 mm 和 nn 分别是矩阵的行数和列数。空间复杂度主要取决于队列，队列中的元素个数不会超过 mnmn。



----

## **BM62** **斐波那契数列**

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 n ，请计算 F(n) 。

要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*) ，本题也有时间复杂度 O(logn)*O*(*l**o**g**n*) 的解法

```js
var fib = function(n) {
    if (n < 2) {
        return 1;
    }
    let p = 1, q = 1, r = 1;
    for (let i = 3; i <= n; i++) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```



----

## **BM63** **跳台阶**

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

要求：时间复杂度：O(n)*O*(*n*) ，空间复杂度： O(1)*O*(1)

```js
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function(n) {
    const MOD = 1000000007;
    if (n < 2) {
        return 1;
    }
    let p = 1, q = 1, r = 0;
    for (let i = 2; i <= n; i++) {
        r = (p + q) % MOD;
        p = q;
        q = r;
    }
    return r;
}
```



----

## **BM64** **最小花费爬楼梯**

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

![使用最小花费爬楼梯](E:\pogject\学习笔记\image\niuke\使用最小花费爬楼梯.png)

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    const n = cost.length;
    const dp = new Array(n + 1).fill(0);

    for (let i = 2; i <= n; i++) {
    	dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
};

let cost = [1,100,1,1,1,100,1,1,100,1];
console.log(minCostClimbingStairs(cost));
```

将空间复杂度优化到 O(1)。

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    const n = cost.length;
    const dp = new Array(n + 1).fill(0);

    let pre = 0, curr = 0, next = 0;
    for (let i = 2; i <= n; i++) {
    	next = Math.min(curr + cost[i - 1], pre + cost[i - 2]);
    	pre = curr;
    	curr = next;
    }
    return curr;
};

let cost = [1,100,1,1,1,100,1,1,100,1];
console.log(minCostClimbingStairs(cost));
```



----

## **BM65** **最长公共子序列(二)**

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

![最长公共子序列](E:\pogject\学习笔记\image\niuke\最长公共子序列.png)

```js
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 1; i <= m; i++) {
        const c1 = text1[i - 1];
        for (let j = 1; j <= n; j++) {
            const c2 = text2[j - 1];
            if (c1 === c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```

给定两个字符串str1和str2，**输出两个字符串的最长公共子序列**。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

```js
/**
 * longest common subsequence
 * @param s1 string字符串 the string
 * @param s2 string字符串 the string
 * @return string字符串
 */
function LCS( s1 ,  s2 ) {
    // write code here
 		const m = s1.length, n = s2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        const c1 = s1[i - 1];
        for (let j = 1; j <= n; j++) {
            const c2 = s2[j - 1];
            if (c1 === c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    if (dp[m][n] === 0) {
    	return "-1";
    }

    const ans = [];
    let row = m, col = n;
    while(dp[row][col] >= 1) {
    	if (s1[row - 1] === s2[col - 1]) {
    		ans.push(s1[row - 1]);
    		row--;
    		col--;
    	} else if (dp[row - 1][col] >= dp[row][col - 1]) {
    		row--;
    	} else {
    		col--;
    	}
    }
    return ans.reverse().join("");
};

let s1 = "1A2C3D4B56", s2 = "B1D23A456A";
console.log(LCS(s1, s2));
```



-----

## **BM66** **最长公共子串**

给定两个字符串str1和str2,输出两个字符串的最长公共子串

题目保证str1和str2的最长公共子串存在且唯一。 

数据范围： 1 ≤∣*str*1∣,∣*str*2∣≤5000
要求： 空间复杂度 O(n^2)*O*(*n*2)，时间复杂度 O(n^2)*O*(*n*2)

```
输入：
"1AB2345CD","12345EF"

返回值：
"2345"
```

这里的dp含义和上一次不一样了，最长公共子序列的dp[i][j]表示str1的i位置和st2的j位置截止的最大长度，

而最长公共字串的dp[i][j]表示str1的i位置和str2的j位置作为最后一个元素所构成的最长公共字串，也就是str1的第i个位置必须作为公共子串的最后一个元素，在dp的过程中用index记录最大字串长度的最后一个元素下标

```js
/**
 * longest common subsequence
 * @param s1 string字符串 the string
 * @param s2 string字符串 the string
 * @return string字符串
 */
function LCS( s1 ,  s2 ) {
    // write code here
 		const m = s1.length, n = s2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    let maxLength = 0;  //最大字串长度
	  let index;  //i记录max最大时候的坐标，用于确定子串

	  for (let i = 0; i < n; i++) {
	  	dp[0][i] = (s1[0] === s2[i]) ? 1 : 0;
	  }
	  for (let i = 0; i < m; i++) {
	  	dp[i][i] = (s1[i] === s2[0]) ? 1 : 0;
	  }

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s1[i] === s2[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (maxLength < dp[i][j]) {
                	maxLength = dp[i][j];
                	index = i;
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }
    if (dp[m][n] === 0) {
    	return "-1";
    }

    return s1.slice(index - maxLength + 1, index + 1);
};

let s1 = "1A2C3D4B56", s2 = "B1D23A456A";
console.log(LCS(s1, s2));
```



-----

## **BM67** **不同路径的数目(一)**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

#### 动态规划

![不同路径的数目](E:\pogject\学习笔记\image\niuke\不同路径的数目.png)

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    // const dirs = [[1, 0], [0, 1]];
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

    for (let i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (let i = 0; i < n; i++) {
        dp[0][i] = 1;
    }

    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
};

console.log(uniquePaths(3, 7))
```

我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为O(n)

#### 组合数学

![不同路径的数目组合数学](E:\pogject\学习笔记\image\niuke\不同路径的数目组合数学.png)

```js
var uniquePaths = function(m, n) {
    let ans = 1;
    for (let x = n, y = 1; y < m; ++x, ++y) {
        ans = Math.floor(ans * x / y);
    }
    return ans;
};
```



----

## **BM68** **矩阵的最小路径和**

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。



#### 动态规划

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    const m = grid.length, n = grid[0].length;
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
    dp[0][0] = grid[0][0];

    for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (let i = 1; i < n; i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }

    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
};

let grid = [[1,3,1],[1,5,1],[4,2,1]];
console.log(minPathSum(grid));
```

空间复杂度可以优化，例如每次只存储上一行的dp 值，则可以将空间复杂度优化到 O(n)。

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    const m = grid.length, n = grid[0].length;
    const dp = new Array(n).fill(0);
    dp[0] = grid[0][0];

    for (let i = 1; i < n; i++) {
        dp[i] = dp[i - 1] + grid[0][i];
    }

    for (let i = 1; i < m; i++) {
        dp[0] = dp[0] + grid[i][0];
        for (let j = 1; j < n; j++) {
            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }
    return dp[n - 1];
};

let grid = [[1,3,1],[1,5,1],[4,2,1]];
console.log(minPathSum(grid));
```



----

## **BM69** **把数字翻译成字符串**

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

#### 动态规划

```js
/**
 * @param {number} num
 * @return {number}
 */
var translateNum = function(num) {
    num = num.toString();
    let p = 0, q = 0, r = 1;
    let n = num.length;
    for (let i = 0; i < n; i++) {
        p = q;
        q = r;
        r = q;
        if (i === 0) {
            continue;
        }
        let pre = num.substring(i - 1, i + 1);
        if (num[i - 1] !== "0" && Number(pre) < 26 && Number(pre) >= 0) {
            r += p;
        }
    }
    return r;
};

let num = 12258;
console.log(translateNum(num));
```



有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。

我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。

由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 'a' 也可以看做是一个 'k' 。但 10 只可能是 'j' ，因为 0 不能编译成任何结果。

现在给一串数字，返回有多少种可能的译码结果

```js
/**
 * @param {number} num
 * @return {number}
 */
var translateNum = function(num) {
    num = num.toString();
    const n = num.length;
    if (n === 0 || num[0] === "0") {
        return 0;
    }

    let p = 0, q = 0, r = 1;
    const dp = new Array(n).fill(1);

    if (num[1] !== "0" && Number(num[0] + num[1]) <= 26) {
        dp[1] = 2;
    }

    for (let i = 2; i < n; i++) {
        if (num[i] === "0") {
            if (num[i - 1] === "0") {
                // 连续两个0，或者0前面的数大于2则无法解码0的部分
                return 0;
            } else if (num[i - 1] <= '2') {
                //对应10和20的情况
                dp[i] = dp[i - 2];
            } else {
                return 0;
            }
        } else {
            if (num[i - 1] === '0') {
                dp[i] = dp[i - 1];
            } else if (Number(num[i -1] + num[i]) <= 26) {
                dp[i] = dp[i - 1] + dp[i - 2];
            } else {
                dp[i] = dp[i - 1];
            }
        }
    }
    // console.log(dp)
    return dp[n - 1];
};

let num = 120258;
console.log(translateNum(num));
```



-----

## **BM70** **兑换零钱(一)**

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

#### 动态规划

将问题转化为背包问题解决。

因为每种硬币可以使用无数次，所以可以转化为完全背包问题。

确定dp数组的定义。dp[i]表示凑成总金额i的硬币个数。

确定递推公式。得到dp[j]就只有当前总金额j减去当前硬币面额coins[i]的硬币数dp[j - coins[i]]，再加1表示用上coins[i]。dp[j]就要在dp[j - coins[i]] + 1中选一个最小的，所以递推公式为min(dp[j - coins[i]] + 1, dp[j])。

确定初始化方式。因为要找最小值，所以除dp[0]初始化为0以外，其余初始化为最大值。

确定遍历方式。因为与硬币排列方式无关，所以可以选择先遍历硬币，再遍历背包。且因为是完全背包，每种硬币可以使用无数次，所以内层循环为正序。

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
	if (amount === 0) {
		return 0;
	}
	const dp = new Array(amount + 1).fill(Infinity);
	dp[0] = 0;
	const n = coins.length;
	for (let i = 0; i < coins.length; i++) {
		for (let j = coins[i]; j <= amount; j++) {
			dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);
		}
	}

	return dp[amount] === Infinity ? -1 : dp[amount];
}
```

复杂度分析

时间复杂度：O(Sn)O(Sn)，其中 SS 是金额，nn 是面额数。我们一共需要计算 O(S)O(S) 个状态，SS 为题目所给的总金额。对于每个状态，每次需要枚举 nn 个面额来转移状态，所以一共需要 O(Sn)O(Sn) 的时间复杂度。
空间复杂度：O(S)O(S)。数组 \textit{dp}dp 需要开长度为总金额 SS 的空间。



----

## **BM71** **最长上升子序列(一)**

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?



#### 动态规划

![最长上升子序列动态规划](E:\pogject\学习笔记\image\niuke\最长上升子序列动态规划.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
	if (nums.length === 0) {
		return 0;
	}
	const n = nums.length;
	const dp = new Array(n).fill(1);

	let ans = 1;
	for (let i = 1; i < n; i++) {
		for (let j = 0; j < i; j++) {
			if (nums[j] < nums[i]) {
				dp[i] = Math.max(dp[i], dp[j] + 1);
			}
		}
		ans = Math.max(ans, dp[i]);
	}
	return ans;
};

let nums = [10,9,2,5,3,7,101,18];
console.log(lengthOfLIS(nums))

```



#### 贪心 + 二分查找

![最长上升子序列贪心二分查找](E:\pogject\学习笔记\image\niuke\最长上升子序列贪心二分查找.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
	if (nums.length === 0) {
		return 0;
	}
	const n = nums.length;
	const dp = new Array(n + 1).fill(0);
	let len = 1;
	dp[len] = nums[0];

	for (let i = 1; i < n; i++) {
		if (nums[i] > dp[len]) {
			dp[++len] = nums[i];
		} else {
			// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
			let left = 1, right = len, pos = 0;
			while (left <= right) {
				const mid = (left + right) >> 1;
				if (dp[mid] < nums[i]) {
					pos = mid;
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
			dp[pos + 1] = nums[i];
		}
	}
	return len;
};

let nums = [10,9,2,5,3,7,101,18];
console.log(lengthOfLIS(nums))

```

时间复杂度：O(n\log n)O(nlogn)。数组 \textit{nums}nums 的长度为 nn，我们依次用数组中的元素去更新 dd 数组，而更新 dd 数组时需要进行 O(\log n)O(logn) 的二分搜索，所以总时间复杂度为 O(n\log n)O(nlogn)。

空间复杂度：O(n)O(n)，需要额外使用长度为 nn 的 dd 数组。



----

## **BM72** **连续子数组的最大和**

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。空间复杂度为(1)

#### 动态规划

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let ans = nums[0];
    let sum = nums[0];
    let n = nums.length;
    for (let i = 1; i < n; i++) {
        sum = Math.max(sum + nums[i], nums[i]);
        ans = Math.max(ans, sum);
    }
    return ans;
};
```



#### 分治



```js
function Status(l, r, m, i) {
    this.lSum = l;
    this.rSum = r;
    this.mSum = m;
    this.iSum = i;
}

const pushUp = (l, r) => {
    const iSum = l.iSum + r.iSum;
    const lSum = Math.max(l.lSum, l.iSum + r.lSum);
    const rSum = Math.max(r.rSum, r.iSum + l.rSum);
    const mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
    return new Status(lSum, rSum, mSum, iSum);
}

const getInfo = (a, l, r) => {
    if (l === r) {
        return new Status(a[l], a[l], a[l], a[l]);
    }
    const m = (l + r) >> 1;
    const lSub = getInfo(a, l, m);
    const rSub = getInfo(a, m + 1, r);
    return pushUp(lSub, rSub);
}

var maxSubArray = function(nums) {
    return getInfo(nums, 0, nums.length - 1).mSum;
};


```



----

## **BM73** **最长回文子串**

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

进阶: 空间复杂度 O(n)，时间复杂度 O(n)

#### 动态规划

![最长回文子串(动态规划)](E:\pogject\学习笔记\image\leetcode\最长回文子串(动态规划).png)

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param A string字符串 
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome  =  function(s) {
    const n = s.length;
    if (n < 2) {
        return s;
    }

    let maxLen = 1;
    let begin = 0;
    const dp = new Array(n).fill(0).map(() => new Array(n).fill(false));
    //dp[i][j] 表示 s[i..j] 是否是回文串
    for (let i = 0; i < n; i++){
        /// 初始化：所有长度为 1 的子串都是回文串
        dp[i][i] = true;
    }

    // 递推开始, 先枚举子串长度
    for(let L = 2; L <= n; L++){
        // 枚举左边界，左边界的上限设置可以宽松一些
        for(let i = 0; i < n; i++){
            // 由 L 和 i 可以确定右边界，即 j - i + 1  =  L 得
            let j = L + i - 1;
            if (j >= n) {
                // 如果右边界越界，就可以退出当前循环
                break;
            }
            if (s[i] !== s[j]) {
                dp[i][j] = false;
            } else {
                if (j - i < 3) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }
            // 只要 dp[i][L]  =  =  true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
            if (dp[i][j] && j - i + 1 > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }

    return s.slice(begin, begin + maxLen);
};
```



#### 中心扩展算法

![最长回文子串(中心扩展算法)](E:\pogject\学习笔记\image\leetcode\最长回文子串(中心扩展算法).png)

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let n = s.length;
    if (n < 2) {
        return s;
    }

    let start = 0,end = 0;
    let len1, len2, len;
    for (let i = 0; i < n; i++){
        len1 = expandAroundCenter(s, i, i);
        len2 = expandAroundCenter(s, i, i + 1);
        len = Math.max(len1, len2);
        console.log(start, end);
        if (len > end - start) {
            start = i - Math.floor((len - 1) / 2);
            end = i + Math.floor(len / 2);
        }
    }
    return s.slice(start, end + 1);
};

var expandAroundCenter=function(s, left, right){
    while(left >= 0 && right < s.length && s[left] === s[right]){
        left--;
        right++;
    }
    return right - left - 1;
}


let str1 = "cbbd";
let result=longestPalindrome(str1);
console.log(result);
```

复杂度分析

时间复杂度：O(n^2)O(n 2 )，其中 nn 是字符串的长度。长度为 11 和 22 的回文中心分别有 nn 和 n-1n−1 个，每个回文中心最多会向外扩展 O(n)O(n) 次。

空间复杂度：O(1)O(1)。



#### Manacher 算法

https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/

```java
class Solution {
    public String longestPalindrome(String s) {
        int start = 0, end = -1;
        StringBuffer t = new StringBuffer("#");
        for (int i = 0; i < s.length(); ++i) {
            t.append(s.charAt(i));
            t.append('#');
        }
        t.append('#');
        s = t.toString();

        List<Integer> arm_len = new ArrayList<Integer>();
        int right = -1, j = -1;
        for (int i = 0; i < s.length(); ++i) {
            int cur_arm_len;
            if (right >= i) {
                int i_sym = j * 2 - i;
                int min_arm_len = Math.min(arm_len.get(i_sym), right - i);
                cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);
            } else {
                cur_arm_len = expand(s, i, i);
            }
            arm_len.add(cur_arm_len);
            if (i + cur_arm_len > right) {
                j = i;
                right = i + cur_arm_len;
            }
            if (cur_arm_len * 2 + 1 > end - start) {
                start = i - cur_arm_len;
                end = i + cur_arm_len;
            }
        }

        StringBuffer ans = new StringBuffer();
        for (int i = start; i <= end; ++i) {
            if (s.charAt(i) != '#') {
                ans.append(s.charAt(i));
            }
        }
        return ans.toString();
    }

    public int expand(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return (right - left - 2) / 2;
    }
}

```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是字符串的长度。由于对于每个位置，扩展要么从当前的最右侧臂长 right 开始，要么只会进行一步，而 right 最多向前走 O(n)O(n) 步，因此算法的复杂度为 O(n)O(n)。

空间复杂度：O(n)O(n)，我们需要 O(n)O(n) 的空间记录每个位置的臂长。



----

## **BM74** **数字字符串转化成IP地址**

给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。



#### 回溯

由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用回溯的方法，对所有可能的字符串分隔方式进行搜索，并筛选出满足要求的作为答案。

设题目中给出的字符串为 ss。我们用递归函数 \textit{dfs}(\textit{segId}, \textit{segStart})dfs(segId,segStart) 表示我们正在从 s[\textit{segStart}]s[segStart] 的位置开始，搜索 IP 地址中的第 \textit{segId}segId 段，其中 \textit{segId} \in \{0, 1, 2, 3\}segId∈{0,1,2,3}。由于 IP 地址的每一段必须是 [0, 255][0,255] 中的整数，因此我们从 \textit{segStart}segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 \textit{segEnd}segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 \textit{dfs}(\textit{segId} + 1, \textit{segEnd} + 1)dfs(segId+1,segEnd+1)。

特别地，由于 IP 地址的每一段不能有前导零，因此如果 s[\textit{segStart}]s[segStart] 等于字符 00，那么 IP 地址的第 \textit{segId}segId 段只能为 00，需要作为特殊情况进行考虑。

在搜索的过程中，如果我们已经得到了全部的 44 段 IP 地址（即 \textit{segId} = 4segId=4），并且遍历完了整个字符串（即 \textit{segStart} = |s|segStart=∣s∣，其中 |s|∣s∣ 表示字符串 ss 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  const n = s.length;
  const SEG_COUNT = 4;
  const segments = new Array(SEG_COUNT);

  const ans = [];

  const dfs = (s, segId, segStart) => {
    // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
    if (segId === SEG_COUNT) {
      if (segStart === n) {
        ans.push(segments.join("."));
      }
      return;
    }

    // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
    if (segStart === n) {
      return;
    }

    // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
    if (s[segStart] === "0") {
      segments[segId] = 0;
      dfs(s, segId + 1, segStart + 1);
    }

    // 一般情况，枚举每一种可能性并递归
    let addr = 0;
    for (let segEnd = segStart; segEnd < n; segEnd++) {
      addr = addr * 10 + (s[segEnd] - '0');
      if (addr > 0 && addr <= 255) {
        segments[segId] = addr;
        dfs(s, segId + 1, segEnd + 1);
      } else {
        break;
      }
    }
  }

  dfs(s, 0, 0);
  return ans;
};

let s = "25525511135";
console.log(restoreIpAddresses(s));
```





----

## **BM75** **编辑距离(一)**

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成



#### 动态规划

编辑距离算法被数据科学家广泛应用，是用作机器翻译和语音识别评价标准的基本算法。

最直观的方法是暴力检查所有可能的编辑方法，取最短的一个。所有可能的编辑方法达到指数级，但我们不需要进行这么多计算，因为我们只需要找到距离最短的序列而不是所有可能的序列。

我们可以对任意一个单词进行三种操作：

- 插入一个字符；

- 删除一个字符；

- 替换一个字符。


题目给定了两个单词，设为 A 和 B，这样我们就能够六种操作方法。

但我们可以发现，如果我们有单词 A 和单词 B：

- 对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；

- 同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；

- 对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -> c，和修改单词 B 的第一个字母 c -> b 是等价的。


这样以来，本质不同的操作实际上只有三种：

- 在单词 A 中插入一个字符；

- 在单词 B 中插入一个字符；

- 修改单词 A 的一个字符。


这样以来，我们就可以把原问题转化为规模较小的子问题。

我们用 A = horse，B = ros 作为例子，来看一看是如何把这个问题转化为规模较小的若干子问题的。

- 在单词 A 中插入一个字符：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串；

- 在单词 B 中插入一个字符：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上；

- 修改单词 A 的一个字符：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。


那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。

注意：为什么我们总是在单词 A 和 B 的末尾插入或者修改字符，能不能在其它的地方进行操作呢？答案是可以的，但是我们知道，操作的顺序是不影响最终的结果的。例如对于单词 cat，我们希望在 c 和 a 之间添加字符 d 并且将字符 t 修改为字符 b，那么这两个操作无论为什么顺序，都会得到最终的结果 cdab。

你可能觉得 horse 到 ro 这个问题也很难解决。但是没关系，我们可以继续用上面的方法拆分这个问题，对于这个问题拆分出来的所有子问题，我们也可以继续拆分，直到：

- 字符串 A 为空，如从 转换到 ro，显然编辑距离为字符串 B 的长度，这里是 2；

- 字符串 B 为空，如从 horse 转换到 ，显然编辑距离为字符串 A 的长度，这里是 5。


因此，我们就可以使用动态规划来解决这个问题了。我们用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。

如上所述，当我们获得 D[i][j-1]，D[i-1][j] 和 D[i-1][j-1] 的值之后就可以计算出 D[i][j]。

- D[i][j-1] 为 A 的前 i 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i][j-1] + 1；

- D[i-1][j] 为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题。即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i-1][j] + 1；

- D[i-1][j-1] 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么 D[i][j] 最小可以为 D[i-1][j-1] + 1。特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，D[i][j] 最小可以为 D[i-1][j-1]。


那么我们可以写出如下的状态转移方程：

若 A 和 B 的最后一个字母相同：

```js

D[i][j] = min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1]) = 1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)
```

 

若 A 和 B 的最后一个字母不同：

```js
D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])
```

对于边界情况，一个空串和一个非空串的编辑距离为 D[i][0] = i 和 D[0][j] = j，D[i][0] 相当于对 word1 执行 i 次删除操作，D[0][j] 相当于对 word1执行 j 次插入操作。

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
  const n = word1.length, m = word2.length;

  // 有一个字符串为空串
  if (m * n === 0) {
    return m + n;
  }

  const dp = new Array(n + 1).fill(0).map(() => new Array(m + 1));

  // 边界状态初始化
  for (let i = 0; i < n + 1; i++) {
    dp[i][0] = i;
  }
  for (let i = 0; i < m + 1; i++) {
    dp[0][i] = i;
  }

  // 计算所有 DP 值
  for (let i = 1; i < n + 1; i++) {
    for (let j = 1; j < m + 1; j++) {
      let left = dp[i - 1][j] + 1;
      let down = dp[i][j - 1] + 1;
      let left_down = dp[i - 1][j - 1];
      if (word1[i - 1] !== word2[j - 1]) {
        left_down += 1;
      }
      dp[i][j] = Math.min(left, down, left_down);
    }
  }
  return dp[n][m];
};

let word1 = "intention", word2 = "execution";
console.log(minDistance(word1, word2));
```

复杂度分析

时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。

空间复杂度 ：O(mn)，我们需要大小为 O(mn) 的 D 数组来记录状态值。



----

## **BM76** **正则表达式匹配**

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。



提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 只包含从 a-z 的小写字母。
p 只包含从 a-z 的小写字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符



#### 直接调用正则方法

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    return new RegExp("^"+p+"$").test(s);
};
```



#### 动态规划

[题解](https://leetcode.cn/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/)

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  const m = s.length, n = p.length;
  const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(false));
  dp[0][0] = true;

  for (let i = 0; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (p[j - 1] === "*") {
        dp[i][j] = dp[i][j - 2];
        if (matches(s, p, i, j - 1)) {
          dp[i][j] = dp[i][j] || dp[i - 1][j];
        }
      } else {
        if (matches(s, p, i, j)) {
          dp[i][j] = dp[i - 1][j - 1];
        }
      }
    }
  }
  return dp[m][n]
};

const matches = (s, p, i, j) => {
  if (i === 0) {
    return false;
  }
  if (p[j - 1] === ".") {
    return true;
  }
  return s[i - 1] === p[j - 1];
}

let s = "ab", p = ".*";
console.log(isMatch(s, p));
```





----

## **BM77** **最长的括号子串**

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`



#### 动态规划

![有效括号子串动态规划](D:\project\学习笔记\image\niuke\有效括号子串动态规划.png)

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  if (s.length < 2) {
    return 0;
  }
  const n = s.length;
  let ans = 0;
  const dp = new Array(n).fill(0);
  for (let i = 1; i < n; i++) {
    if (s[i] === ")") {
      if (s[i - 1] === "(") {
        dp[i] = (i >= 2 ? dp[i - 2] : 0 ) + 2;
      } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] === "(") {
        dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
      }
      ans = Math.max(ans, dp[i]);
    }
  }
  return ans;
};

let s = ")()())";
console.log(longestValidParentheses(s));
```



#### 栈

撇开方法一提及的动态规划方法，相信大多数人对于这题的第一直觉是找到每个可能的子串后判断它的有效性，但这样的时间复杂度会达到 O(n^3)，无法通过所有测试用例。但是通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。

具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

- 对于遇到的每个 ‘(’ ，我们将它的下标放入栈中

- 对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：
- - 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
  - 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」

我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  if (s.length < 2) {
    return 0;
  }
  const n = s.length;
  let ans = 0;
  const stack = [-1];
  for (let i = 0; i < n; i++) {
    if (s[i] === "(") {
      stack.push(i);
    } else {
      stack.pop();
      if (stack.length === 0) {
        stack.push(i);
      } else {
        ans = Math.max(ans, i - stack[stack.length - 1]);
      }
    }
  }
  return ans;
};

let s = ")()())";
console.log(longestValidParentheses(s));
```



#### 不需要额外的空间

在此方法中，我们利用两个计数器 \textit{left}left 和 \textit{right}right 。首先，我们从左到右遍历字符串，对于遇到的每个 \text{‘(’}‘(’，我们增加 \textit{left}left 计数器，对于遇到的每个 \text{‘)’}‘)’ ，我们增加 \textit{right}right 计数器。每当 \textit{left}left 计数器与 \textit{right}right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 \textit{right}right 计数器比 \textit{left}left 计数器大时，我们将 \textit{left}left 和 \textit{right}right 计数器同时变回 00。

这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。

解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：

当 \textit{left}left 计数器比 \textit{right}right 计数器大时，我们将 \textit{left}left 和 \textit{right}right 计数器同时变回 00
当 \textit{left}left 计数器与 \textit{right}right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串
这样我们就能涵盖所有情况从而求解出答案。

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  if (s.length < 2) {
    return 0;
  }
  const n = s.length;
  let ans = 0;
  let left = 0, right = 0;

  for (let i = 0; i < n; i++) {
    if (s[i] === "(") {
      left++;
    } else {
      right++;
    }
    if (left === right) {
      ans = Math.max(ans, 2 * right);
    } else if (right > left) {
      left = right = 0;
    }
  }
  left = right = 0;
  for (let i = n - 1; i > 0; i--) {
    if (s[i] === "(") {
      left++;
    } else {
      right++;
    }
    if (left === right) {
      ans = Math.max(ans, 2 * left);
    } else if (right < left) {
      left = right = 0;
    }
  }
  return ans;
};

let s = ")()())";
console.log(longestValidParentheses(s));
```

- 时间复杂度： O(n)*O*(*n*)，其中 n*n* 为字符串长度。我们只要正反遍历两边字符串即可。
- 空间复杂度： O(1)*O*(1)。我们只需要常数空间存放若干变量。





----

## **BM78** **打家劫舍(一)**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

#### 动态规划

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let p = 0;
  let q = nums[0];
  const n = nums.length;
  let r = nums;;
  for (let i = 1; i < n; i++) {
    r = Math.max(p + nums[i], q);
    p = q;
    q = r;
  }
  return r;
};

let nums = [2,7,9,3,1];
console.log(rob(nums));
```



----

## **BM79** **打家劫舍(二)**

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

#### 动态规划

首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。

注意到当房屋数量不超过两间时，最多只能偷窃一间房屋，因此不需要考虑首尾相连的问题。如果房屋数量大于两间，就必须考虑首尾相连的问题，第一间房屋和最后一间房屋不能同时偷窃。

如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。

假设数组 \textit{nums}nums 的长度为 nn。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0, n-2][0,n−2]；如果不偷窃第一间房屋，则偷窃房屋的下标范围是 [1, n-1][1,n−1]。在确定偷窃房屋的下标范围之后，即可用第 198 题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在 nn 间房屋中可以偷窃到的最高总金额。



```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  const n = nums.length;
  if (n === 1) {
    return nums[0];
  } else if (n === 2) {
    return Math.max(nums[0], nums[1]);
  } else {
    return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
  }
};

const robRange = (nums, start, end) => {
  let first = nums[start], second = Math.max(nums[start], nums[start + 1]);
  for (let i = start + 2; i <= end; i++) {
    const temp = second;
    second = Math.max(first + nums[i], second);
    first = temp;
  }
  return second;
}

let nums = [2,7,9,3,1];
console.log(rob(nums));
```







----

## 337. 打家劫舍 III

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

#### 动态规划

简化一下这个问题：一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。

我们可以用 f(o)f(o) 表示选择 oo 节点的情况下，oo 节点的子树上被选择的节点的最大权值和；g(o)g(o) 表示不选择 oo 节点的情况下，oo 节点的子树上被选择的节点的最大权值和；ll 和 rr 代表 oo 的左右孩子。

当 oo 被选中时，oo 的左右孩子都不能被选中，故 oo 被选中情况下子树上被选中点的最大权值和为 ll 和 rr 不被选中的最大权值和相加，即 f(o) = g(l) + g(r)f(o)=g(l)+g(r)。
当 oo 不被选中时，oo 的左右孩子可以被选中，也可以不被选中。对于 oo 的某个具体的孩子 xx，它对 oo 的贡献是 xx 被选中和不被选中情况下权值和的较大值。故 g(o) = \max \{ f(l) , g(l)\}+\max\{ f(r) , g(r) \}g(o)=max{f(l),g(l)}+max{f(r),g(r)}。
至此，我们可以用哈希表来存 ff 和 gg 的函数值，用深度优先搜索的办法后序遍历这棵二叉树，我们就可以得到每一个节点的 ff 和 gg。根节点的 ff 和 gg 的最大值就是我们要找的答案。

```js
var rob = function(root) {
    const f = new Map();
    const g = new Map();

    const dfs = (node) => {
        if (node === null) {
            return;
        }
        dfs(node.left);
        dfs(node.right);
        f.set(node, node.val + (g.get(node.left) || 0) + (g.get(node.right) || 0));
        g.set(node, Math.max(f.get(node.left) || 0, g.get(node.left) || 0) + Math.max(f.get(node.right) || 0, g.get(node.right) || 0));
    }
    
    dfs(root);
    return Math.max(f.get(root) || 0, g.get(root) || 0);
};

```

假设二叉树的节点个数为 nn。

我们可以看出，以上的算法对二叉树做了一次后序遍历，时间复杂度是 O(n)O(n)；由于递归会使用到栈空间，空间代价是 O(n)O(n)，哈希表的空间代价也是 O(n)O(n)，故空间复杂度也是 O(n)O(n)。

我们可以做一个小小的优化，我们发现无论是 f(o)f(o) 还是 g(o)g(o)，他们最终的值只和 f(l)f(l)、g(l)g(l)、f(r)f(r)、g(r)g(r) 有关，所以对于每个节点，我们只关心它的孩子节点们的 ff 和 gg 是多少。我们可以设计一个结构，表示某个节点的 ff 和 gg 值，在每次递归返回的时候，都把这个点对应的 ff 和 gg 返回给上一级调用，这样可以省去哈希表的空间。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  const dfs = (node) => {
    if (node === null) {
      return [0, 0];
    }
    const l = dfs(node.left);
    const r = dfs(node.right);
    const selected = node.val + l[1] + r[1];
    const notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
    return [selected, notSelected];
  }

  const rootStatus = dfs(root);
  return Math.max(rootStatus[0], rootStatus[1]);
};
```

复杂度分析

时间复杂度：O(n)O(n)。上文中已分析。

空间复杂度：O(n)O(n)。虽然优化过的版本省去了哈希表的空间，但是栈空间的使用代价依旧是 O(n)O(n)，故空间复杂度不变。



----

## **BM80** **买卖股票的最好时机(一)**

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

#### 一次遍历

显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。

因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  const n = prices.length;
  if (n < 2) {
    return 0;
  }
  let minP = prices[0];
  let ans = 0;
  for (let i = 1; i < n; i++) {
    if (prices[i] < minP) {
      minP = prices[i];
    } else if (prices[i] - minP > ans) {
      ans = prices[i] - minP;
    }
  }
  return ans;
};
```



----

## **BM81** **买卖股票的最好时机(二)**

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

#### 动态规划

![股票交易2动态规划](D:\project\学习笔记\image\niuke\股票交易2动态规划.png)

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  const n = prices.length;
  if (n < 2) {
    return 0;
  }
  const dp = new Array(n).fill(0).map(() => new Array(2).fill(0));
  dp[0][0] = 0, dp[0][1] = -prices[0];
  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
  }
  return dp[n - 1][0];
};
```

注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 \textit{dp}[i-1][0]dp[i−1][0] 和 \textit{dp}[i-1][1]dp[i−1][1] 存放在两个变量中，通过它们计算出 \textit{dp}[i][0]dp[i][0] 和 \textit{dp}[i][1]dp[i][1] 并存回对应的变量，以便于第 i+1i+1 天的状态转移即可。

```js
var maxProfit = function(prices) {
    const n = prices.length;
    let dp0 = 0, dp1 = -prices[0];
    for (let i = 1; i < n; ++i) {
        let newDp0 = Math.max(dp0, dp1 + prices[i]);
        let newDp1 = Math.max(dp1, dp0 - prices[i]);
        dp0 = newDp0;
        dp1 = newDp1;
    }
    return dp0;
};
```



#### 贪心

![股票交易2贪心](D:\project\学习笔记\image\niuke\股票交易2贪心.png)

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let ans = 0;
  const n = prices.length;
  for (let i = 1; i < n; i++) {
    ans += Math.max(0, prices[i] - prices[i - 1]);
  }
  return ans;
};
```



----

## **BM82** **买卖股票的最好时机(三)**

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

#### 动态规划

由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：

- 未进行过任何操作；

- 只进行过一次买操作；

- 进行了一次买操作和一次卖操作，即完成了一笔交易；

- 在完成了一笔交易的前提下，进行了第二次买操作；

- 完成了全部两笔交易。


作者：LeetCode-Solution
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  const n = prices.length;
  let buy1 = -prices[0], buy2 = -prices[0];
  let sell1 = 0, sell2= 0;
  for (let i = 1; i < n; i++) {
    buy1 = Math.max(buy1, -prices[i]);
    sell1 = Math.max(sell1, buy1 + prices[i]);
    buy2 = Math.max(buy2, sell1 - prices[i]);
    sell2 = Math.max(sell2, buy2 + prices[i]);
  }
  return sell2;
};

let prices = [3,3,5,0,0,3,1,4];
console.log(maxProfit(prices));
```



-----

## 188. 买卖股票的最佳时机 IV

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 与其余的股票问题类似，我们使用一系列变量存储「买入」的状态，再用一系列变量存储「卖出」的状态，通过动态规划的方法即可解决本题。

我们用 \textit{buy}[i][j]buy[i][j] 表示对于数组 \textit{prices}[0..i]prices[0..i] 中的价格而言，进行恰好 jj 笔交易，并且当前手上持有一支股票，这种情况下的最大利润；用 \textit{sell}[i][j]sell[i][j] 表示恰好进行 jj 笔交易，并且当前手上不持有股票，这种情况下的最大利润。

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp/

```js
var maxProfit = function(k, prices) {
    if (!prices.length) {
        return 0;
    }

    const n = prices.length;
    k = Math.min(k, Math.floor(n / 2));
    const buy = new Array(n).fill(0).map(() => new Array(k + 1).fill(0));
    const sell = new Array(n).fill(0).map(() => new Array(k + 1).fill(0));

    buy[0][0] = -prices[0];
    sell[0][0] = 0;
    for (let i = 1; i <= k; ++i) {
        buy[0][i] = sell[0][i] = -Number.MAX_VALUE;
    }

    for (let i = 1; i < n; ++i) {
        buy[i][0] = Math.max(buy[i - 1][0], sell[i - 1][0] - prices[i]);
        for (let j = 1; j <= k; ++j) {
            buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j] - prices[i]);
            sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);   
        }
    }

    return Math.max(...sell[n - 1]);
};


```



----

## **BM83** **字符串变形**

对于一个长度为 n 字符串，我们需要对它做一些变形。

首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。

比如"Hello World"变形后就变成了"wORLD hELLO"。

数据范围: 1\le n \le 10^61≤*n*≤106 , 字符串中包括大写英文字母、小写英文字母、空格。

进阶：空间复杂度 O(n)*O*(*n*) ， 时间复杂度 O(n)*O*(*n*)

```js
function trans(s, n){
    //write code here
    s = s.split(" ").reverse();
    const m = s.length;
    const ans = [];
    for (let i = 0; i < m; i++) {
        for (let ch of s[i]) {
            if(/[a-z]/.test(ch)) {
                ans.push(ch.toUpperCase());
            } else {
                ans.push(ch.toLowerCase());
            }
        }
        if (i < m - 1) {
            ans.push(" ");
        }
    }
    return ans.join("")
}

module.exports = {
    trans : trans
}
```



----

## **BM84** **最长公共前缀**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

#### 纵向扫描

```js
/**
  * 
  * @param strs string字符串一维数组 
  * @return string字符串
  */
function longestCommonPrefix( strs ) {
    // write code here
    if (strs.length < 1) {
        return "";
    }
    const len = strs[0].length;
    const n = strs.length;
    for (let i = 0; i < len; i++) {
        for (let j = 1; j < n; j++) {
            if (i === strs[j].length || strs[j][i] !== strs[0][i]) {
                return strs[0].substring(0, i);
            }
        }
    }
    return strs[0];
}
module.exports = {
    longestCommonPrefix : longestCommonPrefix
};
```



#### 二分查找

显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 \textit{minLength}minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,\textit{minLength}][0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值 \textit{mid}mid，判断每个字符串的长度为 \textit{mid}mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 \textit{mid}mid，如果不相同则最长公共前缀的长度一定小于 \textit{mid}mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        int minLength = Integer.MAX_VALUE;
        for (String str : strs) {
            minLength = Math.min(minLength, str.length());
        }
        int low = 0, high = minLength;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (isCommonPrefix(strs, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return strs[0].substring(0, low);
    }

    public boolean isCommonPrefix(String[] strs, int length) {
        String str0 = strs[0].substring(0, length);
        int count = strs.length;
        for (int i = 1; i < count; i++) {
            String str = strs[i];
            for (int j = 0; j < length; j++) {
                if (str0.charAt(j) != str.charAt(j)) {
                    return false;
                }
            }
        }
        return true;
    }
}

```





-----

**BM85** **验证IP地址**

给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 "IPv4" ；如果是有效的 IPv6 地址，返回 "IPv6" ；如果不是上述类型的 IP 地址，返回 "Neither" 。

有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 <= xi <= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。

一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:

1 <= xi.length <= 4
xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。
在 xi 中允许前导零。
例如 "2001:0db8:85a3:0000:0000:8a2e:0370:7334" 和 "2001:db8:85a3:0:0:8A2E:0370:7334" 是有效的 IPv6 地址，而 "2001:0db8:85a3::8A2E:037j:7334" 和 "02001:0db8:85a3:0000:0000:8a2e:0370:7334" 是无效的 IPv6 地址。

我们首先查找给定的字符串 \textit{queryIP}queryIP 中是否包含符号 \text{`.'}‘.’。如果包含，那么我们需要判断其是否为 IPv4 地址；如果不包含，我们则判断其是否为 IPv6 地址。

```js
var validIPAddress = function(queryIP) {
    if (queryIP.indexOf('.') >= 0) {
        // IPv4
        let last = -1;
        for (let i = 0; i < 4; ++i) {
            const cur = (i === 3 ? queryIP.length : queryIP.indexOf('.', last + 1));
            if (cur < 0) {
                return "Neither";
            }
            if (cur - last - 1 < 1 || cur - last - 1 > 3) {
                return "Neither";
            }
            let addr = 0;
            for (let j = last + 1; j < cur; ++j) {
                if (!isDigit(queryIP[j])) {
                    return "Neither";
                }
                addr = addr * 10 + (queryIP[j].charCodeAt() - '0'.charCodeAt());
            }
            if (addr > 255) {
                return "Neither";
            }
            if (addr > 0 && queryIP[last + 1].charCodeAt() === '0'.charCodeAt()) {
                return "Neither";
            }
            if (addr === 0 && cur - last - 1 > 1) {
                return "Neither";
            }
            last = cur;
        }
        return "IPv4";
    } else {
        // IPv6
        let last = -1;
        for (let i = 0; i < 8; ++i) {
            const cur = (i === 7 ? queryIP.length : queryIP.indexOf(':', last + 1));
            if (cur < 0) {
                return "Neither";
            }
            if (cur - last - 1 < 1 || cur - last - 1 > 4) {
                return "Neither";
            }
            for (let j = last + 1; j < cur; ++j) {
                if (!isDigit(queryIP[j]) && !('a' <= queryIP[j].toLowerCase() && queryIP[j].toLowerCase() <= 'f')) {
                    return "Neither";
                }
            }
            last = cur;
        }
        return "IPv6";
    }
};

const isDigit = (ch) => {
    return parseFloat(ch).toString() === "NaN" ? false : true;
}

```



----

## **BM86** **大数加法**

以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。

数据范围：s.length,t.length ≤100000，字符串仅由'0'~‘9’构成

要求：时间复杂度 O(n)



```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算两个数之和
 * @param s string字符串 表示第一个整数
 * @param t string字符串 表示第二个整数
 * @return string字符串
 */
function solve( s ,  t ) {
    // write code here
    let ans = [];

    s = s.split("").reverse();
    t = t.split("").reverse();
    if (s.length > t.length) {
    //确保s是短的一个数字
    [s, t] = [t, s];
    }
    const n = s.length;
    const m = t.length;

    let ret = 0;
    let sum = 0;
    for (let i = 0; i < m; i++) {
        let a = 0;
        if (i < n) {
            a = Number(s[i]);
        }
        let b = Number(t[i]);
        sum = a + b + ret;
        ret = sum > 9 ? 1 : 0;
        sum %= 10;
        ans .unshift(sum);
    }
    if (ret > 0) {
        ans.unshift(1);
    }

    return ans.join("");
}
// let s = "9", t = "99999999999999999999999999999999999999999999999999999999999994";
// console.log(solve(s, t));

module.exports = {
    solve : solve
};
```





---

## **BM87** **合并两个有序的数组**

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。



#### 逆向双指针

可以指针设置为从后向前遍历，每次取两者之中的较大者放进 nums1 的最后面。

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    let cur;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 === -1) {
            cur = nums2[p2--];
        } else if (p2 === -1) {
            cur = nums1[p1--];
        } else if (nums1[p1] > nums2[p2]) {
            cur = nums1[p1--];
        } else {
            cur = nums2[p2--];
        }
        nums1[tail--] = cur;
    }
};
```





----

## **BM88** **判断是否为回文字符串**

给定一个字符串 `s` ，验证 `s` 是否是 **回文串** ，只考虑字母和数字字符，可以忽略字母的大小写。

本题中，将空字符串定义为有效的 **回文串** 。

####  双指针

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 
 * @param str string字符串 待判断的字符串
 * @return bool布尔型
 */
function judge( str ) {
    // write code here
    let left = 0, right = str.length - 1;
    while (left < right) {
        if (str[left++] !== str[right--]) {
            return false;
        }
    }
    return true;
}
module.exports = {
    judge : judge
};
```



----

## **BM89** **合并区间**

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。



#### 排序

如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。

区间集合，要将重叠区间合并，需要排序，以便找到重叠区间。

对于区间集合进行排序有两个选择，对于左边界或者右边界进行排序。

排序后，找重叠部分，对于左边界进行排序，如果一个区间的右边界大于等于下一个区间的左边界，表明这两个区间有重叠部分，要将前一个区间的右边界拓宽，选择这两个区间中较大的右边界。

如果一个区间的右边界小于下一个区间的左边界，这两个区间没有重叠，将前一个区间加入结果集合中。

遍历结束后还要将最后一个区间加入结果集合中。



```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length < 1) {
        return [];
    }
    intervals.sort((a, b) => a[0] - b[0]);

    const ans = [intervals[0]];
    const n = intervals.length;
    let j = 0;

    for (let i = 1; i < n; i++) {
        if (ans[j][1] < intervals[i][0]) {
            ans.push(intervals[i]);
            j++;
        } else {
            ans[j][1] = Math.max(ans[j][1], intervals[i][1]);
        }
    }
    return ans;
};

let intervals = [[1,3],[2,6],[8,10],[15,18]];
console.log(merge(intervals));
```



----

## **BM90** **最小覆盖子串**

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

#### 滑动窗口

本问题要求我们返回字符串 ss 中包含字符串 tt 的全部字符的最小窗口。我们称包含 tt 的全部字母的窗口为「可行」窗口。

我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 rr 指针，和一个用于「收缩」窗口的 ll 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 ss 上滑动窗口，通过移动 rr 指针不断扩张窗口。当窗口包含 tt 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

如何判断当前的窗口包含所有 tt 所需的字符呢？我们可以用一个哈希表表示 tt 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 tt 的哈希表中的所有字符，并且对应的个数都不小于 tt 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。

处理右指针：
1.新建左指针，右指针
2.将输入t的所有字符存入，map中
3.建立循环，直到右指针到s字符串长度结束
4.逐位移动右指针
5.如果need中有当前右指针的字符，need中当前右指针字符对应的value - 1
6.如果当前右指针字符对应的value === 0 needType -= 1
7.当needType === 0时候说明已经找到符合要求的子串开始处理左指针

以上处理完右指针，开始处理左指针：
1.建立循环，直到needType === 0
2.逐位移动左指针
3.如果need中有当前左指针的字符，need中当前左指针字符对应的value + 1
4.并且，need中当前右指针字符对应的value === 1时，needType +=1 退出左指针循环，到外层右指针循环中

以上左右指针都处理好后：
1.在左指针循环中，通过左右指针作为下标获得子串
2.比较所得子串的length,最终得到最小子串

注意：对need.size的缓存变量needType是，重要标志
1.从右指针循环中，needType === 0说明找到符合要求的子串
2.从左指针循环中，needType !== 0说明移动左指针后的子串中不符合要求了，并且把当前缺少的左指针字符对应的value + 1
3.重复的在1和2两种情况中切换最终得到所有符合条件的子串



```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    let l = 0
    let r = 0
    const need = new Map()
    for(let c of t){
        need.set( c, need.has(c) ? need.get(c) + 1 : 1)
    }

    let needType = need.size
    let res = ''
    while(r < s.length){
        let c = s[r]
        if(need.has(c)){
            need.set( c,need.get(c) -1 )
            if( need.get(c) === 0) needType -= 1
        }
        
        while(needType === 0){
            const newRes = s.substring(l,r+1)
            if( !res || newRes.length < res.length ) res = newRes

            const c2 = s[l]
            if(need.has(c2)){
                need.set(c2,need.get(c2) + 1)
                if( need.get(c2) === 1 ) needType += 1
            }
            l += 1
        }
        r += 1
    }
    return res
};


let s = "ADOBECODEBANC", t = "ABC";
console.log(minWindow(s, t));
```



-----

## **BM91** **反转字符串**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```js
/**
 * 反转字符串
 * @param str string字符串 
 * @return string字符串
 */
function solve( str ) {
    // write code here
    str = str.split("");
    let left = 0, right = str.length - 1;
    while (left < right) {
        [str[left], str[right]] = [str[right], str[left]];
        left++;
        right--;
    }
    return str.join("")
}
module.exports = {
    solve : solve
};
```



----

## **BM92** **最长无重复子数组**

给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。

子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组



```js
/**
 * 
 * @param arr int整型一维数组 the array
 * @return int整型
 */
function maxLength( arr ) {
    // write code here
    if (arr.length < 2) {
        return arr.length;
    }
    let ans = 0;
    const n = arr.length;
    const m = new Map();
    let left = 0;
    m.set(arr[0], 0);

    for (let i = 1; i < n; i++) {
        if (m.has(arr[i])) {
            ans = Math.max(i - left, ans);
            if (m.get(arr[i]) >= left) {
                left = m.get(arr[i]) + 1;
            }
        }
        // console.log(left)
        m.set(arr[i], i);
    }
    ans = Math.max(n - left, ans);
    return ans;
}

let arr = [9,9];
console.log(maxLength(arr))

// module.exports = {
//     maxLength : maxLength
// };
```





----

## **BM93** **盛水最多的容器**

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

#### 双指针

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param height int整型一维数组 
 * @return int整型
 */
function maxArea( height ) {
    // write code here
    if (height < 2) {
        return 0;
    }
    let left = 0, right = height.length - 1;
    let ans = 0;
    while (left < right) {
        let area = Math.min(height[left], height[right]) * (right - left);
        ans = Math.max(ans, area);
        if (height[left] <= height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return ans;
}
module.exports = {
    maxArea : maxArea
};
```



----

## **BM94** **接雨水问题**

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

https://leetcode.cn/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/

#### **动态规划方法**

找到当前位置左右比两边最大的高度，然后用小的一个高度减当前高度就是当前位置能接到的雨水量

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    //动态规划方法
    let n = height.length;
    let leftMax = new Array(n);
    let rightMax = new Array(n);

    leftMax[0] = height[0];
    rightMax[n - 1] = height[n - 1];

    for (let i = 1; i < n; i++) {
        leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        rightMax[n - 1 - i] = Math.max(rightMax[n - i], height[n - 1 - i]);
    }

    let ans = 0;
    for (let i = 0; i < n; i++) {
        ans += Math.min(leftMax[i], rightMax[i]) - height[i];
    }
    return ans;
};

let height = [0,1,0,2,1,0,1,3,2,1,2,1];
console.log(trap(height));
```

#### **单调栈**

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let ans = 0;
    const stack = [];  // 单调栈存储索引
    const n = height.length;

    for (let i = 0; i < n; i++) {
        while (stack.length && height[i] > height[stack[stack.length - 1]]) {
            const top = stack.pop();
            if (!stack.length) {
                break;
            }
            const left = stack[stack.length - 1];
            const currWidth = i - left - 1;
            const currHeight = Math.min(height[left], height[i]) - height[top];
            ans += currWidth * currHeight;
        }
        stack.push(i);
    }
    return ans;
};

let height = [0,1,0,2,1,0,1,3,2,1,2,1];
console.log(trap(height));
```



#### 双指针

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let ans = 0;
    let left = 0, right = height.length - 1;
    let leftMax = 0, rightMax = 0;

    while (left < right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);
        if (height[left] < height[right]) {
            ans += leftMax - height[left];
            left++;
        } else {
            ans += rightMax - height[right];
            right--;
        }
    }
    return ans;
};
```



----

## **BM95** **分糖果问题**

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 1 个糖果。

- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。



#### 两次遍历

我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。

左规则：当 ratings[i−1]<ratings[i] 时，ii 号学生的糖果数量将比 i - 1i−1 号孩子的糖果数量多。

右规则：当 ratings[i]>ratings[i+1] 时，ii 号学生的糖果数量将比 i + 1i+1 号孩子的糖果数量多。

我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。

具体地，以左规则为例：我们从左到右遍历该数组，假设当前遍历到位置 ii，如果有 \textit{ratings}[i - 1] < \textit{ratings}[i]ratings[i−1]<ratings[i] 那么 ii 号学生的糖果数量将比 i - 1i−1 号孩子的糖果数量多，我们令 \textit{left}[i] = \textit{left}[i - 1] + 1left[i]=left[i−1]+1 即可，否则我们令 \textit{left}[i] = 1left[i]=1。

在实际代码中，我们先计算出左规则 \textit{left}left 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。

```js
/**
 * @param {number[]} ratings
 * @return {number}
 */
var candy = function(ratings) {
    const n = ratings.length;
    const left = new Array(n).fill(0);

    for (let i = 0; i < n; i++) {
        if (i > 0 && ratings[i] > ratings[i - 1]) {
            left[i] = left[i - 1] + 1;
        } else {
            left[i] = 1;
        }
    }

    let right = 0, ans = 0;
    for (let i = n - 1; i > -1; i--) {
        if (i < n - 1 && ratings[i] > ratings[i + 1]) {
            right++;
        } else {
            right = 1;
        }
        ans += Math.max(left[i], right);
    }
    return ans;
};
```



#### 常数空间遍历

依据前面总结的规律，我们可以提出本题的解法。我们从左到右枚举每一个同学，记前一个同学分得的糖果数量为 \textit{pre}pre：

如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 \textit{pre} + 1pre+1 个糖果即可。

否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。

我们无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量。

同时注意当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中。

这样，我们只要记录当前递减序列的长度 \textit{dec}dec，最近的递增序列的长度 \textit{inc}inc 和前一个同学分得的糖果数量 \textit{pre}pre 即可。

```js
/**
 * @param {number[]} ratings
 * @return {number}
 */
var candy = function(ratings) {
    const n = ratings.length;
    let ans = 1;
    let inc = 1, dec = 0, pre = 1;

    for (let i = 1; i < n; i++) {
        if (ratings[i] >= ratings[i - 1]) {
            dec = 0;
            if (ratings[i] === ratings[i - 1]) {
                pre = 1;
            } else {
                pre++;
            }
            ans += pre;
            inc = pre;
        } else {
            dec++;
            if (dec === inc) {
                dec++;
            }
            ans += dec;
            pre = 1;
        }
    }
    return ans;
};

let ratings = [1,2,2];
console.log(candy(ratings));
```



-----

## **BM96** **主持人调度（二）**

有 n 个活动即将举办，每个活动都有开始时间与活动的结束时间，第 i 个活动的开始时间是 starti ,第 i 个活动的结束时间是 endi ,举办某个活动就需要为该活动准备一个活动主持人。

一位活动主持人在同一时间只能参与一个活动。并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第 i 个活动，那么该主持人在 (starti,endi) 这个时间段不能参与其他任何活动。求为了成功举办这 n 个活动，最少需要多少名主持人。

数据范围: 1 \le n \le 10^51≤*n*≤105 ， -2^{32} \le start_i\le end_i \le 2^{31}-1−232≤*s**t**a**r**t**i*≤*e**n**d**i*≤231−1

复杂度要求：时间复杂度 O(n \log n)*O*(*n*log*n*) ，空间复杂度 O(n)*O*(*n*)

#### 贪心思想

贪心思想属于动态规划思想中的一种，其基本原理是找出整体当中给的每个局部子结构的最优解，并且最终将所有的这些局部最优解结合起来形成整体上的一个最优解。

**思路：**

我们利用贪心思想，什么时候需要的主持人最少？那肯定是所有的区间没有重叠，每个区间首和上一个的区间尾都没有相交的情况，我们就可以让同一位主持人不辞辛劳，一直主持了。但是题目肯定不是这种理想的情况，那我们需要对交叉部分，判断需要增加多少位主持人。

**具体做法：**

- step 1: 利用辅助数组获取单独各个活动开始的时间和结束时间，然后分别开始时间和结束时间进行排序，方便后面判断是否相交。
- step 2: 遍历nn*n*个活动，如果某个活动开始的时间大于之前活动结束的时候，当前主持人就够了，活动结束时间往后一个。
- step 3: 若是出现之前活动结束时间晚于当前活动开始时间的，则需要增加主持人。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 计算成功举办活动需要多少名主持人
 * @param n int整型 有n个活动
 * @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间
 * @return int整型
 */
function minmumNumberOfHost( n ,  startEnd ) {
    // write code here
    const start = new Array(n);
    const end = new Array(n);

    //分别得到活动起始时间
    for (let i = 0; i < n; i++) {
        start[i] = startEnd[i][0];
        end[i] = startEnd[i][1];
    }
    // 排序
    start.sort((a, b) => a - b);
    end.sort((a, b) => a - b);

    let ans = 0;
    let j = 0;
    for (let i = 0; i < n; i++) {
        //新开始的节目大于上一轮结束的时间，主持人不变
        if (start[i] >= end[j]) {
            j++;
        } else {
            // 主持人增加
            ans++;
        }
    }
    return ans;
}

// let n = 2, startEnd = [[1,3],[2,4]];
// console.log(minmumNumberOfHost(n, startEnd));

module.exports = {
    minmumNumberOfHost : minmumNumberOfHost
};
```



----

## **BM97** **旋转数组**

一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M >=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

数据范围：0 < n \le 1000<*n*≤100，0 \le m \le 10000≤*m*≤1000

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

**题目主要信息:**

- 一个长度为nn*n*的数组，将数组整体循环右移mm*m*个位置（mm*m*可能大于nn*n*）
- 循环右移即最后mm*m*个元素放在数组最前面，前n−mn-m*n*−*m*个元素依次后移
- 不能使用额外的数组空间

#### 三次翻转

循环右移相当于从第m个位置开始，左右两部分视作整体翻转。即abcdefg右移3位efgabcd可以看成AB翻转成BA（这里小写字母看成数组元素，大写字母看成整体）。既然是翻转我们就可以用到reverse函数。

**具体做法:**

- step 1：因为m可能大于n，因此需要对n取余，因为每次长度为n的旋转数组相当于没有变化。
- step 2：第一次将整个数组翻转，得到数组的逆序，它已经满足了右移的整体出现在了左边。
- step 3：第二次就将左边的m个元素单独翻转，因为它虽然移到了左边，但是逆序了。
- step 4：第三次就将右边的n−m个元素单独翻转，因此这部分也逆序了。

```js
/**
 * 旋转数组
 * @param n int整型 数组长度
 * @param m int整型 右移距离
 * @param a int整型一维数组 给定数组
 * @return int整型一维数组
 */
function solve( n ,  m ,  a ) {
    if (n < 2 || m === 0) {
        return a;
    }
    //取余，因为每次长度为n的旋转数组相当于没有变化
    m = m % n;
    //第一次逆转全部数组元素
    reverse(a, 0, n - 1);
    //第二次只逆转开头m个
    reverse(a, 0, m - 1);
    //第三次只逆转结尾m个
    reverse(a, m, n - 1);

    return a;
}

const reverse = (arr, start, end) => {
    while (start < end) {
        [arr[start], arr[end]] = [arr[end], arr[start]];
        start++;
        end--;
    }
}

// let nums = [1,2,3,4,5,6];
// console.log(solve(6, 2, nums));

module.exports = {
    solve : solve
};
```



-----

## **BM98** **螺旋矩阵**

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

#### 按层模拟

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 k*k* 层是到最近边界距离为 k*k* 的所有顶点。

对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (\textit{top}, \textit{left})(top,left)，右下角位于 (\textit{bottom}, \textit{right})(bottom,right)，按照如下顺序遍历当前层的元素。

从左到右遍历上侧元素，依次为 (\textit{top}, \textit{left})(top,left) 到 (\textit{top}, \textit{right})(top,right)。

从上到下遍历右侧元素，依次为 (\textit{top} + 1, \textit{right})(top+1,right) 到 (\textit{bottom}, \textit{right})(bottom,right)。

如果 \textit{left} < \textit{right}left<right 且 \textit{top} < \textit{bottom}top<bottom，则从右到左遍历下侧元素，依次为 (\textit{bottom}, \textit{right} - 1)(bottom,right−1) 到 (\textit{bottom}, \textit{left} + 1)(bottom,left+1)，以及从下到上遍历左侧元素，依次为 (\textit{bottom}, \textit{left})(bottom,left) 到 (\textit{top} + 1, \textit{left})(top+1,left)。

遍历完当前层的元素之后，将 \textit{left}left 和 \textit{top}top 分别增加 11，将 \textit{right}right 和 \textit{bottom}bottom 分别减少 11，进入下一层继续遍历，直到遍历完所有元素为止。

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length) {
        return [];
    }

    const m = matrix.length, n = matrix[0].length;
    const order = [];

    let left = 0, right = n - 1, top = 0, bottom = m - 1;
    while (left <= right && top <= bottom) {
        for (let col = left; col <= right; col++) {
            order.push(matrix[top][col]);  // 从左到右
        }
        for (let row = top + 1; row <= bottom; row++) {
            order.push(matrix[row][right]);  // 从上到下
        }
        if (left < right && top < bottom) {
            for (let col = right - 1; col > left; col--) {
                order.push(matrix[bottom][col]);  // 从右到左
            }
            for (let row = bottom; row > top; row--) {
                order.push(matrix[row][left]);  // 从下到上
            }
        }
        [left, right, top, bottom] = [left + 1, right - 1, top + 1, bottom - 1];
    }

    return order;
};

let matrix = [[1,2,3],[4,5,6],[7,8,9]];
console.log(spiralOrder(matrix));
```

时间复杂度：O(mn)O(mn)，其中 mm 和 nn 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。

空间复杂度：O(1)O(1)。除了输出数组以外，空间复杂度是常数。



----

## **BM99** **顺时针旋转矩阵**

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

#### 原地旋转

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    const n = matrix.length;
    for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = 0; j < Math.floor((n + 1) / 2); j++) {
            const temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
    return matrix;
};

let matrix = [[1,2,3],[4,5,6],[7,8,9]];
console.log(rotate(matrix));
```



#### 用翻转代替旋转

```js
var rotate = function(matrix) {
    const n = matrix.length;
    // 水平翻转
    for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = 0; j < n; j++) {
            [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];
        }
    }
    // 主对角线翻转
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
};

```



----

## **BM100** **设计LRU缓存结构**

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。

实现 LRUCache 类：

- LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
- void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

#### 哈希表 

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.capacity = capacity;
    this.map = new Map();
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (this.map.has(key)) {
        let value = this.map.get(key);
        // 重新set，相当于更新到 map最后
        this.map.delete(key);
        this.map.set(key, value);
        return value;
    }
    return -1;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    // 如果有，就删了再赋值
    if (this.map.has(key)) {
        this.map.delete(key);
    }
    this.map.set(key, value);
    // 判断是不是容量超了，淘汰机制
    if (this.map.size > this.capacity) {
        this.map.delete(this.map.keys().next().value);
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```



----

## **BM101** **设计LFU缓存结构**

请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

实现 LFUCache 类：

- LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
- int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。
- void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。

为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

#### 双哈希表

```js
/**
 * @param {number} capacity
 */
var LFUCache = function(capacity) {
    this.capacity = capacity;
    // 缓存存储
    this.values = new Map();  // key:value
    this.times = new Map();  // key:次数

    // 找到当前次数最小的 key
    // useMap 更新的逻辑，其实 vue 的响应式依赖管理很像
    this.useMap = new Map();  // 次数：set(key)
    this.min = 0;  // 最小次数是多少
};

LFUCache.prototype.updateContent = function(key) {
    let time = this.times.get(key);
    let useSet = this.useMap.get(time);

    if (this.min === time && useSet.size === 1) {
        //当前次数是最小值 并且 这个次数set集合只有一个 key
        this.min += 1;
    }
    time += 1;
    useSet.delete(key);
    useSet = this.useMap.get(time) || new Set();
    useSet.add(key);

    this.useMap.set(time, useSet);
    this.times.set(key, time);
};

/** 
 * @param {number} key
 * @return {number}
 */
LFUCache.prototype.get = function(key) {
    if (this.values.has(key)) {
        // 更新计数
        this.updateContent(key);
        return this.values.get(key);
    }
    return -1;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LFUCache.prototype.put = function(key, value) {
    // 缓存空间为 0，不操作
    if (this.capacity === 0) {
        return;
    }
    if (this.values.has(key)) {
        // key值存在，不需要淘汰
        this.values.set(key, value);
        this.updateContent(key);
    } else {
        // key值不存在，判断是否超过缓存 size 
        if (this.capacity === this.values.size) {
            // 满了需要淘汰掉 次数最少的、最长时间未访问的
            let minSet = this.useMap.get(this.min);
            let minKey = minSet.keys().next().value;
            minSet.delete(minKey);
            this.values.delete(minKey);
            this.times.delete(minKey);
        }

        // 加入缓存
        this.values.set(key, value);
        // 这个数据出现了 1 次
        let useSet = this.useMap.get(1) || new Set();
        useSet.add(key);
        this.useMap.set(1, useSet);
        this.times.set(key, 1);
        this.min = 1;
    }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * var obj = new LFUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```





----

