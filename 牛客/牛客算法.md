-----

## **NC1** **大数加法**

以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。

数据范围：len(s),len(t) <= 100000，字符串仅由'0'~‘9’构成

要求：时间复杂度 O(n)*O*(*n*)

```
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 计算两个数之和
 * @param s string字符串 表示第一个整数
 * @param t string字符串 表示第二个整数
 * @return string字符串
 */
function solve( s ,  t ) {
    // write code here
    return ""+(Number(s)+Number(t));
}
module.exports = {
    solve : solve
};
```

涉及大数加法

-----

## **NC65** **斐波那契数列**

大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。

要求：空间复杂度 O*(1)，时间复杂度 O*(*n*) ，本题也有时间复杂度 O(logn) 的解法

```js
function Fibonacci(n){
    // write code here
    if (n===1 || n===2) {
        return 1;
    }
    let i=3;
    let f1=1;
    let f2=1;
    let f3=0;
    while(i<=n){
        f3=f1+f2;
        f1=f2;
        f2=f3;
        i++;
    }
    return f3;
    //return Fibonacci(n-1)+Fibonacci(n-2)
}
module.exports = {
    Fibonacci : Fibonacci
};
```

```

```

-----

## **NC78** **反转链表**

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0\leq n\leq10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead){
    if (pHead == null) {
    	return pHead;
    }
    let prev = null;
    let curr = pHead;
    while (curr){
    	let next = curr.next;  //当前结点的后继
    	curr.next = prev;  //将当前节点的 next 指针改为指向前一个节点
    	prev = curr;  //先存储其前一个节点
    	curr = next;  //存储后一个节点
    }
    return prev;
}
module.exports = {
    ReverseList : ReverseList
};
```

---

**NC93** **设计LRU缓存结构**

设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:
\1. Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
\2. get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。
\3. set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value

提示:
1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。
2.当缓存的大小超过capacity时，移除最不经常使用的记录。
3.返回的value都以字符串形式表达，如果是set，则会输出"null"来表示(不需要用户返回，系统会自动输出)，方便观察
4.函数set和get必须以O(1)的方式运行
5.为了方便区分缓存里key与value，下面说明的缓存里key用""号包裹

```

```



----

## **NC103** **反转字符串**

写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）

```javascript
/**
 * 反转字符串
 * @param str string字符串 
 * @return string字符串
 */
function solve( str ) {
    // write code here
    //return str.split("").reverse().join("");
    let newStr="";
    for (let i=str.length-1;i>=0;i--){
        newStr+=str[i];
    }
    return newStr;
}
module.exports = {
    solve : solve
};
```

----

## **NC140** **排序**

给定一个长度为 n 的数组，请你编写一个函数，返回该数组按升序排序后的结果。

要求：时间复杂度 O(n^2)，空间复杂度 O*(*n*)

进阶：时间复杂度 O(nlogn)，空间复杂度 O*(*n*)

注：本题数据范围允许绝大部分排序算法，请尝试多种排序算法的实现。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 将给定数组排序
 * @param arr int整型一维数组 待排序的数组
 * @return int整型一维数组
 */
function MySort( arr ) {
    // 快速排序
    if (arr.length < 2) {
    	return arr;
    }
    const left = [];
    const right = [];
    let randomIndex = Math.floor(Math.random() * arr.length);
    let pivot = arr[randomIndex];  //随机选一个基准
    for (let i = 0; i < arr.length; i++){
    	if (arr[i] < pivot) {
    		left.push(arr[i]);
    	}else{
    		right.push(arr[i]);
    	}
    }

    return MySort(left).concat(MySort(right));

}

module.exports = {
    MySort : MySort
};
```

