# js部分



## js数组API

filter是过滤出符合条件的元素。

every是检测数组是否所有元素都满足条件。

some是检测数组是否有满足条件的元素。

map是遍历数组，且对每个元素进行操作。

## Symbol

Symbol为ES6新增的基本数据类型，表示独一无二的值。
**Symbol()函数会返回symbol类型的值，每个从Symbol()返回的symbol值都是唯一的。**
*Symbol.for() 返回由给定的 key 找到的 symbol，否则就是返回新创建的 symbol*

Symbol类型属于ES6中新增的基本数据类型之一，**内部没有construtor构造器，不能使用new关键字创建**

## jS目前共有八种数据类型

基本数据类型七种:(string,number,boolean,null,undefined,  es6后新增symbol bigint)

引用数据类型: 一种 （object） 包含array，function,Date,RegExp..等引用类型

## Math.round(）

Math.round(）函数返回一个数字四舍五入后最接近的整数

如果参数的小数部分大于0.5，四舍五入到相邻的绝对值更大的整数

如果参数的小数部分小于0.5，四舍五入到相邻的绝对值更小的整数

如果参数的小数部分等于0.5，四舍五入到相邻的在正无穷（+∞）方向上的整数。

例：

```js
x=Math.round(2019.49) ;   //2019
x=Math.round(2019.5);     //2020
x=Math.round(-2019.5);    //-2019
x=Math.round(-2019.51);   //-2020
```

math.round() 方法，原来的数字加上0.5，再向下取整 

## start&&end的返回值

&& 运算，如果前面值为true,则结果为后面的值。如果前面值为false,则值为false.

|| 运算，如果前面值为true,则结果为前面的值,如果前面的值为false,则结果为后面的值。

start&&end
start 如果为true 则直接返回end的值
start如果为false 则不管end为什么直接返回false



## 关于AngularJS

```
前端mvc，极大降低前端开发的耦合
Angular大大减少了对DOM的访问。
实现了数据双向绑定
```

jQuery极大的丰富了DOM操作

### 依赖注入

**依赖注入（Dependency Injection），是这样一个过程：由于某客户类只依赖于服务类的一个接口，而不依赖于具体服务类，所以客户类只定义一个注入点。在程序** 运行过程**中，客户类不直接实例化具体服务类实例，而是客户类的运行上下文环境或专门组件负责实例化服务类，然后将其注入到客户类中，保证客户类的正常运行。**

## call/apply

call/apply用来改变函数的执行上下文（this），它们的第一个参数thisArg是个对象，即作为函数内的this。有两种情况需要注意，**传null或undefined时，将是JS执行环境的全局变量**。浏览器中是window，其它环境（如node）则是global。

## +运算符

+运算符作为二元运算符时，有两个功能 数字相加连接字符串 数字相加没啥好说的，连接字符串时，会先把两个参数都转换成字符串再进行连接。 

+作为一元运算符时，会将参数转换为数字返回 

-运算符，输出一个转换后的负数

# HTML部分

## label标签

**html5规范不允许加id，但是浏览器厂商却实现了这个功能,**

label标签只有两个属性

for（ 规定 label 绑定到哪个表单元素。 ）

form（规定 label 字段所属的一个或多个表单）

## SVG与Canvas的区别

```
 SVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 
 
Canvas 通过 JavaScript 来绘制 2D 图形。 Canvas 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 

Canvas 与 SVG 的比较 下表列出了 canvas 与 SVG 之间的一些不同之处。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用
```





# css部分

## css3新增特性

```tex
1、CSS3选择器 2、CSS3边框(Borders) 3、CSS3背景 4、CSS3渐变 5、CSS3文本效果 6、CSS3字体(@font-face规则) 7、CSS3转换和变形 1）2D转换方法 2）3D转换属性 8、CSS3过度（transition属性） 9、CSS3动画（@keyframes规则 animation属性） 10、CSS3多列 11、CSS3盒模型 12、CSS3伸缩布局盒模型(弹性盒子)（flexbox） 13、CSS3多媒体查询（@media）
```

## 预编译 CSS 工具

**CSS 预处理器**是一个能让你通过预处理器自己独有的语法来生成[CSS](https://developer.mozilla.org/zh-CN/docs/Glossary/CSS)的程序。市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性，例如代码混合，嵌套选择器，继承选择器等。这些特性让CSS的结构更加具有可读性且易于维护。

要使用CSS预处理器，你必须在web服务中服务器安装CSS编译工具。

这里是一些最流行的CSS预处理器:

- [Sass](https://sass-lang.com/)
- [LESS](https://lesscss.org/)
- [Stylus](http://stylus-lang.com/)
- [PostCSS](http://postcss.org/)

## Background-position属性

```
Background-position属性

用处：配合background-image属性一起使用，用于设置背景图片在盒子中的位置

参数：xpos ypos |x% y% |x y三种,

如果只写第一个水平方向的参数，第二个垂直方向的参数会默认为：

center|50%|容器高度的一半px

Xpos：规定水平方向的对齐方式,值有left,right,center

Ypos：规定垂直方向的对齐方式,值有top,bottom,center

x%:规定图片水平方向的距离。
你会不会以为这个x%就是父级容器宽度的x%？那你就想错了哦，这里的x%指的是父级容器的宽度减去图片的宽度后的差值的x%。
举个栗子：background-position：50%，20%；
图片的宽度为     imgwidth：100px；高度为     imgheight：100px；
容器的宽度为     conwidth：200px；高度为     conheight：200px；
那么此时图片的左顶点距离容器的左顶点的水平距离就是(conwidth-imgwidth)*50%=50px,而不是conwidth*50%=100px；(很好理解的吧，不然盒子宽度200px，图片宽度100px，又距离左边100px，岂不是50%没实现水平居中而紧靠右了吗？)
由此也可以算出图片的左顶点距离容器的左顶点的垂直距离为20px
y%:对应x%

x:图片距离容器水平方向距离

y:图片距离容器垂直方向距离
```

