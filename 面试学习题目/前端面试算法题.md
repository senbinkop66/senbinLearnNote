   

----

## 2.1 树 找到某节点的路径

查找某个节点的路径的方法通常有两种，一种是递归算法,另一种是非递归算法

### 1.定义树节点和构建树

```js
//定义树结点
function TreeNode(val,left,right){
	this.val = (val === undefined ? 0 : val);
	this.left = (left === undefined ? null : left);
	this.right = (right === undefined ? null : right);
}

//构建树
let root=new TreeNode(1);
root.left=new TreeNode(2);
root.right=new TreeNode(3);
root.left.left=new TreeNode(4);
root.right.right=new TreeNode(5);

//console.log(root);
```

### **2.递归算法**

```js
// 递归中序遍历二叉树
function midOrder(root){
	if (!root || !(root instanceof TreeNode)) {
		return;
	}
	//递归访问左子树
	midOrder(root.left);
	console.log(root.val);
	//递归访问右子树
	midOrder(root.right);
}

midOrder(root);
```

### **3非递归算法**

```js
//非递归中序遍历二叉树
function midOrder(root){
	if (!root || !(root instanceof TreeNode)) {
		return;
	}
	let arr=[];  //arr作为栈
	let p=root;  //p为当前遍历的节点， 初始为根
	while(p || arr.length!==0){
		if (p) {
			//遍历左子树
			arr.push(p);
			p=p.left;   //每遇到非空二叉树先向左走
		}else{
			// p为空，出栈
			let node=arr.pop();
			console.log(node.val);  //访问该结点
			p=node.right;  // 访问该结点的右子树
		}
	}
}

midOrder(root);
```

### **4.迭代方法**

```js
//迭代中序遍历二叉树
function midOrderTraversal(root){
	if (!root || !(root instanceof TreeNode)) {
		return;
	}
	let ans=[];
	let arr=[root];
	while(arr.length!==0){
		let node=arr[arr.length-1];
		if (!node.left || (node.left && node.left.isOk)) {
			//左子树访问了
			arr.pop();
			node.isOk=true;
			console.log(node.val);
			if (node.right) {
				arr.push(node.right);
			}
		}else if(node.left && !node.left.isOk){
			//左子树没有访问
			arr.push(node.left);
		}
	}

}

midOrderTraversal(root);
```



----

## 2.2 洗完牌抽5张判断是否为同花顺

题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2-10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成任意数字。

思路一:

我们需要把扑克牌的背景抽象成计算机语言。不难想象，我们可以把5张牌看成由5个数字组成的数组。大小王是特殊的数字，我们不妨把它们都当成0，这样和其他扑克牌代表的数字就不重复了。接下来我们来分析怎样判断5个数字是不是连续的。最直观的是，我们把数组排序。但值得注意的是，由于0可以当成任意数字，我们可以用0去补满数组中的空缺。也就是排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但如果我们有足够的0可以补满这两个数字的空缺，这个数组实际上还是连续的。举个例子，数组排序之后为{0，1，3，4，5}。在1和3之间空缺了一个2，刚好我们有一个0，也就是我们可以它当成2去填补这个空缺。

于是我们需要做三件事情：把数组排序，统计数组中0的个数，统计排序之后的数组相邻数字之间的空缺总数。如果空缺的总数小于或者等于0的个数，那么这个数组就是连续的；反之则不连续。最后，我们还需要注意的是，如果数组中的非0数字重复出现，则该数组不是连续的。换成扑克牌的描述方式，就是如果一副牌里含有对子，则不可能是顺子。

```

```

思路二:

1）确认5张牌中除了0，其余数字没有重复的（可以用表统计的方法）;

2）满足这样的逻辑：（max，min分别代表5张牌中的除0以外的最大值最小值）

 如果没有0，则max-min=4，则为顺子，否则不是

 如果有一个0，则max-min=4或者3，则为顺子，否则不是

 如果有两个0，则max-min=4或者3或者2，则为顺子，否则不是最大值和最小值在1）中就可以获得，这样就 不用排序了

```

```

---

## 2.3 爬楼梯 编代码

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意**：**给定 *n* 是一个正整数。

方法分析：

这道题主要是要明白该爬楼梯的规律其实就是符合斐波那契数列（Fibonacci Sequence） 规律的，问题就迎刃而解了。为什么说它是斐波那契数列呢？我们可以这样来思考：当我们从第 n-1 阶楼梯爬到第 n 阶楼梯时，需要1步；当我们从第 n-2 阶楼梯爬到第 n 阶楼梯时，需要2步.也就是说 到达第 n 阶楼梯的方法数等于到达第 n-1 阶楼梯的方法数加上到达第 n-2 阶楼梯的方法数，其正好符合斐波那契通项。

### **1.采用递归实现**

递归是求解斐波那契数列最经典和最直接的方式，其简洁易懂；但是递归特别费时，在该题中使用会出现[超出时间限制]的错误提示。

```js
function climbStairs(n){
	if (n===1) {
		return 1;
	}
	if (n===2) {
		return 2;
	}
	return climbStairs(n-1)+climbStairs(n-2);
}

let n=10;
console.log(climbStairs(n));  //89
```

### **2.数组方式**

数组方式大大的减少了运行时间，我们先预设好前两项，再得到结果，返回数组最后一项即可。

```js
function climbStairs(n){
	const result=[1,2];
	for (let i=2; i<n; i++){
		result.push(result[i-1]+result[i-2]);
	}
	return result[n-1];
}

let n=10;
console.log(climbStairs(n));  //89
```

### **3.ES6的方式**

```js
function climbStairs(n){
	let a=b=1;
	for (let i=0; i<n; i++){
		[a,b]=[b,a+b];
	}
	return a;
}

let n=10;
console.log(climbStairs(n));  //89
```

其中 [a, b] = [b, a + b] 表示解构赋值，其等价于

```js
temp = a;
a = b;
b = temp + b;
```

---

## 2.4 怎么识别100枚硬币中的假币

**问题描述：**
在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，但不知道假币与真币相比较轻还是较重。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币(**以下提供两种方法**)。

**解题思路1 (本例为真币重量大于假币)：**
使用减治法的解题思路，将硬币分为3堆，则每堆的硬币数量为 n/3 ，但是这是在 n%3==0 的情况下才能成立，所以我们将 n 枚硬币分为 3 堆加 1 堆 余数堆(余数堆可能为0)，则可分为如下(n-n%3)/3, (n-n%3)/3, (n-n%3)/3, n%3。
**如下分组：**
a堆： (n-n%3)/3
b堆： (n-n%3)/3
c堆： (n-n%3)/3
d(余数堆): n%3
**逻辑流程：**

1. 判断n中的硬币数量，如果n>2则执行2，否则执行5.
2. 将n分为上图的四堆，拿 a 和 b 比较，如果 a == b ,则 假币在 c 或 d 中。否则假币在 a 或 b 中。
3. 如果 a == b，则拿 a 和 c 比较。如果 a == c,则假币在d(余数堆)中。将 d 再次 执行流程1，并且n=n%3。如果不等，则假币在 c 中，将 c 再次 执行流程1，并且n=(n-n%3)/3。
4. 如果 a != b，则拿 a 和 c 比较。如果 a == c,则假币在b中，将 b 再次 执行流程1，并且n=(n-n%3)/3。如果不等，则假币在 a 中，将 a 再次 执行流程 1，并且n=(n-n%3)/3。
5. 如果n==2，则将两枚硬币进行比较找出假币。
6. 如果n==1，则该硬币就是假币，输出结果结束。

**解题思路2（以12枚硬币为例，且假币未知轻重）：**

1. 将硬币编号：1，2，3，4，5，6，7，8，9，10，11，12。三次称重如下安排：
2. 称重：
   第一次称重：左盘：1，2，3，4 右盘：5，6，7，8 其他：9，10，11，12
   第二次称重：左盘：1，6，7，8 右盘：5，10，11，12 其他：9，2，3，4
   第三次称重：左盘：5，6，10，2 右盘：9，7，11，3 其他：1，8，12，4
   称重结果：平衡取0，左倾取1，右倾取-1。
   3次称重安排可表示成矩阵形式：

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/1605692726(1).png)
其中，矩阵第一行是硬币序号，下面每一行都是一次称重结果，1表示该硬币放左盘，-1表示放右盘，0表示不放。矩阵每一列为检测结果，检测结果对应的硬币序号为假币。如果结果与上边的符合，则对应重量为重，如果结果不包含在上述表中，则进行1 -1互换，得到的重量为轻。例如：若称重结果是110，则1号为假币，且重量较重：若称重结果为1-10，1与-1进行交换后为-110，则8号为假币，且重量较轻。

---

## 2.5 快排算法

思想：

1. 在数据集之中，选择一个元素作为"基准"（pivot）。
2. 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
3. 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

实现：

```js
function quickSort(nums){
	if (nums.length<=1){
		return nums;
	}
	let pivotIndex = Math.floor(nums.length / 2);
	let pivot = nums.splice(pivotIndex,1)[0];  //基准值
	const left = [];
	const right = [];
	for (let i = 0; i < nums.length; i++){
		if (nums[i] < pivot) {
			left.push(nums[i]);
		}else{
			right.push(nums[i]);
		}
	}
	return quickSort(left).concat([pivot],quickSort(right));
}

let test=[1,3,4,5,6,2,3,1,5,8];
console.log(quickSort(test));  //
```

----

## 2.6 常见的排序算法和它们的时间复杂度是多少？

**参考答案**：

|          稳定的排序          |            时间复杂度            | 空间复杂度 |
| :--------------------------: | :------------------------------: | :--------: |
|    冒泡排序(bubble sort)     | 最差、平均都是O(n^2)，最好是O(n) |     1      |
|   插入排序(insertion sort)   | 最差、平均都是O(n^2)，最好是O(n) |     1      |
|     归并排序(merge sort)     |  最差、平均、最好都是O(n log n)  |    O(n)    |
|     桶排序(bucket sort)      |               O(n)               |    O(k)    |
|     基数排序(Radix sort)     |         O(nk)（k是常数）         |    O(n)    |
| 二叉树排序(Binary tree sort) |            O(n log n)            |    O(n)    |

|       不稳定的排序       |           时间复杂度           | 空间复杂度 |
| :----------------------: | :----------------------------: | :--------: |
| 选择排序(selection sort) |      最差、平均都是O(n^2)      |     1      |
|   希尔排序(shell sort)   |           O(n log n)           |     1      |
|     堆排序(heapsort)     | 最差、平均、最好都是O(n log n) |     1      |
|   快速排序(quicksort)    | 平均是O(n log n)，最差是O(n^2) |  O(log n)  |



---

## 2.7 说一下归并排序思想怎么实现的

“归并”的意思是将两个或两个以上的有序表组合成一个新的有序表。假如初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（向上取整）个长度为2或1的有序子序列；再两两归并，……，如此重复，直到得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。

步骤解析：

1、把长度为n的输入序列分成两个长度为n/2的子序列；

2、对这两个子序列继续分为m/2的子序列，一直分下去，直为1个元素；

3、将两个排序好的子序列合并成一个最终的排序序列。

特点：

速度仅次于快速排序，为稳定排序算法，一般用于总体无序，但是各子项相对有序的数列，属于分治思想，递归归并。

动图演示：

![img](https://static.nowcoder.com/images/activity/2021jxy/front/images/20180502102359525.png)

**JavsScript代码实现：**

```javascript
//归并排序
function mergeSort(arr){
  var len = arr.length;
  if(len < 2){
    return arr;
  }

  //首先将无序数组划分为两个数组
  var mid = Math.floor(len / 2);
  var left = arr.slice(0,mid);
  var right = arr.slice(mid,len);
  return merge(mergeSort(left),mergeSort(right));//递归分别对左右两部分数组进行排序合并
}
//合并
function merge(left,right){
  var result = [];
  while(left.length>0 && right.length>0){
    if(left[0]<=right[0]){
      //如果左边的数据小于右边的数据，将左边数据取出，放在新数组中
      result.push(left.shift());
    }else{
       result.push(right.shift());
     }
  }

  while(left.length){
     result.push(left.shift());
  }
  while(right.length){
     result.push(right.shift());
  }
  return result;
}

var arr = [3,44,38,5,47,15,36,26];
console.log(mergeSort(arr));//3,5,15,26,36,38,44,47
```

----

## 2.8 算法：3数之和

题目描述：

给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，\*使得 \*a + b + c =* 0 ？找出所有满足条件且不重复的三元组。

```js
function threeNumberSum(nums){
	nums=nums.sort((a,b)=>a-b);  //排序
	let n=nums.length;
	const ans=[];
	let sum=0;
	//枚举第一个数字
	for (let first=0; first<n; first++){
		// 需要和上一次枚举的数不相同
		if (nums[first]>0) {
			//first元素大于0后，后面sum不可能等于0
			break;
		}
		if (first>0 && nums[first]===nums[first-1]){
			continue;
		}
		//第三个数对应的指针初始指向数组的最右端
		let third=n-1;
		let target=-nums[first];
		for (let second=first+1; second<n; second++){
			if (nums[second] > target) {
				//前两个元素和已经大于0，则再加第三个一定大于0;
				break;
			}
			// 需要和上一次枚举的数不相同
			if (second>first+1 && nums[second]===nums[second-1]) {
				continue;
			}
			// 需要保证 second 的指针在 third 的指针的左侧
			while(second<third && nums[second]+nums[third]>target){
				third--;
			}
			// 如果指针重合，随着 second 后续的增加
			// 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
			if (second===third) {
				break;
			}
			if (nums[second]+nums[third]===target) {
				ans.push([nums[first],nums[second],nums[third]]);
			}
		}
	}
	return ans;
}

let test=[-1, 0, 1, 2, -1, -4];
console.log(threeNumberSum(test));  // [ [ -1, -1, 2 ], [ -1, 0, 1 ] ]
```

---

## 2.9 算法：连续最大乘积

题目描述

给一个浮点数序列，取最大乘积连续子串的值，例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。也就是说，上述数组中，3 0.5 8这3个数的乘积3*0.5*8=12是最大的，而且是连续的。

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/maximum-product-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

分析与解法

此最大乘积连续子串与最大乘积子序列不同，请勿混淆，前者子串要求连续，后者子序列不要求连续。也就是说，最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence，LCS）是：

- 子串（Substring）是串的一个连续的部分，
- 子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；

更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串“ acdfg ”同“ akdfc ”的最长公共子串为“ df ”，而它们的最长公共子序列LCS是“ adf ”，LCS可以使用动态规划法解决。

![最大子数组乘积](E:\pogject\学习笔记\image\leetcode\最大子数组乘积.png)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let n=nums.length;
    const maxF=[...nums];
    const minF=[...nums];
    let ans=maxF[0];
    for (let i=1;i<n;i++){
        maxF[i]=Math.max(maxF[i-1]*nums[i], Math.max(nums[i],minF[i-1]*nums[i]));
        ans = ans > maxF[i] ? ans : maxF[i];
        minF[i]=Math.min(minF[i-1]*nums[i], Math.min(nums[i],maxF[i-1]*nums[i]));
    }
    return ans;
};

let nums=[2,3,-2,4];
let result=maxProduct(nums);
console.log(result);
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let n=nums.length;
    let maxF=nums[0];
    let minF=nums[0];
    let ans=nums[0];
    for (let i=1;i<n;i++){
        let mx=maxF,mn=minF;
        maxF=Math.max(mx*nums[i], Math.max(nums[i],mn*nums[i]));
        ans = Math.max(maxF,ans);
        minF=Math.min(mn*nums[i], Math.min(nums[i],mx*nums[i]));
    }
    return ans;
};

let nums=[2,3,-2,4];
let result=maxProduct(nums);
console.log(result);
```

动态规划求解的方法一个for循环搞定，所以时间复杂度为O(n)。

---

## 2.10 第K大的数

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

三种方案：

- 排序，取第 `k` 个
- 构造前 `k` 个最大元素小顶堆，取堆顶
- 计数排序或桶排序，但它们都要求输入的数据必须是有确定范围的整数，所以本题不可用

那么除了这两种方案还有没有其它的方式可解决本题喃？其实还有两种：

- 快速选择（quickselect）算法
- 中位数的中位数（bfprt）算法

解法一：数组排序，取第 k 个数

最简单

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
	nums.sort((a,b)=>b-a);
	return nums[k-1];
};

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```

**复杂度分析：**

- 时间复杂度：O(nlogn)
- 空间复杂度：O(logn)

解法二：构造前 `k` 个最大元素小顶堆，取堆顶

我们也可以通过构造一个前 `k` 个最大元素小顶堆来解决，小顶堆上的任意节点值都必须小于等于其左右子节点值，即堆顶是最小值。

所以我们可以从数组中取出 `k` 个元素构造一个小顶堆，然后将其余元素与小顶堆对比，如果大于堆顶则替换堆顶，然后堆化，所有元素遍历完成后，堆中的堆顶即为第 `k` 个最大值

具体步骤如下：

- 从数组中取前 `k` 个数（ `0` 到 `k-1` 位），构造一个小顶堆
- 从 `k` 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。
- 遍历完成后，堆顶的数据就是第 K 大的数据

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
*/
var findKthLargest = function(nums, k) {
	//从nums中取出前k个数，构建一个小顶锥
	const heap=[,];
	let i=0;
	while(i<k){
		heap.push(nums[i++]);
	}
	bulidHeap(heap,k);

	// 从 k 位开始遍历数组
	for (let i=k; i < nums.length; i++){
		if (heap[1] < nums[i]) {
			//替换并堆化
			heap[1]=nums[i];
			heapify(heap,k,1);
		}
	}
	//返回堆顶元素
	return heap[1];
};

// 原地建堆，从后往前，自上而下式建小顶堆
var bulidHeap=(arr,k)=>{
	if (k===1) {
		return;
	}
	// 从最后一个非叶子节点开始，自上而下式堆化
	for (let i=Math.floor(k/2);i>=1;i--){
		heapify(arr,k,i);
	}
}

//堆化
var heapify=(arr,k,i)=>{
	// 自上而下式堆化
	while(true){
		let minIndex=i;
		if(2*i<=k && arr[2*i] < arr[i]){
			minIndex=2*i;
		}
		if (2*i+1 <= k && arr[2*i+1] < arr[minIndex]) {
			minIndex=2*i+1;
		}
		if (minIndex !== i) {
			swap(arr,i,minIndex);
			i=minIndex;
		}else{
			break;
		}
	}
}

//交换元素
var swap=(arr,i,j)=>{
	let temp=arr[i];
	arr[i]=arr[j];
	arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6],k=4;
console.log(findKthLargest(test,k));  //
```

**复杂度分析：**

- 时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)
- 空间复杂度：O(k)

解法三：快速选择（quickselect）算法

无论是排序算法还是构造堆求解 Top k问题，我们都经过的一定量的不必要操作：

- 如果使用排序算法，我们仅仅想要的是第 k 个最大值，但对其余不需要的数也进行了排序
- 如果使用堆排序，需要维护一个大小为 `k` 的堆(大顶堆，小顶堆)，时间复杂度也为 `O(nlogk)`

快速选择（quickselect）算法与快排思路上相似，我们先看看快排是如何实现的？

快排

快排使用了分治策略的思想，所谓分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。

快排的过程简单的说只有三步：

- 首先从序列中选取一个数作为基准数
- 将比这个数大的数全部放到它的右边，把小于或者等于它的数全部放到它的左边 （一次快排 `partition`）
- 然后分别对基准的左右两边重复以上的操作，直到数组完全排序

具体按以下步骤实现：

- 创建两个指针分别指向数组的最左端以及最右端
- 在数组中任意取出一个元素作为基准
- 左指针开始向右移动，遇到比基准大的停止
- 右指针开始向左移动，遇到比基准小的元素停止，交换左右指针所指向的元素
- 重复3，4，直到左指针超过右指针，此时，比基准小的值就都会放在基准的左边，比基准大的值会出现在基准的右边
- 然后分别对基准的左右两边重复以上的操作，直到数组完全排序

注意这里的基准该如何选择喃？最简单的一种做法是每次都是选择最左边的元素作为基准，但这对几乎已经有序的序列来说，并不是最好的选择，它将会导致算法的最坏表现。还有一种做法，就是选择中间的数或通过 `Math.random()` 来随机选取一个数作为基准，下面的代码实现就是以随机数作为基准。

```js
var quickSort=(arr)=>{
    quick(arr, 0, arr.length - 1);
}

var quick=(arr,left,right)=>{
    let index;
    if (left < right) {
        //划分数组
        index=partition(arr, left, right);
        if (left < index - 1) {
            quick(arr, left, index - 1);
        }
        if (index < right) {
            quick(arr, index, right);
        }
    }
}

// 一次快排
var partition=(arr,left,right)=>{
    //取中间项为基准
    let datum=arr[Math.floor(Math.random() * (right - left + 1)) + left];
    let i=left;
    let j=right;
    // 开始调整
    while (i <= j){
        //左指针右移
        while(arr[i] < datum){
            i++;
        }
        // 右指针左移
        while(arr[j] > datum){
            j--;
        }
        //交换
        if (i <= j) {
            swap(arr, i, j);
            i += 1;
            j -= 1;
        }
    }
    return i;
}

//交换元素
var swap=(arr,i,j)=>{
    let temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}

let test=[3,2,3,1,2,4,5,5,6];
quickSort(test);
console.log(test);  //
```

快排是从小到大排序，所以第 `k` 个最大值在 `n-k` 位置上

**复杂度分析**

- 时间复杂度：O(nlog~~2~~n)
- 空间复杂度：O(nlog~~2~~n)

快速选择（quickselect）算法

上面我们实现了快速排序来取第 k 个最大值，其实没必要那么麻烦，我们仅仅需要在每执行一次快排的时候，比较基准值位置是否在 `n-k` 位置上，如果小于 `n-k` ，则第 k 个最大值在基准值的右边，我们只需递归快排基准值右边的子序列即可；如果大于 `n-k` ，则第 k 个最大值在基准值的做边，我们只需递归快排基准值左边的子序列即可；如果等于 `n-k` ，则第 k 个最大值就是基准值

```js
let findKthLargest = function(nums, k) {
    return quickSelect(nums, nums.length - k)
};

let quickSelect = (arr, k) => {
  return quick(arr, 0 , arr.length - 1, k)
}

let quick = (arr, left, right, k) => {
  let index
  if(left < right) {
    // 划分数组
    index = partition(arr, left, right)
    // Top k
    if(k === index) {
        return arr[index]
    } else if(k < index) {
        // Top k 在左边
        return quick(arr, left, index-1, k)
    } else {
        // Top k 在右边
        return quick(arr, index+1, right, k)
    }
  }
  return arr[left]
}

let partition = (arr, left, right) => {
  // 取中间项为基准
  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],
      i = left,
      j = right
  // 开始调整
  while(i < j) {

    // 左指针右移
    while(arr[i] < datum) {
      i++
    }

    // 右指针左移
    while(arr[j] > datum) {
      j--
    }

    // 交换
    if(i < j) swap(arr, i, j)

    // 当数组中存在重复数据时，即都为datum，但位置不同
    // 继续递增i，防止死循环
    if(arr[i] === arr[j] && i !== j) {
        i++
    }
  }
  return i
}

// 交换
let swap = (arr, i , j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

**复杂度分析：**

- 时间复杂度：平均时间复杂度O(n)，最坏情况时间复杂度为O(n2)
- 空间复杂度：O(1)

解法四：中位数的中位数（BFPRT）算法

又称为**中位数的中位数算法**，它的最坏时间复杂度为 O(n) ，它是由**Blum、Floyd、Pratt、Rivest、Tarjan**提出。该算法的思想是修改快速选择算法的主元选取方法，提高算法在最坏情况下的时间复杂度。

在BFPTR算法中，仅仅是改变了快速选择（quickselect）算法中 `Partion` 中的基准值的选取，在快速选择（quickselect）算法中，我们可以选择第一个元素或者最后一个元素作为基准元，优化的可以选择随机一个元素作为基准元，而在 BFPTR 算法中，每次选择五分中位数的中位数作为基准元（也称为主元**pivot**），这样做的目的就是使得划分比较合理，从而避免了最坏情况的发生。

BFPRT 算法步骤如下：

- 选取主元
  - 将 n 个元素按顺序分为 `n/5` 个组，每组 5 个元素，若有剩余，舍去
  - 对于这 `n/5` 个组中的每一组使用插入排序找到它们各自的中位数
  - 对于上一步中找到的所有中位数，调用 BFPRT 算法求出它们的中位数，作为主元；
- 以主元为分界点，把小于主元的放在左边，大于主元的放在右边；
- 判断主元的位置与 k 的大小，有选择的对左边或右边递归

**代码实现：**

```js
let findKthLargest = function(nums, k) {
    return nums[bfprt(nums, 0, nums.length - 1, nums.length - k)]
}

let bfprt = (arr, left , right, k) => {
  let index
  if(left < right) {
    // 划分数组
    index = partition(arr, left, right)
    // Top k
    if(k === index) {
        return index
    } else if(k < index) {
        // Top k 在左边
        return bfprt(arr, left, index-1, k)
    } else {
        // Top k 在右边
        return bfprt(arr, index+1, right, k)
    }
  }
  return left
}

let partition = (arr, left, right) => {
  // 基准
  var datum = arr[findMid(arr, left, right)],
      i = left,
      j = right
  // 开始调整
  while(i < j) {
    // 左指针右移
    while(arr[i] < datum) {
      i++
    }

    // 右指针左移
    while(arr[j] > datum) {
      j--
    }

    // 交换
    if(i < j) swap(arr, i, j)

    // 当数组中存在重复数据时，即都为datum，但位置不同
    // 继续递增i，防止死循环
    if(arr[i] === arr[j] && i !== j) {
        i++
    }
  }
  return i
}

/**
 * 数组 arr[left, right] 每五个元素作为一组，并计算每组的中位数，
 * 最后返回这些中位数的中位数下标（即主元下标）。
 *
 * @attention 末尾返回语句最后一个参数多加一个 1 的作用其实就是向上取整的意思，
 * 这样可以始终保持 k 大于 0。
 */
let findMid = (arr, left, right) => {
    if (right - left < 5)
        return insertSort(arr, left, right);

    let n = left - 1;

    // 每五个作为一组，求出中位数，并把这些中位数全部依次移动到数组左边
    for (let i = left; i + 4 <= right; i += 5)
    {
        let index = insertSort(arr, i, i + 4);
        swap(arr[++n], arr[index]);
    }

    // 利用 bfprt 得到这些中位数的中位数下标（即主元下标）
    return findMid(arr, left, n);
}

/**
 * 对数组 arr[left, right] 进行插入排序，并返回 [left, right]
 * 的中位数。
 */
let insertSort = (arr, left, right) => {
    let temp, j
    for (let i = left + 1; i <= right; i++) {
        temp = arr[i];
        j = i - 1;
        while (j >= left && arr[j] > temp)
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
    return ((right - left) >> 1) + left;
}

// 交换
let swap = (arr, i , j) => {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
```

**为什么是5？**

在BFPRT算法中，为什么是选5个作为分组？

首先，偶数排除，因为对于奇数来说，中位数更容易计算。

如果选用3，有 ![图片说明](https://uploadfiles.nowcoder.com/images/20210301/59_1614587226282/7A310A449D4D97D485E7E6FFD81C3BAA) ，其操作元素个数还是 `n` 。

如果选取7，9或者更大，在插入排序时耗时增加，常数 `c` 会很大，有些得不偿失。

总结

所以，这里我们总结一下，求topk问题其实并不难，主要有以下几个思路：

- 整体排序：O(nlogn)
- 局部排序：只冒泡排序前k个最大值，O(nk)
- 堆：O(nlogk)
- 计数或桶排序：计数排序用于前k个最值，时间复杂度为O(n + m)，其中 m 表示数据范围；桶排序用于最高频k个，时间复杂度为O(n)； **但这两者都要求输入数据必须是有确定范围的整数**
- 快速选择（quickselect）算法：平均O(n)，最坏O(n2)
- 中位数的中位数（bfprt）算法：最坏O(n)

----

## 2.11 验证有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。

第一种：用repace方法，闭合才有效，也就是最里边的也要闭合，那就把最里边的括号取代为空

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
	while(s.length){
		let temp=s;
		s=s.replace("()", "");
		s=s.replace("[]", "");
		s=s.replace("{}", "");
		if (s===temp) {
			return false;
		}
	}
	return true;
};

let s = "()[]{}";
console.log(isValid(s));
```

第二种：栈思想 括号都是要闭合的，也就是说遇到第一个右括号时，必定左边就是对应的左括号，也就是说把遇到的左括号都放进栈里，然后遇到右括号时取出栈顶的元素匹配 如"{[()]}"遇到{[(放入栈内，然后遇到）与栈顶匹配，栈顶也就是最后一个进栈的元素（，然后把栈的最后一个元素删掉

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
	let stack = [];
	let leftBracketSet = new Set(['(', '[', '{']);
	let bracketMap = new Map([[')','('],[']','['],['}','{']]);
	console.log(bracketMap)
	for (let i = 0; i < s.length; i++){
		if (leftBracketSet.has(s[i])) {
			stack.push(s[i]);
		}else{
			if (stack.length > 0 && stack[stack.length - 1] === bracketMap.get(s[i])) {
				stack.pop();
			}else{
				return false;
			}
		}
	}
	return stack.length===0;
};

let s = "()[]{}";
console.log(isValid(s));
```

比起第一个方法快了不少但是还是慢

第三种：使用map数据结构

循环s字符串，ch in map 的意思是循环map的键值，也就是遇到左括号时，放进数组，当开始遇到右括号时，用pop（）弹出栈顶的元素与与之比对，若是不相等，就ruturn false （leftArr.pop()为左括号，map[key]=value,也就是右括号），当程序走完时，left的length长度应该为0，若不为0则没闭合(当length=0 时，!leftArr.length为ture，当length>0 时，!leftArr.length为false)

```js
var isValid = function(s) {
    let map = {
        "{":"}",
        "[":"]",
        "(":")",
    }
    let leftArr = [];
    for(let ch of s){
        if(ch in map){
            leftArr.push(ch)
        }else{
            if(ch!=map[leftArr.pop()]){
                return false
            }
        }
    }
     return !leftArr.length
};
```

---

## 2.12 算法题，反转单链表

解法一：迭代法
解题思路： 将单链表中的每个节点的后继指针指向它的前驱节点即可

确定边界条件： 当链表为 null 或链表中仅有一个节点时，不需要反转

在遍历链表时，将当前节点的 \textit{next}next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
	let prev = null;
	let curr = head;  //当前结点
	while (curr){
		const next = curr.next;  //保存当前结点的后继
		curr.next = prev;  //设置当前结点的后继为前一结点
		prev = curr;
		curr = next;
	}
	return prev;
};

```

**复杂度分析**

- 时间复杂度：O*(*n)，其中 n 是链表的长度。需要遍历链表一次。
- 空间复杂度：O(1)。

解法二：递归法
解题思路： 不断递归反转当前节点 head 的后继节点 next

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
	if (head == null || head.next == null){
		return head;
	}
	const newHead = reverseList(head.next);
	head.next.next = head;
	head.next = null;
	return newHead;
};
```

复杂度分析

时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。

空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。

解法二：尾递归法
解题思路： 从头节点开始，递归反转它的每一个节点，直到 null ，思路和解法一类似

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
	if (head == null || head.next == null){
		return head;
	}
	head = reverse(null, head);
	return head;
	const newHead = reverseList(head.next);
	head.next.next = head;
	head.next = null;
	return newHead;
};

var reverse = function(prev, curr){
	if (curr == null) {
		return prev;
	}
	var next = curr.next;
	curr.next = prev;
	return reverse(curr, next);
}
```

时间复杂度：O(n)

空间复杂度：O(n)

---

## 2.13 索引是怎么实现的，倒排索引

倒排索引是目前搜索引擎公司对搜索引擎最常用的存储方式，也是搜索引擎的核心内容，在搜索引擎的实际应用中，有时需要按照关键字的某些值查找记录，所以是按照关键字建立索引，这个索引就被称为倒排索引。

首先你要明确，索引这东西，一般是用于提高查询效率的。举个最简单的例子，已知有5个文本文件，需要我们去查某个单词位于哪个文本文件中，最直观的做法就是挨个加载每个文本文件中的单词到内存中，然后用for循环遍历一遍数组，直到找到这个单词。这种做法就是正向索引的思路。

举一个例子，有两段文本

```java
D1：Hello, conan!

D2：Hello, hattori!
```

第一步，找到所有的单词

```java
Hello、conan、hattori
```

第二步，找到包含这些单词的文本位置

```java
Hello（D1，D2）

conan（D1）

hattori（D2）
```

我们将单词作为Hash表的Key，将所在的文本位置作为Hash表的Value保存起来。

当我们要查询某个单词的所在位置时，只需要根据这张Hash表就可以迅速的找到目标文档。

结合之前的说的正向索引，不难发现。正向索引是通过文档去查找单词，反向索引则是通过单词去查找文档。

倒排索引的优点还包括在处理复杂的多关键字查询时，可在倒排表中先完成查询的并、交等逻辑运算，得到结果后再对记录进行存取，这样把对文档的查询转换为地址集合的运算，从而提高查找速度。

---

## 2.14 二叉树的实际应用场景

1. 哈夫曼编码，来源于哈夫曼树（给定n个权值作为n个叶子结点，构造一棵[二叉树](http://blog.csdn.net/hguisu/article/details/7686515)，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为赫夫曼树(Huffman tree)。即带权路径长度最短的树），在数据压缩上有重要应用，提高了传输的有效性，详见《信息论与编码》。
2. 海量数据并发查询，二叉树复杂度是O(K+LgN)。二叉排序树就既有链表的好处，也有数组的好处， 在处理大批量的动态的数据是比较有用。
3. C++ STL中的set/multiset、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。查找最大（最小）的k个数，红黑树，红黑树中查找/删除/插入，都只需要O(logk)。
4. B-Tree，B+-Tree在文件系统中的目录应用。
5. 路由器中的路由搜索引擎。

---

## 2.15 数组和链表的优缺点

**数组**:存放内存地址必须连续的.
查找的时候很方便,可以通过数组下标获取数据;
添加删除很不方便,如果插入一个元素,必须这个元素后面的元素都往后移一个内存地址
删除,所有后面元素都往前移动一个内存地址

**链表**:存放内存地址可以不连续,存放方式是通过元素中的指针,来寻找下一个元素.
这种结构添加删除元素很容易,只要修改指针指向下下个元素,就能删除,而添加则是
一个元素的指针指向后面的插入位置后面的元素,插入位置的指针指向插入元素就行

**比较**

**数组**
优点:查询速度快,可随机访问
缺点:

1. 删除插入效率低,
2. 内存必须连续
3. 有浪费内存的可能
4. 数组大小固定,不能动态拓展

**链表**
优点:插入删除速度快,内存不需要连续,大小可以不固定
缺点:查询效率低,每次通过第一个开始遍历,只能顺序访问,不支持随机访问

---

## 2.16 1000w条数据如何排序，取前一百个

**参考答案**：

1. 根据快速排序划分的思想
   (1) 递归对所有数据分成[a,b）b（b,d]两个区间，(b,d]区间内的数都是大于[a,b)区间内的数
   (2) 对(b,d]重复(1)操作，直到最右边的区间个数小于100个。注意[a,b)区间不用划分
   (3) 返回上一个区间，并返回此区间的数字数目。接着方法仍然是对上一区间的左边进行划分，分为[a2,b2）b2（b2,d2]两个区间，取（b2,d2]区间。如果个数不够，继续(3)操作，如果个数超过100的就重复1操作，直到最后右边只有100个数为止。

2. 先取出前100个数，维护一个100个数的最小堆，遍历一遍剩余的元素，在此过程中维护堆就可以了。具体步骤如下：
   step1：取前m个元素（例如m=100），建立一个小顶堆。保持一个小顶堆得性质的步骤，运行时间为O（lgm);建立一个小顶堆运行时间为mO（lgm）=O(m lgm);
   step2:顺序读取后续元素，直到结束。每次读取一个元素，如果该元素比堆顶元素小，直接丢弃
   如果大于堆顶元素，则用该元素替换堆顶元素，然后保持**最小堆性质**。最坏情况是每次都需要替换掉堆顶的最小元素，因此需要维护堆的代价为(N-m)O(lgm);
   最后这个堆中的元素就是前最大的100个。时间复杂度为O(N lgm）。
   补充：这个方法的说法也可以更简化一些：
   假设数组arr保存100个数字，首先取前100个数字放入数组arr，对于第101个数字k，如果k大于arr中的最小数，则用k替换最小数，对剩下的数字都进行这种处理。

3. 分块查找

   先把1000w个数分成100份，每份10w个数。先分别找出每10w个数里面的最大的数，然后比较。找出100个最大的数中的最大的数和最小的数，取最大数的这组的第二大的数，与最小的数比较

---

## 2.17 AST 抽象语法树

抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。

抽象语法树在很多领域有广泛的应用，比如浏览器，智能编辑器，编译器。

---

## 2.18 算法：一个小偷要偷一排顺序的房子，每个房子有固定的价值，但小偷不能偷连续的房子，问小偷能偷到的最大价值

示例 1:

输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。

示例 2:

输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。

- 问题求解 题意简单说来就是不能偷相邻的两个房屋, 而且要尽量偷得多. 这是典型的动态规划问题, 思路如下, 由于后面房间能偷到的最大钱数取决于前面房间能偷到的最大钱数, 所以可以从第一间房子向后看. 建立一个数组dp, 数组中的第n个元素保存**前n间**房屋**总共**能偷到的**最大**钱数:

1. 若只有一间房子, 则只能偷这间, 则前1间房屋能偷到的最大金额一已知, 保存下来;
2. 若有两间, 则偷其中最多的, 则前两间房屋能偷到的最大金额已知, 保存下来;
3. 若有3间, 则分为两种情况, 1)偷房屋 1和3; 2) 只偷房屋2. 比较这两种哪种获益大. 这可以抽象成两个子问题, 决定这两个子问题的关键是第三间房子偷与否. 分别把偷(子问题1)和不偷(子问题2) 的结果计算出来, 选出最大就是了. 现在, 前三间能偷到的最大金额已知, 保存下来, 以供偷第4、5...N 间房子时参考.
4. 若有4间, 则又是两种情况: 1)偷4不偷3; 2)不偷4. 这两种情况只和前三间房屋偷到的金额(dp[3])和前两间房屋偷到的金额(dp[2])的结果有关,把这两种情况下的金额计算出来, 选择最大的就可以了, 即 `max(房屋4的钱+dp[2], dp[3])`;
5. 由此可得, 第n间房屋偷还是不偷只要考虑 dp 数组中的dp[n-1]和dp[n-2]+当前可得的金额这两个因素就可以了.

所以状态方程为:`max(dp[n-2] + thisValue, dp[n-1])`, 代码为:

```js
var rob = function(nums) {
    // 判断异常
    if(!nums || nums.length === 0){ 
        return 0;
    }
    // 边界条件
    if(nums.length < 3){
        return Math.max(...nums);
    }
    // 状态方程 dp(i) = max( dp(i-1) , dp(2) + arr[i])
    let dp = [];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0],nums[1]);
    for(let i = 2; i < nums.length; i++){
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    }
    return dp[dp.length-1];
};
```

---



# 数组及对象扁平化

数组

```js
const nestArr = [1, [2], [[3], [4]], [[[5], [6]]]];

function flattenArray(array) {
    let result = [];
    for (let i = 0; i < array.length; i++) {
        if (Array.isArray(array[i])) {
            result = result.concat(flattenArray(array[i]));
        } else {
            result.push(array[i]);
        }
        
    }
    return result;
}

console.log(flattenArray(nestArr))  // => [ 1, 2, 3, 4, 5, 6 ]
```



对象

```js
const obj = {
            a: {
                b: 1,
                c: 2,
                d: { e: 5 },
            },
            b: [1, 3, { a: 2, b: 3 }],
            c: 3
        }
        /* 
            {   
                'a.b': 1,  
                'a.c': 2, 
                'a.d.e': 5, 
                'b[0]': 1, 
                'b[1]': 3,    
                'b[2].a': 2,   
                'b[2].b': 3  
                 c: 3  
            }
        */

        function flatObj(o) {
            if (typeof o !== 'object'){
                throw new Error(`TypeError: need a object type but get a ${typeof o}`)
            }
            const res = {}
            const flat = (obj, preKey = '') => {
                Object.entries(obj).forEach(([key, value]) => {
                    // preKey默认是'', 如果是递归入口 preKey有值 需要加 . 或者 [] 分割
                    let newKey = key
                    if (preKey) {
                        newKey = `${preKey}${ Array.isArray(obj) ? `[${newKey}]` : `.${newKey}` }`
                    }

                   // 引用类型继续递归拍平, 基本类型设置到结果对象上
                    if (value && typeof value === 'object') {
                        return flat(value, newKey)
                    }
                    res[newKey] = value
                })
            }

            flat(o)
            return res
        }
        console.log(flatObj(obj))
```

```js
let flatten = (obj) => {
    let result = {};

    let process = (key, value) => {
        // 首先判断是基础数据类型还是引用数据类型
        if (Object(value) !== value) {
            // 基础数据类型
            if (key) {
                result[key] = value;
            }
        } else if(Array.isArray(value)){
               for (let i = 0; i< value.length; i++) {
                process(`${key}[${i}]`, value[i])
            }
            if (value.length === 0) {
                result[key] = [];
            }
        } else {
            let objArr = Object.keys(value);
            objArr.forEach(item => {
                process(key ? `${key}.${item}` : `${item}`, value[item])
            });
            if (objArr.length === 0 && key) {
                result[key] = {};
            }
        }
    }
    process('', obj)
    return result;
}


```



---

# 手写Promise

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>自定义Promise</title>
</head>
<body>

<script type="text/javascript">
  
// 自定义 Promise
(function (window) {

  // Promise 构造函数
  // excutor: 内部同步执行的函数 (resolve, reject) => {}
  function Promise(excutor) {
    const self = this;
    self.status = "pending";  // 状态值, 初始状态为 pending, 成功了变为resolved, 失败了变为 rejected
    self.data = undefined;  // 用来保存成功 value 或失败 reason 的属性
    self.callbacks = [];  // 用来保存所有待调用的包含 onResolved 和 onRejected 回调函数的对象的数组

    // 异步处理成功后应该调用的函数
    // value: 将交给 onResolve()的成功数据
    function resolve(value) {
      if (self.status !== "pending") {
        return;
      }
      //立即更新状态, 保存数据
      self.status = "resolved";
      self.data ="自定义" + value;
      // 异步调用所有待处理的 onResolved 成功回调函数
      if (self.callbacks.length > 0) {
        setTimeout(() => {
          self.callbacks.forEach(fn => {
            fn.onResolved(value);
          });
        });
      }
    }

    // 异步处理失败后应该调用的函数
    // reason: 将交给 onRejected()的失败数据
    function reject(reason) {
      if (self.status !== "pending") {
        return;
      }
      //立即更新状态, 保存数据
      self.status = "rejected";
      self.data = "自定义" +  reason;
      // 异步调用所有待处理的 onRejected 回调函数
      if (self.callbacks.length > 0) {
        setTimeout(() => {
          self.callbacks.forEach(fn => {
            fn.onRejected(reason);
          });
        });
      }
    }

    try {
      // 立即同步调用 excutor()处理
      excutor(resolve, reject);
    } catch (error) {
      // 如果出了异常, 直接失败
      reject(error);
    }
  }

  // 为 promise 指定成功/失败的回调函数
  // 函数的返回值是一个新的 promise 对象
  Promise.prototype.then = function (onResolved, onRejected) {
    const self = this;

    // 如果 onResolved/onRejected 不是函数, 可它指定一个默认的函数
    // 指定返回的 promise 为一个成功状态, 结果值为 value
    onResolved = typeof onResolved === "function" ? onResolved : value => value;
    // 指定返回的 promise 为一个失败状态, 结果值为 reason
    onRejected = typeof onRejected === "function" ? onRejected : reason => { throw reason; };

    // 返回一个新的 promise 对象
    return new Promise((resolve, reject) => {
      //专门抽取的用来处理 promise 成功/失败结果的函数
      // callback: 成功/失败的回调函数
      function handle(callback) {
        // 1. 抛出异常 ===> 返回的 promise 变为 rejected
        try {
          const x = callback(self.data);
          // 2. 返回一个新的 promise ===> 得到新的 promise 的结果值作为返回的promise 的结果值
          if (x instanceof Promise) {
            // 一旦 x 成功了, resolve(value), 一旦 x失败了: reject(reason)
            x.then(resolve, reject);
          } else {
            // 3. 返回一个一般值(undefined) ===> 将这个值作为返回的 promise 的成功值
            resolve(x);
          }
        } catch (error) {
          reject(error);
        }
      }
      if (self.status === "resolved") {
        // 当前 promise 已经成功了
        setTimeout(() => {
          handle(onResolved);
        });
      } else if (self.status === "rejected") {
        // 当前 promise 已经失败了
        setTimeout(() => {
          handle(onRejected);
        });
      } else {
        // 当前 promise 还未确定 pending
        // 将 onResolved 和 onRejected 保存起来
        self.callbacks.push({
          onResolved(value) {
            handle(onResolved);
          },
          onRejected(reason) {
            handle(onRejected);
          }
        });
      }
    });
  }

  // 为 promise 指定失败的回调函数
  // 是 then(null, onRejected)的语法糖
  Promise.prototype.catch = function (onRejected) {
    return this.then(null, onRejected);
  }

  // 返回一个指定了成功 value 的 promise 对象
  //value: 一般数据或 promise
  Promise.resolve = function (value) {
    return new Promise((resolve, reject) => {
      if (value instanceof Promise) {
        value.then(resolve, reject);
      } else {
        resolve(value);
      }
    });
  }

  // 返回一个指定了失败 reason 的 promise 对象
  // reason: 一般数据/error
  Promise.reject = function (reason) {
    return new Promise((resolve, reject) => {
      reject(reason);
    });
  }

  // 返回一个 promise, 只有 promises 中所有 promise 都成功时, 才最终成功, 只要有一个失败就直接失败
  Promise.all = function (promises) {
    // 返回一个新的 promise
    return new Promise((resolve, reject) => {
      // 已成功的数量
      let resolvedCount = 0;
      // 待处理的 promises 数组的长度
      const promisesLength = promises.length;
      // 准备一个保存成功值的数组
      const values = new Array(promisesLength);
      // 遍历每个待处理的 promise
      for (let i = 0; i < promisesLength; i++){
        // promises 中元素可能不是一个数组, 需要用 resolve 包装一下
        Promise.resolve(promises[i]).then(
          value => {
            // 成功当前 promise 成功的值到对应的下标
            values[i] = value;
            // 成功的数量加 1
            resolvedCount++;
            // 一旦全部成功
            if (resolvedCount === promisesLength) {
              // 将所有成功值的数组作为返回 promise 对象的成功结果值
              resolve(values);
            }
          },
          reason => {
            // 一旦有一个promise 产生了失败结果值, 将其作为返回promise 对象的失败结果值
            reject(reason);
          }
        );
      }
    });
  }

  // 返回一个 promise， 一旦某个 promise 解决或拒绝， 返回的 promise 就会解决或拒绝。
  Promise.race = function (promises) {
    // 返回新的 promise 对象
    return new Promise((resolve, reject) => {
      //遍历所有 promise
      for (let i = 0; i < promises.length; i++){
        Promise.resolve(promises[i]).then(
          value => {
            //只要有一个成功了, 返回的 promise 就成功了
            resolve(value);
          },
          reason => {
            //只要有一个失败了, 返回的结果就失败了
            reject(reason);
          }
        );
      }
    });
  }

  //返回一个延迟指定时间才确定结果的 promise 对象
  Promise.resolveDelay = function (value, time) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (value instanceof Promise) {
          //如果 value 是一个 promise, 取这个promise 的结果值作为返回的 promise 的结果值
          //如果 value 成功, 调用resolve(val), 如果 value 失败了, 调用 reject(reason)
          value.then(resolve, reject);
        } else {
          resolve(value);
        }
      }, time);
    });
  }

  //返回一个延迟指定时间才失败的 Promise 对象。
  Promise.rejectDelay = function (reason, time){
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(reason);
      }, time);
    });
  }

  // 暴露构造函数
  window.Promise = Promise;

})(window);

const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Date.now() % 2 === 0) {
      resolve(66)
    } else {
      reject(99)
    }
  }, 100);
});
p.then((value) => {
    // 成功的回调函数onResolved,得到成的value
    console.log("成功的value: " + value);
  }, (reason) => {
    // 失败的回调函数onRejected,得到失败的reason
    console.log("失败的reason: " + reason);
});

</script>
</body>
</html>
```

---

# js手写发布订阅模式

发布-订阅模式其实是一种对象间**一对多的依赖关系**，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。
订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。

**思路**：

- 需要有一个`list`对象缓存订阅事件
- 订阅（`on`）如果存在事件就往list里面缓存事件
- 取消订阅（`off`）从list对象找到订阅事件删除
- 发布（`emit`）从list对象找到事件去执行就OK
- 只发布一次（`once`）执行完删除即可

```js
/*
(1) 创建一个 EventEmitter 类在该类上创建一个事件中心（Map）

(2) on 方法用来把函数 fn 都加到事件中心中（订阅者注册事件到调度中心）

(3)emit 方法取到 arguments 里第一个当做 event，根据 event 去执行对应事件中心中的函数（发布者发布事件到调度中心，调度中心处理代码）

(4) off 方法可以根据 event 值取消订阅（取消订阅）

(5) once 方法只监听一次，调用完毕后删除缓存函数（订阅一次）

(6) 注册一个 newListener 用于监听新的事件订阅
*/

class EventEmitter {
  // 创建一个类，并初始化一个事件存储中心
  constructor(){
    // 单例模式
    if (!EventEmitter.instance) {
      EventEmitter.instance = this;
      this._events = {};  // 事件缓存列表
    }
    return EventEmitter.instance;
  }

  // 实现事件的订阅方法 on, 需要接收订阅事件名和对应的回调函数
  // 基本思路：将事件回调函数存储到对应的事件上
  on(eventName, callback) {
    // 由于一个事件可能注册多个回调函数，所以使用数组来存储事件队列
    if (this._events[eventName]) {
      // 如果存在该事件名
      this._events[eventName].push(callback);
    } else {
      this._events[eventName] = [callback];
    }
  }

  // 实现事件的发布方法 emit，需要接收发布事件名和对应的参数
  // 基本思路： 获取到事件对应的回调函数依次执行
  emit(eventName, ...args) {
    // args 用于收集发布事件时传递的参数
    if (this._events[eventName]) {
      //创建副本，如果回调函数内部继续注册相同的事件，会造成死循环
      let handlers = [...this._events[eventName]];
      handlers.forEach(callback => callback(...args));
    }
  }

  // 实现事件的取消订阅方法 off
  // 基本思路：找到事件对应的回调函数，删除对应的回调函数
  off(eventName, callback) {
    let callbacks = this._events[eventName];
    let newCallbacks = callbacks.filter(fn => fn != callback && fn.initialCallback != callback);
    // fn.initialCallback != callback /* 用于once的取消订阅 */
    this._events[eventName] = newCallbacks;
    /*
    let index = callback.indexOf(callback);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
    */
  }

  //实现事件的单次订阅方法 once，需要添加的订阅事件名及指定的回调函数
  once(eventName, callback) {
    //由于需要在回调函数执行后，取消订阅当前事件，所以需要对传入的回调函数做一层包装,然后绑定包装后的函数
    let wrapper = (...args) => {
      // 执行回调函数
      callback(...args);
      // 取消订阅当前事件
      this.off(eventName, wrapper);
    }
    // 由于：我们订阅事件的时候，修改了原回调函数的引用，所以，用户触发 off 的时候不能找到对应的回调函数
    // 所以，我们需要在当前函数与用户传入的回调函数做一个绑定，我们通过自定义属性来实现
    wrapper.initialCallback = callback;
    this.on(eventName, wrapper);
  }

}

// 测试
let eventBus = new EventEmitter();

let fn1 = function(name, age) {
  console.log(`${name} ${age}`);
}

let fn2 = function(name, age) {
  console.log(`hello, ${name} ${age}`);
}

eventBus.on('aaa', fn1);
eventBus.on('aaa', fn2);
eventBus.emit('aaa', 'kop', 66);
eventBus.once("bbb", fn2);
eventBus.emit("bbb", "John", 26);
eventBus.emit("bbb", "Bob", 21);
eventBus.off("aaa",fn1);
eventBus.emit("aaa", "Alison", 29);

// kop 66
// hello, kop 66
// hello, John 26
// hello, Alison 29

```

简单

```js
// 发布订阅模式
class EventEmitter {
    constructor() {
        // 事件对象，存放订阅的名字和事件
        this.events = {};
    }
    // 订阅事件的方法
    on(eventName,callback) {
       if (!this.events[eventName]) {
           // 注意时数据，一个名字可以订阅多个事件函数
           this.events[eventName] = [callback]
       } else  {
          // 存在则push到指定数组的尾部保存
           this.events[eventName].push(callback)
       }
    }
    // 触发事件的方法
    emit(eventName) {
        // 遍历执行所有订阅的事件
       this.events[eventName] && this.events[eventName].forEach(cb => cb());
    }
    // 移除订阅事件
    removeListener(eventName, callback) {
        if (this.events[eventName]) {
            this.events[eventName] = this.events[eventName].filter(cb => cb != callback)
        }
    }
    // 只执行一次订阅的事件，然后移除
    once(eventName,callback) {
        // 绑定的时fn, 执行的时候会触发fn函数
        let fn = () => {
           callback(); // fn函数中调用原有的callback
           this.removeListener(eventName,fn); // 删除fn, 再次执行的时候之后执行一次
        }
        this.on(eventName,fn)
    }
}
let em = new EventEmitter();
let workday = 0;
em.on("work", function() {
    workday++;
    console.log("work everyday");
});

em.once("love", function() {
    console.log("just love you");
});

function makeMoney() {
    console.log("make one million money");
}
em.on("money",makeMoney)；

let time = setInterval(() => {
    em.emit("work");
    em.removeListener("money",makeMoney);
    em.emit("money");
    em.emit("love");
    if (workday === 5) {
        console.log("have a rest")
        clearInterval(time);
    }
}, 1);
/*
work everyday
just love you
work everyday
work everyday
work everyday
work everyday
have a rest
*/
```

