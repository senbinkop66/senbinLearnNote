------

# 浏览器

---

## 1.1 cookie sessionStorage localStorage 区别

共同点：都是保存在浏览器端、且同源的

区别：

1. cookie数据始终在**同源**的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
2. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、**所以cookie只适合保存很小的数据，如会话标识**。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：**只在设置的cookie过期时间之前有效**，即使窗口关闭或浏览器关闭
4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的
5. web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6. web Storage的api接口使用更方便

---

#### 1.2 如何写一个会过期的localStorage，说说想法

**参考答案**：

**两种方案：惰性删除 和 定时删除**

**惰性删除**

惰性删除是指，某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。我们先来简单实现一下：

```js
    var lsc=(function(self){
      var prefix="one_more_lsc_";
      /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
      self.set=function(key,val,expires){
        key=prefix+key;
        val=JSON.stringify({'val':val,'expires':new Date().getTime()+expires*1000});
        localStorage.setItem(key,val);
      };
      /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
      self.get=function(key){
        key=prefix+key;
        var val=localStorage.getItem(key);
        if (!val) {
          return null;
        }
        val=JSON.parse(val);
          //检查是否过期
        if (val.expires<new Date().getTime()) {
          localStorage.removeItem(key);
          return null;
        }
        return val.val;
      };
      return self;
    }(lsc || {}));

//测试
    lsc.set("kop","66",10);
    console.log(lsc.get("kop"));
    setTimeout(()=>{
      console.log(lsc.get("kop"));
    },12000);
```

上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。

**定时删除**

定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。

每隔一秒执行一次定时删除，操作如下：

1. 随机测试20个设置了过期时间的key。
2. 删除所有发现的已过期的key。
3. 若删除的key超过5个则重复**步骤1**，直至重复500次。

具体实现如下：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>测试</title>
<style type="text/css">
  
</style>
</head>
<body>
<div>
    <button onclick="openLink()">打开</button>
</div>
<script type="text/javascript">
    var lsc=(function(self){
      var list=[];
      var prefix="one_more_lsc_";

      //初始化list
      self.init=function(){
        var keys=Object.keys(localStorage);
        var reg=new RegExp("^"+prefix);
        var temp=[];
        //遍历所有localStorage中的所有key
        for(let i=0;i<keys.length;i++){
          //找出可过期缓存的key
          if (reg.test(keys[i])) {
            temp.push(keys[i]);
          }
        }
        list=temp;
      };

      self.init();
      
      /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
      self.set=function(key,val,expires){
        key=prefix+key;
        val=JSON.stringify({'val':val,'expires':new Date().getTime()+expires*1000});
        localStorage.setItem(key,val);
      };
      /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
      self.get=function(key){
        key=prefix+key;
        var val=localStorage.getItem(key);
        if (!val) {
          return null;
        }
        val=JSON.parse(val);
        if (val.expires<new Date().getTime()) {
          localStorage.removeItem(key);
          return null;
        }
        return val.val;
      };

      self.check=function(){
        if (!list || list.length===0) {
          return;
        }
        let checkCount=0;
        while(checkCount<500){
          let expireCount=0;
          //随机测试20个设置了过期时间的key
          for(let i=0;i<20;i++){
            if (list.length===0) {
              break;
            }
            let index=Math.floor(Math.random()*list.length);
            let key=list[index];
            let val=localStorage.getItem(key);
            //从list中删除被惰性删除的key
            if (!val) {
              list.splice(index,1);
              expireCount++;
              continue;
            }
            val=JSON.parse(val);
            ///删除所有发现的已过期的key
            if (val.expires<new Date().getTime()) {
              list.splice(index,1);
              localStorage.removeItem(key);
              expireCount++;
            }
          }
          //若删除的key不超过5个则跳出循环
          if (expireCount<=5 || list.length===0) {
            break;
          }
          checkCount++;
        }
      }
      //每隔一秒执行一次定时删除
      window.setInterval(self.check,1000);
      return self;
    }(lsc || {}));
    /*
    for (let i=1;i<200;i++){
      lsc.set("key"+i,i.toString(),Math.random()*10);
    }
    */
    for (let i=1;i<200;i++){
      console.log(lsc.get("key"+i));
    }
    
</script>

</body>
</html>

```

-----

#### 1.4 localStorage 能跨域吗

**参考答案**：

不能

解决方案：

- 通过postMessage来实现跨源通信
- 可以实现一个公共的iframe部署在某个域名中，作为共享域
- 将需要实现localStorage跨域通信的页面嵌入这个iframe
- 接入对应的SDK操作共享域，从而实现localStorage的跨域存储

![localStorage跨域](E:\pogject\学习笔记\image\js\localStorage跨域.png)

----

#### 1.5 memory cache 如何开启

**参考答案**：

memory cache 如何开启是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉。如果真的不想使用缓存，可以设置no-store，这样，即便是内存缓存，也不会生效。

---

#### 1.6 localstorage的限制

**参考答案**：

1. 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性
2. 目前**所有的浏览器中都会把localStorage的值类型限定为string类型**，这个在对我们日常比较常见的JSON对象类型需要一些转换
3. localStorage在浏览器的隐私模式下面是不可读取的
4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
5. localStorage不能被爬虫抓取到

---

#### 1.7 浏览器输入URL发生了什么

**参考答案**：

1. URL 解析
2. DNS 查询
3. TCP 连接
4. 处理请求
5. 接受响应
6. 渲染页面

-----

#### 1.8 浏览器如何渲染页面的？

**参考答案**：

**可以分析出基本过程：**

1. HTML 被 HTML 解析器解析成 DOM 树；

2. CSS 被 CSS 解析器解析成 CSSOM 树；

- 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
- 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
- 将布局绘制(paint)在屏幕上，显示出整个页面。
- 不同的浏览器内核不同，所以渲染过程不太一样。

WebKit 主流程

![WebKit 主流程](E:\pogject\学习笔记\image\js\WebKit 主流程.png)

Mozilla 的 Gecko 呈现引擎主流程

![Mozilla 的 Gecko 呈现引擎主流程](E:\pogject\学习笔记\image\js\Mozilla引擎主流程.png)

Mozilla 的 Gecko 呈现引擎主流程

由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。
Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它 由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。

HTML的整个文件的加载过程







---

#### 1.9 重绘、重排区别如何避免

**参考答案**：

1. 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

2. 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等

3. 区别：**重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）**

4. 引发重排

   4.1 添加、删除可见的dom

   4.2 元素的位置改变

   4.3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)

   4.4 页面渲染初始化

   4.5 浏览器窗口尺寸改变

   4.6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。

5. 优化：

   **浏览器自己的优化**：

   浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘

   **减少 reflow/repaint**：
   （1）不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。

   （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
   （3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
   （4）**千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局**。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)

   （5）不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）

------

---

#### 1.12 浏览器垃圾回收机制

**参考答案：**

**1. 介绍**

浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以**垃圾回收器会按照固定的时间间隔周期性的执行**。

不再使用的变量也就是生命周期结束的变量，**当然只可能是局部变量**，全局变量的生命周期直至浏览器卸载页面才会结束。**局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值**，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

还是上代码说明吧：

```js
function fn1() {
    var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
    var obj = {name:'hanzichi', age: 10};
    return obj;
}

var a = fn1();
var b = fn2();
```

我们来看代码是如何执行的。首先定义了两个function，分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: 'hanzichi', age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量是没有用的？**所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存**。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。引用计数不太常用，标记清除较为常用。

**2. 标记清除**

js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

```js
function test(){
	var a = 10 ;             //被标记 ，进入环境 
	var b = 20 ;             //被标记 ，进入环境
}
test();                     //执行完毕 之后 a、b又被标离开环境，被回收。
```

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（**闭包**）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

**3. 引用计数**

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

```js
function test(){
    var a = {} ;         //a的引用次数为0 
    var b = a ;         //a的引用次数加1，为1 
    var c =a;           //a的引用次数再加1，为2
    var b ={};          //a的引用次数减1，为1
}
```

Netscape Navigator3是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

```js
function fn() {
    var a = {};
    var b = {};
    a.pro = b;
    b.pro = a;
}
fn();
```

以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，**如果fn函数被大量调用，就会造成内存泄露**。在IE7与IE8上，内存直线上升。

我们知道，IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的**COM对象依然是基于引用计数策略**的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.e = element;
element.o = myObject;
```

这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。

举个栗子：

```js
window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
};

```

这段代码看起来没什么问题，但是obj引用了document.getElementById('element')，而document.getElementById('element')的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug)

**解决办法：**

最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样

```js
myObject.element = null;
element.o = null;

window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
    obj=null;
};

```

**将变量设置为null意味着切断变量与它此前引用的值之间的连接。**当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。

要注意的是，**IE9+并不存在循环引用导致Dom内存泄露问题**，可能是微软做了优化，或者Dom的回收方式已经改变

#### 1.10 事件循环Event loop

**参考答案**：

主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为**事件循环**。此机制具体如下: 主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。

**详细步骤**：

1.  选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。
2. 事件循环的当前运行宏任务设置为已选择的宏任务。
3. 运行宏任务。
4. 将事件循环的当前运行任务设置为null。
5. 将运行完的宏任务从宏任务队列中移除。
6. microtasks步骤：进入microtask检查点。
7. 更新界面渲染。
8. 返回第一步。

**执行进入microtask检查的的具体步骤如下:**

1. 设置进入microtask检查点的标志为true。
2. 当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。
3. 对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。
4. 清理indexedDB的事务。
5. 设置进入microtask检查点的标志为false。

需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。**同一次事件循环中, 微任务永远在宏任务之前执行。**

![事件循环Eventloop](E:\pogject\学习笔记\image\js\事件循环Eventloop.png)



----

#### 1.11 let a = "sssssss"，存在哪儿？

**参考答案**：

使用let声明的全局变量不是挂在window对象下的，**声明的全局变量存在于一个块级作用域中**。

具体查看，我们可以通过打印一个全局函数，在let声明的全局变量在全局函数的scope下，我们平时使用时直接 用变量名称就能访问到

具体位置如下图：

![let变量存储](E:\pogject\学习笔记\image\js\let变量存储.png)





**4. 内存管理**

#### **4.1 什么时候触发垃圾回收？**

垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。

微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，**如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍**，如果回收的内存高于85%，说明大部分内存早就该清理了，**这时候把触发条件置回。这样就使垃圾回收工作职能了很多**

**4.2 合理的GC方案**

**1. 基础方案**

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：

1. 遍历所有可访问的对象。
2. 回收已不可访问的对象。

**2. GC的缺陷**

和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

**3. GC优化策略**

David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了：

1. **分代回收**（Generation GC） 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：

	![分代回收](E:\pogject\学习笔记\image\js\分代回收.png)

这里需要补充的是：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。

2. **增量GC** 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图：

![增量GC](E:\pogject\学习笔记\image\js\增量GC.png)

这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。

比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。

------

#### 1.14 token 能放在cookie中吗

**参考答案**：

能

**解析**：

- token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。
- **「简单 token 的组成」**:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）

**token认证流程**

![token认证流程](E:\pogject\学习笔记\image\js\token认证流程.png)

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端签发一个 token ，并把它发送给客户端
4. 客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. 客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）
6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据

------

#### 1.15 js如何获取/禁用cookie

**参考答案**：

**js如何获取cookie**

假设cookie中存储的内容为：name=jack;password=123

则在B页面中获取变量username的值的JS代码如下：

```html
<script type="text/javascript">
    //arusername=document.cookie.split(";")[0].split("=")[1];

    //JS操作cookies方法!
    //写cookies
    function setCookie(name,value){
      let days=30;
      let expires=new Date();
      expires.setTime(expires.getTime()+days*24*60*60*1000);
      document.cookie=name+"="+escape(value)+";"+"expires="+expires.toGMTString();
    }
    
    //读取cookies
    function getCookie(name){
      let arr;
      let reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)");
      if (arr=document.cookie.match(reg)) {
        return unescape(arr[2]);
      }else{
        return null;
      }
    }

    //setCookie("kop",66);
    console.log(getCookie("kop"));
</script>
```

---

#### 1.16 cookie

**参考答案**：

**1. cookie 是什么？**

- cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。
- **实际上 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名**，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。
- 不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。

> PS：cookie 和 session 都能保存计算机中的变量，但是 session 是运行在服务器端的，而客户端我们只能通过 cookie 来读取和创建变量

**2. cookie 能做什么？**

- 用户在第一次登录某个网站时，要输入用户名密码，如果觉得很麻烦，下次登录时不想输入了，那么就在第一次登录时将登录信息存放在 cookie 中。下次登录时我们就可以直接获取 cookie 中的用户名密码来进行登录。

  > PS:虽然 浏览器将信息保存在 cookie 中是加密了，**但是可能还是会造成不安全的信息泄露**

- 类似于购物车性质的功能，第一次用户将某些商品放入购物车了，但是临时有事，将电脑关闭了，下次再次进入此网站，我们可以通过读取 cookie 中的信息，恢复购物车中的物品。

  > PS：实际操作中，这种方法很少用了，基本上都是将这些信息存储在数据库中。然后通过查询数据库的信息来恢复购物车里的物品

- 页面之间的传值。在实际开发中，我们往往会通过一个页面跳转到另外一个页面。后端服务器我们可以通过数据库，session 等来传递页面所需要的值。但是在浏览器端，我们可以将数据保存在 cookie 中，然后在另外页面再去获取 cookie 中的数据。

  > PS：这里要注意 cookie 的时效性，不然会造成获取 cookie 中数据的混乱。

**3. 怎么使用 cookie？**

- 语法

  ```js
  document.cookie = "name=value;expires=evalue; path=pvalue; domain=dvalue; secure";
  ```

- 对各个参数的解释

1. **name=value** 必选参数

这是一个键值对，分别表示要存入的 属性 和 值。

比如：

```js
document.cookie="name=中文";
//为了防止中文乱码，我们可以使用encodeURIComponent()编码；decodeURIComponent()解码
document.cookie = encodeURIComponent("name")+"="+encodeURIComponent("中文");

```

2. **expires=evalue** 可选参数

该对象的有效时间（可选）**只支持GTM 标准时间，即要将时间转换**，toUTCString()（默认为当前浏览器 会话有用，关闭浏览器就消失）;

比如：

```js
var date = new Date(); 　
date.setTime(date.getTime()+2000);//获取当前时间并加上 2 秒钟 　
alert(date.toUTCString());//格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果
alert(date.toGMTString());//与上面的结果一样，但是这个方法已经被上面取代了 
document.cookie="name=vae;expires="+date.toUTCString(); 
alert(document.cookie); // name=vae 　
setTimeout(function(){alert(document.cookie)},4000);//4 秒后打印空的字符串
```

3. **path=pvalue** 可选参数

限制访问 cookie 的目录，默认情况下对于当前网页所在的同一目录下的所有页面有效

4. **domain=dvalue** 可选参数

用于限制只有设置了的域名才可以访问；如果没有设置，则默认在当前域名访问

比如设置 test*.com 表示域名为test*.com的服务器共享该Cookie

5. **secure=true|false** 可选参数，默认是 true 不安全传输

安全设置，指明必须通过 安全的通信通道来传输（https) 才能获得 cookie,  **true 不安全**，默认值；**false 安 全，必须通过 https 来访问**

**比如：如果你设置 document.cookie = "name=vae;secure"**

上面的代码如果是在 http 的协议中访问，那么是访问不了的

```js
　　　　　　　//设置 cookie
            function setCookie(objName, objValue, objHours){//添加cookie
                var str = objName + "=" + encodeURIComponent(objValue);
                if (objHours > 0) {//为0时不设定过期时间，浏览器关闭时cookie自动消失
                    var date = new Date();
                    var ms = objHours * 3600 * 1000;
                    date.setTime(date.getTime() + ms);
                    str += "; expires=" + date.toUTCString();
                }
                document.cookie = str;

            }
            //获取 cookie
            function getCookie(objName){//获取指定名称的cookie的值
                //多个cookie 保存的时候是以 ;空格  分开的
                var arrStr = document.cookie.split("; ");
                for (var i = 0; i < arrStr.length; i++) {
                    var temp = arrStr[i].split("=");
                    if (temp[0] == objName){
                        return decodeURIComponent(temp[1]);
                    }else{
                        return "";
                    }

                }
            }

            //为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间
            function delCookie(name){
                var date = new Date();
                date.setTime(date.getTime() - 10000);
                document.cookie = name + "=a; expires=" + date.toUTCString();
            }

```

注意：

（1）**cookie可能被禁用**。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；

（2）cookie是与浏览器相关的。这意味着即使访问的是同一个页面，**不同浏览器之间所保存的cookie也是不能互相访问的**；

（3）**cookie可能被删除**。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；

（4）**cookie安全性不够高**。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。

（5）cookie 在保存时，只要后面保存的 name 相同，那么就会覆盖前面的 cookie，**注意是完全覆盖**，包括失效时间，pat

---

#### 1.17 cookie 禁用

**参考答案**：

**问题描述：**

sessionID通过cookie保存在客户端，如果将cookie禁用，必将对session的使用造成一定的影响。

**解决这个问题的办法是**：URL重写

**URL重写**

1. servlet中涉及向客户端输出页面元素的时候，可以在相应的请求地址外面包上一层方法，也就是说使用response.encodeURL(“请求地址”);为请求地址添加一个JSESSIONID的值
2. servlet中涉及跳转到新的页面时，可以使用response.encodeRedirectURL(“请求地址”);为请求地址添加一个JSESSIONID的值

---

#### 1.18 调试工具

**参考答案**：

**谷歌浏览器自带的调试工具：**

1. Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。
2. console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。
3. Sources：**断点调试JS**，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。
4. Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“小编有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。
5. Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。
6. Application：记录网站加载的各个资源信息。
7. Security：判断网页是否安全。
8. Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。

**Postman**

地址：https://www.postman.com/

几乎所有前端应用程序都发送和接收JSON响应和请求。 应用程序通过请求 API 可以做很多事情，例如身份验证，用户数据传输，甚至是一些简单的事情，例如获取所在位置的当前天气。

Postman 是调试接口的最佳工具之一。 它适用于 **MacOS**，**Windows** 和**Linux**的系统， 可以快速轻松地直接发送**REST**，**SOAP**和**GraphQL**请求。

使用 Postman，我们可以调整请求，分析响应和调试问题。 当不确定问题出在前端还是后端时，这是很有帮助的。

**CSS Lint**

地址： http://csslint.net/

**CSSLint** 是一个用来帮你找出 CSS 代码中问题的工具，它可做基本的语法检查以及使用一套预设的规则来检查代码中的问题，规则是可以扩展的。

**JSON Formatter & Validator**

地址：https://jsonformatter.curiousconcept.com/

在未格式化的 JSON 中很难发现语法错误或键值不正确的键，因为它很难读取。 对于 压缩的 JSON 文件，要发现其中的错误是比较难的，所以我们需要一种格式化的工具。

JSON Formatter & Validator tool 就是一个格式化 JSON 的工具，只需输入压缩的JSON格式，就能获得正确格式。该工具也可以验证 JSON 到 RFC 标准。

**Sentry**

地址：https://sentry.io/welcome/

无论测试如何完善的程序，bug总是免不了会存在的，有些bug不是每次都会出现，测试时运行好好的代码可能在某个用户使用时就歇菜了，可是当程序在用户面前崩溃时，你是看不到错误的，当然你会说:”Hey, 我有记日志呢”。 但是说实话，程序每天每时都在产生大量的日志，而且分布在各个服务器上，并且如果你有多个服务在维护的话，日志的数量之多你是看不过来的吧。等到某天某个用户实在受不了了，打电话来咆哮的时候，你再去找日志你又会发现日志其实没什么用：缺少上下文，不知道用户什么操作导致的异常，异常太多（从不看日志的缘故）不知如何下手 等等。

**Sentry**就是来帮我们解决这个问题的，它是是一个实时事件日志记录和聚合平台。它专门用于监视错误和提取执行适当的事后操作所需的所有信息, 而无需使用标准用户反馈循环的任何麻烦。

Sentry是一个日志平台, 它分为客户端和服务端，客户端(目前客户端有Python, PHP,C#, Ruby等多种语言)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web节目方便查看。**Sentry** 由 python 编写，源码开放，性能卓越，易于扩展，目前著名的用户有Disqus, Path, mozilla, Pinterest等。

**JSHint**

地址：https://jshint.com/

JSHint 是一个 Javascript 代码分析检测工具，不仅可以帮助我们检测到 JS 代码错误和潜在问题，也能帮助我们规范代码开发。

**JSHint** 扫描一个用JavaScript编写的程序，并报告常见的错误和潜在的bug。潜在的问题可能是语法错误、隐式类型转换导致的错误、泄漏变量或其他完全的问题。

**BrowserStack**

地址：https://www.browserstack.com/

现在拥有各自内核的浏览器越来越多，各自的特性也千差万别。如果作为一个前端工程师想要检测网站在不同的操作系统和移动平台下的各种浏览器的兼容性，那是相当痛苦不堪的。看到有在自己电脑上装虚拟机配置各种环境，有自己的电脑上组建好这样的环境，然后一一测试，可是人的精力毕竟有限，我们没法在同一台电脑上装那么多系统，那么多浏览器的。幸好出了个 BrowserStack 是前端的福音呀。

BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备很多虚拟机或者手机模拟器。

**BrowserStack** 是一个提供网站浏览器兼容性测试的在线云端应用，支持9大操作系统上的100多款浏览器。支持本地测试，支持与Visual Studio集成。或者你也可以直接前往 [http://modern.ie](http://modern.ie/) 在线测试，现在注册可以免费试用三个月，三个月后是收费的，三个月后要是你想用又不想付费作为天朝的开发者你懂得。

-----

# webAPI

------

#### 13.1 window.open

**参考答案：**

这个方法是用来打开新窗口的

1. 最基本的弹出窗口

   ```js
   window.open('page.html');
   ```

2. 经过设置后的弹出窗口

   ```js
    window.open('page.html', 'newwindow', 'height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no')   
      //该句写成一行代码
      //参数解释：
      // window.open 弹出新窗口的命令； 
   　　//'page.html' 弹出窗口的文件名； 
   　　//'newwindow' 弹出窗口的名字（不是文件名），非必须，可用空''代替； 
   　　//height=100 窗口高度； 
   　　//width=400 窗口宽度； 
   　　//top=0 窗口距离屏幕上方的象素值； 
   　　//left=0 窗口距离屏幕左侧的象素值； 
   　　//toolbar=no 是否显示工具栏，yes为显示； 
   　　//menubar，scrollbars 表示菜单栏和滚动栏。 
   　　//resizable=no 是否允许改变窗口大小，yes为允许； 
   　　//location=no 是否显示地址栏，yes为允许； 
   　　//status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许
   ```

   

3. 用函数控制弹出窗口

   ```html
    <html> 
   　　<head> 
   　　<script LANGUAGE="JavaScript"> 
   　　<!-- 
   　　function openwin() { 
   　　window.open ("page.html", "newwindow", "height=100, width=400, toolbar =no, menubar=no, scrollbars=no, resizable=no, location=no, status=no") //写成一行
   　　} 
   　　//--> 
   　　</script> 
   　　</head> 
   　　<body οnlοad="openwin()"> 
   　　任意的页面内容... 
   　　</body> 
   　　</html> 
   ```

   解释：这里定义了一个函数openwin(), 函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？ 

   方法一：<body οnlοad="openwin()"> 浏览器读页面时弹出窗口； 

   方法二：<body οnunlοad="openwin()"> 浏览器离开页面时弹出窗口； 

   方法三：用一个连接调用： <a href="#" οnclick="openwin()"> 打开一个窗口 注意：使用的"#"是虚连接。 

   方法四：用一个按扭调用： <input type="button" οnclick="openwin()" value="打开窗口" />

4. 弹出两个窗口

   ```html
   <script LANGUAGE="JavaScript"> 
   　　<!-- 
   　　function openwin() { 
   　　window.open ("page.html", "newwindow", "height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=n o, status=no")//写成一行 
   　　window.open ("page2.html", "newwindow2", "height=100, width=100, top=100, left=100,toolbar=no, menubar=no, scrollbars=no, resizable=no, loca tion=no, status=no")//写成一行 
   　　} 
   　　//--> 
   </script>
   ```

   为避免弹出的2个窗口覆盖，用top和left控制一下弹出的位置不要相互覆盖即可。最后用上面的说过的四种方法调用即可。 注意：2个窗口的name(newwindow与 newwindow2)不要相同，或者干脆全部为空。

5. 主窗口打开文件1.htm，同时弹出小窗口page.html

   ```js
    function openwin(){
        window.open("page.html","","width=200,height=200") 
    } 
   ```

   ```html
      //加入body区：
    <a href="1.htm" οnclick="openwin()">open</a>即可。
   ```

6. 弹出的窗口之定时关闭控制

   将一小段代码加入弹出的页面（注意是加入page.html的HTML中，可不是主页面中，否则......），让它在10秒后自动关闭

   ```js
    function closeit(){
       setTimeout("selft.close()", 10000)   //毫秒
    }
   ```

   ```html
   <body οnlοad="closeit()">
   ```

7. 在弹出窗口中加上一个关闭按扭

   ```html
   <input type="button" value="关闭" οnclick="window.close()">
   ```

   

8. 内包含的弹出窗口---一个页面两个窗口

   上面的例子都包含两个窗口，一个是主窗口，另一个是弹出的小窗口。通过下面的例子，你可以在一个页面内完成上面的效果

   ```html
   <html> 
   　　<head> 
   　　<SCRIPT LANGUAGE="JavaScript"> 
   　　function openwin() 
   　　{ 
   　　OpenWindow=window.open("", "newwin", "height=250, width=250,toolbar=no ,scrollbars="+scroll+",menubar=no"); 
   　　//写成一行 
   　　OpenWindow.document.write("<TITLE>例子</TITLE>") 
   　　OpenWindow.document.write("<BODY BGCOLOR=#ffffff>") 
   　　OpenWindow.document.write("<h1>Hello!</h1>") 
   　　OpenWindow.document.write("New window opened!") 
   　　OpenWindow.document.write("</BODY>") 
   　　OpenWindow.document.write("</HTML>") 
   　　OpenWindow.document.close() 
   　　} 
   　　</SCRIPT> 
   　　</head> 
   　　<body> 
   　　<a href="#" οnclick="openwin()">打开一个窗口</a> 
   　　<input type="button" οnclick="openwin()" value="打开窗口"> 
   　　</body> 
   　　</html> 
   
   ```

   

9. 终极应用---弹出的窗口这Cookie控制

   ```js
    function openwin(){ 
   　　window.open("page.html","","width=200,height=200") 
    } 
    function get_cookie(Name){
       var search=Name+"=";
       var returnvalue="";
       if(document.cookie.length>0){
   　　    if (offset != -1) { 
   　　      offset += search.length 
   　　      end = document.cookie.indexOf(";", offset); 
   　　      if (end == -1) 
   　　       end = document.cookie.length; 
   　　        returnvalue=unescape(document.cookie.substring(offset, end));
             }
        }
        return returnvalue;
    }
    function ladpopup(){
       if(get_cookie('popped=yes')){
         openwin()
         document.cookie="popped=yes";
       }
   }
   
   ```

   ```html
   <body οnlοad="loadpopup()">
   ```

   ---

   

#### 13.2 实现 Eventemitter 类，有on、emit、off 方法

**参考答案：**

1. on(event,fn)：监听event事件，事件触发时调用fn函数；
2. once(event,fn)：为指定事件注册一个单次监听器，单次监听器最多只触发一次，触发后立即解除监听器；
3. emit(event,arg1,arg2,arg3...)：触发event事件，并把参数arg1,arg2,arg3....传给事件处理函数；
4. off(event,fn)：停止监听某个事件

```js
class EventEmitter{
    constructor(){
        this._events={};
    }
    on(event,callback){  //监听event事件，触发时调用callback函数
        let callbacks=this._events[event] || [];
        callbacks.push(callback);
        return this;
    }
    off(event,callback){  //停止监听event事件
        let callbacks=this._events[event];
        this._events[event]=callbacks && callbacks.filter(fn=>fn!==callback);
        return this;
    }
    emit(...args){  //触发事件，并把参数传给事件的处理函数
        const event=args[0];
        const params=[].slice.call(args,1);
        const callbacks=this._events[event];
        callbacks.forEach(fn=>fn.apply(this.params));
        return this;
    }
    once(event,callback){  //为事件注册单次监听器
        let wrapFanc=(...args)=>{
            callback.apply(this.args);
            this.off(event,wrapFanc);
        }
        this.on(event,wrapFanc);
        return this;
    }
}
```

------

#### 13.3 查找给定的两个节点的第一个公共父节点

**参考答案**：

**解题思路**

递归循环树的节点，因二叉树不能重复的特性,当前节点为 p or q ，返回当前节点 父节点循环中，如果找到一个，则查找其他子树 其他子树没有找到另外一个，就证明当前节点为找到的子树是最近公共祖先 两个都找到了，对应当前节点是两个节点的父节点这种情况，则返回当前节点。 代码

```js
var lowestCommonAncestor = function(root, p, q) {
	if (!root || root === p || root === q) return root
    let left = lowestCommonAncestor(root.left, p, q)
    let right = lowestCommonAncestor(root.right, p, q)
    if (!left) return right
    if (!right) return left
    return root
};
```

-----

###   **3.** **cookie、localStorage、sessionStorage区别？**

cookie是服务器发给客户端的一种特殊认证信息，通常以文本的方式保存在客户端，始终在同源的http请求中携带（即使不需要），以供服务器验证当前浏览器用户身份，常见应用场景：验证用户身份、保存上次登录信息、统计浏览次数

sessionStorage和localStorage仅用于本地保存，不会自动把数据发给服务器

|                | 有期时间                                           | 作用域                                                       | 存储大小                           | 存储位置 |
| -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | -------- |
| cookie         | 在过期时间前一直有效（即使浏览窗口器关闭）         | domain本身以及domain下的所有子域名（跨域请求的 cookie在fetch时需要设置 withCredentials） | 不能超过4k                         | 浏览器端 |
| localStorage   | 长期存储，浏览器窗口关闭数据不丢失（除非主动删除） | 所有同源窗口共享                                             | 虽有存储大小限制，但可达到5M或更大 |          |
| sessionStorage | 临时存储，当前浏览器窗口关闭后自动删除             | 不同浏览器窗口不共享                                         |                                    |          |

----

### **4.** **WebSocket协议及实现原理？**

HTTP协议有一个局限：通信只能由客户端发起，服务器端不能实时发送最新数据给客户端（具有被动性）

数据交互有两种模式：Push（推模式）、Pull（拉模式）

- Push：客户端与服务端建立好**网络长连接**，服务器有相关数据，直接通过长连接通道推送到客户端

- Pull：客户端主动向服务端**发出请求**，拉取相关数据


那怎么获取最新数据呢？ 传统有两种方式：轮询、长轮询

- 轮询：开启一个定时器，每隔一段时间调用Ajax请求一次数据


- 长轮询：本质也是轮询，不过是阻塞型（一直打电话，没收到就不挂电话），客户端发起连接后，如果没消息，就一直不返回Response给客户端，直到有消 息才返回或超时。基于事件的触发，一个事件接一个事件。


而**WebSocket协议只需要发送一次请求**，只要服务器有最新数据就会自动发送给客户端，不用重复请求（类似天气预报，每当天气有变化则会自动更新最新天气状况）

**WebSocket协议没有同源限制，**客户端可与任意服务器通信，可用于解决跨域

实现原理：

WebSocket是一个应用层协议，必须依赖 HTTP 协议进行第一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 再无关联。WebSocket进行了**HTTP握手 + 双工的TCP数据传输**

协议以frame形式传输数据，会将一条消息分为几个frame，按照先后顺序传输。大数据可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况，可以边生成数据边传递消息，传输效率高

```js
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

```

---



----

## 1.3 请问你了解浏览器的渲染机制？

首先，浏览器的渲染机制中有几个基本概念名称：

（1）、DOM：浏览器将HTML解析成树形的数据结构

```
文档对象模型 (DOM) 将 web 页面与到脚本或编程语言连接起来。通常是指  JavaScript，但将 HTML、SVG 或 XML 文档建模为对象并不是 JavaScript 语言的一部分。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM的方法(methods)让你可以用特定方式操作这个树，用这些方法你可以改变文档的结构、样式或者内容。节点可以关联上事件处理器，一旦某一事件被触发了，那些事件处理器就会被执行。
```

（2）、CSSOM：浏览器将CSS解析成树形的数据结构

```
CSS 对象模型 (CSSOM) 是树形形式的所有CSS选择器和每个选择器的相关属性的映射，具有树的根节点，同级，后代，子级和其他关系。CSSOM 与 文档对象模型(DOM) 非常相似。两者都是关键渲染路径的一部分，也是正确渲染一个网站必须采取的一系列步骤。

CSSOM 与 DOM一起构建渲染树，浏览器依次使用渲染树来布局和绘制网页。

CSS 对象模型也是一组API，允许从JavaScript 操纵 CSS。它非常类似于DOM，但应用于 CSS 而不是 HTML。它允许用户动态读取和修改 CSS样式。
```

（3）、Render Tree：DOM和CSSOM合并后生成Render Tree（渲染树）

（4）、Layout：计算出Render Tree每个节点的具体位置置

（5）、Painting：通过显卡，将Layout后的节点内容分别呈现到屏幕上

浏览器整个渲染流程如下：

（1）、用户输入一个URL后，浏览器就会向服务器发出一个请求，请求URL对应的资源

（2）、接到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一颗DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点

（3）、将CSS解析成CSSOM树

（4）、根据DOM树与CSSOM树，构建Render Tree

（5）、浏览器会根据Render Tree能知道网页中哪些有节点，各个节点的CSS，以及各个节点的从属关系

（6）、计算出每个节点在屏幕中的位置后，最后一步就是Painting，根据计算出的规则，把内容画到屏幕上

![img](https://uploadfiles.nowcoder.com/images/20211008/897353_1633683890278/9F4F2AB266BD95CA60C23F32300F594A)

注意：

浏览器在获得HTML文件后，是自上而下的加载，并在加载过程中进行解析与渲染

加载过程中：

遇到外部CSS文件和图片等静态资源时，浏览器会另外发送一个异步请求

遇到js文件时，HTML文件会挂起渲染的进程，等待js文件加载完毕后，再继续进行渲染，因为js可能会修改DOM，导致后续HTML资源白白加载，这也是为什么建议将js文件写在底部body标签前

----

## 1.4 请问如何解决浏览器加载js时的阻塞问题吗？

**（1）、推迟加载**

若页面初始的渲染并不依赖于js或CSS可以用推迟加载，最后在加载js和CSS，把引用外部文件的代码写在最后

**（2）、defer延迟加载**

```html
<script src="" defer></script>
```

在文档解析完成开始执行，并且在DOMContentLoaded事件之前执行完成，会按照在文档出现的顺序去下载解析，效果和把script放在文档最后</body>之前是一样

    注意：**defer最好用在引用外部文件中使用**，用了defer不要使用document.write()方法，使用defer时最好不要请求样式信息，因为样式表可能尚未加载，浏览器会禁止该脚本等待样式表加载完成，相当于样式表阻塞脚本执行

**（3）、异步加载**

async异步加载：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执行

```html
 <script type="text/javascript" src="a.js" async></script>
```

**（4）script dom element：**用js动态创建一个script元素添加在document中

注意：会阻止onload事件

```html
<script type="text/javascript">
    (function() {
     var s = document.createElement('script');
     s.type = 'text/javascript';
     s.async = true;                   //这句可以删除，但是效果不变。
     s.src = 'js/a.js';
     var x = document.getElementsByTagName('script')[0];
     x.parentNode.insertBefore(s, x);
 })();
</script>
```

**（5）onload时异步加载：**与script dom element法差不多，但不是同时执行js和html，是等html的文件、图片之类的、页面所有的资源全部加载完成后再下载执行js，这样的方法可以避免阻塞onload事件的触发

**注意：**DOMContentLoaded与onload事件不同，DOMContentLoaded是页面解析完成，页面的dom元素可以使用，但是页面的图片、视频等资源可能还没加载完成

----

## 1.5 请问你了解什么是重绘？什么是回流？两者有何区别？

**重绘：**

更换某个元素颜色，这样的行为是不影响页面布局，DOM树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染

常见情况：

（1）、回流必定引发重绘，但重绘也会单独触发

（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）

**回流：**

增删DOM节点，或修改一个元素的宽高，页面布局发生变化，DOM树结构发生变化，需要重新构建DOM树，而DOM树与渲染树是紧密相连的，DOM树构建完，渲染树也会随之对页面进行再次渲染

**常见情况：**

（1）、页面渲染初始化

（2）、DOM树变化（添加或者删除可见的DOM元素、元素位置改变）

（3）、Render树变化（元素尺寸改变：边距、填充、边框、宽度和高度）

（4）、浏览器窗口尺寸改变，resize事件发生

（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；

（6）、查询布局信息，包括offestLeft/Top/Width/Height、scrollLeft/Top/Width/Height、clientLeft/Top/Width/Height、浏览为了返回最新值，会触发回流

-----

## 2.1 请问在浏览器中输入 URL后，浏览器会做哪些工作？

从输入URL到渲染出整个页面包括三个部分：

**（1）、DNS解析URL**

DNS解析就是**寻找哪个服务器上有请求的资源**，因为ip地址不易记忆，一般会使用URL域名（如[www.baidu.com](http://www.baidu.com/)）作为网址，**DNS解析就是将域名“翻译”成IP地址**

具体过程：

a、浏览器缓存：浏览器会按照一定的频率，缓存DNS记录

b、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会去操作系统中找

c、路由缓存：路由器也有DNS缓存

d、ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求

e、根服务器：ISP的DNS服务器找不到，就要向根服务器发出请求，进行递归查询

**（2）、浏览器发送请求与服务器交互**

a、浏览器**利用tcp协议**通过三次握手与服务器建立连接

http请求包括header和body，header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie，body中有请求的内容

b、浏览器根据解析到的IP地址和端口号发起http的get请求

c、服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

d、若状态码为200显示响应成功，浏览器接收到返回的HTML页面后，开始渲染页面

**（3）、浏览器对接收到的HTML页面进行渲染**

a、浏览器根据**深度遍历**的方式把HTML节点遍历成DOM树

b、将CSS解析成CSSOM树

c、将DOM树和CSSOM树构造成Render树

d、根据Render树计算所有节点在屏幕中的位置，进行布局（回流）

e、遍历Render树并调用硬件API绘制所有节点（重绘）

----

## 简单描述从输入网址到页面显示的过程

很多大公司面试喜欢问这样一道面试题，输入URL到看见页面发生了什么？

简单来说，共有以下几个过程：

- DNS解析
- 发起TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束

下面我们来看看具体的细节。

## DNS解析

DNS解析实际上就是寻找你所需要的资源的过程。假设你输入www.baidu.com，而这个网址并不是百度的真实地址，互联网中每一台机器都有唯一标识的IP地址，这个才是关键，但是它不好记，乱七八糟一串数字谁记得住啊，所以就需要一个网址和IP地址的转换，也就是DNS解析。

DNS解析其实是一个递归的过程。

输入www.google.com网址后，首先在本地的域名服务器中查找，没找到去根域名服务器查找，没有再去com顶级域名服务器查找，，如此的类推下去，直到找到IP地址，然后把它记录在本地，供下次使用。大致过程就是.-> .com ->google.com. -> [www.google.com.。](http://www.google.com../) (最后这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上)

### DNS优化

既然已经懂得了解析的具体过程，我们可以看到上述一共经过了N个过程，每个过程有一定的消耗和时间的等待，因此我们得想办法解决一下这个问题！

- DNS缓存

DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

- DNS负载均衡

比如访问baidu.com的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡。

## 发起TCP连接

TCP提供一种可靠的传输，这个过程涉及到三次握手，四次挥手。

### 三次握手



![img](https://i.loli.net/2021/07/04/aG5WH4zdPXQnwpf.png)

预览



- 第一次握手：

客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

- 第二次握手：

服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

- 第三次握手：

客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

### 四次挥手

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，假设客户端主动关闭，服务器被动关闭。



![img](https://i.loli.net/2021/07/04/96LM2FZmOhRUxbP.png)

预览



- 第一次挥手：

客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。

FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- 第二次挥手：

服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

- 第三次挥手：

服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：

主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

至此，完成四次挥手。

## 发送HTTP请求

发送HTTP请求，就是构建HTTP请求报文，并通过TCP协议，发送到服务器指定端口。

请求报文由`请求行`，`请求报头`，`请求正文`组成。

## 服务器处理请求并返回HTTP报文

对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，比如Tomcat, Nginx和Apache等Web服务器。

HTTP报文也分成三段：`状态码`，`响应报头`和`响应报文`。

## 浏览器解析渲染页面



![img](https://i.loli.net/2021/07/04/kK39pXjgDdJ75Ux.png)

预览



这个图就是Webkit解析渲染页面的过程。

- 解析HTML形成DOM树
- 解析CSS形成CSSOM 树
- 合并DOM树和CSSOM树形成渲染树
- 浏览器开始渲染并绘制页面



---

## 2.2 请问你了解浏览器缓存吗？

缓存可以重复利用文件，降低网络负荷，提高网页打开速度，提升用户体验

缓存分类：

从宏观上分为**私有缓存**和**共享缓存**，共享缓存就是那些能被各级代理缓存的缓存，私有缓存就是用户专享的，各级代理不能缓存

从微观上可以分为以下几类：

a、浏览器缓存

b、代理服务器缓存

c、CDN缓存

d、数据库缓存

e、应用层缓存

主要对浏览器的缓存进行分析：

![img](https://uploadfiles.nowcoder.com/compress/mw1000/images/20211008/897353_1633685850116/826C8F1D891122B9999FE81E1D55CA33)

**（1）、HTTP缓存：主要分为强缓存与协商缓存**

- 强缓存

强可理解为强制的意思，当浏览器去请求某个文件的时候，**服务端就在respone header里面对该文件做了缓存配置**。缓存的时间、缓存类型都由服务端控制，具体由 respone header 的cache-control 控制，常见的设置是max-age public， private ，no-cache ，no-store等，各类设置对应情况：

a、cache-control: **max-age=xxxx，public**

**客户端和代理服务器都可以缓存该资源**，客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code200 ，如果用户做了刷新操作，就向服务器发起http请求

b、cache-control: **max-age=xxxx，private**

**只让客户端可以缓存该资源**；代理服务器不缓存，客户端在xxx秒内直接读取缓存，statu code:200

c、cache-control: **max-age=xxxx，immutable**

客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code:200 ，**即使用户做了刷新操作，也不向服务器发起http请求**

d、cache-control: **no-cache**

跳过设置强缓存，**但不妨碍设置协商缓存**；通常做了强缓存，只有强缓存失效了才走协商缓存的，**设置了no-cache就不会走强缓存了，每次请求都回询问服务端**

e、cache-control: no-store

**不缓存**，客户端、服务器都不缓存

- 协商缓存

可理解为**强缓存就是为资源设置一个有效时间，每次请求资源时都会检查是否过期，只有过期才会去请求服务器**（可有效减少请求次数），当强制缓存失效后，浏览器携带**缓存标识**向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程协商缓存生效，返回304和Not Modified

在 response header里面的设置etag、last-modified

**etag**：每个文件具有唯一一个“标识”

**last-modified**：文件的修改时间，精确到秒

每次请求返回携带**response header**中的etag和last-modified，在下次请求时**request header**也会带上，服务端对比etag标识，判断资源是否更改，**如更改直接返回新的资源**，**并更新response header的etag、last-modified**，如资源不变，etag、last-modified不变，**对客户端来说，每次请求都进行了协商缓存**，即：

发请求-->资源是否过期？-->过期（没过期为强缓存）-->请求服务器-->服务器对比资源是否真的过期？-->没过期-->返回304状态码-->客户端用缓存的老资源

当服务端发现资源过期时：

服务器对比资源是否真的过期-？->过期-->返回200状态码-->客户端像第一次接收该资源一样，记录cache-control中的max-age、etag、last-modified等信息

**（2）、本地存储**

主要有：localStorage，sessionStorage和cookie，WebSql和IndexDB主要用在前端有**大容量存储需求的页面上**，如在线编辑浏览器或者网页邮箱，可以将数据存储在浏览器，应该根据不同的场景进行使用

- Cookie

**由服务器生成，且前端也可设置**，保存在客户端本地的一个文件，通过response header的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器

其中包含的信息：

a、用户ID、密码、浏览过的网页、停留的时间等信息，当该用户再打开该网站时，网站通过读取Cookie，就可以做出相应的动作，如身份校验、提示语等

b、还保存host属性，即网站的域名或ip，一个网站只能读取它自己放置的信息，不能读取其他网站的Cookie文件

Cookie **优点**：给用户更人性化的使用体验，如自动登陆、提示语；**弥补了HTTP无连接特性**；可作为站点统计访问量依据

Cookie **缺点**：无法解决多人共用电脑问题，具有安全隐患；Cookie文件容易被误删除；可人为修改host文件，可以非法访问目标站点的Cookie；容量较小，不能超过4kb；直接在response header上带数据安全性差

- LocalStorage（本地存储）

主要是开发人员在前端设置，一旦数据保存在本地后，就可避免再向服务器请求数据，从而减少不必要的数据请求，可以长期存储数据，没有时间限，遵循同源策略，不同的网站不能直接共用

一般浏览器localStorage支持的是5M大小，不同的浏览器会略有不同

LocalStorage **优点**：拓展了Cookie的4k限制；可以将第一次请求的5M大小数据直接存储到本地，相比于Cookie节约带宽

LocalStorage **缺点**：需要手动删除，否则长期存在；浏览器大小不一，版本的支持也不一样；**只支持string类型的存储**，JSON对象需要转换；本质上是对字符串的读取，存储内容过多会消耗内存空间，导致卡顿

- SessionStorage（会话存储）

同样是开发人员在前端设置，用于**临时保存同一窗口(或标签页)的数据**，在关闭窗口或标签页之后将会删除这些数据，大多数浏览器限制为5MB

- WebSQL

WebSQL 是在浏览器上模拟数据库，可以使用JS来操作SQL进行数据读写，使用 SQL 来操纵客户端数据库的 API（**异步**），现阶段使用较少

- IndexedDB

随浏览器的功能日益强大，越来越多的网站将大量数据储存在客户端，可减少从服务器获取数据，直接从本地获取数据

现有浏览器数据储存方案，都不适用于储存大量数据：Cookie 大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 大小在2.5MB 到 10MB 之间（各家浏览器不同），且不提供搜索功能，不能建立自定义的索引。

IndexedDB 是浏览器提供的本地数据库，**可被网页脚本创建和操作**。IndexedDB 允许储存大量数据，**提供查找接口，还能建立索引**。但IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库

----



---

## 2.3 请问Cookie和Session的机制是什么？两者有什么区别？

cookie 机制是通过检查**客户身上的“通行证”**来确定客户身份，session 机制就是通过检查**服务器上的“客户明细表”**来确认客户身份。

session 可理解为在服务器上建立一份客户档案，客户来访的时候只需要查询客户档案表是否有该客户，**session 是基于 cookie 实现的**

cookie 和 session 的区别：

**存储位置**： cookie 存在于客户端，临时文件夹中；session 存在于服务器的内存中，一个 session 域对象为一个用户浏览器服务

**安全性**： cookie 是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；session 存放于服务器的内存中，所以安全性好

**生命周期**(以 20 分钟为例) ：cookie 的生命周期是**累计的**，从创建时，就开始计时，20 分钟后 cookie 生命周期结束； session 的生命周期是**间隔的**，从创建时，开始计时，在 20 分钟内，没有访问 session，那 session 生命周期被销毁。如在 20 分钟内（如在第 19 分钟时）访问过 session，那将重新计算 session 的生命周期。关机会造成 session 生命周期的结束，但是对 cookie 没有影响

**访问范围**： cookie 为多个用户浏览器共享；session 为一个用户浏览器独享

---

## 2.4 请问GET请求和POST请求区别？

**参数传递**：GET 参数通过 url 传递，POST 放在 body 中（http 协议规定，url 在请求头中，所以大小限制很小）

**长度限制**：GET 请求在 url 中传递的参数是有长度限制的，POST 没有

**参数类型**：对参数的数据类型，**GET 只接受 ASCII字符**（发起之前需要进行 UrlEncoding），而 POST 没有限制

**回退影响**：GET 在浏览器回退时是无害的，**POST 会再次提交请求**

**安全性**：GET 比 POST 不安全，参数直接暴露在 url 中，不能用来传递敏感信息

**请求过程**：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包（大多数浏览器）。对于 GET 请求，浏览器会把 http 的 header 和 data 一并发送出去，服务器响应200（返回数据）；而 POST请求，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应200 ok（返回数据）

-----

## 2.5 请问HTTP状态码有哪些分类，你了解哪些状态码？

| **类别** | **原因短语**                 |                                    |
| -------- | ---------------------------- | ---------------------------------- |
| 1XX      | Informational（信息性状态码) | 接受的请求正在处理                 |
| 2XX      | Success（成功状态码）        | 请求正常处理完毕                   |
| 3XX      | Redirection（重定向）        | 需要进行附加操作以完成请求         |
| 4XX      | Client error（客户端错误）   | 客户端请求出错，服务器无法处理请求 |
| 5XX      | Server Error（服务器错误）   | 服务器处理请求出错                 |

常见HTTP 状态码：

**1xx（请求状态）：**

100 ： 继续，请求者应当继续提出请求。**服务器返回此代码表示已收到请求的第一部分**，正在等待其余部分

101 ：切换协议，请求者已要求服务器切换协议，服务器已确认并准备切换



**2xx（成功）：**

200：成功，服务器已经成功处理了请求

201：已创建，请求成功并且服务器创建了新的资源

202：已接受，服务器已接受请求，但尚未处理

203：**非授权信息**，服务器已经成功处理了请求，但返回的信息可能来自另一来源

204：无内容，服务器成功处理了请求，但没有返回任何内容

205：重置内容，服务器成功处理了请求，但没有返回任何内容

206：部分内容，服务器成功处理了部分GET请求



**3xx（重定向）：**

300：多种选择，针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择

301：**永久移动**，请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置

302：**临时移动**，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

303：**查看其它位置**，请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码

304：**未修改，自上次请求后，请求的网页未修改过**。服务器返回此响应，不会返回网页的内容

305：**使用代理**，请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理

307：**临时性重定向**，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求



**4xx（客户端请求错误）：**

400：**错误请求**，服务器不理解请求的语法

401：**未授权**，请求要求身份验证。对于需要登录的网页，服务器可能返回此响应

403：**禁止**，服务器拒绝请求

404：**未找到**，服务器找不到请求的网页

405：方法禁用，禁用请求中指定的方法

406：**不接受**，无法使用请求的内容特性响应请求的网页

407：**需要代理授权**，此状态码与401（未授权）类似，但指定请求者应当授权使用代理

408：**请求超时**，服务器等候请求时发生超时

409：冲突，服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息

410：**已删除**，如果请求的资源已永久删除，服务器就会返回此响应

411：需要有效长度，服务器不接受不含有效内容长度标头字段的请求

412：未满足前提条件，服务器未满足请求者在请求者设置的其中一个前提条件

413：请求实体过大，服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力

414：**请求的URI过长**，请求的URI（通常为网址）过长，服务器无法处理

415：不支持媒体类型，请求的格式不受请求页面的支持

416：**请求范围不符合要求**，如果页面无法提供请求的范围，则服务器会返回此状态码

417：未满足期望值，服务器未满足“期望”请求标头字段的要求



**5xx（服务器错误）：**

500：**服务器内部错误**，服务器遇到错误，无法完成请求

501：尚未实施，服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码

502：**错误网关**，服务器作为网关或代理，从上游服务器无法收到无效响应

503：**服务器不可用**，服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态

504：网关超时，服务器作为网关代理，但是没有及时从上游服务器收到请求

505：HTTP版本不受支持，服务器不支持请求中所用的HTTP协议版本

-----

## 3.1 请谈谈你对浏览器的理解？

浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式

HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，但各浏览器厂商纷纷开发自己的扩展功能，对规范遵循并不完善，这便导致了严重的兼容性问题

简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少

**shell** 是指**浏览器外壳**：例如菜单，工具栏等，主要是提供给用户界面操作，参数设置，是调用内核来实现各种功能的

**内核** 是**浏览器的核心**，是基于标记语言显示内容的程序或模块

---

## 3.2 请谈谈你对浏览器内核的理解？

浏览器内核主要分成两部分：

**渲染引擎：**其职责就是渲染，**即在浏览器窗口中显示所请求的内容**。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件显示 PDF 格式

**JS 引擎：**解析和执行 javascript 来实现网页的动态效果

起初渲染引擎和 JS 引擎区分并不明确，而后 JS 引擎越来越独立，**内核就倾向于只指渲染引擎**

**目前常见的浏览器内核：**

**IE 浏览器：**Trident 内核，也俗称 IE 内核

**Chrome 浏览器：**统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，**现在是 Blink内核**

F**irefox 浏览器：**Gecko 内核，俗称 Firefox 内核

**Safari 浏览器：**Webkit 内核

**Opera 浏览器：**最初是自家公司的 Presto 内核，后来从 Webkit 又转到了 Blink 内核

**360浏览器、猎豹浏览器内核：**IE + Chrome 双内核

**搜狗、遨游、QQ 浏览器内核：**Trident（兼容模式）+ Webkit（高速模式）

---

##  从存储位置看，浏览器缓存分为哪几种？

从存储位置来看，浏览器缓存一共分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

### Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。**使用 Service Worker的话，传输协议必须为 HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

Service Worker 实现缓存功能一般分为三个步骤：

- 首先需要先注册 Service Worker
- 然后监听到 install 事件以后就可以缓存需要的文件
- 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。
- 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。**但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。**

### Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**绝大部分的缓存都来自 Disk Cache。**

### Push Cache

Push Cache（**推送缓存**）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。他有如下的一些特性：

- 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差。
- Push Cache 中的缓存只能被使用一次
- 可以给其他域名推送资源
- 浏览器可以拒绝接受已经存在的资源推送
- 一旦连接被关闭，Push Cache 就被释放
- 可以推送 no-cache 和 no-store 的资源
- 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑， 有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。



---
