----

##  1. 请说说cookie与session的机制，有什么区别？

- 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。

典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。**这个Session是保存在服务端的，有一个唯一标识。**

在服务端保存Session的方法很多，内存、数据库、文件都有。

集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

- 思考一下服务端如何识别特定的客户？

这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，**第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID**，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。

有人问，如果客户端的浏览器禁用了 Cookie 怎么办？

一般这种情况下，会使用一种叫做**URL重写的技术**来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

- Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？

这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。

这也是Cookie名称的由来，给用户的一点甜头。

所以，**总结一下**：

- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
- Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。



cookie 机制是通过检查**客户身上的“通行证”**来确定客户身份，session 机制就是通过检查**服务器上的“客户明细表”**来确认客户身份。

session 可理解为在服务器上建立一份客户档案，客户来访的时候只需要查询客户档案表是否有该客户，**session 是基于 cookie 实现的**

cookie 和 session 的区别：

- **存储位置**： cookie 存在于客户端，临时文件夹中；session 存在于服务器的内存中，一个 session 域对象为一个用户浏览器服务

- **安全性**： cookie 是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；session 存放于服务器的内存中，所以安全性好
- **生命周期**(以 20 分钟为例) ：cookie 的生命周期是**累计的**，从创建时，就开始计时，20 分钟后 cookie 生命周期结束； session 的生命周期是**间隔的**，从创建时，开始计时，在 20 分钟内，没有访问 session，那 session 生命周期被销毁。如在 20 分钟内（如在第 19 分钟时）访问过 session，那将重新计算 session 的生命周期。关机会造成 session 生命周期的结束，但是对 cookie 没有影响
- **访问范围**： cookie 为多个用户浏览器共享；session 为一个用户浏览器独享



----

## 2. cookie、 sessionStorage、 localStorage 区别

### Cookie

- Cookie 就是访问者在访问网站后留下的一个**信息片段**。

- Cookie 用于个性化用户的体验。可能包含用户在访问网站时的参数或输入。用户可以自定义浏览器来接受，拒绝或删除 Cookie。

- Cookie **可以在服务器级别设置和修改**，使用 Set-Cookie HTTP header, 或者在 JavaScript 中用 document.cookie.
- **cookie是服务器发给客户端的一种特殊认证信息，通常以文本的方式保存在客户端**，始终在同源的http请求中携带（即使不需要），以供服务器验证当前浏览器用户身份
- 常见应用场景：验证用户身份、保存上次登录信息、统计浏览次数

### sessionStorage

`sessionStorage` 属性允许你访问一个，对应**当前源**的 session [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象。它与 [`localStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage) 相似，不同之处在于 `localStorage` 里面存储的数据没有过期时间设置，而存储在 `sessionStorage` 里面的数据在页面会话结束时会被清除。

- 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。
- **在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，**这点和 session cookies 的运行方式不同。
- 打开多个相同的 URL 的 Tabs 页面，会创建各自的 `sessionStorage`。
- 关闭对应浏览器标签或窗口，会清除对应的 `sessionStorage`。 

### localStorage

只读的`localStorage` 属性允许你访问一个[`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document) 源（origin）的对象 [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage)；存储的数据将保存在浏览器会话中。`localStorage` 类似 [`sessionStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage)，但其区别在于：存储在 `localStorage` 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 `sessionStorage` 的数据会被清除 。

应注意，无论数据存储在 `localStorage` 还是 `sessionStorage` ，**它们都特定于页面的协议。**

另外，`localStorage` 中的键值对总是以字符串的形式存储。 (需要注意，和 js 对象相比，键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).

### 共同点

都是保存在浏览器端、且同源的

### 区别

**请求是否携带**

- cookie数据始终在**同源**的http请求中携带（即使不需要），**即cookie在浏览器和服务器间来回传递**
- 而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
- **cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下**

**存储大小限制**

- cookie数据不能超过4K，**同时因为每次http请求都会携带**cookie、**所以cookie只适合保存很小的数据，如会话标识**。
- sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

**数据有效期**

- sessionStorage：仅在当前浏览器窗口关闭之前有效；
- localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
- cookie：**只在设置的cookie过期时间之前有效**，即使窗口关闭或浏览器关闭

**作用域**

- sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；
- localstorage在所有同源窗口中都是共享的；
- cookie也是在所有同源窗口中都是共享的

**事件通知机制**

- web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
- web Storage的api接口使用更方便



|                | 有期时间                                           | 作用域                                                       | 存储大小                           | 存储位置 |
| -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | -------- |
| cookie         | 在过期时间前一直有效（即使浏览窗口器关闭）         | domain本身以及domain下的所有子域名（跨域请求的 cookie在fetch时需要设置 withCredentials） | 不能超过4k                         | 浏览器端 |
| localStorage   | 长期存储，浏览器窗口关闭数据不丢失（除非主动删除） | 所有同源窗口共享                                             | 虽有存储大小限制，但可达到5M或更大 |          |
| sessionStorage | 临时存储，当前浏览器窗口关闭后自动删除             | 不同浏览器窗口不共享                                         |                                    |          |

---

## 3. 如何写一个会过期的localStorage，说说想法

**两种方案：惰性删除 和 定时删除**

### 惰性删除

惰性删除是指，**某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删**除。我们先来简单实现一下：

```js
    var lsc=(function(self){
      var prefix="one_more_lsc_";
      /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
      self.set=function(key,val,expires){
        key=prefix+key;
        val=JSON.stringify({'val':val,'expires':new Date().getTime()+expires*1000});
        localStorage.setItem(key,val);
      };
      /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
      self.get=function(key){
        key=prefix+key;
        var val=localStorage.getItem(key);
        if (!val) {
          return null;
        }
        val=JSON.parse(val);
          //检查是否过期
        if (val.expires<new Date().getTime()) {
          localStorage.removeItem(key);
          return null;
        }
        return val.val;
      };
      return self;
    }(lsc || {}));

//测试
    lsc.set("kop","66",10);
    console.log(lsc.get("kop"));
    setTimeout(()=>{
      console.log(lsc.get("kop"));
    },12000);
```

上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。

### 定时删除

定时删除是指，**每隔一段时间执行一次删除操作**，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。

每隔一秒执行一次定时删除，操作如下：

1. 随机测试20个设置了过期时间的key。
2. 删除所有发现的已过期的key。
3. 若删除的key超过5个则重复**步骤1**，直至重复500次。

具体实现如下：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>测试</title>
<style type="text/css">
  
</style>
</head>
<body>
<div>
    <button onclick="openLink()">打开</button>
</div>
<script type="text/javascript">
    var lsc=(function(self){
      var list=[];
      var prefix="one_more_lsc_";

      //初始化list
      self.init=function(){
        var keys=Object.keys(localStorage);
        var reg=new RegExp("^"+prefix);
        var temp=[];
        //遍历所有localStorage中的所有key
        for(let i=0;i<keys.length;i++){
          //找出可过期缓存的key
          if (reg.test(keys[i])) {
            temp.push(keys[i]);
          }
        }
        list=temp;
      };

      self.init();
      
      /**
     * 增加一个键值对数据
     * @param key 键
     * @param val 值
     * @param expires 过期时间，单位为秒
     */
      self.set=function(key,val,expires){
        key=prefix+key;
        val=JSON.stringify({'val':val,'expires':new Date().getTime()+expires*1000});
        localStorage.setItem(key,val);
      };
      /**
     * 读取对应键的值数据
     * @param key 键
     * @returns {null|*} 对应键的值
     */
      self.get=function(key){
        key=prefix+key;
        var val=localStorage.getItem(key);
        if (!val) {
          return null;
        }
        val=JSON.parse(val);
        if (val.expires<new Date().getTime()) {
          localStorage.removeItem(key);
          return null;
        }
        return val.val;
      };

      self.check=function(){
        if (!list || list.length===0) {
          return;
        }
        let checkCount=0;
        while(checkCount<500){
          let expireCount=0;
          //随机测试20个设置了过期时间的key
          for(let i=0;i<20;i++){
            if (list.length===0) {
              break;
            }
            let index=Math.floor(Math.random()*list.length);
            let key=list[index];
            let val=localStorage.getItem(key);
            //从list中删除被惰性删除的key
            if (!val) {
              list.splice(index,1);
              expireCount++;
              continue;
            }
            val=JSON.parse(val);
            ///删除所有发现的已过期的key
            if (val.expires<new Date().getTime()) {
              list.splice(index,1);
              localStorage.removeItem(key);
              expireCount++;
            }
          }
          //若删除的key不超过5个则跳出循环
          if (expireCount<=5 || list.length===0) {
            break;
          }
          checkCount++;
        }
      }
      //每隔一秒执行一次定时删除
      window.setInterval(self.check,1000);
      return self;
    }(lsc || {}));
    /*
    for (let i=1;i<200;i++){
      lsc.set("key"+i,i.toString(),Math.random()*10);
    }
    */
    for (let i=1;i<200;i++){
      console.log(lsc.get("key"+i));
    }
    
</script>

</body>
</html>

```





-----

## 4. localStorage 能跨域吗

不能

解决方案：

- 通过postMessage来实现跨源通信
- 可以实现一个公共的iframe部署在某个域名中，作为共享域
- 将需要实现localStorage跨域通信的页面嵌入这个iframe
- 接入对应的SDK操作共享域，从而实现localStorage的跨域存储

![localStorage跨域](E:\pogject\学习笔记\image\浏览器\localStorage跨域.png)



----

## 5. localstorage的限制

1. **浏览器的大小不统一**，并且在IE8以上的IE版本才支持localStorage这个属性
2. 目前**所有的浏览器中都会把localStorage的值类型限定为string类型**，这个在对我们日常比较常见的JSON对象类型需要一些转换
3. localStorage在浏览器的**隐私模式下面是不可读取的**
4. localStorage**本质上是对字符串的读取**，如果存储内容多的话会消耗内存空间，会导致页面变卡
5. localStorage**不能被爬虫抓取到**



localStorage或者sessionStorage怎么设计缓存的数据结构，如果数据量很大怎么查找

**localStorage的运行解析**

1. localStorage的关键问题在于它是通过同步操作的方式来进行文件I/o操作。
2. 写入localStorage的数据都会保存到磁盘上，除非主动删除数据，否则数据是永远不会过期的。
3. 用过nodeJs的人都知道，对于文件的I/O是非常昂贵和不一致的（不可信赖）。
4. 任何时间点任何的程序都可以访问文件。举例来说，你注意到过当一个杀毒软件运行的时候你的电脑是如何慢下来的吗？在理想状态下，你读取的文件不会有其他程序在同一时间访问该文件。在极端坏的情况下，如果你想读取一个文件，就必须等待文件上的锁被释放（其他程序操作文件时会锁定文件）。



鉴于此，从localStorage读取数据的最佳策略是使用尽可能少的键值，存储尽可能多的数据。因为读取10个字符和读取2000个字符所需时间大致是相同的，所以你应该尝试把尽可能多的数据保存为一个键值对应的值。每次调用getItem()（或从localStorage读取属性）都会增加时耗，所以一定要确保每次访问读取数据最大化。对于任何一个变量或对象属性，你越快将它读取到内存，后续的所有操作也会越快。

**结论**

- 日常我们工作中，使用localStorage进行本地存储的时候，分批次与整体存入 存在效率问题，但是两者的相差不大，**建议整体存入，减少文件的i/o操作,转为js的对象操作**
- localStorage存储、读取的速度，与每次存入的数据量大小，读写文件的次数有关系。
- 理论上来说，处理js对象的开销 小于读取文件的开销，但是当数据量庞大到一个量级的时候 ，整体存入的时间就会大于分批次存入的事件（待验证）
- safari的localStorage 相对于chrome来说  存储和读取更快，但是同时容量更小。
- 浏览器无痕模式下，localStorage会失效，需要捕捉错误，并暴露出来





----

## 6. 说说你对cookie的理解

### Cookie 简介

HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？

- cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。
- **实际上 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名**，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。
- 不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是 不能获取的。

> PS：cookie 和 session 都能保存计算机中的变量，但是 session 是运行在服务器端的，而客户端我们只能通过 cookie 来读取和创建变量

HTTP 为此引入了 Cookie。**Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储**(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。**而服务端可以通过响应头中的`Set-Cookie`字段来对客户端写入`Cookie`。**举例如下:

```http
// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx
```

### Cookie 属性

#### 生存周期

Cookie 的有效期可以通过`Expires`和`Max-Age`两个属性来设置。

- `Expires`即`过期时间`
- `Max-Age`用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

#### 作用域

关于作用域也有两个属性: `Domain`和`path`, 给 `Cookie` 绑定了域名和路径，**在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。**值得注意的是，对于路径来说，**`/`表示域名下的任意路径都允许使用 Cookie。**

#### 安全相关

如果带上`Secure`，**说明只能通过 HTTPS 传输 cookie。**

**如果 cookie 字段带上`HttpOnly`，那么说明只能通过 HTTP 协议传输**，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。

相应的，对于 CSRF 攻击的预防，也有`SameSite`属性。

`SameSite`可以设置为三个值，`Strict`、`Lax`和`None`。

- **在`Strict`模式下，浏览器完全禁止第三方请求携带Cookie**。比如请求`sanyuan.com`网站只能在`sanyuan.com`域名当中请求才能携带 Cookie，在其他网站请求都不能。
- **在`Lax`模式**，就宽松一点了，但是**只能在 `get 方法提交表单`况或者`a 标签发送 get 请求`的情况下可以携带 Cooki**e，其他情况均不能。
- **在`None`模式下**，也就是默认模式，**请求会自动携带上 Cookie。**

### cookie 能做什么？

- 用户在第一次登录某个网站时，要输入用户名密码，如果觉得很麻烦，下次登录时不想输入了，那么就在第一次登录时将登录信息存放在 cookie 中。下次登录时我们就可以直接获取 cookie 中的用户名密码来进行登录。

  > PS:虽然 浏览器将信息保存在 cookie 中是加密了，**但是可能还是会造成不安全的信息泄露**

- 类似于购物车性质的功能，第一次用户将某些商品放入购物车了，但是临时有事，将电脑关闭了，下次再次进入此网站，我们可以通过读取 cookie 中的信息，恢复购物车中的物品。

  > PS：实际操作中，这种方法很少用了，基本上都是将这些信息存储在数据库中。然后通过查询数据库的信息来恢复购物车里的物品

- 页面之间的传值。在实际开发中，我们往往会通过一个页面跳转到另外一个页面。后端服务器我们可以通过数据库，session 等来传递页面所需要的值。但是在浏览器端，我们可以将数据保存在 cookie 中，然后在另外页面再去获取 cookie 中的数据。

  > PS：这里要注意 cookie 的时效性，不然会造成获取 cookie 中数据的混乱。

###  怎么使用 cookie？

- 语法

  ```js
  document.cookie = "name=value;expires=evalue; path=pvalue; domain=dvalue; secure";
  ```

- 对各个参数的解释

1. **name=value** 必选参数

这是一个键值对，分别表示要存入的 属性 和 值。

比如：

```js
document.cookie="name=中文";
//为了防止中文乱码，我们可以使用encodeURIComponent()编码；decodeURIComponent()解码
document.cookie = encodeURIComponent("name")+"="+encodeURIComponent("中文");

```

2. **expires=evalue** 可选参数

该对象的有效时间（可选）**只支持GTM 标准时间，即要将时间转换**，toUTCString()**（默认为当前浏览器 会话有用，关闭浏览器就消失**）;

比如：

```js
var date = new Date(); 　
date.setTime(date.getTime()+2000);//获取当前时间并加上 2 秒钟 　

alert(date.toUTCString());//格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果
alert(date.toGMTString());//与上面的结果一样，但是这个方法已经被上面取代了 

document.cookie="name=kop;expires="+date.toUTCString();

alert(document.cookie); // name=kop 　

setTimeout(function(){alert(document.cookie)},4000);//4 秒后打印空的字符串
```

3. **path=pvalue** 可选参数

限制访问 cookie 的目录，**默认情况下对于当前网页所在的同一目录下的所有页面有效**

4. **domain=dvalue** 可选参数

用于限制只有设置了的域名才可以访问；**如果没有设置，则默认在当前域名访问**

比如设置 test*.com 表示域名为test*.com的服务器共享该Cookie

5. **secure=true|false** 可选参数，**默认是 true 不安全传输**

安全设置，指明必须通过 安全的通信通道来传输（https) 才能获得 cookie,  **true 不安全**，默认值；**false 安 全，必须通过 https 来访问**

**比如：如果你设置 document.cookie = "name=vae;secure"**

上面的代码如果是在 http 的协议中访问，那么是访问不了的

```js
　　　　　　　//设置 cookie
            function setCookie(objName, objValue, objHours){//添加cookie
                var str = objName + "=" + encodeURIComponent(objValue);
                if (objHours > 0) {//为0时不设定过期时间，浏览器关闭时cookie自动消失
                    var date = new Date();
                    var ms = objHours * 3600 * 1000;
                    date.setTime(date.getTime() + ms);
                    str += "; expires=" + date.toUTCString();
                }
                document.cookie = str;

            }

            //获取 cookie
            function getCookie(objName){//获取指定名称的cookie的值
                //多个cookie 保存的时候是以 ;空格  分开的
                var arrStr = document.cookie.split("; ");
                for (var i = 0; i < arrStr.length; i++) {
                    var temp = arrStr[i].split("=");
                    if (temp[0] == objName){
                        return decodeURIComponent(temp[1]);
                    }else{
                        return "";
                    }

                }
            }

            //为了删除指定名称的cookie，可以将其过期时间设定为一个过去的时间
            function delCookie(name){
                var date = new Date();
                date.setTime(date.getTime() - 10000);
                document.cookie = name + "=a; expires=" + date.toUTCString();
            }

```

注意：

（1）**cookie可能被禁用**。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；

（2）cookie是与浏览器相关的。这意味着即使访问的是同一个页面，**不同浏览器之间所保存的cookie也是不能互相访问的**；

（3）**cookie可能被删除**。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；

（4）**cookie安全性不够高**。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。

（5）cookie 在保存时，只要后面保存的 name 相同，那么就会覆盖前面的 cookie，**注意是完全覆盖**，包括失效时间，pat



### Cookie 的缺点

- **容量缺陷**。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
- **性能缺陷**。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容**。但可以通过`Domain`和`Path`指定`作用域`来解决。**
- **安全缺陷**。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。



### Cookie失效问题原因以及解决方案

**`Access-Control-Allow-Credentials`** 响应头用于在请求要求包含 credentials（[`Request.credentials`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FRequest%2Fcredentials) 的值为 `include`）时，告知浏览器是否可以将对请求的响应暴露给前端 JavaScript 代码。 当请求的 credentials 模式为 `include` 时，浏览器仅在响应标头 `Access-Control-Allow-Credentials` 的值为 `true` 的情况下将响应暴露给前端的 JavaScript 代码。。我理解是只有开启后，浏览器在读取到响应头的Set-cookie字段时，才能将cookie字段设置于浏览器中。

Access-Control-Allow-Credentials 标头需要与 XMLHttpRequest.withCredentials 或 Fetch API 的 Request() 构造函数中的 credentials 选项结合使用。Credentials 必须在前后端都被配置（即 Access-Control-Allow-Credentials header 和 XHR 或 Fetch request 中都要配置）才能使带 credentials 的 CORS 请求成功。

**`XMLHttpRequest.withCredentials`** 属性是一个布尔类型，它指示了是否该使用类似 Cookies、Authorization Headers (头部授权) 或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site `Access-Control`）请求。在同一个站点下使用 `withCredentials` 属性是无效的。此外也会被用做`响应中` Cookies 被忽视的标示。默认值是 false。 如果在发送来自其他域的 XMLHttpRequest 请求之前，未设置`withCredentials` 为 true，那么就不能为它自己的域设置 Cookie 值。而通过设置 `withCredentials` 为 true 获得的第三方 Cookies，将会依旧享受同源策略，因此不能被通过document.cookie或者从头部相应请求的脚本等访问。



---

## 7. token 能放在cookie中吗

能

**解析**：

- token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token 便应运而生。
- **「简单 token 的组成」**:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）

**token认证流程**

![token认证流程](E:\pogject\学习笔记\image\js\token认证流程.png)

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，**服务端签发一个 token ，并把它发送给客户端**
4. 客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. **客户端每次发送请求时都需要带着服务端签发的 token**（把 token 放到 HTTP 的 Header 里）
6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据



---

## 8. memory cache 如何开启

memory cache 如何开启是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。

**但这种缓存是暂时的，一旦关闭了浏览器，这一部分用于缓存的内存空间就会被释放掉**。如果真的不想使用缓存，可以设置**no-store**，这样，即便是内存缓存，也不会生效。



---

## 9. 请问在浏览器中输入 URL后，浏览器会做哪些工作？

从输入URL到渲染出整个页面包括三个部分：

**（1）、DNS解析URL**

DNS解析就是**寻找哪个服务器上有请求的资源**，因为ip地址不易记忆，一般会使用URL域名（如[www.baidu.com](http://www.baidu.com/)）作为网址，**DNS解析就是将域名“翻译”成IP地址**

具体过程：

a、浏览器缓存：浏览器会按照一定的频率，缓存DNS记录

b、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会去操作系统中找

c、路由缓存：路由器也有DNS缓存

d、ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求

e、根服务器：ISP的DNS服务器找不到，就要向根服务器发出请求，进行递归查询



**（2）、浏览器发送请求与服务器交互**

a、浏览器**利用tcp协议**通过三次握手与服务器建立连接

b、浏览器根据解析到的IP地址和端口号发起http请求。http请求包括header和body，header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie，body中有请求的内容

c、服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

d、若状态码为200显示响应成功，浏览器接收到返回的HTML页面后，开始渲染页面，304去读取缓存是否可用



**（3）、浏览器对接收到的HTML页面进行渲染**

a、浏览器根据**深度遍历**的方式把HTML节点遍历成DOM树

b、将CSS解析成CSSOM树

c、将DOM树和CSSOM树构造成Render树

d、根据Render树计算所有节点在屏幕中的位置，进行布局（回流）

e、遍历Render树并调用硬件API绘制所有节点（重绘）



---

## 10. 简单描述从输入网址到页面显示的过程

1. URL 解析
2. DNS 查询
3. 发起TCP连接
4. 发送HTTP请求
5. 处理请求：服务器处理请求并返回HTTP报文
6. 接受响应
7. 渲染页面：浏览器解析渲染页面
8. 连接结束



----

## 11. 请问你了解浏览器的渲染机制？

首先，浏览器的渲染机制中有几个基本概念名称：

（1）、DOM：浏览器将HTML解析成树形的数据结构

文档对象模型 (DOM) 将 web 页面与到脚本或编程语言连接起来。通常是指  JavaScript，但将 HTML、SVG 或 XML 文档建模为对象并不是 JavaScript 语言的一部分。DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM的方法(methods)让你可以用特定方式操作这个树，用这些方法你可以改变文档的结构、样式或者内容。节点可以关联上事件处理器，一旦某一事件被触发了，那些事件处理器就会被执行。

（2）、CSSOM：浏览器将CSS解析成树形的数据结构

- CSS 对象模型 (CSSOM) 是树形形式的所有CSS选择器和每个选择器的相关属性的映射，具有树的根节点，同级，后代，子级和其他关系。CSSOM 与 文档对象模型(DOM) 非常相似。两者都是关键渲染路径的一部分，也是正确渲染一个网站必须采取的一系列步骤。

- CSSOM 与 DOM一起构建渲染树，浏览器依次使用渲染树来布局和绘制网页。

- CSS 对象模型也是一组API，允许从JavaScript 操纵 CSS。它非常类似于DOM，但应用于 CSS 而不是 HTML。它允许用户动态读取和修改 CSS样式。

（3）、Render Tree：DOM和CSSOM合并后生成Render Tree（渲染树）

（4）、Layout：计算出Render Tree每个节点的具体位置置

（5）、Painting：通过显卡，将Layout后的节点内容分别呈现到屏幕上

![WebKit 主流程](E:\pogject\学习笔记\image\js\WebKit 主流程.png)

浏览器整个渲染流程如下：

（1）、用户输入一个URL后，浏览器就会向服务器发出一个请求，请求URL对应的资源

（2）、接到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一颗DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点

（3）、将CSS解析成CSSOM树

（4）、根据DOM树与CSSOM树，构建Render Tree

（5）、浏览器会根据Render Tree能知道网页中哪些有节点，各个节点的CSS，以及各个节点的从属关系

（6）、计算出每个节点在屏幕中的位置后，最后一步就是Painting，根据计算出的规则，把内容画到屏幕上



注意：

浏览器在获得HTML文件后，是自上而下的加载，并在加载过程中进行解析与渲染

加载过程中：

遇到外部CSS文件和图片等静态资源时，浏览器会另外发送一个异步请求

遇到js文件时，HTML文件会挂起渲染的进程，等待js文件加载完毕后，再继续进行渲染，**因为js可能会修改DOM**，导致后续HTML资源白白加载，这也是为什么建议将js文件写在底部body标签前



----

## 12. 请问如何解决浏览器加载js时的阻塞问题吗？

**（1）、推迟加载**

若页面初始的渲染并不依赖于js或CSS可以用推迟加载，最后在加载js和CSS，把引用外部文件的代码写在最后

**（2）、defer延迟加载**

```html
<script src="" defer></script>
```

在文档解析完成开始执行，并且在DOMContentLoaded事件之前执行完成，会按照在文档出现的顺序去下载解析，效果和把script放在文档最后`</body>`之前是一样

    注意：**defer最好用在引用外部文件中使用**，用了defer不要使用document.write()方法，使用defer时最好不要请求样式信息，因为样式表可能尚未加载，浏览器会禁止该脚本等待样式表加载完成，相当于样式表阻塞脚本执行

**（3）、异步加载**

async异步加载：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执行

```html
 <script type="text/javascript" src="a.js" async></script>
```

**（4）script dom element：**用js动态创建一个script元素添加在document中

注意：会阻止onload事件

```html
<script type="text/javascript">
    (function() {
     var s = document.createElement('script');
     s.type = 'text/javascript';
     s.async = true;                   //这句可以删除，但是效果不变。
     s.src = 'js/a.js';
     var x = document.getElementsByTagName('script')[0];
     x.parentNode.insertBefore(s, x);
 })();
</script>
```

**（5）onload时异步加载：**与script dom element法差不多，但不是同时执行js和html，是等html的文件、图片之类的、页面所有的资源全部加载完成后再下载执行js，这样的方法可以避免阻塞onload事件的触发

**注意：**DOMContentLoaded与onload事件不同，DOMContentLoaded是页面解析完成，页面的dom元素可以使用，但是页面的图片、视频等资源可能还没加载完成



----

## 13. 请问你了解什么是重绘？什么是回流？两者有何区别？

**重绘：**

更换某个元素颜色，这样的行为是不影响页面布局，DOM树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染

常见情况：

（1）、回流必定引发重绘，但重绘也会单独触发

（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）

**回流：**

增删DOM节点，或修改一个元素的宽高，页面布局发生变化，DOM树结构发生变化，需要重新构建DOM树，而DOM树与渲染树是紧密相连的，DOM树构建完，渲染树也会随之对页面进行再次渲染

**常见情况：**

（1）、页面渲染初始化

（2）、DOM树变化（添加或者删除可见的DOM元素、元素位置改变）

（3）、Render树变化（元素尺寸改变：边距、填充、边框、宽度和高度）

（4）、浏览器窗口尺寸改变，resize事件发生

（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；

（6）、查询布局信息，包括offestLeft/Top/Width/Height、scrollLeft/Top/Width/Height、clientLeft/Top/Width/Height、**浏览为了返回最新值，会触发回流**



---

## 14. 重绘、重排区别如何避免

1. 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

2. 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等

3. 区别：**重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）**

4. 引发重排

   4.1 添加、删除可见的dom

   4.2 元素的位置改变

   4.3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)

   4.4 页面渲染初始化

   4.5 浏览器窗口尺寸改变

   4.6 获取某些属性。当获取一些属性时，**浏览器为取得正确的值也会触发重排,它会导致队列刷新**，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。**所以，在多次使用这些值时应进行缓存。**

5. 优化：

   **浏览器自己的优化**：

   浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，**这样多次重排，重绘变成一次重排重绘**

   **减少 reflow/repaint**：
   
   （1）不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。
   
   （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
   （3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
   （4）**千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局**。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)
   
   （5）不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）
   
   
   
----


## 15.浏览器垃圾回收机制

**1. 介绍**

浏览器的 Javascript 具有自动**垃圾回收机制(GC:Garbage Collecation)**，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以**垃圾回收器会按照固定的时间间隔周期性的执行**。

不再使用的变量也就是生命周期结束的变量，**当然只可能是局部变量**，全局变量的生命周期直至浏览器卸载页面才会结束。**局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值**，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

```js
function fn1() {
    var obj = {name: 'hanzichi', age: 10};
}
function fn2() {
    var obj = {name:'hanzichi', age: 10};
    return obj;
}

var a = fn1();
var b = fn2();
```

我们来看代码是如何执行的。首先定义了两个function，分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: 'hanzichi', age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；**在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。**

这里问题就出现了：到底哪个变量是没有用的？**所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存**。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。引用计数不太常用，标记清除较为常用。

**2. 标记清除**

js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。**从逻辑上讲，永远不能释放进入环境的变量所占用的内存**，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

```js
function test(){
	var a = 10 ;             //被标记 ，进入环境 
	var b = 20 ;             //被标记 ，进入环境
}
test();                     //执行完毕 之后 a、b又被标离开环境，被回收。
```

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及**被环境中的变量引用的变量的标记**（**闭包**）。

而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，**销毁那些带标记的值并回收它们所占用的内存空间**。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

**3. 引用计数**

**引用计数的含义是跟踪记录每个值被引用的次数。**当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。**当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。**这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

```js
function test(){
    var a = {} ;         //a的引用次数为0 
    var b = a ;         //a的引用次数加1，为1 
    var c =a;           //a的引用次数再加1，为2
    var b ={};          //a的引用次数减1，为1
}
```

Netscape Navigator3是最早使用引用计数策略的浏览器，**但很快它就遇到一个严重的问题：循环引用**。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

```js
function fn() {
    var a = {};
    var b = {};
    a.pro = b;
    b.pro = a;
}
fn();
```

以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，**如果fn函数被大量调用，就会造成内存泄露**。在IE7与IE8上，内存直线上升。

我们知道，IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的**COM对象依然是基于引用计数策略**的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.e = element;
element.o = myObject;
```

这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。

举个栗子：

```js
window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
};

```

这段代码看起来没什么问题，但是obj引用了document.getElementById('element')，**而document.getElementById('element')的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽**啊。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug)

**解决办法：**

最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样

```js
myObject.element = null;
element.o = null;

window.onload=function outerFunction(){
    var obj = document.getElementById("element");
    obj.onclick=function innerFunction(){};
    obj=null;
};

```

**将变量设置为null意味着切断变量与它此前引用的值之间的连接。**当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。

要注意的是，**IE9+并不存在循环引用导致Dom内存泄露问题**，可能是微软做了优化，或者Dom的回收方式已经改变

----

## 16. 什么时候触发垃圾回收？

垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。

微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，**如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍**，如果回收的内存高于85%，说明大部分内存早就该清理了，**这时候把触发条件置回。这样就使垃圾回收工作职能了很多**

**合理的GC方案**

### **1. 基础方案**

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即：

1. 遍历所有可访问的对象。
2. 回收已不可访问的对象。

### **2. GC的缺陷**

和其他语言一样，javascript的GC策略也无法避免一个问题：**GC时，停止响应其他操作，这是为了安全考虑**。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。

### **3. GC优化策略**

主要介绍了2个优化方案，而这也是最主要的2个优化方案了：

1. **分代回收**（Generation GC） 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多**回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation）**，减少每次需遍历的对象，从而减少每次GC的耗时。如图：

   ![分代回收](E:\pogject\学习笔记\image\js\分代回收.png)

这里需要补充的是：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。

2. **增量GC** 这个方案的思想很简单，就是“**每次处理一点，下次再处理一点**，如此类推”。如图：

![增量GC](E:\pogject\学习笔记\image\js\增量GC.png)

这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。

比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。



----

## 17. 事件循环Event loop

主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为**事件循环**。此机制具体如下: 主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。

**详细步骤**：

1.  选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。
2. 事件循环的当前运行宏任务设置为已选择的宏任务。
3. 运行宏任务。
4. 将事件循环的当前运行任务设置为null。
5. 将运行完的宏任务从宏任务队列中移除。
6. microtasks步骤：进入microtask检查点。
7. 更新界面渲染。
8. 返回第一步。

**执行进入microtask检查的的具体步骤如下:**

1. 设置进入microtask检查点的标志为true。
2. 当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。
3. 对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。
4. 清理indexedDB的事务。
5. 设置进入microtask检查点的标志为false。

需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。**同一次事件循环中, 微任务永远在宏任务之前执行。**

![事件循环Eventloop](E:\pogject\学习笔记\image\js\事件循环Eventloop.png)



----

## 18. let a = "sssssss"，存在哪儿？

使用let声明的全局变量不是挂在window对象下的，**声明的全局变量存在于一个块级作用域中**。

具体查看，我们可以通过打印一个全局函数，在let声明的全局变量在全局函数的scope下，我们平时使用时直接 用变量名称就能访问到

具体位置如下图：

![let变量存储](E:\pogject\学习笔记\image\js\let变量存储.png)





----

## 19. 调试工具

**谷歌浏览器自带的调试工具：**

1. Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。
2. console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。
3. Sources：**断点调试JS**，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。
4. Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息（“有时候就利用这下载一些网站不给下载的在线视频，比如教学视频”）。
5. Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。
6. Application：记录网站加载的各个资源信息。
7. Security：判断网页是否安全。
8. Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。

**Postman**

地址：https://www.postman.com/

几乎所有前端应用程序都发送和接收JSON响应和请求。 应用程序通过请求 API 可以做很多事情，例如身份验证，用户数据传输，甚至是一些简单的事情，例如获取所在位置的当前天气。

Postman 是调试接口的最佳工具之一。 它适用于 **MacOS**，**Windows** 和**Linux**的系统， 可以快速轻松地直接发送**REST**，**SOAP**和**GraphQL**请求。

使用 Postman，我们可以调整请求，分析响应和调试问题。 当不确定问题出在前端还是后端时，这是很有帮助的。

**CSS Lint**

地址： http://csslint.net/

**CSSLint** 是一个用来帮你找出 CSS 代码中问题的工具，它可做基本的语法检查以及使用一套预设的规则来检查代码中的问题，规则是可以扩展的。

**JSON Formatter & Validator**

地址：https://jsonformatter.curiousconcept.com/

在未格式化的 JSON 中很难发现语法错误或键值不正确的键，因为它很难读取。 对于 压缩的 JSON 文件，要发现其中的错误是比较难的，所以我们需要一种格式化的工具。

JSON Formatter & Validator tool 就是一个格式化 JSON 的工具，只需输入压缩的JSON格式，就能获得正确格式。该工具也可以验证 JSON 到 RFC 标准。

**Sentry**

地址：https://sentry.io/welcome/

无论测试如何完善的程序，bug总是免不了会存在的，有些bug不是每次都会出现，测试时运行好好的代码可能在某个用户使用时就歇菜了，可是当程序在用户面前崩溃时，你是看不到错误的，当然你会说:”Hey, 我有记日志呢”。 但是说实话，程序每天每时都在产生大量的日志，而且分布在各个服务器上，并且如果你有多个服务在维护的话，日志的数量之多你是看不过来的吧。等到某天某个用户实在受不了了，打电话来咆哮的时候，你再去找日志你又会发现日志其实没什么用：缺少上下文，不知道用户什么操作导致的异常，异常太多（从不看日志的缘故）不知如何下手 等等。

**Sentry**就是来帮我们解决这个问题的，**它是是一个实时事件日志记录和聚合平台。它专门用于监视错误和提取执行适当的事后操作所需的所有信息,** 而无需使用标准用户反馈循环的任何麻烦。

Sentry是一个日志平台, 它分为客户端和服务端，客户端(目前客户端有Python, PHP,C#, Ruby等多种语言)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web节目方便查看。**Sentry** 由 python 编写，源码开放，性能卓越，易于扩展，目前著名的用户有Disqus, Path, mozilla, Pinterest等。

**JSHint**

地址：https://jshint.com/

JSHint 是一个 Javascript 代码分析检测工具，不仅可以帮助我们检测到 JS 代码错误和潜在问题，也能帮助我们规范代码开发。

**JSHint** 扫描一个用JavaScript编写的程序，并报告常见的错误和潜在的bug。潜在的问题可能是语法错误、隐式类型转换导致的错误、泄漏变量或其他完全的问题。

**BrowserStack**

地址：https://www.browserstack.com/

现在拥有各自内核的浏览器越来越多，各自的特性也千差万别。如果作为一个前端工程师想要检测网站在不同的操作系统和移动平台下的各种浏览器的兼容性，那是相当痛苦不堪的。看到有在自己电脑上装虚拟机配置各种环境，有自己的电脑上组建好这样的环境，然后一一测试，可是人的精力毕竟有限，我们没法在同一台电脑上装那么多系统，那么多浏览器的。幸好出了个 BrowserStack 是前端的福音呀。

BrowserStack 是一款提供网站浏览器兼容性测试的在线云端测试工具，从而开发测试人员不必再准备很多虚拟机或者手机模拟器。

**BrowserStack** 是一个提供网站浏览器兼容性测试的在线云端应用，支持9大操作系统上的100多款浏览器。支持本地测试，支持与Visual Studio集成。或者你也可以直接前往 [http://modern.ie](http://modern.ie/) 在线测试，现在注册可以免费试用三个月，三个月后是收费的。



------

## 20. window.open

这个方法是用来打开新窗口的

1. 最基本的弹出窗口

   ```js
   window.open('page.html');
   ```

2. 经过设置后的弹出窗口

   ```js
    window.open('page.html', 'newwindow', 'height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no')   
      //该句写成一行代码
      //参数解释：
      // window.open 弹出新窗口的命令； 
   　　//'page.html' 弹出窗口的文件名； 
   　　//'newwindow' 弹出窗口的名字（不是文件名），非必须，可用空''代替； 
   　　//height=100 窗口高度； 
   　　//width=400 窗口宽度； 
   　　//top=0 窗口距离屏幕上方的像素值； 
   　　//left=0 窗口距离屏幕左侧的像素值； 
   　　//toolbar=no 是否显示工具栏，yes为显示； 
   　　//menubar，scrollbars 表示菜单栏和滚动栏。 
   　　//resizable=no 是否允许改变窗口大小，yes为允许； 
   　　//location=no 是否显示地址栏，yes为允许； 
   　　//status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许
   ```

   

3. 用函数控制弹出窗口

   ```html
    <html> 
   　　<head> 
   　　<script LANGUAGE="JavaScript"> 
   　　<!-- 
   　　function openwin() { 
   　　	window.open ("page.html", "newwindow", "height=100, width=400, toolbar =no, menubar=no, scrollbars=no, resizable=no, location=no, status=no") //写成一行
   　　} 
   　　//--> 
   　　</script> 
   　　</head> 
   　　<body οnlοad="openwin()"> 
   　　任意的页面内容... 
   　　</body> 
   　　</html> 
   ```

   解释：这里定义了一个函数openwin(), 函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？ 

   方法一：`<body οnlοad="openwin()">` 浏览器读页面时弹出窗口； 

   方法二：`<body οnunlοad="openwin()">` 浏览器离开页面时弹出窗口； 

   方法三：用一个连接调用： `<a href="#" οnclick="openwin()">` 打开一个窗口 注意：使用的"#"是虚连接。 

   方法四：用一个按扭调用： `<input type="button" οnclick="openwin()" value="打开窗口" />`

   

4. 弹出两个窗口

   ```html
   <script LANGUAGE="JavaScript"> 
   　　<!-- 
   　　function openwin() { 
   　　	window.open ("page.html", "newwindow", "height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=n o, status=no")//写成一行 
   　　	window.open ("page2.html", "newwindow2", "height=100, width=100, top=100, left=100,toolbar=no, menubar=no, scrollbars=no, resizable=no, loca tion=no, status=no")//写成一行 
   　　} 
   　　//--> 
   </script>
   ```

   为避免弹出的2个窗口覆盖，**用top和left控制一下弹出的位置不要相互覆盖即可**。最后用上面的说过的四种方法调用即可。 注意：2个窗口的name(newwindow与 newwindow2)不要相同，或者干脆全部为空。

   

5. 主窗口打开文件1.htm，同时弹出小窗口page.html

   ```js
    function openwin(){
        window.open("page.html","","width=200,height=200") 
    } 
   ```

   ```html
      //加入body区：
    <a href="1.htm" οnclick="openwin()">open</a>即可。
   ```

   

6. 弹出的窗口之定时关闭控制

   将一小段代码加入弹出的页面（注意是加入page.html的HTML中，可不是主页面中，否则......），让它在10秒后自动关闭

   ```js
    function closeit(){
       setTimeout("self.close()", 10000)   //毫秒
    }
   ```

   ```html
   <body οnlοad="closeit()">
   ```

7. 在弹出窗口中加上一个关闭按扭

   ```html
   <input type="button" value="关闭" οnclick="window.close()">
   ```

   

8. 内包含的弹出窗口---一个页面两个窗口

   上面的例子都包含两个窗口，一个是主窗口，另一个是弹出的小窗口。通过下面的例子，你可以在一个页面内完成上面的效果

   ```html
   <html> 
   　　<head> 
   　　<SCRIPT LANGUAGE="JavaScript"> 
   　　function openwin() { 
   　　	OpenWindow=window.open("", "newwin", "height=250,width=250,toolbar=no,scrollbars=scroll,menubar=no"); 
   　　	//写成一行 
         OpenWindow.document.write("<TITLE>例子</TITLE>") 
         OpenWindow.document.write("<BODY BGCOLOR=#ffffff>") 
         OpenWindow.document.write("<h1>Hello!</h1>") 
         OpenWindow.document.write("New window opened!") 
         OpenWindow.document.write("</BODY>") 
         OpenWindow.document.write("</HTML>") 
         OpenWindow.document.close() 
   　　} 
   　　</SCRIPT> 
   　　</head> 
   　　<body> 
   　　<a href="#" οnclick="openwin()">打开一个窗口</a> 
         
   　　<input type="button" οnclick="openwin()" value="打开窗口"> 
   　　</body> 
   　　</html> 
   
   ```

   

9. 终极应用---弹出的窗口这Cookie控制

   ```js
    function openwin(){ 
   　　window.open("page.html","","width=200,height=200") 
    } 
    function get_cookie(Name){
       var search=Name+"=";
       var returnvalue="";
       if(document.cookie.length>0){
   　　    if (offset != -1) { 
   　　      offset += search.length 
   　　      end = document.cookie.indexOf(";", offset); 
   　　      if (end == -1) 
   　　       end = document.cookie.length; 
   　　        returnvalue=unescape(document.cookie.substring(offset, end));
             }
        }
        return returnvalue;
    }
    function ladpopup(){
       if(get_cookie('popped=yes')){
         openwin()
         document.cookie="popped=yes";
       }
   }
   
   ```

   ```html
   <body οnlοad="loadpopup()">
   ```

   

###   

----

## 21. WebSocket协议及实现原理？

HTTP协议有一个局限：通信只能由客户端发起，服务器端不能实时发送最新数据给客户端（具有被动性）

数据交互有两种模式：**Push（推模式）**、**Pull（拉模式）**

- Push：客户端与服务端建立好**网络长连接**，服务器有相关数据，直接通过长连接通道推送到客户端

- Pull：客户端主动向服务端**发出请求**，拉取相关数据


那怎么获取最新数据呢？ 传统有两种方式：轮询、长轮询

- **轮询**：开启一个定时器，每隔一段时间调用Ajax请求一次数据


- **长轮询**：本质也是轮询，不过是阻塞型（一直打电话，没收到就不挂电话），客户端发起连接后，如果没消息，就一直不返回Response给客户端，直到有消 息才返回或超时。基于事件的触发，一个事件接一个事件。



而**WebSocket协议只需要发送一次请求**，**只要服务器有最新数据就会自动发送给客户端，不用重复请求**（类似天气预报，每当天气有变化则会自动更新最新天气状况）

**WebSocket协议没有同源限制，**客户端可与任意服务器通信，可用于解决跨域

实现原理：

WebSocket是一个应用层协议，**必须依赖 HTTP 协议进行第一次握手 ，握手成功后，数据就直接从 TCP 通道传输**，与 HTTP 再无关联。WebSocket进行了**HTTP握手 + 双工的TCP数据传输**

协议以frame形式传输数据，会将一条消息分为几个frame，按照先后顺序传输。大数据可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况，**可以边生成数据边传递消息，传输效率高**

```js
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

```



HTML5开始提供的一种浏览器与服务器进行**全双工通讯的网络技术**，属于**应用层协议**。它基于**TCP**传输协议，并复用HTTP的握手通道。

说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。

- 支持双向通信，实时性更强。
- 更好的二进制支持。
- 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），**客户端到服务端的的话，需要加上额外的4字节的掩码**。而HTTP协议每次通信都需要携带完整的头部。
- 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）



---

## 22. 请问GET请求和POST请求区别？

**参数传递**：GET 参数通过 url 传递，POST 放在 body 中（http 协议规定，url 在请求头中，所以大小限制很小）

**长度限制**：GET 请求在 url 中传递的参数是有长度限制的，POST 没有

**参数类型**：对参数的数据类型，**GET 只接受 ASCII字符**（发起之前需要进行 UrlEncoding），而 POST 没有限制

**回退影响**：GET 在浏览器回退时是无害的，**POST 会再次提交请求**

**安全性**：GET 比 POST 不安全，参数直接暴露在 url 中，不能用来传递敏感信息

**请求过程**：GET 产生**一个 TCP 数据包**；POST 产生**两个 TCP 数据包**（大多数浏览器）。对于 GET 请求，浏览器会把 http 的 header 和 data 一并发送出去，服务器响应200（返回数据）；而 POST请求，浏览器先发送 header，服务器响应100 continue，浏览器再发送 data，服务器响应200 ok（返回数据）

**是否缓存**：因为不同的应用场景，所以浏览器**一般会对 Get 请求缓存**，但很少对 Post 请求缓存。



-----

## 23. 请问HTTP状态码有哪些分类，你了解哪些状态码？

| **类别** | **原因短语**                 |                                    |
| -------- | ---------------------------- | ---------------------------------- |
| 1XX      | Informational（信息性状态码) | 接受的请求正在处理                 |
| 2XX      | Success（成功状态码）        | 请求正常处理完毕                   |
| 3XX      | Redirection（重定向）        | 需要进行附加操作以完成请求         |
| 4XX      | Client error（客户端错误）   | 客户端请求出错，服务器无法处理请求 |
| 5XX      | Server Error（服务器错误）   | 服务器处理请求出错                 |

常见HTTP 状态码：

**1xx（请求状态）：**

100 ： 继续，请求者应当继续提出请求。**服务器返回此代码表示已收到请求的第一部分**，正在等待其余部分

101 ：切换协议，**请求者已要求服务器切换协议**，服务器已确认并准备切换



**2xx（成功）：**

200：成功，服务器已经成功处理了请求

201：已创建，请求成功并且服务器创建了新的资源

202：已接受，服务器已接受请求，但尚未处理

203：**非授权信息**，服务器已经成功处理了请求，但返回的信息可能来自另一来源

204：无内容，服务器成功处理了请求，但没有返回任何内容

205：重置内容，服务器成功处理了请求，但没有返回任何内容

206：部分内容，服务器成功处理了部分GET请求



**3xx（重定向）：**

300：多种选择，针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择

301：**永久移动**，请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置

302：**临时移动**，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

303：**查看其它位置**，请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码

304：**未修改，自上次请求后，请求的网页未修改过**。服务器返回此响应，不会返回网页的内容

305：**使用代理**，请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理

307：**临时性重定向**，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求



**4xx（客户端请求错误）：**

400：**错误请求**，服务器不理解请求的语法

401：**未授权**，请求要求身份验证。对于需要登录的网页，服务器可能返回此响应

403：**禁止**，服务器拒绝请求

404：**未找到**，服务器找不到请求的网页

405：**方法禁用**，禁用请求中指定的方法

406：**不接受**，无法使用请求的内容特性响应请求的网页

407：**需要代理授权**，此状态码与401（未授权）类似，但指定请求者应当授权使用代理

408：**请求超时**，服务器等候请求时发生超时

409：**冲突**，服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息

410：**已删除**，如果请求的资源已永久删除，服务器就会返回此响应

411：**需要有效长度**，服务器不接受不含有效内容长度标头字段的请求

412：**未满足前提条件**，服务器未满足请求者在请求者设置的其中一个前提条件

413：**请求实体过大**，服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力

414：**请求的URI过长**，请求的URI（通常为网址）过长，服务器无法处理

415：**不支持媒体类型**，请求的格式不受请求页面的支持

416：**请求范围不符合要求**，如果页面无法提供请求的范围，则服务器会返回此状态码

417：**未满足期望值**，服务器未满足“期望”请求标头字段的要求



**5xx（服务器错误）：**

500：**服务器内部错误**，服务器遇到错误，无法完成请求

501：**尚未实施，服务器不具备完成请求的功能**。例如，服务器无法识别请求方法时可能会返回此代码

502：**错误网关**，服务器作为网关或代理，从上游服务器无法收到无效响应

503：**服务器不可用**，服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态

504：**网关超时**，服务器作为网关代理，但是没有及时从上游服务器收到请求

505：**HTTP版本不受支持**，服务器不支持请求中所用的HTTP协议版本



-----

## 24. 请谈谈你对浏览器的理解？

浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式

HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，但各浏览器厂商纷纷开发自己的扩展功能，对规范遵循并不完善，这便导致了严重的兼容性问题

简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少

**shell** 是指**浏览器外壳**：例如菜单，工具栏等，主要是提供给用户界面操作，参数设置，是调用内核来实现各种功能的

**内核** 是**浏览器的核心**，是基于标记语言显示内容的程序或模块



---

## 25. 请谈谈你对浏览器内核的理解？

浏览器内核主要分成两部分：

**渲染引擎：**其职责就是渲染，**即在浏览器窗口中显示所请求的内容**。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件显示 PDF 格式

**JS 引擎：**解析和执行 javascript 来实现网页的动态效果

起初渲染引擎和 JS 引擎区分并不明确，而后 JS 引擎越来越独立，**内核就倾向于只指渲染引擎**

**目前常见的浏览器内核：**

**IE 浏览器：**Trident 内核，也俗称 IE 内核

**Chrome 浏览器：**统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，**现在是 Blink内核**

**Firefox 浏览器**：Gecko 内核，俗称 Firefox 内核

**Safari 浏览器：**Webkit 内核

**Opera 浏览器：**最初是自家公司的 Presto 内核，后来从 Webkit 又转到了 Blink 内核

**360浏览器、猎豹浏览器内核：**IE + Chrome 双内核

**搜狗、遨游、QQ 浏览器内核：**Trident（兼容模式）+ Webkit（高速模式）



##### **JS 线程**

![img](E:\pogject\学习笔记\image\浏览器\js执行2)

虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：

> 其中三个只是协助，只有 JS 引擎线程是真正执行的

- **JS 引擎线程**：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎
- **事件触发线程**：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行
- **定时器触发线程**：主要控制`setInterval`和`setTimeout`，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。
- **HTTP 异步请求线程**：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。

> **注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。**



---

##  26. 从存储位置看，浏览器缓存分为哪几种？

从存储位置来看，浏览器缓存一共分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

### Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。**使用 Service Worker的话，传输协议必须为 HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。**Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。**

Service Worker 实现缓存功能一般分为三个步骤：

- 首先需要先注册 Service Worker
- 然后监听到 install 事件以后就可以缓存需要的文件
- 那么在下次用户访问的时候就可以**通过拦截请求的方式查询是否存在缓存**，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。
- 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。**但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。**

### Memory Cache

Memory Cache 也就是**内存中的缓存**，主要包含的是当前页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,**内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放**。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

### Disk Cache

Disk Cache 也就是存储在**硬盘中的缓存**，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上**。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**绝大部分的缓存都来自 Disk Cache。**

### Push Cache

Push Cache（**推送缓存**）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。他有如下的一些特性：

- 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差。
- Push Cache 中的缓存只能被使用一次
- 可以给其他域名推送资源
- 浏览器可以拒绝接受已经存在的资源推送
- 一旦连接被关闭，Push Cache 就被释放
- **可以推送 no-cache 和 no-store 的资源**
- 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑， 有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。



----

## 27. 请问你了解浏览器缓存吗？

缓存可以重复利用文件，降低网络负荷，提高网页打开速度，提升用户体验

缓存分类：

从宏观上分为**私有缓存**和**共享缓存**，共享缓存就是那些能被各级代理缓存的缓存，私有缓存就是用户专享的，各级代理不能缓存

从微观上可以分为以下几类：

a、浏览器缓存

b、代理服务器缓存

c、CDN缓存

d、数据库缓存

e、应用层缓存

主要对浏览器的缓存进行分析：

![img](E:\pogject\学习笔记\image\浏览器\826C8F1D891122B9999FE81E1D55CA33)

**（1）、HTTP缓存：主要分为强缓存与协商缓存**

- 强缓存

强可理解为强制的意思，当浏览器去请求某个文件的时候，**服务端就在respone header里面对该文件做了缓存配置**。缓存的时间、缓存类型都由**服务端**控制，具体由 respone header 的cache-control 控制，常见的设置是max-age public， private ，no-cache ，no-store等，各类设置对应情况：

a、cache-control: **max-age=xxxx，public**

**客户端和代理服务器都可以缓存该资源**，客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code200 ，**如果用户做了刷新操作，就向服务器发起http请求**

b、cache-control: **max-age=xxxx，private**

**只让客户端可以缓存该资源**；代理服务器不缓存，客户端在xxx秒内直接读取缓存，statu code:200

c、cache-control: **max-age=xxxx，immutable**

客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code:200 ，**即使用户做了刷新操作，也不向服务器发起http请求**

d、cache-control: **no-cache**

跳过设置强缓存，**但不妨碍设置协商缓存**；通常做了强缓存，只有强缓存失效了才走协商缓存的，**设置了no-cache就不会走强缓存了，每次请求都回询问服务端**

e、cache-control: no-store

**不缓存**，客户端、服务器都不缓存

- 协商缓存

可理解为**强缓存就是为资源设置一个有效时间，每次请求资源时都会检查是否过期，只有过期才会去请求服务器**（可有效减少请求次数），当强制缓存失效后，浏览器携带**缓存标识**向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程协商缓存生效，返回304和Not Modified

在 response header里面的设置etag、last-modified

**etag**：每个文件具有唯一一个“标识”

**last-modified**：文件的修改时间，精确到秒

每次请求返回携带**response header**中的etag和last-modified，在下次请求时**request header**也会带上，服务端对比etag标识，判断资源是否更改，**如更改直接返回新的资源**，**并更新response header的etag、last-modified**，如资源不变，etag、last-modified不变，**对客户端来说，每次请求都进行了协商缓存**，即：

发请求-->资源是否过期？-->过期（没过期为强缓存）-->请求服务器-->服务器对比资源是否真的过期？-->没过期-->返回304状态码-->客户端用缓存的老资源

当服务端发现资源过期时：

服务器对比资源是否真的过期-？->过期-->返回200状态码和资源-->客户端像第一次接收该资源一样，记录cache-control中的max-age、etag、last-modified等信息

**（2）、本地存储**

主要有：localStorage，sessionStorage和cookie，WebSql和IndexDB主要用在前端有**大容量存储需求的页面上**，如在线编辑浏览器或者网页邮箱，可以将数据存储在浏览器，应该根据不同的场景进行使用

- Cookie

**由服务器生成，且前端也可设置**，保存在客户端本地的一个文件，通过response header的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器

其中包含的信息：

a、用户ID、密码、浏览过的网页、停留的时间等信息，当该用户再打开该网站时，网站通过读取Cookie，就可以做出相应的动作，如身份校验、提示语等

b、还保存host属性，即网站的域名或ip，一个网站只能读取它自己放置的信息，不能读取其他网站的Cookie文件

Cookie **优点**：给用户更人性化的使用体验，如自动登陆、提示语；**弥补了HTTP无连接特性**；可作为站点统计访问量依据

Cookie **缺点**：无法解决多人共用电脑问题，具有安全隐患；Cookie文件容易被误删除；可人为修改host文件，可以非法访问目标站点的Cookie；容量较小，不能超过4kb；直接在response header上带数据安全性差

- LocalStorage（本地存储）

主要是开发人员在前端设置，一旦数据保存在本地后，就可避免再向服务器请求数据，从而减少不必要的数据请求，可以长期存储数据，没有时间限，遵循同源策略，不同的网站不能直接共用

一般浏览器localStorage支持的是5M大小，不同的浏览器会略有不同

LocalStorage **优点**：拓展了Cookie的4k限制；可以将第一次请求的5M大小数据直接存储到本地，相比于Cookie节约带宽

LocalStorage **缺点**：需要手动删除，否则长期存在；浏览器大小不一，版本的支持也不一样；**只支持string类型的存储**，JSON对象需要转换；**本质上是对字符串的读取，存储内容过多会消耗内存空间，导致卡顿**

- SessionStorage（会话存储）

同样是开发人员在前端设置，用于**临时保存同一窗口(或标签页)的数据**，在关闭窗口或标签页之后将会删除这些数据，大多数浏览器限制为5MB

- WebSQL

WebSQL 是**在浏览器上模拟数据库**，可以使用JS来操作SQL进行数据读写，使用 SQL 来操纵客户端数据库的 API（**异步**），现阶段使用较少

- **IndexedDB**

随浏览器的功能日益强大，越来越多的网站将大量数据储存在客户端，可减少从服务器获取数据，直接从本地获取数据

现有浏览器数据储存方案，都不适用于储存大量数据：Cookie 大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 大小在2.5MB 到 10MB 之间（各家浏览器不同），且不提供搜索功能，不能建立自定义的索引。

IndexedDB 是浏览器提供的本地数据库，**可被网页脚本创建和操作**。IndexedDB 允许储存大量数据，**提供查找接口，还能建立索引**。但IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），**更接近 NoSQL 数据库**



---

## 28. 为什么部分请求中，参数需要使用 encodeURIComponent 进行转码？

一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。

这是因为网络标准RFC 1738做了硬性规定.

这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致"URL编码"成为了一个混乱的领域。

不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果。如果程序员要把每一种结果都考虑进去，是不是太恐怖了？有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？

就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。

Javascript语言用于编码的函数，一共有三个，最古老的一个就是escape()。虽然这个函数现在已经不提倡使用了，但是由于历史原因，很多地方还在使用它，所以有必要先从它讲起。

它的具体规则是，除了ASCII字母、数字、标点符号"@ * _ + - . /"以外，对其他所有字符进行编码。

encodeURI()是Javascript中真正用来对URL编码的函数。

它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号"; / ? : @ & = + $ , #"，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。

最后一个Javascript编码函数是**encodeURIComponent()**。与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。

因此，"; / ? : @ & = + $ , #"，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。

它对应的解码函数是decodeURIComponent()。



---

## 29. WebSocket 中的心跳是为了解决什么问题？

- **为了定时发送消息，使连接不超时自动断线，避免后端设了超时时间自动断线**。所以需要定时发送消息给后端，让后端服务器知道连接还在通消息不能断。
- **为了检测在正常连接的状态下，后端是否正常**。如果我们发了一个定时检测给后端，后端按照约定要下发一个检测消息给前端，这样才是正常的。如果后端没有正常下发，就要根据设定的超时进行重连。



----

## 30. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？

短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。

### 短轮询

**短轮询的基本思路是** 浏览器每隔一段时间向服务器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，**通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化**。

这种方式的**优点**是比较简单，易于理解。

**缺点**是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。

### 长轮询

**长轮询的基本思路是** 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。**如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回**。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。

长轮询和短轮询比起来，它的**优点**是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。

长轮询的**缺点**在于，连接挂起也会导致资源的浪费。

### SSE

**SSE 的基本思想是** 服务器使用流信息向浏览器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，**有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息**。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，**视频播放就是这样的例子**。

SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。

### WebSocket

**WebSocket** 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的**缺点**是在服务器端的配置比较复杂。

WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 **SSE 的方式是单向通信的，只能由服务器端向客户端推送信息**，如果客户端需要发送信息就是属于下一个 http 请求了。



**上面的四个通信协议，前三个都是基于HTTP协议的。** 对于这四种即时通信协议，从性能的角度来看： **WebSocket > 长连接（SEE） > 长轮询 > 短轮询** 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： **短轮询 > 长轮询 > 长连接（SEE） > WebSocket** 所以，还是要根据具体的使用场景来判断使用哪种方式。



----

## 31. HSTS是什么

HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书。 目前大多数主流浏览器都支持 HSTS (只有一些移动浏览器无法使用它)。

**HTTP严格传输安全性** （HSTS）是一种网络安全策略机制，旨在保护HTTPS网站免受降级攻击和cookie劫持。 配置为使用HSTS的Web服务器指示Web浏览器（或其他客户端软件）仅使用HTTPS连接，并禁止使用HTTP协议。

该指令称为“ HSTS策略”，并使用HTTP响应标头字段（作为对连接的初始请求的一部分）发送给客户端（Strict-Transport-Security）。 服务器的HSTS策略包括客户端应将指令缓存多长时间，以及子域是否也仅使用HTTPS。

HSTS是HTTPS协议的永久组成部分，并在 [RFC 6797](https://tools.ietf.org/html/rfc6797).

> HSTS 可以用来抵御 SSL 剥离攻击。SSL 剥离攻击是中间人攻击的一种，由 Moxie Marlinspike 于2009年发明。他在当年的黑帽大会上发表的题为 “New Tricks For Defeating SSL In Practice” 的演讲中将这种攻击方式公开。SSL剥离的实施方法是阻止浏览器与服务器创建HTTPS连接。它的前提是用户很少直接在地址栏输入https://，用户总是通过点击链接或3xx重定向，从HTTP页面进入HTTPS页面。所以攻击者可以在用户访问HTTP页面时替换所有https://开头的链接为http://，达到阻止HTTPS的目的。
>
> HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。
>
> 另外，如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。

场景举例：

> 当你通过一个无线路由器的免费 WiFi 访问你的网银时，很不幸的，这个免费 WiFi 也许就是由黑客的笔记本所提供的，他们会劫持你的原始请求，并将其重定向到克隆的网银站点，然后，你的所有的隐私数据都曝光在黑客眼下。
>
> 严格传输安全可以解决这个问题。如果你之前使用 HTTPS 访问过你的网银，而且网银的站点支持 HSTS，那么你的浏览器就知道应该只使用 HTTPS，无论你是否输入了 HTTPS。这样就防范了中间人劫持攻击。

注意，**如果你之前没有使用 HTTPS 访问过该站点，那么 HSTS 是不奏效的**。网站需要通过 HTTPS 协议告诉你的浏览器它支持 HSTS。

服务器开启 HSTS 的方法是，当客户端通过HTTPS发出请求时，在服务器返回的 HTTP 响应头中包含 Strict-Transport-Security 字段。非加密传输时设置的HSTS字段无效。



---

## 谈谈indexDB





----

## postMessage 有哪些使用场景？

`window.postMessage()` 方法可以安全地实现跨源通信。`window.postMessage()` 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全

postMessage 是 HTML5 新方法，它可以实现跨域窗口之间通讯。到目前为止，只有 IE8+, Firefox 3, Opera 9, Chrome 3和 Safari 4 支持，而本篇文章主要讲述 postMessage 方法与 message 事件跨浏览器实现。


postMessage 方法 JSONP 技术不一样，前者是前端擅长跨域文档数据即时通讯，后者擅长针对跨域服务端数据通讯，postMessage 应用场景能说明这个区别：

## 应用场景举例

1. webOS 使用 iframe 嵌入第三方应用，此时 webOS 与应用需要实时接收/发送各自的消息与响应事件。
2. 页面弹出一个由 iframe 层，嵌入第三方提供的图片上传页面，文件上传完毕后需要获取返回图片地址插入到编辑器。
3. iframe 跨域高度自适应。



场景分析：第三方在页面中初始化SDK,这个SDK生成一个iframe，iframe中有个表单，提交表单，根据同源策略，提交表单发出的请求是向我方服务器发送的，返回的结果也只能在iframe中，如何把iframe中的消息也就是我方服务器返回的结果传给第三方在页面？这就是跨域，于是postMesage 就派上了用场。



**可用于两个不同的Iframe（不同源） 之间的通讯**

语法

```
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

参数说明

- `data`

  从其他 window 中传递过来的对象。

- `origin`

  调用 `postMessage` 时消息发送方窗口的 [origin](https://developer.mozilla.org/en-US/docs/Origin) . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “`https://example.org` (隐含端口 `443`)”、“`http://example.net` (隐含端口 `80`)”、“`http://example.com:8080`”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。

- `source`

  对发送消息的[窗口](https://developer.mozilla.org/en-US/docs/Web/API/Window)对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。

例子

子框架传递信息

```html
<script>

// 子框架向父框架发送信息

function goParentIfromPostMessage(msg,parentUrl){

    var parentUrl = window.parent.location.origin;

        window.onload=function(){

        window.parent.postMessage(msg,parentUrl);

        }
    }
 }
 
    goParentIfromPostMessage('msgStr',parentIfromUrl)

</script>
```

父框架接收端

```html
<script>

        window.addEventListener('message',function(e){

            console.log(e.origin,e.data);

            console.log(e.data);

        })

</script>
```

这样即可以实现简单的框架跨域通信，但是会有一些安全问题

安全问题

**如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。** 这是一个完全万无一失的方式来避免安全问题。

如果您确实希望从其他网站接收message，请**始终使用origin和source属性验证发件人的身份**。 任何窗口（包括例如[http://evil.example.com）都可以向任何其他窗口发送消息，并且您不能保证未知发件人不会发送恶意消息。](http://evil.example.xn--com)%2C-si1ha8cz2h5hyf7h8bz0ah3ak6dswlfyleae18asi11a590rxkkla2qq9cvzfr23eri3bqa4568f7etajg5c182e536asa219g./) 但是，验证身份后，您仍然应该**始终验证接收到的消息的语法**。 否则，您信任只发送受信任邮件的网站中的安全漏洞可能会在您的网站中打开跨网站脚本漏洞。

**当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是\*。** 恶意网站可以在您不知情的情况下更改窗口的位置，因此它可以拦截使用postMessage发送的数据。

示例

```js
/*
 * A窗口的域名是<http://example.com:8080>，以下是A窗口的script标签下的代码：
 */

var popup = window.open(...popup details...);

// 如果弹出框没有被阻止且加载完成

// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）
popup.postMessage("The user is 'bob' and the password is 'secret'",
                  "https://secure.example.net");

// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）
popup.postMessage("hello there!", "http://example.org");

function receiveMessage(event)
{
  // 我们能相信信息的发送者吗?  (也许这个发送者和我们最初打开的不是同一个页面).
  if (event.origin !== "http://example.org")
    return;

  // event.source 是我们通过window.open打开的弹出页面 popup
  // event.data 是 popup发送给当前页面的消息 "hi there yourself!  the secret response is: rheeeeet!"
}
window.addEventListener("message", receiveMessage, false);
/*
 * 弹出页 popup 域名是<http://example.org>，以下是script标签中的代码:
 */

//当A页面postMessage被调用后，这个function被addEventListener调用
function receiveMessage(event)
{
  // 我们能信任信息来源吗？
  if (event.origin !== "http://example.com:8080")
    return;

  // event.source 就当前弹出页的来源页面
  // event.data 是 "hello there!"

  // 假设你已经验证了所受到信息的origin (任何时候你都应该这样做), 一个很方便的方式就是把event.source
  // 作为回信的对象，并且把event.origin作为targetOrigin
  event.source.postMessage("hi there yourself!  the secret response " +
                           "is: rheeeeet!",
                           event.origin);
}

window.addEventListener("message", receiveMessage, false);
```



----

## window.requestAnimationFrame的使用

**`window.requestAnimationFrame()`** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

> **备注：** 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 `window.requestAnimationFrame()`

当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数 (即你的回调函数)。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当`requestAnimationFrame()` 运行在后台标签页或者隐藏的[``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe) 里时，`requestAnimationFrame()` 会被暂停调用以提升性能和电池寿命。

回调函数会被传入[`DOMHighResTimeStamp`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp)参数，[`DOMHighResTimeStamp`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp)指示当前被 `requestAnimationFrame()` 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为 1ms(1000μs)。

> **警告：** 请确保总是使用第一个参数 (或其它获得当前时间的方法) 计算每次调用之间的时间间隔，否则动画在高刷新率的屏幕中会运行得更快。

```js
window.requestAnimationFrame(callback);
```

- `callback`

  下一次重绘之前更新动画帧所调用的函数 (即上面所说的回调函数)。该回调函数会被传入[`DOMHighResTimeStamp`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp)参数，该参数与[`performance.now()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now)的返回值相同，它表示`requestAnimationFrame()` 开始去执行回调函数的时刻。

返回值

一个 `long` 整数，请求 ID ，**是回调列表中唯一的标识**。是个非零值，没别的意义。你可以传这个值给 [`window.cancelAnimationFrame()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame) 以取消回调函数。

```js
const element = document.getElementById('some-element-you-want-to-animate');
let start, previousTimeStamp;
let done = false

function step(timestamp) {
  if (start === undefined) {
    start = timestamp;
  }
  const elapsed = timestamp - start;

  if (previousTimeStamp !== timestamp) {
    // 这里使用 `Math.min()` 确保元素刚好停在 200px 的位置。
    const count = Math.min(0.1 * elapsed, 200);
    element.style.transform = 'translateX(' + count + 'px)';
    if (count === 200) done = true;
  }

  if (elapsed < 2000) { // 在两秒后停止动画
    previousTimeStamp = timestamp;
    if (!done) {
      window.requestAnimationFrame(step);
    }
  }
}

window.requestAnimationFrame(step);

```

