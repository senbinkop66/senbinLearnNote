----

# 计算机组成原理部分

-----

## 原码、反码和补码分别是什么？

**原码**

原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。

**反码**

正数的反码和其原码一样；

**负数的反码，符号位为1**，数值部分按原码取反。

如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

**补码**

**正数的补码和其原码一样**；

**负数的补码为其反码加1。**

例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；

[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001

之所以在计算机中使用补码来表示负数的原因是，**这样可以将加法运算扩展到所有的数值计算上**，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。

----

## Unicode 和 UTF-8 之间有什么关系？

Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。

UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。

----

##  堆与栈有什么区别？

堆（Heap）与栈（Stack）是开发人员必须面对的两个概念，在理解这两个概念时，需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：

- 程序内存布局场景下，堆与栈表示**两种内存管理方式**；
- 数据结构场景下，堆与栈表示**两种常用的数据结构**。

### 程序内存分区中的堆与栈

#### 栈简介

栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式**类似于数据结构中的栈**。

其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。**栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量**，栈中存储的数据的生命周期随着函数的执行完成而结束。

#### 堆简介

堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式**类似于链表**。

堆的**内存地址生长方向与栈相反，由低到高**，但需要注意的是，**后申请的内存空间并不一定在先申请的内存空间的后面，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存**，从而导致先后分配的内存空间在地址上不存在先后关系。**堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。**

关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。

#### 堆与栈区别

堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：

（1）**管理方式不同**。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）**空间大小不同**。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

（3）**生长方向不同**。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）**分配方式不同**。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

（5）**分配效率不同**。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）**存放内容不同**。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。

无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。

### 数据结构中的堆与栈

数据结构中，堆与栈是两个常见的数据结构，理解二者的定义、用法与区别，能够利用堆与栈解决很多实际问题。

#### 栈简介

栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“先进后出”的特性（First In Last Out），简称FILO。

栈分顺序栈和链式栈两种。栈是一种线性结构，所以可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。使用数组实现的栈叫做顺序栈，使用链表实现的栈叫做链式栈，二者的区别是顺序栈中的元素地址连续，链式栈中的元素地址不连续。

栈的基本操作包括初始化、判断栈是否为空、入栈、出栈以及获取栈顶元素等。

#### 堆简介

堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一特性称之为堆序性。因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。堆的左右孩子没有大小的顺序。

堆的存储一般都用数组来存储堆，i节点的父节点下标就为( i – 1 ) / 2 (i – 1) / 2(i–1)/2。它的左右子节点下标分别为 2 ∗ i + 1 2 * i + 12∗i+1 和 2 ∗ i + 2 2 * i + 22∗i+2。如第0个节点左右子节点下标分别为1和2。





----

# 操作系统部分

----

## 1.说说你对操作系统的理解？核心概念有哪些？

### 操作系统是什么

操作系统（Operating System，缩写：OS）是一组管理并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石

简单来讲，**操作系统就是一种复杂的软件，相当于软件管家**

操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务，

操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统，在计算机与用户之间起接口的作用，如下图：



![img](E:\pogject\学习笔记\image\其他\os1)

许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序



### 核心概念

操作系统的核心概念都是对具体物理硬件的抽象，主要有如下：

- 进程（线程）：进程（线程）是操作系统对CPU的抽象
- 虚拟内存（地址空间）：虚拟内存是操作系统对物理内存的抽象
- 文件：文件是操作系统对物理磁盘的抽象
- shell：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。
- GUI ：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互
- 计算机架构(computer architecture)： 在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构
- 多处理系统(Computer multitasking)：是指计算机同时运行多个程序的能力
- 程序计数器(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置
- 多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术
- CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核
- 图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片
- 缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中
- RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器
- ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除
- 虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制
- 驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序
- USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范
- 地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范
- 进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法
- 目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器
- 路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。
- 根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /
- 工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。
- 文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念
- 客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。
- 服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备

###  操作系统的作用

- 1.3.1 进程

  - •进程概念

    - –一个正在执行的程序

    - –计算机中正在运行的程序的一个实例

    - –可分配给处理器并由处理器执行的一个实体

    - –由下述表征的活动单元

      - 一个单一顺序线程

      - 一个当前状态

      - 一组相关系统资源

  - •设计协调不同活动的系统软件非常困难

    - –不正确的同步

    - –失败的互斥

    - –不确定的程序操作

    - –死锁

  - •进程的组成

    - –一段可执行的程序

    - –程序所需要的相关数据（变量、工作空间、缓冲区等）

    - –程序的执行上下文（executioncontext）

      - 进程状态（process state）

      - 操作系统用来管理和控制进程所需的所有数据

- 1.3.2 内存管理

  - •存储管理的任务

    - –进程隔离：每个进程拥有独立的地址空间，互不干扰

    - –自动分配和管理：动态分配，对程序员透明

    - –支持模块化程序设计：能够动态加载、销毁程序员定义的模块

    - –保护和访问控制：一个应用程序不能任意访问其它程序的存储空间

    - –长期存储：关机后仍能长时间存储信息

  - •存储管理的实现方式
    - 文件系统 + 虚拟存储

  - •文件系统

    - –实现了长期存储

    - –文件

      - 一个有名称的对象

      - 访问控制和保护的基本单元

  - •虚拟存储

    - –程序以逻辑方式访问存储器

    - –多作业同时驻留内存

    - –每个作业部分驻留

    - 换入、换出机制

  - •分页机制

    - –进程由若干个固定大小的块组成——页

    - –虚地址（virtualaddress）由页号和页内偏移量组成

    - –进程中的每一页均可置于内存中任何位置

    - –提供了虚地址和实地址（realaddress）之间的动态映射机制

- 1.3.3 信息保护和安全

  - •操作系统的4类典型安全问题

    - –可用性
      - 保护系统不被中断

    - –机密性
      - 保证用户不能读取未授权访问的数据

    - –完整性
      - 保护数据不被未授权修改

    - –认证
      - 涉及用户身份的正确认证和消息或数据的合法性

- 1.3.4 调度和资源管理

  - •考虑因素

    - –公平性
      - 所有进程享有同等和公平的资源访问机会

    - –有差别的响应性
      - 区分进程类型且可动态调整

    - –有效性
      - 折中处理矛盾需求



### 操作系统的基本特征

- 1.4.1 并发性

  - 并发性——最重要的特征，其它特征的前提

  - •并发：两个或多个事件在同一时间间隔内发生

  - •并行：两个或多个事件在同一时刻发生

  - •程序：静态实体，无法并发

  - •进程：动态实体，可并发执行

    - –单处理机系统：进程可并发执行，无法并行执行

    - –多处理机系统：进程既可并发执行，又可并行执行

  - • 并发性： 在多道程序环境下，在一段时间内，有多个任务同时运行

  - •优点：让CPU、I/O设备并行工作，提高资源利用率。

- 1.4.2 共享

  - •概念
    - 系统中的资源可供内存中多个并发执行的进程共同使用。

  - •共享资源类型

    - –临界资源：在一段时间内，只允许一个进程访问

    - –非临界资源：在一段时间内，允许多个进程访问

  - •共享方式

    - –互斥共享方式
      - 对临界资源的访问，如打印机

    - –同时访问方式
      - 对非临界资源的访问，如磁盘

- 1.4.3 虚拟性

  - •虚拟
    - 通过某种技术把一个物理实体变为若干个逻辑上的对应物。

  - •实现方式

    - –时分复用技术

      - 虚拟处理机

      - 虚拟设备，如打印机（SPOOLING技术）

    - –空分复用技术

      - 虚拟磁盘

      - 虚拟内存

- 1.4.4 异步性

  - •不确定性（异步性）

    - 在多道程序环境下，程序执行过程的不确定性

      - -何时执行

      - -执行顺序

      - -完成运行所需时间

  - •通常而言，操作系统的不确定性是指异步性，而非程序执行结果的不确定性。



----

## 进程与线程有什么区别？

- 进程是系统进行资源分配和调度的一个独立单位
- 线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
- 一个进程至少由一个线程组成。

线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。





----

## 进程间有哪些通信方式？

- 管道通信
- 消息队列通信
- 信号量通信
- 共享内存通信
- 套接字通信



----

##  什么是内存泄漏？

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。

```c
char * buffer;
buffer = (char*) malloc(42);

// Do something with buffer

free(buffer);
```

上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。



---





----

# 数据库部分

----

## 关系型和非关系型数据库的区别？

关系型数据库的优点

- 容易理解，因为它采用了关系模型来组织数据。
- 可以保持数据的一致性。
- 数据更新的开销比较小。
- 支持复杂查询（带 where 子句的查询）

非关系型数据库（NOSQL）的优点

- 无需经过 SQL 层的解析，读写效率高。
- 基于键值对，读写性能很高，易于扩展
- 可以支持多种类型数据的存储，如图片，文档等等。
- 扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。

----

### 详细说一下一条 MySQL 语句执行的步骤

Server 层按顺序执行 SQL 的步骤为：

- 客户端请求 -> 连接器（验证用户身份，给予权限）
- 查询缓存（存在缓存则直接返回，不存在则执行后续操作）
- 分析器（对 SQL 进行词法分析和语法分析操作）
- 优化器（主要对执行的 SQL 优化选择最优的执行方案方法）
- 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）





----

##  介绍一下数据库设计的三大范式

目前关系数据库有六种范式，一般来说，数据库只需满足第三范式(3NF）就行了。

**第一范式（1NF）**：

是指在关系模型中，**对于添加的一个规范要求，所有的域都应该是原子性的**，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。

**第二范式（2NF）：**

在1NF的基础上，非主码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。

第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。**第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。**选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。

例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。

**第三范式（3NF）：**

在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。

第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。

例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。