----

# 计算机组成原理部分

-----

## 原码、反码和补码分别是什么？

**原码**

原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。

**反码**

正数的反码和其原码一样；

**负数的反码，符号位为1**，数值部分按原码取反。

如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

**补码**

**正数的补码和其原码一样**；

**负数的补码为其反码加1。**

例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；

[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001

之所以在计算机中使用补码来表示负数的原因是，**这样可以将加法运算扩展到所有的数值计算上**，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。

----

## Unicode 和 UTF-8 之间有什么关系？

Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。

UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。

----

##  堆与栈有什么区别？

堆（Heap）与栈（Stack）是开发人员必须面对的两个概念，在理解这两个概念时，需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：

- 程序内存布局场景下，堆与栈表示**两种内存管理方式**；
- 数据结构场景下，堆与栈表示**两种常用的数据结构**。

### 程序内存分区中的堆与栈

#### 栈简介

栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式**类似于数据结构中的栈**。

其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。**栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量**，栈中存储的数据的生命周期随着函数的执行完成而结束。

#### 堆简介

堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式**类似于链表**。

堆的**内存地址生长方向与栈相反，由低到高**，但需要注意的是，**后申请的内存空间并不一定在先申请的内存空间的后面，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存**，从而导致先后分配的内存空间在地址上不存在先后关系。**堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。**

关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。

#### 堆与栈区别

堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：

（1）**管理方式不同**。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）**空间大小不同**。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

（3）**生长方向不同**。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）**分配方式不同**。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

（5）**分配效率不同**。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）**存放内容不同**。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。

无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。

### 数据结构中的堆与栈

数据结构中，堆与栈是两个常见的数据结构，理解二者的定义、用法与区别，能够利用堆与栈解决很多实际问题。

#### 栈简介

栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“先进后出”的特性（First In Last Out），简称FILO。

栈分顺序栈和链式栈两种。栈是一种线性结构，所以可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。使用数组实现的栈叫做顺序栈，使用链表实现的栈叫做链式栈，二者的区别是顺序栈中的元素地址连续，链式栈中的元素地址不连续。

栈的基本操作包括初始化、判断栈是否为空、入栈、出栈以及获取栈顶元素等。

#### 堆简介

堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一特性称之为堆序性。因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。堆的左右孩子没有大小的顺序。

堆的存储一般都用数组来存储堆，i节点的父节点下标就为( i – 1 ) / 2 (i – 1) / 2(i–1)/2。它的左右子节点下标分别为 2 ∗ i + 1 2 * i + 12∗i+1 和 2 ∗ i + 2 2 * i + 22∗i+2。如第0个节点左右子节点下标分别为1和2。





----

# 操作系统部分

----

## 1.说说你对操作系统的理解？核心概念有哪些？

### 操作系统是什么

操作系统（Operating System，缩写：OS）是一组管理并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石

简单来讲，**操作系统就是一种复杂的软件，相当于软件管家**

操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务，

操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统，在计算机与用户之间起接口的作用，如下图：



![img](E:\pogject\学习笔记\image\其他\os1)

许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序



### 核心概念

操作系统的核心概念都是对具体物理硬件的抽象，主要有如下：

- 进程（线程）：进程（线程）是操作系统对CPU的抽象
- 虚拟内存（地址空间）：虚拟内存是操作系统对物理内存的抽象
- 文件：文件是操作系统对物理磁盘的抽象
- shell：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。
- GUI ：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互
- 计算机架构(computer architecture)： 在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构
- 多处理系统(Computer multitasking)：是指计算机同时运行多个程序的能力
- 程序计数器(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置
- 多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术
- CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核
- 图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片
- 缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中
- RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器
- ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除
- 虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制
- 驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序
- USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范
- 地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范
- 进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法
- 目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器
- 路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。
- 根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /
- 工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。
- 文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念
- 客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。
- 服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备

###  操作系统的作用

- 1.3.1 进程

  - •进程概念

    - –一个正在执行的程序

    - –计算机中正在运行的程序的一个实例

    - –可分配给处理器并由处理器执行的一个实体

    - –由下述表征的活动单元

      - 一个单一顺序线程

      - 一个当前状态

      - 一组相关系统资源

  - •设计协调不同活动的系统软件非常困难

    - –不正确的同步

    - –失败的互斥

    - –不确定的程序操作

    - –死锁

  - •进程的组成

    - –一段可执行的程序

    - –程序所需要的相关数据（变量、工作空间、缓冲区等）

    - –程序的执行上下文（executioncontext）

      - 进程状态（process state）

      - 操作系统用来管理和控制进程所需的所有数据

- 1.3.2 内存管理

  - •存储管理的任务

    - –进程隔离：每个进程拥有独立的地址空间，互不干扰

    - –自动分配和管理：动态分配，对程序员透明

    - –支持模块化程序设计：能够动态加载、销毁程序员定义的模块

    - –保护和访问控制：一个应用程序不能任意访问其它程序的存储空间

    - –长期存储：关机后仍能长时间存储信息

  - •存储管理的实现方式
    - 文件系统 + 虚拟存储

  - •文件系统

    - –实现了长期存储

    - –文件

      - 一个有名称的对象

      - 访问控制和保护的基本单元

  - •虚拟存储

    - –程序以逻辑方式访问存储器

    - –多作业同时驻留内存

    - –每个作业部分驻留

    - 换入、换出机制

  - •分页机制

    - –进程由若干个固定大小的块组成——页

    - –虚地址（virtualaddress）由页号和页内偏移量组成

    - –进程中的每一页均可置于内存中任何位置

    - –提供了虚地址和实地址（realaddress）之间的动态映射机制

- 1.3.3 信息保护和安全

  - •操作系统的4类典型安全问题

    - –可用性
      - 保护系统不被中断

    - –机密性
      - 保证用户不能读取未授权访问的数据

    - –完整性
      - 保护数据不被未授权修改

    - –认证
      - 涉及用户身份的正确认证和消息或数据的合法性

- 1.3.4 调度和资源管理

  - •考虑因素

    - –公平性
      - 所有进程享有同等和公平的资源访问机会

    - –有差别的响应性
      - 区分进程类型且可动态调整

    - –有效性
      - 折中处理矛盾需求



### 操作系统的基本特征

- 1.4.1 并发性

  - 并发性——最重要的特征，其它特征的前提

  - •并发：两个或多个事件在同一时间间隔内发生

  - •并行：两个或多个事件在同一时刻发生

  - •程序：静态实体，无法并发

  - •进程：动态实体，可并发执行

    - –单处理机系统：进程可并发执行，无法并行执行

    - –多处理机系统：进程既可并发执行，又可并行执行

  - • 并发性： 在多道程序环境下，在一段时间内，有多个任务同时运行

  - •优点：让CPU、I/O设备并行工作，提高资源利用率。

- 1.4.2 共享

  - •概念
    - 系统中的资源可供内存中多个并发执行的进程共同使用。

  - •共享资源类型

    - –临界资源：在一段时间内，只允许一个进程访问

    - –非临界资源：在一段时间内，允许多个进程访问

  - •共享方式

    - –互斥共享方式
      - 对临界资源的访问，如打印机

    - –同时访问方式
      - 对非临界资源的访问，如磁盘

- 1.4.3 虚拟性

  - •虚拟
    - 通过某种技术把一个物理实体变为若干个逻辑上的对应物。

  - •实现方式

    - –时分复用技术

      - 虚拟处理机

      - 虚拟设备，如打印机（SPOOLING技术）

    - –空分复用技术

      - 虚拟磁盘

      - 虚拟内存

- 1.4.4 异步性

  - •不确定性（异步性）

    - 在多道程序环境下，程序执行过程的不确定性

      - -何时执行

      - -执行顺序

      - -完成运行所需时间

  - •通常而言，操作系统的不确定性是指异步性，而非程序执行结果的不确定性。



----

## 进程与线程有什么区别？

- 进程是系统进行资源分配和调度的一个独立单位
- 线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
- 一个进程至少由一个线程组成。

线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。





----

## 进程间有哪些通信方式？

- 管道通信
- 消息队列通信
- 信号量通信
- 共享内存通信
- 套接字通信



----

##  什么是内存泄漏？

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。

```c
char * buffer;
buffer = (char*) malloc(42);

// Do something with buffer

free(buffer);
```

上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。



---

## 死锁是什么？死锁产生的原因和必要条件

一、死锁概念
死锁是指两个或多个进程在执行的过程中，**因为竞争资源而造成互相等待的现象**，若无外力作用，它们都无法推进下去。

当进程需要以独占的方式访问资源时，可能会发生死锁（Deadlock）。死锁是指两个或以上进程因竞争临界资源而造成的一种僵局，即一个进程等待一个已经被占用且永不释放的资源。若无外力作用，这些进程都无法向前推进。

**产生死锁的根本原因**是系统能够提供的资源个数比要求该资源的进程数要少。

**产生死锁的基本原因**可以分为两类：资源竞争和进程推进顺序不合理。

1.在等待对方时占有不可抢占的资源
举个例子，假设有P1，P2两个进程，都需要A和B两个资源，两个都等待另一个资源而不肯释放资源，就这样无限等待中，这就形成死锁。这只是死锁的一种情况，就是在等待对方时占有不可抢占的资源。
2.竞争可消耗资源引起死锁
有P1，P2，P3三个进程，P1向P2发送消息并接受P3消息，P2向P3发送消息并接受P2消息，P3向P1发送消息并接受P2消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，也造成了死锁。
3.进程推进顺序不当引起死锁
有进程P1，P2，都需要资源A,B，本来可以P1运行A，P1运行B，P2运行B，P2运行A，P2运行B，但顺序换了，P1运行A时P2运行B，容易引发死锁，属于第一种的资源抢占问题。

二、产生死锁的四个必要条件
1.互斥条件
**一个资源每次只能被一个进程使用**，即在一段时间内某资源仅为一个进程所使用。此时如果有其他进程请求该资源，则请求进程只能等待。

2.占有并等待（部分分配）
**进程中已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有**，此时请求进程被阻塞，但对自己已经获得资源保持不放。

3.不可剥夺条件
**进程未使用完的资源在未使用完毕之前，不能被其他进程强行夺走**，即只能由获得该资源的进程自己来释放。

4.循环等待条件
**若干进程间形成首尾相接循环等待资源的关系**。在发生死锁时必然存在一个进程等待队列{P1，P2，…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请。

注意：**这四个条件是死锁的必然条件，只要系统发生死锁，这些条件必然成立**。只要有上述条件有一条不满足，就不会发生死锁。

三、死锁的预防
我们可以通过破坏产生死锁的四个必要条件来预防死锁，由于资源互斥是固有特性无法改变的。
1.**破坏“请求与保持”条件**
方法一：静态分配，每个进程在开始执行时就申请他所需要的全部资源。
方法二：动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。
2.**破坏“不可剥夺”条件**
一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
3.**破坏“循环等待”条件**
采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。

- **预防死锁**

通过设置一些限制条件，破坏死锁的四个必要条件中的一个或几个，让死锁无法发生。

例如，将资源分层，得到上一层资源后才能够申请下一层资源，这样就破坏了环路等待条件。用户申请资源时，要求一次性申请所需要的全部资源，这就破坏了占有并等待条件。当一个已经占有某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经占有的所有资源，待以后需要时再重新申请，这就破坏了不剥夺条件。

这些预防死锁的方法破坏了系统的并行性和并发性，通常会降低系统的效率。

- **避免死锁**

该方法同样属于事先预防，但它并不事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在动态分配资源的过程中，用一些算法来防止系统进入不安全状态，避免死锁的发生。

具体策略如下：

\1. 如果进程请求的资源会导致死锁，系统就拒绝启动该进程；

\2. 如果对一个资源的分配会导致下一步的死锁，系统就拒绝本次分配；

显然要避免死锁，系统必须事先知道所拥有的资源数量及其属性。

一个著名的避免死锁的算法是银行家算法。

银行家算法是DijkstraE W于1968年提出的。之所以称为银行家算法，是因为该算法可用于银行系统。

所谓银行家算法，是指分配资源之前先确定资源分配是否会造成系统死锁。如果会死锁，则不分配，只有确认不会死锁后才进行分配。

银行家算法，需要按如下原则判断是否分配资源：

- 新进程进入系统时，它必须说明对各类资源的最大需求量，这一数量不能超过系统的资源总数。只有满足这一条件系统才接纳该进程。

- 当进程申请一组资源时，该算法需要检查进程对各类资源的最大需求量，如果系统现存的各类资源的数量可以满足此时的资源最大需求量时，就分配资源；否则进程必须等待，直到其他进程释放足够的资源为止。
- 进程需要在一定时间内无条件地归还它所申请的全部资源。

- **死锁的检测及解除**

  死锁预防和避免都是对资源分配进行适当限制，属于事前措施，并不利于系统资源的充分共享。而死锁检测不会试图阻止死锁，即在死锁发生前不会做任何操作，只是通过设 置的检测机制，检测当前是否发生死锁。若发生死锁，则采取一些措施来 解除死锁。

  判断死锁的法则主要基于第四条死锁的必要条件：

- 资源分配路径中没有环路，则系统不会出现死锁
- 资源分配路径中存在环路，则系统可能出现死锁
- 如果环路中的每个资料类中都只有一个资源，则系统存在死锁
- 如果环路中的每个资源类的资源个数不止一个，则环路的存在是产生死锁的必要条件但不是充分条件

解除死锁的方法 包括资源剥夺法、进程撤销法、进程回退法、系统重启法等：

- 资源剥夺法

剥夺陷入死锁的进程所占用的资源，但并不撤销此进程，再将这些资源分配给需要的进程，直至死锁解除。

- 进程撤销法

- 一次性撤销陷入死锁的所有进程，回收所有占用的资源，等死锁解除后，再重新运行进程。
- 逐个撤销陷入死锁的进程，依次回收其资源并重新分配，直至死锁解除。可以优先撤销优先级低、预计剩余执行时间最长、CPU消耗时间少的进程。

- 进程回退法

让所有的进程回退到系统保存的检查点，这种方法要求系统建立并保存检查点、建立回退机制。

- 系统重启法

  结束所有进程并重启系统。这种方法很简单，但损失很大，先前的工作可能都浪费了。











----

# 数据库部分

----

## 关系型和非关系型数据库的区别？

关系型数据库的优点

- 容易理解，因为它采用了关系模型来组织数据。
- 可以保持数据的一致性。
- 数据更新的开销比较小。
- 支持复杂查询（带 where 子句的查询）

非关系型数据库（NOSQL）的优点

- 无需经过 SQL 层的解析，读写效率高。
- 基于键值对，读写性能很高，易于扩展
- 可以支持多种类型数据的存储，如图片，文档等等。
- 扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。

----

### 详细说一下一条 MySQL 语句执行的步骤

Server 层按顺序执行 SQL 的步骤为：

- 客户端请求 -> 连接器（验证用户身份，给予权限）
- 查询缓存（存在缓存则直接返回，不存在则执行后续操作）
- 分析器（对 SQL 进行词法分析和语法分析操作）
- 优化器（主要对执行的 SQL 优化选择最优的执行方案方法）
- 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）





----

##  介绍一下数据库设计的三大范式

目前关系数据库有六种范式，一般来说，数据库只需满足第三范式(3NF）就行了。

**第一范式（1NF）**：

是指在关系模型中，**对于添加的一个规范要求，所有的域都应该是原子性的**，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

**即实体中的某个属性有多个值时，必须拆分为不同的属性**。在符合第一范式表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，**第一范式就是无重复的域**。

**第二范式（2NF）：**

在1NF的基础上，**非主码属性必须完全依赖于候选码**（在1NF基础上消除非主属性对主码的部分函数依赖）。

第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。**第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。**选取一个能区分每个实体的属性或属性组，**作为实体的唯一标识**。

例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。

**第三范式（3NF）：**

在2NF基础上，**任何非主属性不依赖于其它非主属性**（在2NF基础上消除传递依赖）。

第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。

例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。