----

##  1.什么是同源策略,为什么需要同源策略

### **同源策略**

同源策略(Same Origin Policy)是一种约定，它是**浏览器最核心最基本的安全功能**。所谓的同源是指域名、协议、端口相同。不同源的客户端脚本在没有明确授权的情况下是不允许读写其他网站的资源。

所谓同源（即指在同一个域）具有以下三个相同点

- 协议相同（protocol）
- 主机相同（host）
- 端口相同（port）

反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域

### **同源策略的限制**

1. Cookie、LocalStorage 和 IndexDB 无法读取。
2. DOM 无法获得。
3. AJAX 请求发送后，结果被浏览器拦截了

### **同源策略作用**

**同源策略**是一个重要的安全策略，它用于限制一个`origin`的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。

1. 防止恶意网页可以获取其他网站的本地数据。
2. 防止恶意网站iframe其他网站的时候，获取数据。
3. 防止恶意网站在自已网站有访问其他网站的权利，以免通过cookie免登，拿到数据。



----

## 2.跨域及解决跨域的方法

### **跨域**

跨域本质是浏览器基于**同源策略**的一种安全手段

受浏览器同源策略的限制，非同源的两个URL间不能通信，非同源的脚本不能操作其他源下面的对象，但在实际开发场景中， 这种情况。经常出现， 此时**需要通过跨域进行非同源通信**。

> 一定要注意**跨域是浏览器的限制**，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。

> 注意：同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制

**同源策略**是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。

**所谓同源是指"协议+域名+端口"三者相同**，即便两个不同的域名指向同一个ip地址，也非同源。

![同源策略及其限制内容](E:\pogject\学习笔记\image\http\同源策略及其限制内容.png)

以下两种不受同源策略的限制：

（1）**页面中的链接**，**重定向**以及**表单提交**是不会受到同源策略限制

（2）**跨域资源的引入**，但是js不能读写加载的内容，如嵌入到页面中的`<script src="..."></script>，<img>，<link>，<iframe>`等

当A与B非同源时，从域名A下的一个页面获取域名B下的一个资源，是不被浏览器允许的， **浏览器还是会发出这个请求，但是它会拦截响应内容**（因为非同源，**不安全**）（请求是页面发出的，页面在浏览器中显示，**故发出的请求是通过浏览器代为执行**）

但是有四个标签是允许跨域加载资源：

```html
<img src="xxx">
<link href='xxx'>
<script src='xxx'></script>
<iframe></iframe>
```

> 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，**只是结果被浏览器拦截了**。

### **跨域解决方案**

1. jsonp
2. cors
3. postMessage
4. websocket
5. Node中间件代理(两次跨域)
6. nginx反向代理
7. window.name + iframe
8. location.hash + iframe
9. document.domain + iframe

CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案，JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。**日常工作中，用得比较多的跨域方案是cors和nginx反向代理**



----

#### (1) 通过jsonp跨域

##### 什么是Jsonp

注意：jsonp和json并没有什么关系， 

JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，而JSONP（JSON with Padding）则是JSON 的一种“使用模式”，通过这种模式可以实现数据的跨域获取。

JSONP：利用在页面中创建 `<script>` 节点的方法向不同域提交HTTP请求的方法。

##### JSONP跨域的基本原理

在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，但img、iframe、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据。利用script标签的开放策略，我们可以实现跨域请求数据，当然，也需要服务端的配合。当我们正常地请求一个JSON数据的时候，服务端返回的是一串JSON类型的数据，而我们使用JSONP模式来请求数据的时候，服务端返回的是一段可执行的JavaScript代码。

##### JSONP的实现流程

1. 声明一个回调函数，其**函数名**(如show)**当做参数值**，要传递给跨域请求数据的服务器，**函数形参为要获取目标数据**(服务器返回的data)。

2. 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。

3. 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show('YNWA!')。

4. 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。


在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，**这时候就需要自己封装一个 JSONP函数**。

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>test</title>
</head>
<body>

<script type="text/javascript">
  function jsonp({url, params, callback}){
    return new Promise((resolve, reject) => {
      let script = document.createElement("script");
      
       window[callback] = function(data) {
        resolve(data);
        document.body.removeChild(script);
      }
        
      params = {...params, callback};  // 要把回调函数传入进去
      let arrs = [];
      for (let key in params) {
        arrs.push(`${key}=${params[key]}`);
      }
      script.src = `${url}?${arrs.join("&")}`;  // 赋值给script的src为需要跨域的请求地址加参数
      document.body.appendChild(script);
    });
  }

//调用
jsonp({
  url: "http://localhost:3000/say",
  params: {wd: "kop"},
  callback: "show"
}).then(data => {
  console.log(data);
});

</script>

</body>
</html>
```

上面这段代码相当于向http://localhost:3000/say?wd=kop&callback=show这个地址请求数据，然后后台返回show('YNWA!')，最后会运行show()这个函数，打印出''YNWA!"。

```js
// server.js
// 服务端代码

const fs=require("fs");
const express=require("express");

let app = express();

app.get('/say', function(req, res) {
	let {wd, callback} = req.query;
	console.log(wd);
	console.log(callback);
	res.end(`${callback}("YNWA!")`);
});

app.listen(3000);
```

##### jQuery的jsonp形式

JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。

```html
<script src="./js/jquery-3.6.0.js" type="text/javascript"></script>
<script type="text/javascript">

function show(data) {
  console.log("跨域请求成功！");
  let result = JSON.stringify(data);
  console.log(result);
}

$(document).ready(()=>{
  $.ajax({
    url:"http://localhost:3000/say?wd=kop",
    dataType:"jsonp",  //指定服务器返回的数据类型
    type:"get",//可以省略
    jsonpCallback:"show",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略
    jsonp:"callback",//->把传递函数名的那个形参callback，可省略
    success:function (data){
      console.log("调用success");
    }
  });
})

</script>
```

##### JSONP和AJAX对比

JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。**但AJAX属于同源策略**，JSONP属于非同源策略（跨域请求）

##### JSONP的优点

- 不受同源策略的限制；
- 兼容性好，在老的浏览器中可以运行；
- 请求完毕后可以通过调用 callback 的方式回传结果。

##### JSONP的缺点

- 只支持 `GET` 这种HTTP请求；
- jsonp在调用失败的时候不会返回各种HTTP状态码；
- 安全性：callback传入的参数是在后端进行了一次拼接，这即代表存在注入的可能，如果后端设计不当，是有可能出现安全风险的。



----

#### (2) 跨域资源共享（CORS）

跨源资源共享 (CORS)（或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），**使得浏览器允许这些 origin 访问加载自己的资源**。

跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，**该机制通过浏览器发起一个到服务器托管的跨源资源的"预检"请求。**在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。

跨源域资源共享（CORS）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch）使用 CORS，以降低跨源 HTTP 请求所带来的风险。



CORS本质上就是使用各种头信息来是浏览器与服务器之间进行身份认证实现跨域数据共享；

CORS中最常使用的响应头为 Access-Control-Allow-Origin、Access-Control-Allow-Headers、Access-Control-Expose-Headers;

CORS中最常使用的请求头为 Origin、Access-Control-Request-Headers、Access-Control-Request-Method;

CORS请求分为简单请求和复杂请求(需预检请求)；

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。**只要后端实现了 CORS，就实现了跨域。**

**服务端设置 Access-Control-Allow-Origin 就可以开启 CORS**。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

**普通跨域请求：**只服务端设置Access-Control-Allow-Origin即可，前端无须设置

**带cookie请求**：前后端都需要设置。

```js
// 前端设置是否带cookie 
xhr.withCredentials = true
```

注意：由于同源策略的限制，**所读取的cookie为跨域请求接口所在域的cookie**，而非当前页

##### 简单请求

不会触发 CORS 预检请求。满足所有下述条件的请求可视为“简单请求”：

1. 请求方法是以下三种方法之一：
   - HEAD
   - GET
   - POST
2. HTTP 的头信息不超出以下几种字段：
   - Accept
   - Accept-Language
   - Content-Language
   - Content-Type （需要注意额外的限制）
   - DPR
   - Downlink
   - Save-Data
   - Last-Event-ID
   - Viewport-Widths
   - Width
3. Content-Type 的值仅限于下列三者之一：
   - text/plain
   - multipart/form-data
   - application/x-www-form-urlencoded
4. 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。
5. 请求中没有使用 ReadableStream 对象。

##### 预检请求

要求必须首先使用 OPTIONS 方法发起一个预检请求到服务端，以获知服务端是否允许该实际请求。如果预检请求不通过，服务端返回正常的 http 响应，但是没有任何 CORS 相关的字段。如果预检请求通过，会返回以下部分字段：

- Access-Control-Allow-Origin：该字段必须
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Allow-Credentials
- Access-Control-Max-Age

##### HTTP 响应首部字段

- Access-Control-Allow-Origin：**指定了允许访问该资源的外域 URI**。如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。告诉客户端服务端对不同的源站返回不同的内容。

> 当响应的是附带身份凭证的请求时，服务端 必须 明确 Access-Control-Allow-Origin 的值，而不能使用通配符“*”。
> XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies，也就附带了身份凭证。

- Access-Control-Allow-Methods：**指明了实际请求所允许使用的 HTTP 方法**（该字段值包含 Access-Control-Request-Methods 中列出的方法时，才可能预检成功）。

> 这个字段在简单请求的的时候比如get/post用*或者不写都可以，但是当使用 PUT/DELETE 请求的时候，必须明确规定写出来

- Access-Control-Allow-Headers：**其指明了实际请求中允许携带的首部字段**（该字段值包含 Access-Control-Request-Headers 中列出的字段时，才可能预检成功）。
- Access-Control-Max-Age：**指定了预检请求的结果能够被缓存多久**。
- Access-Control-Allow-Credentials：默认情况下 Cookie 不包括在 CORS 请求之中，该字段和 AJAX 的 withCredentials 属性都为 true，且 Access-Control-Allow-Origin 值不为星号，此时 Cookie 可以包含在请求中发给服务端。 **指示当请求的凭证标记为 true 时，是否响应该请求。**

> 注意简单的GET 请求没有预检，所以若一个对资源的请求带了credentials，如果这个响应头没有随资源返回，响应就会被浏览器忽视，不会返回到web内容。Access-Control-Allow-Credentials 头 工作中与XMLHttpRequest.withCredentials 或Fetch API中的Request() 构造器中的credentials 选项结合使用。Credentials必须在前后端都被配置（即the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带credentials的CORS请求成功。

- Access-Control-Expose-Headers：**让服务端把允许浏览器访问的头放入白名单。**在跨源访问时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到一些最基本的响应头（Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma），如果要访问其他头，则需要服务端设置本响应头。 **指示哪些 HTTP 头的名称能在响应中列出。**

##### HTTP 请求首部字段

- Origin：预检时将实际请求的源站告诉服务端。**指示获取资源的请求是从什么域发起的**
- Access-Control-Request-Method：预检时将实际请求所使用的 HTTP 方法告诉服务端。 **用于发起一个预请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。**
- Access-Control-Request-Headers：预检请求时告诉服务端哪些非简单的 HTTP 字段实际被使用。 **用于发起一个预请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。**

> 使用 XMLHttpRequest 对象发起跨源请求时，这些字段会自动设置。



----

#### (3) postMessage跨域

从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个  MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 (en-US)。传递给 window.postMessage() 的参数（比如 message ）将通过消息事件对象暴露给接收消息的窗口。

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可解决以下问题：

- 页面和其打开的新窗口的数据传递

- 多窗口之间消息传递

- 页面与嵌套的iframe消息传递

- 上面三个场景的跨域数据传递


用法：postMessage(data，origin)

data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化

origin：协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"

例如：从a.html (http://www.domain1.com/a.html) ->        b.html(http://www.domain2.com/b.html) 

```html
//a.html
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');   // 向domain2传送跨域数据
    };
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);     // 接受domain2返回数据
</script>

//b.html
<script>
    window.addEventListener('message', function(e) {             alert('data from domain1 ---> ' + e.data);  //接收domain1的数据 
    var data = JSON.parse(e.data);         
    if (data) {             
    data.number = 16;             
    window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');     // 处理后再发回domain1
    }     
}, false);
 </script>
```

----

#### (4) WebSocket协议跨域

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。

WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

**原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口**，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据

```html
// socket.html
<script type="text/javascript">
  let socket = new WebSocket("ws://localhost:3000");
  socket.onopen = function() {
    socket.send("kop");  //向服务器发送数据
  }
  socket.onmessage = function(e) {
    console.log(e.data);  //接收服务器返回的数据
  }
</script>
```

```js
// server.js

const fs=require("fs");
const express=require("express");
const WebSocket = require("ws");

let wss = new WebSocket.Server({port: 3000});

wss.on("connection", (ws) => {
	ws.on("message", (data) => {
		console.log(data.toString());
		ws.send("YNWA!");
	});
});

```

---

#### (5) Node中间件代理(两次跨域)

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。** 代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。



----

#### (6) nginx反向代理跨域

实现原理类似于Node中间件代理，**需要你搭建一个中转nginx服务器，用于转发请求。**

使用nginx反向代理实现跨域，**是最简单的跨域方**式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

**原理：** 同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

**实现：**通过nginx配置一个代理服务器（域名与domain1相同，端口不同）**做跳板机**，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录

配置一个代理服务器向服务器请求，再将数据返回给客户端，实质和CORS跨域原理一样，需要配置请求响应头Access-Control-Allow-Origin等字段

```
server { 
    listen 81; server_name www.domain1.com; 
    location / { 
        proxy_pass http://xxxx1:8080; // 反向代理 
        proxy_cookie_domain www.xxxx1.com www.xxxx2.com; // 修改cookie里域名 
        index index.html index.htm; 
        // 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 
        add_header Access-Control-Allow-Origin http://www.xxxx2.com;  // 当前端只跨域不带cookie时，可为* 
        add_header Access-Control-Allow-Credentials true; 
    } 
}
```



----

#### (7) document.domain + iframe跨域

**注意：**仅限主域相同，子域不同的跨域应用场景

**原理：**两个页面都通过js强制设置document.domain为基础主域，就实现了同域



----

#### (8) location.hash + iframe

**原理：** a与b跨域相互通信，通过中间页c来实现， 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信

**A域：**a.html -> B域：b.html -> A域：c.html

a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象

```html
//a.html
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);

    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>

//b.html
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>

//c.html
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```



----

#### (9) window.name + iframe跨域

window.name属性的独特之处：**name值在不同的页面（甚至不同域名）加载后依旧存在**，并且**可以支持非常长的 name 值**（2MB）

通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域，可以巧妙地绕过了浏览器的跨域访问限制，同时又是安全操作



---

## 3. 如何提高网站的安全性？

### 前端常见安全问题

前端常见安全问题的7个方面：

1. iframe
2. opener
3. CSRF（跨站请求伪造）
4. XSS（跨站脚本攻击）
5. ClickJacking（点击劫持）
6. HSTS（HTTP严格传输安全）
7. CND劫持



1. iframe安全

   a.如何让自己的网站不被其他网站的 iframe 引用？

```js
// 检测当前网站是否被第三方iframe引用
// 若相等证明没有被第三方引用，若不等证明被第三方引用。当发现被引用时强制跳转百度。
if(top.location != self.location){
    top.location.href = 'http://www.baidu.com'
}
```

b.如何禁用，被使用的 iframe 对当前网站某些操作？

> sandbox是html5的新属性，主要是提高iframe安全系数。iframe因安全问题而臭名昭著，这主要是因为iframe常被用于嵌入到第三方中，然后执行某些恶意操作。
> 现在有一场景：我的网站需要 iframe 引用某网站，但是不想被该网站操作DOM、不想加载某些js（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性。如使用多项用空格分隔。

- allow-same-origin：允许被视为同源，即可操作父级DOM或cookie等
- allow-top-navigation：允许当前iframe的引用网页通过url跳转链接或加载
- allow-forms：允许表单提交
- allow-scripts：允许执行脚本文件
- allow-popups：允许浏览器打开新窗口进行跳转
- “”：设置为空时上面所有允许全部禁止

1. opener

> 如果在项目中需要 **打开新标签** 进行跳转一般会有两种方式

```js
// 1) HTML -> <a target='_blank' href='http://www.baidu.com'>
// 2)  JS  -> window.open('http://www.baidu.com')

/* 
 * 这两种方式看起来没有问题，但是存在漏洞。
 * 通过这两种方式打开的页面可以使用 window.opener 来访问源页面的 window 对象。
 * 场景：A 页面通过 <a> 或 window.open 方式，打开 B 页面。但是 B 页面存在恶意代码如下：
 * window.opener.location.replace('https://www.baidu.com') 【此代码仅针对打开新标签有效】
 * 此时，用户正在浏览新标签页，但是原来网站的标签页已经被导航到了百度页面。
 * 恶意网站可以伪造一个足以欺骗用户的页面，使得进行恶意破坏。
 * 即使在跨域状态下 opener 仍可以调用 location.replace 方法。
 */
```

a.

```html
<a target="_blank" href="" rel="noopener noreferrer nofollow">a标签跳转url</a>

<!-- 
  通过 rel 属性进行控制：
  noopener：会将 window.opener 置空，从而源标签页不会进行跳转（存在浏览器兼容问题）
  noreferrer：兼容老浏览器/火狐。禁用HTTP头部Referer属性（后端方式）。
  nofollow：SEO权重优化，详情见 https://blog.csdn.net/qq_33981438/article/details/80909881
 -->
```

b.window.open()

```html
<button onclick='openurl("http://www.baidu.com")'>click跳转</button>

function openurl(url) {
    var newTab = window.open();
    newTab.opener = null;
    newTab.location = url;
}
```

1. CSRF / XSRF（跨站请求伪造）

> 你可以这么理解 CSRF 攻击：攻击者盗用了你的身份，以你的名义进行恶意请求。它能做的事情有很多包括：以你的名义发送邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结起来就是：个人隐私暴露及财产安全问题。

```js
/*
 * 阐述 CSRF 攻击思想：（核心2和3）
 * 1、浏览并登录信任网站（举例：淘宝）
 * 2、登录成功后在浏览器产生信息存储（举例：cookie）
 * 3、用户在没有登出淘宝的情况下，访问危险网站
 * 4、危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品/余额转账）
 * 5、携带刚刚在浏览器产生的信息进行恶意请求
 * 6、淘宝验证请求为合法请求（区分不出是否是该用户发送）
 * 7、达到了恶意目标
 */
```

防御措施（推荐添加token / HTTP头自定义属性）

- 涉及到数据修改操作严格使用 post 请求而不是 get 请求
- HTTP 协议中使用 Referer 属性来确定请求来源进行过滤（禁止外域）
- 请求地址添加 token ，使黑客无法伪造用户请求
- HTTP 头自定义属性验证（类似上一条）
- 显示验证方式：添加验证码、密码等

1. XSS/CSS（跨站脚本攻击）

> XSS又叫CSS（Cross Site Script），跨站脚本攻击：攻击者在目标网站植入恶意脚本（js / html），用户在浏览器上运行时可以获取用户敏感信息（cookie / session）、修改web页面以欺骗用户、与其他漏洞相结合形成蠕虫等。

浏览器遇到 html 中的 script 标签时，会解析并执行其中的js代码

针对这种情况，我们对特殊字符进行转译就好了（vue/react等主流框架已经避免类似问题，vue举例：不能在template中写script标签，无法在js中通过ref或append等方式动态改变或添加script标签）

XSS类型：

- 持久型XSS：将脚本植入到服务器上，从而导致每个访问的用户都会执行
- 非持久型XSS：对个体用户某url的参数进行攻击

防御措施（对用户输入内容和服务端返回内容进行过滤和转译）

- 现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护
- 即便如此，我们在开发时也要注意和小心
- 对用户输入内容和服务端返回内容进行过滤和转译
- 重要内容加密传输
- 合理使用get/post等请求方式
- 对于URL携带参数谨慎使用
- 我们**无法做到彻底阻止，但是能增加黑客攻击成本**，当成本与利益不符时自然会降低风险

1. ClickJacking（点击劫持）

> ClickJacking 翻译过来被称为点击劫持。一般会利用透明 iframe 覆盖原网页诱导用户进行某些操作达成目的。

防御措施

- 在HTTP头中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 中【DENY：不能被所有网站嵌套或加载；SAMEORIGIN：只能被同域网站嵌套或加载；ALLOW-FROM URL：可以被指定网站嵌套或加载。】
- 判断当前网页是否被 iframe 嵌套（详情在第一条 firame 中）

1. HSTS（HTTP Strict Transport Security：HTTP严格传输安全）

> 网站接受从 HTTP 请求跳转到 HTTPS 请求的做法，例如我们输入“[http://www.baidu.com](https://link.zhihu.com/?target=http%3A/www.baidu.com)”或“[www.baidu.com”最终都会被302重定向到“[https://www.baidu.com](https://link.zhihu.com/?target=https%3A//www.baidu.com)”。这就存在安全风险，当我们第一次通过](http://www.baidu.xn--com302[https-149fka9451pilkvxhbu0b6i9b4n8fwnxb2izb35d//www.baidu.com](https://link.zhihu.com/?target=https%3A/www.baidu.com)”。这就存在安全风险，当我们第一次通过) HTTP 或域名进行访问时，302重定向有可能会被劫持，篡改成一个恶意或钓鱼网站。
> HSTS：通知浏览器此网站禁止使用 HTTP 方式加载，浏览器应该自动把所有尝试使用 HTTP 的请求自动替换为 HTTPS 进行请求。用户首次访问时并不受 HSTS 保护，因为第一次还未形成链接。我们可以通过 **浏览器预置HSTS域名列表** 或 **将HSTS信息加入到域名系统记录中**，来解决第一次访问的问题。

1. CDN劫持

> 出于性能考虑，前端应用通常会把一些静态资源存放到CDN（Content Delivery Networks）上面，例如 js 脚本和 style 文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。如果攻击者劫持了CDN，或者对CDN中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。
> 现在的CDN以支持SRI为荣，script 和 link 标签有了新的属性 integrity，这个属性是为了防止校验资源完整性来判断是否被篡改。它通过 **验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改**。
> 使用 SRI 需要两个条件：一是要保证 **资源同域** 或开启跨域，二是在中 **提供签名** 以供校验。

integrity 属性分为两个部分，第一部分是指定哈希值的生成算法（例：sha384），第二部分是经过编码的实际哈希值，两者之前用一个短横(-)来分隔

------

#### 4.2 前端安全相关-XSS和CSRF

**参考答案**：

**XSS（Cross-site scripting）**，指的是跨站脚本攻击，攻击者通过向页面A注入代码，达到窃取信息等目的，本质是数据被当作程序执行。XSS危害是很大的，一般XSS可以做到以下的事情：

- 获取页面的数据，包括dom、cookies、localStorage等
- 劫持前端逻辑
- 发送请求

**CSRF(Cross Site Request Frogy)指的是跨站请求伪造**。与XSS不同的是，XSS是攻击者直接对我们的网站A进行注入攻击，CSRF是通过网站B对我们的网站A进行伪造请求。

举个例子，你登录购物网站A之后点击一个恶意链接B，B请求了网站A的下单接口，结果是你在网站A的帐号真的会生成一个订单。其背后的原理是：网站B通过表单、get请求来伪造网站A的请求，这时候请求会带上网站A的cookies，若登录态是保存在cookies中，则实现了伪造攻击。

**解析：**

XSS

1. XSS的类型

   - 反射型（非持久）：通过URL参数直接注入
   - 存储型（持久）：存储到数据库后读取时注入
   - 基于DOM：被执行的恶意脚本会修改页面脚本结构

2. XSS的注入点

   - HTML的节点内容或属性
   - javascript代码
   - 富文本

3. XSS的防御

   3.1 浏览器的防御

   防御和“X-XSS-Protection”有关，默认值为1，即默认打开XSS防御，可以防御反射型的XSS，不过作用有限，只能防御注入到HTML的节点内容或属性的XSS，例如URL参数中包含script标签。不建议只依赖此防御手段。

   3.2 防御HTML节点内容

   存在风险的代码：

```html
<template>
    <p>{{username}}</p>
</template>

<script>
    username = "<script>alert('xss')</script>"
</script>
```

编译后的代码：

```html
<p>
    <script>alert('xss')</script>
</p>
```

以上例子是采用vue语法，但其实在vue这样的框架中，{{username}}中的内容是经过字符串化的，所以是不会被浏览器执行的，若换其他模板语言例如jade，则可能存在风险。下同。

防御代码：

通过转义<为&lt以及>为&gt来实现防御HTML节点内容。

```html
<template>
    <p>{{username}}</p>
</template>
<script>
    escape = function(str){
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
    }
    username = escape("<script>alert('xss')</script>")
</script>
```

3.3 防御HTML属性

```html
<template>
    <img :src="image" />
</template>
<script>
    image = 'www.a.com/c.png" onload="alert(1)'
</script>

```

编译后代码：

```html
<img src="www.a.com/c.png" onload="alert(1)" />
```

防御代码：

通过转义"为&quto;、'为'来实现防御，一般不转义空格，但是这要求属性必须带引号！

```html
<template>
    <img :src="image" />
</template>
<script>
    escape = function(str){
        return str.replace(/"/g, '&quto;').replace(/'/g, '&#39;').replace(/ /g, '&#32;')
    }
    image = escape('www.a.com/c.png" onload="alert(1)')
</script>

```

3.4 防御javaScript代码

假设访问页面地址为[www.a.com?id=1](http://www.a.com/?id=1)";alert(1);"

风险代码：

```js
var id = getQuery('id')

```

编译后代码：

```js
var id = "1";alert(1);""

```

防御代码：

通过将数据进行JSON序列化

```js
escape = function(str){
    return JSON.stringify(str)
}
```

3.5 防御富文本

风险代码：

```html
<template>
    <p v-html="richTxt"></p>
</template>

<script>
    richTxt = '<a onmouseover=alert(document.cookie)>点击</a>'
</script>

```

上面的这段代码中，当鼠标移动到“点击”上面时，就会触发alert弹窗！这在vue中是会发生的。

防御富文本是比较复杂的工程，因为富文本可以包含HTML和script，这些难以预测与防御，建议是通过白名单的方式来过滤允许的HTML标签和标签的属性来进行防御，大概的实现方式是：

- 将HTML代码段转成树级结构的数据

- 遍历树的每一个节点，过滤节点的类型和属性，或进行特殊处理

- 处理完成后，将树级结构转化成HTML代码

  当然，也可以通过开源的第三方库来实现，类似的有js-xss

3.6 CSP **内容安全策略**

CSP(content security policy)，是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。

CSP可以通过HTTP头部（Content-Security-Policy）或``元素配置页面的内容安全策略，以控制浏览器可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的action属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。

---

#### 4.3 url的加密解密

**参考答案**：

JavaScript中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent 。

**三种方式的特点：**

- escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。
- 而encodeURI() 用于编码整个URI,因为URI中的合法字符**都不会**被编码转换。
- encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。

**解析**：

**1.escape()函数**

定义和用法
escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。

语法
escape(string)

参数 描述
string 必需。要被转义或编码的字符串。

返回值
已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列。

说明
**该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码**： - _ . ! ~ * ' ( ) 。其他所有的字符都会被转义序列替换。

2.encodeURI()函数

定义和用法
encodeURI() 函数可把字符串作为 URI 进行编码。

语法
encodeURI(URIstring)

参数 描述
URIstring 必需。一个字符串，含有 URI 或其他要编码的文本。

返回值
URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。

说明
该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。

该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&=+$,#

**3.encodeURIComponent() 函数**

定义和用法
encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。

语法
encodeURIComponent(URIstring)

参数 描述
URIstring 必需。一个字符串，含有 URI 组件或其他要编码的文本。

返回值
URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。

说明
该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。

其他字符（比如 ：;/?:@&=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。

提示和注释
提示：请注意 encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。

---

# 网络攻防

----

## 3.1 请问什么是SQL注入攻击？

SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

一般我们提交的表单数据（未经过滤的情况下）都会拼接到 SQL 查询语句中的，就例如：

```sql
SELECT * FROM users WHERE name='aaa'
```



其中 name 的参数就是从表单中传过来的数据，如果传的参数是一条 SQL 语句，那么就可能骗过了 SQL 数据库，从而执行了一段恶意的代码，达到了攻击效果。

**如何防范SQL注入**？

- **把应用服务器的数据库权限降至最低**，尽可能地减少 SQL 注入攻击带来的危害。
- **避免网站打印出SQL错误信息**，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。
- 对进入数据库的特殊字符（'"\尖括号&*;等）**进行转义处理，或编码转换。**
- 所有的查询语句建议**使用数据库提供的参数化查询接口**，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，**即不要直接拼接SQL语句。**
- 在测试阶段，**建议使用专门的 SQL 注入检测工具进行检测**。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。
- 善用数据库操作库，有些库包可能已经做好了相关的防护，只需阅读其文档，看是否支持相应的功能即可。

---

## 3.2 请问什么是XXS攻击？

**跨站脚本攻击**XSS （Cross Site Scripting），其重点不在于跨站点，**而在于脚本的执行**。那么XSS的原理是：

**恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。**那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。

**反射性XSS**的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。

**反射型XSS的攻击步骤如下：**

\1. 攻击者在url后面的参数中加入恶意攻击代码。

\2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。

\3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。

\4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。

**存储型XSS**的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。

**存储型XSS的攻击步骤如下：**

\1. 攻击者将恶意代码提交到目标网站数据库中。

\2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。

\3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。

\4. 那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。

**如何防范？**

\1. 后端需要对提交的数据进行过滤。

\2. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。

**DOM型XSS**的攻击步骤如下：

\1. 攻击者构造出特殊的URL、在其中可能包含恶意代码。

\2. 用户打开带有恶意代码的URL。

\3. 用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。

\4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。

**DOM XSS 是基于文档对象模型的XSS。一般有如下DOM操作：**

\1. 使用document.write直接输出数据。

\2. 使用innerHTML直接输出数据。

\3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。

----

## 3.3 请问什么是CSRF攻击？

CSRF（Cross-site request forgery），中文名称为**跨站请求伪造**，也被称为：one click attack/session riding，缩写为：CSRF/XSRF

在CSRF攻击中攻击者盗用用户的身份，发送恶意请求。CSRF可能造成的危险：冒名发送邮件，发消息，盗取账号，购买商品，虚拟货币转账等等

**CSRF的防御：**

CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。

1、服务端进行CSRF防御

服务端的CSRF方式方法很多样，但总的思想都是一致的，**就是在客户端页面增加伪随机数。**

- Cookie Hashing

所有表单都包含同一个伪随机值，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。

- **验证码**

每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，**这个方案可以完全解决CSRF**

- One-Time Tokens(**不同的表单包含一个不同的伪随机值**)

在实现One-Time Tokens时，需要注意一点：**并行会话的兼容**。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。**必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。**