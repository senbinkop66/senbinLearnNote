------

## 请问什么是ES6，它有哪些新特性？

ECMAScript规定了浏览器脚本语言（js）的标准，ES6是一个泛指，包含ES5.1版以后的js的下一代标准，涵盖了ES2015、ES2016、ES2017等，（ES2015/2016/2017是正式名称，特指发布的正式版本语言标准的年份），通常提到的ES6一般指ES2015标准，有时也泛指“下一代js语言”

**ES6新特性的分类**

新特性主要归为四大类：

- 解决原有语法上的一些不足

比如let 和 const 的块级作用域

- 对原有语法进行增强

比如解构、展开、参数默认值、模板字符串

- 全新的对象、全新的方法、全新的功能

比如promise、proxy、object的assign、is

- 全新的数据类型和数据结构

比如symbol、set、map



ES6相对于更加简洁，大幅度提高了开发效率，主要新增了以下特性：

（1）let声明变量、const声明常量

（2）箭头函数

（3）解构赋值变量（数组、变量）

```js
let [a, b, c] = [1, 2, 3];
let[a,[[b], c]]=[1,[[2],3]]; //a：1 b：2 c：3
```

（4）Set、Map数据结构

（5）Symbol数据类型

（6）Promise对象

（7）async、await

（8）class类

（9）ES 模块化（Moudule）

（10）函数默认参数

（11）函数的rest参数（...变量名），用于获取函数的多余参数，就不需要用arguments对象

```js
function add(...values){
    let sum = 0;
    for(var val of values){     
        sum += val;
    }
    return sum;
}
add(2,5,3)  //10
```

（12）模板字符串

（13）… 展开运算（延展操作符）

（14）元编程Proxy、Reflet

（15）迭代器Iterator 和 for...of 

（16）新增了一些Object对象方法



----

## ES6 与 ES5 继承的区别

ES6 中有类 class 的概念，类 class 的继承是通过 extends 来实现的，ES5 中是通过设置构造函数的 prototype 属性，来实现继承的。

ES6 与 ES5 中的继承有 2 个区别，第一个是，ES6 中子类会继承父类的属性，第二个区别是，super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的内部属性，而在 ES5 中做不到。



----

## es6中箭头函数

1. 基本语法

   ES6中允许使用箭头=>来定义箭头函数，具体语法，我们来看一个简单的例子：

   ```js
   // 箭头函数
   let fun = (name) => {
       // 函数体
       return `Hello ${name} !`;
   };
   
   // 等同于
   let fun = function (name) {
       // 函数体
       return `Hello ${name} !`;
   };
   ```

   可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了function关键字，采用箭头=>来定义函数。函数的参数放在=>前面的括号中，函数体跟在=>后的花括号中。

   

   关于箭头函数的参数：

   **①** 如果箭头函数没有参数，直接写一个空括号即可。

   **②** 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。

   **③** 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。
   
   ```js
   // 没有参数
   let fun1 = () => {
       console.log(111);
   };
   
   // 只有一个参数，可以省去参数括号
   let fun2 = name => {
       console.log(`Hello ${name} !`)
   };
   
   // 有多个参数
   let fun3 = (val1, val2, val3) => {
       return [val1, val2, val3];
   };
   ```

   

   关于箭头函数的函数体：
   
   **①** 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。
   
   ```js
   let f = val => val;
   // 等同于
   let f = function (val) { return val };
   
   let sum = (num1, num2) => num1 + num2;
   // 等同于
   let sum = function(num1, num2) {
     return num1 + num2;
   };
   ```
   
   **②** 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写：
   
   ```js
   // 用小括号包裹要返回的对象，不报错
   let getTempItem = id => ({ id: id, name: "Temp" });
   
   // 但绝不能这样写，会报错。
   // 因为对象的大括号会被解释为函数体的大括号
   let getTempItem = id => { id: id, name: "Temp" };
   ```
   
   **③** 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），可以给这条语句前面加一个void关键字

   ```js
   let fn = () => void doesNotReturn();
   ```
   
   箭头函数最常见的用处就是简化回调函数。
   
   ```js
   // 例子一
   // 正常函数写法
   [1,2,3].map(function (x) {
     return x * x;
   });
   
   // 箭头函数写法
   [1,2,3].map(x => x * x);
   
   // 例子二
   // 正常函数写法
   var result = [2, 5, 1, 4, 3].sort(function (a, b) {
     return a - b;
   });
   
   // 箭头函数写法
   var result = [2, 5, 1, 4, 3].sort((a, b) => a - b);
   ```
   
   

------

## 箭头函数与普通函数的区别

(1) **语法更加简洁、清晰**

从上面的基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。

(2) **箭头函数不会创建自己的this**

箭头函数没有自己的this，它会捕获自己在**定义时**（注意，是定义时，不是调用时）所处的**外层执行环境的this**，并继承这个this值。所以，**箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。**

```js
var id = 'Global';

function fun1() {
    // setTimeout中使用普通函数
    setTimeout(function(){
        console.log(this.id);
    }, 2000);
}

function fun2() {
    // setTimeout中使用箭头函数
    setTimeout(() => {
        console.log(this.id);
    }, 2000)
}

fun1.call({id: 'Obj'});     // 'Global'

fun2.call({id: 'Obj'});     // 'Obj'
```

上面这个例子，函数fun1中的setTimeout中使用普通函数，2秒后函数执行时，**这时函数其实是在全局作用域执行的，所以this指向Window对象**，this.id就指向全局变量id，所以输出'Global'。 

但是函数fun2中的setTimeout中使用的是箭头函数，这个箭头函数的this在定义时就确定了，**它继承了它外层fun2的执行环境中的this**，而fun2调用时this被call方法改变到了对象{id: 'Obj'}中，所以输出'Obj'



```js
var id = 'GLOBAL';
var obj = {
  id: 'OBJ',
  a: function(){
    console.log(this.id);
  },
  b: () => {
    console.log(this.id);
  }
};

obj.a();    // 'OBJ'
obj.b();    // 'GLOBAL'
```

上面这个例子，对象obj的方法a使用普通函数定义的，**普通函数作为对象的方法调用时，this指向它所属的对象**。所以，this.id就是obj.id，所以输出'OBJ'。 但是方法b是使用箭头函数定义的，箭头函数中的this实际是继承的它定义时所处的全局执行环境中的this，所以指向Window对象，所以输出'GLOBAL'。（**这里要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中！！**）

(3) **箭头函数继承而来的this指向永远不变**（重要！！深入理解！！）

上面的例子，就完全可以说明箭头函数继承而来的this指向永远不变。对象obj的方法b是使用箭头函数定义的，这个函数中的this就**永远指向**它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。

(4) **call()/.apply()/.bind()无法改变箭头函数中this的指向**

.call()/.apply()/.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，虽然这么做代码不会报错。

```js
var id = 'Global';
// 箭头函数定义在全局作用域
let fun1 = () => {
    console.log(this.id)
};

fun1();     // 'Global'
// this的指向不会改变，永远指向Window对象
fun1.call({id: 'Obj'});     // 'Global'
fun1.apply({id: 'Obj'});    // 'Global'
fun1.bind({id: 'Obj'})();   // 'Global'

```

(5) **箭头函数不能作为构造函数使用**

我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。

但是因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会随在哪里调用、被谁调用而改变，**所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错**

```js
let Fun = (name, age) => {
    this.name = name;
    this.age = age;
};

// 报错
let p = new Fun('cao', 24);

```

(6) **箭头函数没有自己的arguments**

箭头函数没有自己的arguments对象。**在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。**

```js
// 例子一
let fun = (val) => {
    console.log(val);   // 111
    // 下面一行会报错
    // Uncaught ReferenceError: arguments is not defined
    // 因为外层全局环境没有arguments对象
    console.log(arguments); 
};
fun(111);

// 例子二
function outer(val1, val2) {
    let argOut = arguments;
    console.log(argOut);    // ①
    let fun = () => {
        let argIn = arguments;
        console.log(argIn);     // ②
        console.log(argOut === argIn);  // ③
    };
    fun();
}
outer(111, 222);

```

上面例子二，①②③处的输出结果如下：

```
[Arguments] { '0': 111, '1': 222 }
[Arguments] { '0': 111, '1': 222 }
true
```

很明显，普通函数outer内部的箭头函数fun中的arguments对象，**其实是沿作用域链向上访问的外层outer函数的arguments对象**。

**可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表！！**

```js
// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();

console.log(sortNumbers(1, 3, 4, 2));  // [ 1, 2, 3, 4 ]
```

(7) **箭头函数没有原型prototype**

```js
let sayHi = () => {
    console.log('Hello World !')
};
console.log(sayHi.prototype); // undefined

```

(8) **箭头函数不能用作Generator函数，不能使用yeild关键字**



（1）箭头函数不会创建自己的this，**只会从自己的作用域链的上一层继承this**

（2）箭头函数的**this是定义时所在的对象**，不是使用时所在的对象

（3）箭头函数的**this指向是固定的**

（4）**不能**做构造函数，**不可**使用new命令，会报错

（5）箭头函数是**没有原型，没有prototype属性**，故不可使用new

（6）没有自己的arguments对象，**箭头函数中访问arguments实际上是外层局部（函数）执行环境中的值**

（7）**不可使用yield命令**，不能用作Generator 函数

一起看两道箭头函数的this指向的高频考题：（极有可能出代码题（面试官给代码，答输出））

箭头函数的this指向取决于外层作用域中的this，**外层作用域或函数的this指向谁，箭头函数中的this便指向谁**；且一旦箭头函数的this绑定成功，也无法被再次修改，**类似于硬绑定**

```js
var a = 'window'
var obj1 = {
    a: 1,
    fn1: function () {
            return () => console.log(this.a)
    }
}
var obj2 = {
    a: 2
};

obj1.fn1()(); // 1
obj1.fn1().call(obj2); // 1 

obj1.fn1.call(obj2)(); // 2
```

obj1.fn1()()等价于：

```js
var fn = obj1.fn1(); //fn1的this指向obj1,箭头函数this参考fn1的this
window.fn();//无法改变箭头函数this
```

obj1.fn1().call(obj2)等价于：

```js
var fn = obj1.fn1(); 
fn.call(obj2);//显式绑定无法改变this
```

obj1.fn1.call(obj2)()等价于：

```js
var fn = obj1.fn1.call(obj2);//fn1的this此时指向obj2,箭头函数的this跟着变化
window.fn();//隐式绑定无法改变箭头函数this
```

**注意：虽无法直接改变箭头函数this指向，但可以修改外层作用域的this间接修改箭头函数this**

```js
var name = 'window'  
function Person(a) {   
    this.a = a;   
    this.fn1 = () => console.log(this.a);   
    this.fn2 = function () {     
        return () => console.log(this.a);   
    }; 
};
var obj1 = new Person(1); 

var obj2 = new Person(2);  

obj1.fn1(); // 1
obj1.fn1.call(obj2); // 1

obj1.fn2()(); // 1
obj1.fn2().call(obj2); // 1

obj1.fn2.call(obj2)(); // 2
```

obj1.fn1()：构造函数在new的过程中this指向了obj1，于是箭头函数的this也指向obj1

obj1.fn1.call(obj2)等价于：

```js
var fn = obj1.fn1;//箭头函数this指向obj1 
fn.call(obj2);//箭头函数this无法改变
```

obj1.fn2()()：fn2指向obj1，箭头函数this同样指向obj1

obj1.fn2().call(obj2)：箭头函数无法被直接修改

obj1.fn2.call(obj2)()等价于：

```js
var fn = obj1.fn2.call(obj2);//fn2的this此时指向obj2,箭头函数的this跟着变化
window.fn();//隐式绑定无法改变箭头函数this
```



----

## 如果new一个箭头函数会怎么样？

箭头函数是ES6中的提出来的，它**没有prototype，也没有自己的this指向，更不可以使用arguments参数**，**所以不能New一个箭头函数**。

new操作符的实现步骤如下：

1、创建一个空的简单JavaScript对象（即{}）；

2、为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；

3、将步骤1新创建的对象作为this的上下文 ；

4、如果该函数没有返回对象，则返回this。

所以，上面的第二、三步，箭头函数都是没有办法执行的。





------

##  箭头函数的 this 指向哪⾥？

箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。

可以⽤Babel理解⼀下箭头函数:

```js
// ES6 
const obj = { 
  getArrow() { 
    return () => { 
      console.log(this === obj); 
    }; 
  } 
}
```

转化后：

```js
// ES5，由 Babel 转译
var obj = { 
   getArrow: function getArrow() { 
     var _this = this; 
     return function () { 
        console.log(_this === obj); 
     }; 
   } 
};
```



----

## ES5是怎么实现箭头函数的效果的

箭头函数没有它自己的 `this` 值，箭头函数内的 `this` 值继承自外围作用域，谁定义的函数this 指向谁

箭头函数要实现类似纯函数的效果，必须剔除外部状态。所以箭头函数不具备普通函数里常见的 this、arguments 等，当然也就不能用 call ()、apply ()、bind () 去改变 this 的指向

对于箭头函数来说，并没有自己的 `this` ，它的 `this` 将始终指向让它生效的对象，即它的外部调用者：

```js
 ES6 function foo() { 
     setTimeout(() => { 
         console.log('id:', this.id); 
     }, 100); 
   } 
 
 ES5 function foo() { 
     var _this = this; 
     setTimeout(function () { 
         console.log('id:', _this.id); 
     }, 100); 
 }
```

```js
var a = 'window'
var obj1 = {
    a: 1,
    fn1: function () {
            return () => console.log(this.a)
    }
}
var obj2 = {
    a: 2
};
```

```js
//ES6
var a = 'window';
var obj1 = {
    a: 1,
    fn1: function () {
        var _this = this;
        return function () { return console.log(_this.a); };
    }
};
var obj2 = {
    a: 2
};

obj1.fn1()(); // 1

obj1.fn1().call(obj2); // 1 

obj1.fn1.call(obj2)(); // 2

```



------

## 哪些类型能被扩展操作符...扩展

**适用类型**：数组、对象、字符串。

复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作。

基础数据只有string可以使用扩展运算符，number,boolean,null,undefined无效



------

## 扩展符用过吗(...)，什么场景下使用

(1) 函数调用

```js
// 1、函数调用
function add(x, y) {
  return x + y;
}
add(...[4, 38]);

function f(v, w, x, y, z) {  }
f(-1, ...[0, 1], 2, ...[3]);
```

(2) 往数组里push多个元素

```js
//2.往数组里push多个元素
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);  
console.log(arr1); //[0,1,2,3,4,5]
```

(3) 替代函数的apply方法

```js
//3.替代函数的apply方法
function f(x, y, z) {  }  
var args = [0, 1, 2];
f.apply(null, args); //ES5 的写法
f(...args); //ES6的写法
```

(4) 求一个数组的最大值、最小值简化

```js
//4.求一个数组的最大数、最小数简化
Math.max.apply(null, [14, 3, 77])  //ES5 的写法
Math.max(...[14, 3, 77])  //ES6 的写法，等同于Math.max(14, 3, 77)
// 77
Math.min(...[14, 3, 77])
// 3
```

(5) 扩展运算符后面可以放表达式

```js
//5.扩展运算符后面可以放表达式
const arr = [...(5 > 0 ? ['a'] : []),'b'];
console.log(arr);  //['a','b'] 
```

(6) 与解构赋值结合，用于生成数组

```js
//6.与解构赋值结合，用于生成数组
const a1 = [1, 2];
const a2 = [...a1];  //写法1
const [...a2] = a1;  //写法2
const [first, ...rest] = [1, 2, 3, 4, 5];
first  //1
rest  //[2, 3, 4, 5]

const [first, ...rest] = [];
first  //undefined
rest  //[]

const [first, ...rest] = ["foo"];
first  //"foo"
rest   //[]

```

(7) 合并数组

```js
//7.合并数组
let arr1 = ['a', 'b'];
let arr2 = ['c', 'd'];
let arr3 = ['e', 'f'];

let arr = [...arr1, ...arr2, ...arr3];
console.log(arr);  // [ 'a', 'b', 'c', 'd', 'e', 'f' ]
```

(8) 数组的克隆

```js
//8.数组的克隆——————————————————————特别注意
var arr1 = [0, 1, 2];
var arr2 = [...arr1];
arr1[0]=100;
console.log(arr2); //[0, 1, 2]  

/* 乍一看，arr2与arr1不共用引用地址，arr2不随着arr1变化，接着往下看 */

var arr1 = [0, [1,11,111], 2];
var arr2 = [...arr1];
arr1[1][0]=100;
console.log(arr2); //[0, [100,11,111], 2]

```



----

##  object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别是什么？

- 扩展运算符

```js
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = {...outObj}
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2, b: 2}}
```

- Object.assign()

```js
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = Object.assign({}, outObj)
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2, b: 2}}
```

可以看到，两者都是浅拷贝。

Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。

扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。**它不复制继承的属性或类的属性**，但是它会复制ES6的 symbols 属性。





------

## 如何让不同的浏览器兼容ES6的方法

针对 ES6 的兼容性问题，很多团队为此开发出了多种语法解析转换工具，把我们写的 ES6 语法转换成 ES5，相当于在 ES6 和浏览器之间做了一个翻译官。比较通用的工具方案有 babel，jsx，traceur，es6-shim 等。



---



----

## 请问var、let 和 const 有何区别？

### var

在ES5中，顶层对象的属性和全局变量是等价的，用`var`声明的变量既是全局变量，也是顶层变量

注意：顶层对象，在浏览器环境指的是`window`对象，在 `Node` 指的是`global`对象

```js
var a = 10;
console.log(window.a) // 10
```

使用`var`声明的变量存在变量提升的情况

```js
console.log(a) // undefined
var a = 20
```

在编译阶段，编译器会将其变成以下执行

```js
var a
console.log(a)
a = 20
```

使用`var`，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明

```js
var a = 20 
var a = 30
console.log(a) // 30
```

在函数中使用使用`var`声明变量时候，**该变量是局部的**

```js
var a = 20
function change(){
    var a = 30
}
change()
console.log(a) // 20 
```

而如果在函数内不使用`var`，**该变量是全局的**

```js
var a = 20
function change(){
   a = 30
}
change()
console.log(a) // 30 
```

### let

`let`是`ES6`新增的命令，用来声明变量

用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效

```js
{
    let a = 20
}
console.log(a) // ReferenceError: a is not defined.
```

**不存在变量提升**

```js
console.log(a) // 报错ReferenceError
let a = 2
```

这**表示在声明它之前，变量`a`是不存在的**，这时如果用到它，就会抛出一个错误

只要块级作用域内存在`let`命令，这个区域就不再受外部影响

```js
var a = 123
if (true) {
    a = 'abc' // ReferenceError
    let a;
}
```

**使用`let`声明变量前，该变量都不可用**，也就是大家常说的“暂时性死区”

最后，`let`不允许在相同作用域中重复声明

```js
let a = 20
let a = 30
// Uncaught SyntaxError: Identifier 'a' has already been declared
```

注意的是相同作用域，下面这种情况是不会报错的

```js
let a = 20
{
    let a = 30
}
```

因此，我们不能在函数内部重新声明参数

```js
function func(arg) {
  let arg;
}
func()
// Uncaught SyntaxError: Identifier 'arg' has already been declared
```

### const

`const`声明一个只读的常量，一旦声明，常量的值就不能改变

```js
const a = 1
a = 3
// TypeError: Assignment to constant variable.
```

这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值

```js
const a;
// SyntaxError: Missing initializer in const declaration
```

如果之前用`var`或`let`声明过变量，再用`const`声明同样会报错

```js
var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
```

`const`实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量

对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的，并不能确保改变量的结构不变

```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

其它情况，`const`与`let`一致

### 区别

`var`、`let`、`const`三者区别可以围绕下面五点展开：

- 变量提升
- 暂时性死区
- 块级作用域
- 重复声明
- 修改声明的变量
- 使用

**作用域不同**：

var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的

let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效

`var`不存在块级作用域

`let`和`const`存在块级作用域

```js
// var
{
    var a = 20
}
console.log(a)  // 20

// let
{
    let b = 20
}
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
{
    const c = 20
}
console.log(c)  // Uncaught ReferenceError: c is not defined
```

**变量提升现象**：

var `声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined

从一个代码块的开始直到代码执行到声明变量的行之前，`let` 或 `const` 声明的变量都处于“暂时性死区”（Temporal dead zone，TDZ）中。

当变量处于暂时性死区之中时，其尚未被初始化，尝试访问变量将抛出 [`ReferenceError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)。当代码执行到声明变量所在的行时，变量被初始化为一个值。如果声明中未指定初始值，则变量将被初始化为 `undefined`。

```js
// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access 'b' before initialization
let b = 10

// const
console.log(c)  // Cannot access 'c' before initialization
const c = 10
```

**变量/常量**：

var 和 let 声明变量，const 声明只读常量

**暂时性死区**：

`var`不存在暂时性死区

`let`和`const`存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量

在let、const声明之前就访问对应的变量与常量，会抛出ReferenceError，产生**原因**：

由let/const声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，**但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问**（摘自ES2015语言标准）

简单来说：用let/const声明的变量会先在作用域中被创建出来，**但此时还未进行词法绑定，是不能被访问的**，会抛出错误。

从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为**TDZ(暂时性死区)**

```js
// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access 'b' before initialization
let b = 10

// const
console.log(c)  // Cannot access 'c' before initialization
const c = 10
```

**重复声明**

`var`允许重复声明变量

`let`和`const`在同一作用域不允许重复声明变量

```js
// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier 'b' has already been declared

// const
const c = 10
const c = 20 // Identifier 'c' has already been declared
```

**修改声明的变量**

`var`和`let`可以

`const`声明一个只读的常量。一旦声明，常量的值就不能改变

```js
// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
```

**使用**

**能用`const`的情况尽量使用`const`**，其他情况下大多数使用`let`，避免使用`var`





----

## const声明的变量是绝对的不可变吗？

实际上，不是const变量的值不得改动，**而是变量指向的那个内存地址不得改动**。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量

对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，**const只能保证这个指针是不变的**，至于它指向的数据结构是否变化，是不可控的



---

## 请问ES6新增的Symbol数据类型有何特点？

**symbol** 是一种基本数据类型 （[primitive data type](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)）。`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："`new Symbol()`"。

每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。更进一步的解析见—— [glossary entry for Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol)。



为保证每个属性的名字都是独一无二，**从根本上防止属性名冲突**，ES6 引入Symbol数据类型

Symbol是第7种基础数据类型，表示独一无二的值，Symbol 值通过Symbol函数生成，对象的属性名现在可以有两种类型，**一种是本来的字符串**，另一种就是**新增的 Symbol 类型**

Symbol 数据类型特点：

（1）、凡属性名属于 Symbol 类型，就是独一无二的，可以保证不会与其他属性名产生冲突

（2）、Symbol数据类型可用 typeof 检测出来，返回“symbol”

（3）、Symbol函数前**不能**使用 new 操作，会报错，**因为生成的 Symbol 是一个基础类型的值，不是对象**，可理解为它是一种类似于字符串的数据类型

（4）、Symbol函数的参数只表示对当前Symbol值的描述，就算参数相同，Symbol函数的返回值是不相等的

```js
// 没有参数的情况 
let s1 =Symbol();
let s2 =Symbol();  
s1 === s2 // false  

// 有参数的情况 
let s1 =Symbol('foo');
let s2 =Symbol('foo');  
s1 === s2 // false
```

（5）、在Symbol 作为属性名，遍历对象的时，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()遍历返回

但它并不是私有属性，Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。**该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值**

**Reflect.ownKeys()方法**可以返回所有类型的键名，包括常规键名和 Symbol 键名

**常用方法：Symbol.for()：（全局注册）**

接受一个字符串作为参数，随后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，**并将其注册到全局，可以实现重新使用同一个 Symbol 值。**



----

##  symbol 有什么用处？

ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。

ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。





----

## 请问ES6 class与ES5构造函数有什么联系？（如何用ES5的方式实现class？）

class其实是一个语法糖，使得js的编码更清晰、更人性化、风格更贴合面向对象的思想，为代码编译器、检查器提供方便

js生成新对象的传统方法是通过**构造函数**定义的，这种写法与传统的面向对象语言差异较大。故ES6引入了**class作为对象的生成模板**

```js
//ES5写法
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.toString = function() {
    return'('+ this.name + ','+ this.age + ')';
}

var person = new Person('TOM', 20);
console.log(person);// Person { name: 'Mia', age: 18 }

//ES6写法
class Person {
    constructor(name, age) {
    	this.name = name;
    	this.age = age;
    }
    toString() {    
    	return'('+ this.name + ','+ this.age + ')';
    }
}
var person = new Person('TOM', 20);
console.log(person);// Person { name: 'Mia', age: 18 }
```

由上述代码可得出：

（1）class类可以看做是**构造函数的另一种写法**

（2）class类的**数据类型就是函数**，typeof Person === 'function' 为true

（3）也可以说class的**底层依然是function构造函数**

class类与构造函数区别：

（1）class内部定义的方法都是**不可枚举的**（non-enumerable），ES5中prototype的方法是可枚举的

（2）class**必须使用new调用**，否则会报错

（3）继承：class用extends实现继承

```js
class Person{
    constructor(skin,language){
        this.skin=skin;
        this.language=language;
    }
    say(){         
        console.log('I am a Person')
    }
}
```

**（1）子类没有constructor时**

```js
class American extends Person{
    aboutMe(){         
        console.log(this.skin+' '+this.language)
    }
}
```

子类American继承父类Person，子类没有定义constrcutor，**则会默认添加一个**，并且在constrcutor中调用super函数，相当于调用父类的构造函数。**调用super函数是为了在子类中获得父类的this，调用之后this指向子类**，也就是父类.prototype.constructor.call(this)

**（2）子类有constructor**

```js
class Chinese extends Person{
    constructor(skin,language,positon){
        //console.log(this);//在没有调用super之前输出this会报错
        super(skin, language);
        //super();//不给父类构造函数传参，父类的构造数的值为undefined       
        console.log(this);
        this.positon=positon;
    }
    aboutMe(){         
        console.log(this.skin+' '+this.language+' '+this.positon);
    }
}
```

子类必须在constructor方法中调用super方法，否则new实例时会报错。**因为子类没有自己的this对象，而是继承父类的this对象**。**如果不调用super函数，子类就得不到this对象。**super()作为父类的构造函数，只能出现在子类的constructor()中；但是super指向父类的原型对象，可以调用父类的属性和方法



----

## es5 中的类和es6中的class有什么区别？

在es5中主要是通过构造函数方式和原型方式来定义一个类，在es6中我们可以通过class来定义类。

(1) class类必须new调用，不能直接执行。

```js
class Foo {
    constructor(color) {
        this.color;
    }
    like() {
        console.log(`like${this.color}`)
    }
}

Foo();
// TypeError: Class constructor Foo cannot be invoked without 'new'
```

(2) class类不存在变量提升

```js
let foo = new Foo();
// ReferenceError: Cannot access 'Foo' before initialization

class Foo {
    constructor(color) {
        this.color;
    }
    like() {
        console.log(`like${this.color}`)
    }
}


```

(3) class类无法遍历它实例原型链上的属性和方法

```js
class Foo {
    constructor (color) {
        this.color = color
    }
    like () {
        console.log(`like${this.color}`)
    }
}
let foo = new Foo('red')

for (let key in foo) {
    // 只打印一个color,没有打印原型链上的like
    console.log(key)  // color
}
```

(4) new.target属性

es6为new命令引入了一个new.target属性，**它会返回new命令作用于的那个构造函数**。如果**不是通过new调用或Reflect.construct()调用的，new.target会返回undefined**

```js
function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}

let obj = {}
Person.call(obj, 'red') // 此时使用非new的调用方式就会报错
```

(5) class类有static静态方法

**static静态方法只能通过类调用**，不会出现在实例上；另外如果静态方法包含 this 关键字，**这个 this 指的是类，而不是实例**。static声明的静态属性和方法都可以被子类继承。

```js
class Foo {
  static bar() {
    this.baz(); // 此处的this指向类
  }
  static baz() {
    console.log('hello'); // 不会出现在实例中
  }
  baz() {
    console.log('world');
  }
}
```



----

##  说说你对 new.target 的理解

`new.target`属性**允许你检测函数或构造方法是否是通过new运算符被调用的**。

在通过new运算符被初始化的函数或构造方法中，`new.target`返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是undefined。

我们可以使用它来检测，一个函数是否是作为构造函数通过new被调用的。

```js
function Foo() {
  if (!new.target) throw "Foo() must be called with new";
  console.log("Foo instantiated with new");
}

Foo(); // throws "Foo() must be called with new"
new Foo(); // logs "Foo instantiated with new"
```



----

## 请问你了解js模块化吗？

js模块化所解决的问题：

**命名冲突**：一些变量和函数命名可能相同

**文件依赖**：一些需要从外部引入的文件数目、顺序

js模块化将按照功能将一个软件切分成许多单独部分，每个部分为一个模块，然后再组装起来。分模块进行使用与维护，提高开发效率。

js模块化发展过程：

**（1）script标签**

最早期的js文件加载方式，把每个文件看做一个模块，接口通常直接暴露在全局作用域（定义在window对象中）

缺点：加载顺序取决于script标签书写顺序

易污染全局作用域

各文件间的依赖关系较繁琐

**（2）CommonJS**

每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载，**在浏览器端，模块需要提前编译打包处理。**

```js
//暴露模块:
module.exports = value 或 exports.xxx = value

//引入模块：
require(xxx)
//如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

// module add.js
module.exports = function add (a, b) { return a + b; }

// main.js
var {add} = require('./math');
console.log('1 + 2 = ' + add(1,2);
```

**CommonJS加载模块是同步的，**只有加载完成，才能执行后面的操作，造成一个重大的局限：**不适用于浏览器**

同步加载对服务器端影响不大，可把所有的模块都存在本地硬盘，同步加载，等待时间就是读取硬盘时间。**但对于浏览器，因为模块都放在服务器端，等待时间取决于网速的快慢，长时间等待会造成浏览器处于”假死”状态**

**浏览器端的模块不能采用同步加载，**只能采用异步加载，便有了AMD

**（3）AMD**

非同步加载模块，允许指定回调函数，浏览器端一般采用AMD

优点： 

（1）适合在浏览器环境中异步加载模块 （2）可以并行加载多个模块

```js
//定义没有依赖的模块
define(function(){
    return 模块
})

//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})

//引入使用模块
require(['module1', 'module2'], function(m1, m2){
   //使用m1/m2
})
```

**（4）CMD**

**专门用于浏览器端**，模块的加载是异步的，模块使用时才会加载执行（延迟执行）

```js
//定义没有依赖的模块
define(function(require, exports, module){
    exports.xxx = value
    module.exports = value
})

//定义有依赖的模块
define(function(require, exports, module){
    //引入依赖模块(同步)
    var module2 = require('./module2')
    //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
    //暴露模块
    exports.xxx = value
})

//引入使用模块
define(function (require) {
    var m1 = require('./module1')
    var m4 = require('./module4')
    m1.show()
    m4.show()
})
```

CMD与AMD区别：

最大的区别是对依赖模块的执行时机处理不同，二者皆为异步加载模块

AMD**依赖前置**，js可以方便知道依赖模块是谁，立即加载

CMD**就近依赖**，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，延迟执行

**（4）UMD**

严格上说，UMD不能算是一种模块规范，它主要用来处理CommonJS、AMD、CMD的差异兼容，使模块代码能在不同的模块环境下都能正常运行，**是模块定义的跨平台解决方案**

**（5）ES6模块化**

设计思想：尽可能静态化，**使得编译时就能确定模块的依赖关系、输入和输出变量**，CommonJS 和 AMD 模块，都只能在运行时确定

```js
//导出模块方式
var a = 0;
export { a }; //第一种

export const b = 1; //第二种 

let c = 2;
export default { c }//第三种 

let d = 2;
export default { d as e }//第四种，别名

//导入模块方式
import { a } from './a.js' //针对export导出方式，.js后缀可省略
import main from './c' //针对export default导出方式,使用时用 main.c
import 'lodash' //仅仅执行lodash模块，但是不输入任何值
```

主要由export和import两个命令构成，export用于规定模块的对外接口，import用于输入其他模块提供的功能

**总结与对比：**

**CommonJS：**主要用于服务端，同步加载模块，并**不适合**在浏览器环境

**AMD：**在浏览器中异步加载模块，且可并行加载多个模块，但开发成本相对高，代码阅读和书写较困难，模块定义方式语义不顺畅

**CMD：**与AMD相似，都用于浏览器，依赖就近，延迟执行，很容易在Node.js中运行

**ES6模块化：**异步加载，有一个独立的模块依赖的解析阶段，实现相对简单，**浏览器和服务器通用模块解决方案**



----

## 怎么理解ES6中Module的？使用场景有哪些？

模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的**集合（即程序代码和数据结构的集合体）**。

两个基本的特征：外部特征和内部特征

- 外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能
- 内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）

### **为什么需要模块化**

- 代码抽象
- 代码封装
- 代码复用
- 依赖管理

如果没有模块化，我们代码会怎样？

- 变量和方法不容易维护，容易污染全局作用域
- 加载资源的方式通过script标签从上到下。
- 依赖的环境主观逻辑偏重，代码较多就会比较复杂。
- 大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃

因此，需要一种将`JavaScript`程序模块化的机制，如

- CommonJs (典型代表：node.js早期)
- AMD (典型代表：require.js)
- CMD (典型代表：sea.js)

**AMD**

`Asynchronous ModuleDefinition`（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行

代表库为`require.js`

```js
/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config({
  baseUrl: "js/lib",
  paths: {
    "jquery": "jquery.min",  //实际路径为js/lib/jquery.min.js
    "underscore": "underscore.min",
  }
});
// 执行基本操作
require(["jquery","underscore"],function($,_){
  // some code here
});
```



**CommonJs**

`CommonJS` 是一套 `Javascript` 模块规范，用于服务端

```js
// a.js
module.exports={ foo , bar}

// b.js
const { foo,bar } = require('./a.js')
```

其有如下特点：

- 所有代码都运行在模块作用域，不会污染全局作用域
- 模块是同步加载的，即只有加载完成，才能执行后面的操作
- 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存
- `require`返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值

既然存在了`AMD`以及`CommonJs`机制，`ES6`的`Module`又有什么不一样？

ES6 在语言标准的层面上，实现了`Module`，即模块功能，完全可以取代 `CommonJS `和 `AMD `规范，成为浏览器和服务器通用的模块解决方案

`CommonJS` 和` AMD` 模块，都只能在运行时确定这些东西。比如，`CommonJS `模块就是对象，输入时必须查找对象属性

```js
// CommonJS模块
let { stat, exists, readfile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```

`ES6`设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量

```js
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上述代码，只加载3个方法，其他方法不加载，即 `ES6` 可以在编译时就完成模块加载

由于编译加载，使得静态分析成为可能。包括现在流行的`typeScript`也是依靠静态分析实现功能



### 使用

`ES6`模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是`ES5`之前就已经规定好

模块功能主要由两个命令构成：

- `export`：用于规定模块的对外接口
- `import`：用于输入其他模块提供的功能

**export**

一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量

```js
// profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export { firstName, lastName, year };
```

输出函数或类

```js
export function multiply(x, y) {
  return x * y;
};
```

通过`as`可以进行输出变量的重命名

```js
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
```

### import

使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块

```js
// main.js
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}
```

同样如果想要输入变量起别名，通过`as`关键字

```js
import { lastName as surname } from './profile.js';
```

当加载整个模块的时候，需要用到星号`*`

```js
// circle.js
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}

// main.js
import * as circle from './circle';
console.log(circle)   // {area:area, circumference:circumference}
```

输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性

```js
import {a} from './xxx.js'

a.foo = 'hello'; // 合法操作
a = {}; // Syntax Error : 'a' is read-only;
```

不过建议即使能修改，但我们不建议。因为修改之后，我们很容易出现差错

`import`后面我们常接着`from`关键字，`from`指定模块文件的位置，可以是相对路径，也可以是绝对路径

```js
import { a } from './a';
```

如果只有一个模块名，需要有配置文件，告诉引擎模块的位置

```js
import { myMethod } from 'util';
```

在编译阶段，`import`会提升到整个模块的头部，首先执行

```js
foo();

import { foo } from 'my_module';
```

多次重复执行同样的导入，只会执行一次

```js
import 'lodash';
import 'lodash';
```

上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载

如果不需要知道变量名或函数就完成加载，就要用到`export default`命令，为模块指定默认输出

```js
// export-default.js
export default function () {
    console.log('foo');
}
```

加载该模块的时候，`import`命令可以为该函数指定任意名字

```js
// import-default.js
import customName from './export-default';
customName(); // 'foo'
```

### 动态加载

允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势

这个新功能允许您将`import()`作为函数调用，将其作为参数传递给模块的路径。 它返回一个 `promise`，它用一个模块对象来实现，让你可以访问该对象的导出

```js
import('/modules/myModule.mjs')
  .then((module) => {
    // Do something with the module.
  });
```

### 复合写法

如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起

```js
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };
```

同理能够搭配`as`、`*`搭配使用



### 使用场景

如今，`ES6`模块化已经深入我们日常项目开发中，像`vue`、`react`项目搭建项目，组件化开发处处可见，其也是依赖模块化实现

`vue`组件

```vue
<template>
  <div class="App">
      组件化开发 ---- 模块化
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  }
}
</script>
```

`react`组件

```jsx
function App() {
  return (
    <div className="App">
		组件化开发 ---- 模块化
    </div>
  );
}

export default App;
```

包括完成一些复杂应用的时候，我们也可以拆分成各个模块



---

## 请说说ES6新增了哪些对象方法？

**(1) 属性的简写**

ES6中，当对象键名与对应值名相等的时候，可以进行简写

```js
const baz = {foo:foo}

// 等同于
const baz = {foo}
```

方法也能够进行简写

```js
const o = {
  method() {
    return "Hello!";
  }
};

// 等同于

const o = {
  method: function() {
    return "Hello!";
  }
}
```

在函数内作为返回值，也会变得方便很多

```js
function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
```

注意：简写的对象方法不能用作构造函数，否则会报错

```js
const obj = {
  f() {
    this.foo = 'bar';
  }
};

new obj.f() // 报错
```

**(2) 属性名表达式**

ES6 允许字面量定义对象时，将表达式放在括号内

```js
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```

表达式还可以用于定义方法名

```js
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
```

注意，属性名表达式与简洁表示法，不能同时使用，会报错

```js
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串`[object Object]`

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // { '[object Object]': 'valueB' }
```

**(3) super关键字**

`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象

```js
const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // "hello"
```

**(4) 扩展运算符的应用**

在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面

```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

注意：解构赋值必须是最后一个参数，否则会报错

解构赋值是浅拷贝

```js
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
```

对象的扩展运算符**等同于使用`Object.assign()`方法**



**(5) 属性的遍历**

ES6 一共有 5 种方法可以遍历对象的属性。

- for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）
- Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名
- Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名
- Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名
- Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举

上述遍历，都遵守同样的**属性遍历的次序规则**：

- 首先遍历所有数值键，**按照数值升序**排列
- 其次遍历所有字符串键，按照**加入时间**升序排列
- 最后遍历所有 Symbol 键，按照**加入时间**升序排

```js
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
```



**（6）Object.is()**

ES5中用 == 和 === 比较两个值是否相等，两者都有缺陷，== 会自动转换数据类型，=== NaN不等于自身，以及 +0 等于 -0。

ES6 提出“Same-value equality”（**同值相等**）算法，即在所有环境中，只要两个值是一样的，则相等，Object.is()就是实现这个算法的新方法，用来比较两个值是否严格相等（除了两个特例，基本与 === 一致）

严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身

```js
Object.is('foo','foo') // true 
Object.is({},{}) // false

//与===的不同之处
Object.is(+0,-0) // false 
Object.is(NaN,NaN) // true

console.log(+0 === -0);  //  true
console.log(NaN === NaN);  //  false
```

**（7）Object.assign()**

Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target

`Object.assign()`方法的第一个参数是目标对象，后面的参数都是源对象

常见用途：为对象添加属性、方法，克隆对象，合并多个对象，为属性指定默认值

```js
const target ={a:1};  
const source1 ={b:2}; 
const source2 ={c:3};  

Object.assign(target, source1, source2); 
console.log(target); // {a:1, b:2, c:3}
```

注意：

- Object.assign()方法是**浅拷贝**，而不是深拷贝，**若源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用**
- Object.assign()拷贝的属性是有限制的，**只拷贝源对象的自身属性**，不拷贝继承属性，不拷贝不可枚举属性
- 一旦遇到同名属性时，会直接替换，后面的属性会覆盖前面的属性
- 若**参数不是对象，则会先转成对象**；由于undefined和null无法转成对象，若它们作为参数，就会报错  

**（8）`__proto__`属性：**本质上是一个内部属性，而不是一个正式的对外的 API，若一个对象本身部署了`__proto__`属性，该属性的值就是对象的原型，实际上是调用了Object.prototype.`__proto__`

**（9）Object.setPrototypeOf()：**功能与`__proto__`相同，用于设置一个对象的原型对象，相较于`__proto__`是ES6推荐的方法

```js
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf({}, null);
```

**（10）Object.getPrototypeOf() ：**用于读取一个对象的原型对象

```js
Object.getPrototypeOf(obj);
```

**（11）Object.keys()：**遍历对象自身（不含继承的）所有可遍历属性的键名，以数组的方式返回

```js
var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// ["foo", "baz"]
```

**（12）Object.values()：**遍历对象自身（不含继承的）所有可遍历属性的值，以数组的方式返回

**（13）Object.entries() ：**遍历对象自身（不含继承的）所有可遍历属性的健值对，以数组的方式返回（只输出属性名非 Symbol 值的属性）

```js
var obj ={ foo:'bar', baz:42}
Object.keys(obj) // ["foo", "baz"]
Object.values(obj) // ["bar", 42]
Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ]
```

**（14）Object.fromEntries()：**将一个键值对数组转为对象，Object.entries()逆操作

```js
Object.fromEntries([['foo','bar'],['baz',42]]) // { foo: "bar", baz: 42 }
```

**（15）Object.getOwnPropertyDescriptors()：**用来**获取一个对象的所有自身属性的描述符**，返回一个对象，所有原来的对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象

```js
const obj = {
  foo: 123,
  get bar() { return 'abc' }
};
console.log(Object.getOwnPropertyDescriptors(obj));
/*
{
  foo: { value: 123, writable: true, enumerable: true, configurable: true },
  bar: {
    get: [Function: get bar],
    set: undefined,
    enumerable: true,
    configurable: true
  }
}
*/
```

---

## 请说说ES6新增了哪些数组方法？

**（1）扩展运算符**

ES6通过扩展元素符`...`，好比 `rest` 参数的逆运算，将一个数组转为用逗号分隔的参数序列，**该运算符主要用于函数调用**

```js
console.log(...[1,2,3]) // 1 2 3  
console.log(1,...[2,3,4],5) // 1 2 3 4 5 

[...document.querySelectorAll('div')]
```

主要用于函数调用的时候，将一个数组变为参数序列

```js
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
```

可以将某些数据结构转为数组

```js
[...document.querySelectorAll('div')]
```

能够更简单实现数组复制

```js
const a1 = [1, 2];
const [...a2] = a1;
// [1,2]
```

数组的合并也更为简洁了

```js
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
```

注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组

```js
const arr1 = ['a', 'b', [1,2]];
const arr2 = ['c'];
const arr3  = [...arr1,...arr2]

arr1[2][0] = 9999 // 修改arr1里面数组成员值
console.log(arr3) // 影响到arr3, [ 'a', 'b', [ 9999, 2 ], 'c' ]
```

扩展运算符可以与解构赋值结合起来，用于生成数组

```js
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = ["foo"];
first  // "foo"
rest   // []
```

如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错

```js
const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
```

可以将字符串转为真正的数组

```js
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```

定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组

```js
let nodeList = document.querySelectorAll('div');
let array = [...nodeList];

let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
```

如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错

```js
const obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
```



关于构造函数，数组新增的方法有如下：

- Array.from()
- Array.of()

**（2）Array.from（）**

用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）

```js
let arrayLike ={
    '0':'a',
    '1':'b',
    '2':'c',    
    length:3
};

// ES5的写法 
var arr1 =[].slice.call(arrayLike); // ['a', 'b', 'c']  
// ES6的写法 
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组

```js
Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

**(3) Array.of()**

用于将一组值，转换为数组

```js
Array.of(3, 11, 8) // [3,11,8]
```

没有参数的时候，返回一个空数组

**当参数只有一个的时候，实际上是指定数组的长度**

参数个数不少于 2 个时，`Array()`才会返回由参数组成的新数组

```js
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```

**(4) copyWithin()**

将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组

参数如下：

- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

```js
[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
```

**（5）数组实例的find（）和findIndex（）**

Array.prototype.find（）：用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，**返回该成员**。如没有符合条件的成员，则返回undefined

```js
[1,4,-5,10].find((n)=> n <0) // -5
```

Array.prototype.findIndex（）：与find方法非常类似，返回第一个符合条件的数组**成员的位置**，如所有成员都不符合条件，则返回-1

```js
[1,5,10,15].findIndex(function(value, index, arr){
    return value > 9;
}) // 2
```

这两个方法都可以接受第二个参数，**用来绑定回调函数的`this`对象**。

```js
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

**(6) fill()**

使用给定值，填充一个数组

```js
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
```

还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置

```js
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```

注意，如果填充的类型为对象，则是浅拷贝

```js
let arr = new Array(3).fill({name: "aa", age: 18});

arr[1].age = 20;

console.log(arr);

/*
[
  { name: 'aa', age: 20 },
  { name: 'aa', age: 20 },
  { name: 'aa', age: 20 }
]
*/
```

**(7) entries()，keys()，values()**

`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

```js
or (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```



**（8）数组实例的includes（）**

Array.prototype.includes（）：返回一个布尔值，表示某个数组是否包含给定的值，第二个参数表示搜索的起始位置，默认为0，与字符串的includes方法类似

```js
[1,2,3].includes(2) // true 
[1,2,3].includes(3,3); // false
[1, 2, NaN].includes(NaN) // true
```

方法的第二个参数表示搜索的起始位置，默认为`0`

参数为负数则表示倒数的位置

```js
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
```

**(9) flat()，flatMap()**

将数组扁平化处理，返回一个新数组，对原数据没有影响

```js
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
```

`flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
```

`flatMap()`方法**对原数组的每个成员执行一个函数相当于执行`Array.prototype.map()`**，然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this

**(10) 数组的空位**

数组的空位指，数组的某一个位置没有任何值

ES6 则是明确将空位转为`undefined`，包括`Array.from`、扩展运算符、`copyWithin()`、`fill()`、`entries()`、`keys()`、`values()`、`find()`和`findIndex()`

建议大家在日常书写中，避免出现空位

**(11) 排序稳定性**

将`sort()`默认设置为稳定的排序算法

```js
const arr = [
  'peach',
  'straw',
  'apple',
  'spork'
];

const stableSorting = (s1, s2) => {
  if (s1[0] < s2[0]) return -1;
  return 1;
};

arr.sort(stableSorting)
// ["apple", "peach", "straw", "spork"]
```

排序结果中，`straw`在`spork`的前面，跟原始顺序一致



----

## ES6中函数新增了哪些扩展?

### **(1) 参数**

`ES6`允许为函数的参数设置默认值

```js
function log(x, y = 'World') {
  console.log(x, y);
}

console.log('Hello') // Hello World
console.log('Hello', 'China') // Hello China
console.log('Hello', '') // Hello
```

函数的形参是默认声明的，不能使用`let`或`const`再次声明

```
function foo(x = 5) {
    let x = 1; // error
    const x = 2; // error
}
```

参数默认值可以与解构赋值的默认值结合起来使用

```js
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```

上面的`foo`函数，当参数为对象的时候才能进行解构，**如果没有提供参数的时候，变量`x`和`y`就不会生成，从而报错**，这里设置默认值避免

```js
function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
```

参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的

```js
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]
```

### **(2) 属性**

**函数的length属性**

`length`将返回没有指定默认值的参数个数

```js
(function (a) {}).length // 1

(function (a = 5) {}).length // 0

(function (a, b, c = 5) {}).length // 2
```

`rest` 参数也不会计入`length`属性

```js
(function(...args) {}).length // 0
```

如果设置了默认值的参数**不是尾参数**，那么`length`属性也不再计入后面的参数了

```js
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

**name属性**

返回该函数的函数名

```js
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"
```

如果将一个具名函数赋值给一个变量，则 `name`属性都返回这个具名函数原本的名字

```js
const bar = function baz() {};
bar.name // "baz"
```

Function`构造函数返回的函数实例，`name`属性的值为`anonymous

```js
(new Function).name // "anonymous"
```

`bind`返回的函数，`name`属性值会加上`bound`前缀

```js
function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "

console.log(((new Function).bind({})).name)  // bound anonymous
```

### **(3) 作用域**

一旦设置了参数的默认值，**函数进行声明初始化时，参数会形成一个单独的作用域**

等到初始化结束，这个作用域就会消失。**这种语法行为，在不设置参数默认值时，是不会出现的**

下面例子中，`y=x`会形成一个单独作用域，**`x`没有被定义，所以指向全局变量`x`**

```js
let x = 1;

function f(y = x) { 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
}

f() // 1
```

### **(4) 严格模式**

只要函数参数使用了默认值、解构赋值、或者扩展运算符，**那么函数内部就不能显式设定为严格模式**，否则会报错

```js
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```

### **(5) 箭头函数**

使用“箭头”（`=>`）定义函数

```js
var f = v => v;

// 等同于
var f = function (v) {
  return v;
};
```

如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分

```js
var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
```

如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回

```js
var sum = (num1, num2) => { return num1 + num2; }
```

如果返回对象，需要加括号将对象包裹

```js
let getTempItem = id => ({ id: id, name: "Temp" });
```

注意点：

- 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象
- 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误
- 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替
- 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数



----

## 说说对 ES6 中rest参数的理解

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```js
function add(...values) {
  let sum = 0;

  for (let val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```

上面代码的`add`函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。

下面是一个 rest 参数代替`arguments`变量的例子。

```js
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```

上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。

`arguments`对象不是数组，**而是一个类似数组的对象**。所以为了使用数组的方法，**必须使用`Array.prototype.slice.call`先将其转为数组**。rest 参数就不存在这个问题，**它就是一个真正的数组**，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组`push`方法的例子。

```js
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
```

注意，rest 参数之后不能再有其他参数（**即只能是最后一个参数**），否则会报错。

```js
// 报错
function f(a, ...b, c) {
  // ...
}
```

**函数的`length`属性，不包括 rest 参数**。

```js
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

> 箭头函数不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替





---

## 请问你了解Set、Map数据结构吗？

**(1) Set**

类似于数组，但**成员的值是唯一的**，没有重复值

最常见应用：去除数组重复值、去除字符串里面的重复字符

```js
// 去除数组的重复成员 
[...newSet(array)]

// 去除字符串里面的重复字符
[...newSet('ababbc')].join('') // "abc"
```

```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```



**(2) WeakSet**

类似于Set，也是不重复的值的集合，与Set区别：

（1）WeakSet 的成员**只能是对象**，不能是其他类型的值

（2）WeakSet 中的对象都是**弱引用**，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果其他对象都不再引用该对象，那垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中

`WeakSet `可以接受一个具有 `Iterable `接口的对象作为参数

```js
const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
```

在`API`中`WeakSet`与`Set`有两个区别：

- 没有遍历操作的`API`
- 没有`size`属性

```js
let ws=new WeakSet();

// 成员不是引用类型
let weakSet=new WeakSet([2,3]);
console.log(weakSet) // 报错

// 成员为引用类型
let obj1={name:1}
let obj2={name:1}
let ws=new WeakSet([obj1,obj2]); 
console.log(ws) //WeakSet {{…}, {…}}
```

`WeakSet `里面的引用只要在外部消失，它在 `WeakSet `里面的引用就会自动消失

**(3) Map**

js对象本质上是键值对的集合（Hash 结构），但是只能用字符串当作键名，**一些非字符串类型的值作为键名前，都会被自动转换为字符串**

Map 正是为解决此问题，它类似于对象，也是键值对的集合，但是键名的范围不限于字符串，**各种类型的值（包括对象）都可以当作键名**

相比Object 结构，Object 是“字符串——值”对应，**Map是“值——值”的对应**

```js
let map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
map.clear()
map.size // 0
```



**(4) WeakMap**

结构于Map类似，也是用于生成键值对的集合，与Map区别：

（1）**只接受对象作为键名**（null除外），不接受其他类型的值作为键名

```js
const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
```

（2）WeakMap的键名所指向的对象，不计入垃圾回收机制

在`API`中`WeakMap`与`Map`有两个区别：

- 没有遍历操作的`API`
- 没有`clear`清空方法

```js
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // "bar"
```

`WeakMap`的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用

举个场景例子：

在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构，当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除

```js
const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information"
```

注意：`WeakMap` 弱引用的只是键名，而不是键值。键值依然是正常引用

下面代码中，键值`obj`会在`WeakMap`产生新的引用，**当你修改`obj`不会影响到内部**

```js
const wm = new WeakMap();
let key = {};
let obj = {foo: 1};

wm.set(key, obj);
obj = null;
wm.get(key)
// Object {foo: 1}
```





---

## 请你了解ES6中的迭代器与生成器吗？

Iterator迭代器是一种接口，为各种不同的数据结构提供统一的访问机制，**任何数据结构只要部署了 Iterator 接口，就可以完成迭代操作**（即遍历，依次处理该数据结构的所有成员）

**Iterator 的主要作用：**

（1）为各种数据结构，提供一个统一的、简便的访问接口

（2）使得数据结构的成员能够按某种次序排列

（3）当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口

**常见默认调用 Iterator 场景：**

for...of循环、解构赋值、扩展运算（...）、yield*

遍历数组也会调用遍历器接口，**任何接受数组作为参数的地方，几乎都调用了遍历器接口**，如Array.from()、Map()、Set()等



**Generator生成器**是一种异步编程解决方案，Generator 是一个状态机，封装了多个内部状态；它是一个迭代器对象生成函数，

执行 Generator 函数会返回一个迭代器对象，也就是说，**Generator 函数除了状态机，还是一个遍历器对象生成函数**。返回的迭代器对象，可以依次遍历 Generator 函数内部的每一个状态。

Generator 对比普通函数，外观上有两个主要特征：function关键字与函数名之间有一个**星号**，函数体内部使用yield表达式，定义不同的内部状态

```js
function* helloWorldGenerator(){   
    yield 'hello';    //yield表达式
    yield 'world';    //yield表达式
    return'ending';
}

let f = helloWorldGenerator()
for (let x of f) {
    console.log(x);
}
// hello
// world
```

代码块定义了一个 Generator 函数：helloWorldGenerator，它内部有两个yield表达式，有三个状态：hello，world 和 return 语句（结束执行）

不同于普通函数，调用 **Generator 函数后不执行**，返回的不是函数运行结果，**而返回一个指向内部状态的指针对象**（迭代器对象）

且必须调用遍历器对象的**next方法**，使得指针移向下一个状态。可理解为：**每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行**，直到遇到下一个yield表达式（或return语句）为止。Generator 函数是分段执行的，**yield表达式是暂停执行的标记**，而**next方法可以恢复执行**。



----

## 简单介绍下 ES6 中的 Iterator 迭代器

想必大家使用过for循环、while循环等，遍历Array获取其中的值，那其他数据结构如何通过遍历获取呢？或者这样说，是否可以提供一个统一的访问机制？来访问Object、Map、Set等。

轮到Iterator迭代器出场，Iterator迭代器就是为了解决这个问题，它提供统一的接口，为不同的数据结构提供统一的访问机制。(目前Map、Set、Array支持Iterator)。

顾名思义，Iterator迭代器的出现就是为了迭代而生，为不同的集合：Object、Array、Map、Set，提供了一个统一的接口（这里接口可以简单的理解为方法，就是遍历方法）。像我们常用的for...of就是依赖与Iterator迭代器。

理解到的遍历、迭代的关系：遍历就是访问数据结构的所有元素，而迭代是遍历的一种形式。

```js
// 阮一峰 ECMAScript 6 入门
// 模拟next方法返回值
var it = makeIterator(['a', 'b']);

it.next() // { value: "a", done: false }
it.next() // { value: "b", done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex < array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true}
    }
  }
}
```

上面的makeIterator函数，它就是一个迭代器生成函数，作用就是返回一个迭代器对象。对数组执行这个函数，就会返回该数组的迭代器对象it。

通过调用next函数，返回value和done两个属性；value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法；当done为true时，即遍历完成。

小结：Iterator迭代器就是一个接口方法，它为不同的数据结构提供了一个统一的访问机制；使得数据结构的成员能够按某种次序排列，并逐个被访问。

## Iterator规范

在上面的代码中，迭代器对象it包含一个next() 方法，调用next()方法，返回两个属性：布尔值done和值value，value的类型无限制。

迭代器对象包含的属性我们知道了，那么在日常开发中，我们如何让一个对象成为一个可迭代对象呢？（可迭代对象即支持迭代器规范的对象）

要成为可迭代对象， 一个对象必须实现@@iterator方法。这意味着对象（或者它原型链上的某个对象）必须有一个键为@@iterator的属性，可通过常量 Symbol.iterator 访问该属性。

```js
let myIterable = {
    a: 1,
    b: 2,
    c: 3
}
myIterable[Symbol.iterator] = function() {
  let self = this;
  let arr = Object.keys(self);
  let index = 0;
  return {
    next() {
      return index < arr.length ? {value: self[arr[index++]], done: false} : {value: undefined, done: true};
    }
  }
}

var it = myIterable[Symbol.iterator]();

it.next();

for(const i of myIterable) {
  console.log(i);
}
/*
1
2
3
*/
```

将myIterable对象添加Symbol.iterator属性，同时在返回的next方法中，添加两个属性，既让它成为了一个可迭代对象。（其实如果真的有这样的需求，可以考虑使用Map）。

小结：Iterator规范————Iterator迭代器包含一个next()方法，方法调用返回返回两个属性：done和value；通过定义一个对象的Symbol.iterator属性，即可将此对象修改为迭代器对象，支持for...of遍历。





---

## 怎么理解ES6中 Generator的？使用场景有哪些？

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同

执行 `Generator` 函数会返回一个遍历器对象，可以依次遍历 `Generator` 函数内部的每一个状态

形式上，`Generator `函数是一个普通函数，但是有两个特征：

- `function`关键字与函数名之间有一个星号
- 函数体内部使用`yield`表达式，定义不同的内部状态

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}
```

`Generator` 函数会返回一个遍历器对象，即具有`Symbol.iterator`属性，并且返回给自己

```js
function* gen(){
  // some code
}

var g = gen();

g[Symbol.iterator]() === g
// true
```

通过`yield`关键字可以暂停`generator`函数返回的遍历器对象的状态

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}
var hw = helloWorldGenerator();
```

上述存在三个状态：`hello`、`world`、`return`

通过`next`方法才会遍历到下一个内部状态，其运行逻辑如下：

- **遇到`yield`表达式，就暂停执行后面的操作**，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。
- 下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式
- 如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。
- 如果该函数没有`return`语句，**则返回的对象的`value`属性值为`undefined`**

```js
hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'ending', done: true }

hw.next()
// { value: undefined, done: true }
```

**`done`用来判断是否存在下个状态**，`value`对应状态值

**yield表达式本身没有返回值**，或者说总是返回 undefined

**通过调用`next`方法可以带一个参数**，该参数就会**被当作上一个`yield`表达式的返回值**

```js
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```

正因为`Generator `函数返回`Iterator`对象，因此我们还可以通过`for...of`进行遍历

```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```

**原生对象没有遍历接口，通过`Generator `函数为它加上这个接口**，就能使用`for...of`进行遍历了

```js
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

**使用场景**

`Generator`是异步解决的一种方案，最大特点则是将异步操作同步化表达出来

```js
function* loadUI() {
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
}
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
```

包括`redux-saga `中间件也充分利用了`Generator`特性

```js
import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'
import Api from '...'

function* fetchUser(action) {
   try {
      const user = yield call(Api.fetchUser, action.payload.userId);
      yield put({type: "USER_FETCH_SUCCEEDED", user: user});
   } catch (e) {
      yield put({type: "USER_FETCH_FAILED", message: e.message});
   }
}

function* mySaga() {
  yield takeEvery("USER_FETCH_REQUESTED", fetchUser);
}

function* mySaga() {
  yield takeLatest("USER_FETCH_REQUESTED", fetchUser);
}

export default mySaga;
```

还能利用`Generator`函数，在对象上实现`Iterator`接口

```js
function* iterEntries(obj) {
  let keys = Object.keys(obj);
  // let keys = Reflect.ownKeys(obj);
  for (let i=0; i < keys.length; i++) {
    let key = keys[i];
    yield [key, obj[key]];
  }
}

let myObj = { foo: 3, bar: 7 };

for (let [key, value] of iterEntries(myObj)) {
  console.log(key, value);
}

// foo 3
// bar 7
```





----

## 异步解决方案

### 回调函数

所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数

```js
fs.readFile('/etc/fstab', function (err, data) {
  if (err) throw err;
  console.log(data);
  fs.readFile('/etc/shells', function (err, data) {
    if (err) throw err;
    console.log(data);
  });
});
```

`readFile`函数的第二个参数，就是回调函数，等到操作系统返回了`/etc/passwd`这个文件以后，回调函数才会执行

### Promise

`Promise`就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用

```js
const fs = require('fs');

const readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function(error, data) {
      if (error) return reject(error);
      resolve(data);
    });
  });
};


readFile('/etc/fstab').then(data =>{
    console.log(data)
    return readFile('/etc/shells')
}).then(data => {
    console.log(data)
})
```

这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强

### generator

`yield`表达式可以暂停函数执行，`next`方法用于恢复函数执行，这使得`Generator`函数非常适合将异步任务同步化

```js
const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```

### async/await

将上面`Generator`函数改成`async/await`形式，更为简洁，语义化更强了

```js
const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```

### 区别：

通过上述代码进行分析，将`promise`、`Generator`、`async/await`进行比较：

- `promise`和`async/await`是专门用于处理异步操作的
- `Generator`并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署`Interator`接口...）
- `promise`编写代码相比`Generator`、`async`更为复杂化，且可读性也稍差
- `Generator`、`async`需要与`promise`对象搭配处理异步情况
- `async`实质是`Generator`的语法糖，相当于会自动执行`Generator`函数
- `async`使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案



----

## 请说说你对Promise的理解？

`Promise `，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大

在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码

```js
doSomething(function(result) {
  doSomethingElse(result, function(newResult) {
    doThirdThing(newResult, function(finalResult) {
      console.log('得到最终结果: ' + finalResult);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
```

阅读上面代码，是不是很难受，上述形成了经典的回调地狱

现在通过`Promise`的改写上面的代码

```js
doSomething().then(function(result) {
  return doSomethingElse(result);
})
.then(function(newResult) {
  return doThirdThing(newResult);
})
.then(function(finalResult) {
  console.log('得到最终结果: ' + finalResult);
})
.catch(failureCallback);
```

瞬间感受到`promise`解决异步操作的优点：

- 链式操作减低了编码难度
- 代码可读性明显增强

**Promise三个优点：**

（1）可以很好地解决异步编程，将异步操作以同步操作的流程表达出来

（2）让回调函数变成更加规范的链式写法，避免了层层嵌套的回调“地域”

（3）可以处理并行任务，提供统一的对外接口

**Promise三种状态：**

（1）pending：进行中

（2）fulfilled(resolved)：已成功

（3）rejected：已失败



**Promise三个特点：**

（1）**对象的状态不受外界影响**，虽执行器函数的执行是**同步**的，但在Promise的状态未从Pending状态变更到其他状态前，then和catch里面的回调函数会放在队列里面等待状态变更以后才执行（**异步**）

（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果

（3）只有两种状态改变可能：pending→fulfilled、pending→rejected



**Promise三个缺点：**

（1）一旦新建Promise就会立即执行，**无法中途取消**

（2）**若不设置回调函数**，Promise内部抛出的错误，不会反应到外部

（3）当处于pending状态时，**无法得知操作现阶段处于哪一个阶段**



**promise流程**

![img](E:\pogject\学习笔记\image\工程化\1b02ae90-58a9-11eb-85f6-6fac77c0c9b3.png)

**用法**

`Promise`对象是一个构造函数，用来生成`Promise`实例

```js
const promise = new Promise(function(resolve, reject) {});
```

Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject

- `resolve`函数的作用是，将`Promise`对象的状态**从“未完成”变为“成功”**
- `reject`函数的作用是，将`Promise`对象的状态**从“未完成”变为“失败”**

**实例方法**

then()

`then`是实例状态发生改变时的回调函数，**第一个参数**是`resolved`状态的回调函数，**第二个参数**是`rejected`状态的回调函数

`then`方法**返回的是一个新的`Promise`实例**，也就是`promise`能链式书写的原因

```js
getJSON("/posts.json").then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
```

catch

`catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，**用于指定发生错误时的回调函数**

```js
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
```

`Promise `对象的错误**具有“冒泡”性质**，会一直向后传递，**直到被捕获为止**

```js
getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
```

一般来说，使用`catch`方法代替`then()`第二个参数

`Promise `对象抛出的错误**不会传递到外层代码**，即不会有任何反应

```js
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};
```

浏览器运行到这一行，会打印出错误提示`ReferenceError: x is not defined`，但是不会退出进程

`catch()`方法之中，**还能再抛出错误**，通过后面`catch`方法捕获到

finally()

`finally()`方法用于指定**不管 Promise 对象最后状态如何，都会执行的操作**

```js
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```



**构造函数方法**

all()

`Promise.all()`方法用于将多个 `Promise `实例，包装成一个新的 `Promise `实例

```js
const p = Promise.all([p1, p2, p3]);
```

接受一个数组（迭代对象）作为参数，数组成员都应为`Promise`实例

实例`p`的状态由`p1`、`p2`、`p3`决定，分为两种：

- 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数
- 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，**此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数**

注意，如果作为参数的 `Promise` 实例，**自己定义了`catch`方法**，那么它一旦被`rejected`，**并不会触发`Promise.all()`的`catch`方法**

```js
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result)
.catch(e => e);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result)
.catch(e => e);  //  自己定义了`catch`方法

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// ["hello", Error: 报错了]
```

如果`p2`**没有自己的`catch`方法**，就会调用`Promise.all()`的`catch`方法

```js
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result);  // 没有自己的`catch`方法

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e));
// Error: 报错了
```



race()

`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例

```js
const p = Promise.race([p1, p2, p3]);
```

**只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变**

率先改变的 Promise 实例的返回值则传递给`p`的回调函数

```js
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(result => console.log(result))
.catch(e => console.log(e));
```



allSettled()

`Promise.allSettled()`方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例

**只有等到所有这些参数实例都返回结果**，不管是`fulfilled`还是`rejected`，包装实例才会结束

```js
const promises = [
  fetch('/api-1'),
  fetch('/api-2'),
  fetch('/api-3'),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
```



resolve()

将现有对象转为 `Promise `对象

```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

参数可以分成四种情况，分别如下：

- 参数是一个 Promise 实例，`promise.resolve`将不做任何修改、原封不动地返回这个实例
- 参数是一个`thenable`对象，`promise.resolve`会将这个对象转为 `Promise `对象，然后就立即执行`thenable`对象的`then()`方法
- 参数不是具有`then()`方法的对象，或根本就不是对象，`Promise.resolve()`会返回一个新的 Promise 对象，状态为`resolved`
- 没有参数时，直接返回一个`resolved`状态的 Promise 对象



reject()

```js
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))

p.then(null, function (s) {
  console.log(s)
});
// 出错了
```

`Promise.reject()`方法的参数，**会原封不动地变成后续方法的参数**

```js
Promise.reject('出错了')
.catch(e => {
  console.log(e === '出错了')
})
// true
```



**使用场景**

将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化

```js
const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

通过链式操作，将多个渲染数据分别给`then`，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题

```js
// 各司其职
getInfo().then(res=>{
    let { bannerList } = res
    //渲染轮播图
    console.log(bannerList)
    return res
}).then(res=>{
    
    let { storeList } = res
    //渲染店铺列表
    console.log(storeList)
    return res
}).then(res=>{
    let { categoryList } = res
    console.log(categoryList)
    //渲染分类列表
    return res
})
```



通过`all()`实现多个请求合并在一起，汇总所有请求结果，只需设置一个`loading`即可

```js
function initLoad(){
    // loading.show() //加载loading
    Promise.all([getBannerList(), getStoreList(), getCategoryList()]).then(res=>{
        console.log(res)
        loading.hide() //关闭loading
    }).catch(err=>{
        console.log(err)
        loading.hide()//关闭loading
    })
}
//数据初始化    
initLoad()
```



通过`race`可以设置图片请求超时

```js
//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
           resolve(img);
        }
        //img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg"; 正确的
        img.src = "https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1";
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});
```



----

## 如何中断Promise？

Promise 有个缺点就是一旦创建就无法取消，所以**本质上 Promise 是无法被终止的**，但我们在开发过程中可能会遇到下面两个需求：

- **中断调用链**

就是在某个 then/catch 执行之后，不想让后续的链式调用继续执行了。

```js
somePromise
  .then(() => {})
  .then(() => {
    // 终止 Promise 链，让下面的 then、catch 和 finally 都不执行
  })
  .then(() => console.log('then'))
  .catch(() => console.log('catch'))
  .finally(() => console.log('finally'))
```

**一种方法是在then中直接抛错, 这样就不会执行后面的then, 直接跳到catch方法打印err**(但此方法并没有实际中断)。但如果链路中对错误进行了捕获，后面的then函数还是会继续执行。

Promise的then方法接收两个参数：

```js
Promise.prototype.then(onFulfilled, onRejected)
```

若onFulfilled或onRejected是一个函数，当函数返回一个新Promise对象时**，原Promise对象的状态将跟新对象保持一致**，详见Promises/A+标准。

因此，**当新对象保持“pending”状态时，原Promise链将会中止执行。**

```js
Promise.resolve().then(() => {
    console.log('then 1')  // then 1
    return new Promise(() => {})
    //后面的不会执行
}).then(() => {
    console.log('then 2')
}).then(() => {
    console.log('then 3')
}).catch((err) => {
    console.log(err)
})
```

- **中断Promise**

注意这里是中断而不是终止，**因为 Promise 无法终止**，这个中断的意思是：**在合适的时候，把 pending 状态的 promise 给 reject 掉**。例如一个常见的应用场景就是希望给网络请求设置超时时间，**一旦超时就就中断，我们这里用定时器模拟一个网络请求，随机 3 秒之内返回。**

```js
function timeoutWrapper(p, timeout = 2000) {
  const wait = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject('请求超时')
    }, timeout)
  })
  return Promise.race([p, wait])
}
```





---

## 请问你能手写Promise吗？

Promise对象是一个构造函数，主要用来生成Promise实例

构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve函数 和 reject函数

```js
//创建一个Promise实例
const promise =new Promise(function(resolve, reject){ 
    // ... some code 
    if(/* 异步操作成功 */){
        resolve(value);
    }else{
        reject(error);
    }
});
```

**resolve 函数：**将 Promise 对象的状态从 pending → fulfilled ，在异步操作成功时调用，并将异步操作的结果，作为参数传递给注册在 then 方法上的回调函数（then方法的第一个参数）；

**reject 函数：**将 Promise 对象的状态从 pending → rejected ，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递给注册在 then 方法上的回调函数（then方法的第二个参数）

**then方法：**定义在原型对象 Promise.prototype 上，作用是为 Promise 实例添加状态改变时的回调函数，返回一个新的 Promise 实例（不是原来那个）。第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数

一步步写出Promise的结构

下面是ES6版本的整体代码，摘自网络，仅供参考：

```js
// 先定义三个常量表示状态
const PENDING="pending";
const FULFILLED="fulfilled";
const REJECTED="rejected";

// 新建 MyPromise 类
class MyPromise{
	constructor(executor){
		// executor 是一个执行器，进入会立即执行
		// 并传入resolve和reject方法
		try{
			executor(this.resolve,this.reject);
		}catch(error){
			this.reject(error);
		}
	}
	
	status=PENDING;  // 储存状态的变量，初始值是 pending
	value=null;  // 成功之后的值
	reason=null;  // 失败之后的原因
	onFulfilledCallbacks=[];  //存储成功回调函数
	onRejectedCallbacks=[];  //存储失败回调函数

	// 更改成功后的状态
	resolve=(value)=>{
		// 只有状态是等待，才执行状态修改
		if (this.status===PENDING) {
			// 状态修改为成功
			this.status=FULFILLED;
			// 保存成功之后的值
			this.value=value;
			// resolve里面将所有成功的回调拿出来执行
			while(this.onFulfilledCallbacks.length){
				// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空
				this.onFulfilledCallbacks.shift()(value);
			}
		}
	}

	// 更改失败后的状态
	reject=(reason)=>{
		// 只有状态是等待，才执行状态修改
		if (this.status===PENDING) {
			// 状态成功为失败
			this.status=REJECTED;
			// 保存失败后的原因
			this.reason=reason;
			// resolve里面将所有失败的回调拿出来执行
			while(this.onRejectedCallbacks.length){
				this.onRejectedCallbacks.shift()(reason);
			}
		}
	}

	then(onFulfilled,onRejected){
		const realOnFulfilled=typeof onFulfilled==="function" ? onFulfilled : value=>value;
		const realOnRejected=typeof onRejected==="function" ? onRejected : reason=>{ throw reason};
		// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去
		const promise2=new MyPromise((resolve,reject)=>{
			const fulfilledMicrotask=()=>{
				//创建一个微任务等待 promise2 完成初始化
				queueMicrotask(()=>{
					try{
						//获取成功回调函数的执行结果
						const x=realOnFulfilled(this.value);
						//传入 resolvePromise 集中处理
						resolvePromise(promise2,x,resolve,reject);
					}catch(error){
						reject(error);
					}
				});
			}

			const rejectedMicrotask=()=>{
				// 创建一个微任务等待 promise2 完成初始化
				queueMicrotask(()=>{
					try{
						//调用失败回调，并且把原因返回
						const x=realOnRejected(this.reason);
						//传入 resolvePromise 集中处理
						resolvePromise(promise2,x,resolve,reject);
					}catch(error){
						throw error;
					}
				});
			}

			//判断状态
			if (this.status===FULFILLED) {
				fulfilledMicrotask();
			}else if (this.status===REJECTED) {
				rejectedMicrotask();
			}else if(this.status===PENDING){
				// 等待
				// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来
				// 等到执行成功失败函数的时候再传递
				this.onFulfilledCallbacks.push(fulfilledMicrotask);
				this.onRejectedCallbacks.push(rejectedMicrotask);
			}
		});
		return promise2;
	}

	//resolve 静态方法
	static resolve(parameter){
		//如果传入 MyPromise 就直接返回
		if (parameter instanceof MyPromise) {
			return parameter;
		}
		//转成常规方式
		return new MyPromise(resolve=>{
			resolve(parameter);
		});
	}

	// reject 静态方法
	static reject(reason){
		return new MyPromise((resolve,reject)=>{
			reject(reason);
		});
	}
}

function reslovePromise(promise2,x,resolve,reject){
	//如果相等了，说明return的是自己，抛出类型错误并返回
	if (promise2===x) {
		return reject(new TypeError("Chaining cycle detected for promise #<Promise>"));
	}
	//判断x是不是 MyPromise 实例对象
	if (x instanceof MyPromise) {
		//执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected
		//x.then(value=>resolve(value),reason=>reject(reason));
		// 简化之后
		x.then(resolve,reject);
	}else{
		//普通值
		resolve(x);
	}
}

module.exports=MyPromise;
```

**Promise.all()：**

将多个Promise，包装成一个新的Promise，只有当所有Promise都成功，新的Promise才成功，一个失败就返回失败的Promise

一些日常开发中十分实用的点：

（1）Promise.all()获得的成功结果的数组里面的数据顺序和Promise.all()接收到的数组顺序是一致的，即便后面的结果返回得慢

（2）Promise.all()可以充分利用并行的优势，**返回结果的时间是最长请求的时间**，这样可以更快处理请求的结果

**Promise.race()：**

将多个Promise，包装成一个新的Promise，**新Promise的结果由第一个完成的Promise决定**， 第一个成功则返回成功的Promise，第一个失败直接返回失败的Promise

```js
/*Promise 函数对象all方法，返回一个promise 只有当所有promise都成功，才成功，一个失败就失败*/
function all(promises){
    const values = new Array(promises.length) //用来保存所有成功value的数组,长度等于promises的长度
    //定义计数器，用来保存成功promise的数量
    let resolvedCount = 0
    
    //返回一个新的promise
    return new Promise((resolve,reject) =>{
        //遍历promises获取每个promise的结果
        promises.forEach((p,index) => {
            Promise.resolve(p).then(
                value => {
                //成功一次 加一
                    resolvedCount++
                // p成功，将成功的value保存values,不能直接push，得按照promises的顺序存
                    values[index] = value
                    //如果全部成功了，将return的promises改为成功
                    if (resolvedCount===promises.length) {
                        resolve(values)
                    }
                },
                reason => { //一个失败，整个失败
                    reject(reason)
                }
            )
        })
    })
}

/*Promise 函数对象race方法，返回一个promise，其结果由第一个完成的promise决定，看传入的promise数组 里谁最先完成，看第一个完成的是成功/失败*/
function race(promises){
    return new Promise((resolve,reject) =>{
    //遍历promises获取每个promise的结果
        promises.forEach((p,index) => {
            Promise.resolve(p).then(
                value => {
               //一旦有成功的，return的promise变为成功
                    resolve(value)
                },
                reason => { //一个失败，return的promise变为失败
                    reject(reason)
                }
            )
        })
    })
}
```

----

## 请问你了解async/await吗？

async/await本质上就是一个语法糖，**底层实现是带有执行器的 Generator 函数**，async函数就是**将 Generator 函数的星号（*）替换成async**，将**yield替换成await**

可简单理解为 async 用于申明一个 函数 是异步的，**而 await 可认为是 async wait 简写**，用于等待一个异步方法执行完成

**async 函数：**返回的是一个 Promise 对象。如果在函数中 return一个直接量，async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象

```js
Promise.resolve(x)
//可看作为下面这句的简写
new Promise(resolve => resolve(x))
```

**Promise.resolve(x)：**可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例

若最外层没有 await 获取其返回值的情况下，应该用原来的方式：.then()链来处理返回的个 Promise 对象



**await ：**通常情况 async 函数返回一个 Promise 对象，**故 await 可以用于等 Promise 对象，实际上它在等一个返回值**。不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量

注意：await 是一个运算符，用于组成表达式，**表达式的运算结果取决于等到的返回值**：

（1）、返回值不是一个 Promise 对象，**运算结果直接为该返回值**

（2）、返回值是一个 Promise 对象，**await 会阻塞后面的代码**，等 Promise 对象完成resolve，随后得到 resolve 的值，作为 await 表达式运算结果，**通常 async 函数调用不会造成阻塞**，因为**它内部所有的阻塞都被封装在一个 Promise 对象中异步执行了**

**async/await 的优势：**处理 then 链，相当于**进一步优化回调问题**

可利用如下代码进行对比，假设有一个任务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。先用 setTimeout模拟异步操作：

```js
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}
function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}
function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}
function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

用 Promise 方式来实现这三个步骤的处理：

```js
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}

doIt();
```

用 async/await 实现：

```js
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}

doIt();
```

这个代码看起来会更清晰明了，几乎跟同步代码一样



---

## 请问async/await中如何进行错误处理？

await 后的异步操作出错，等同于async函数返回的 Promise 对象被reject，**所以最好把await 命令放在 try...catch 代码块中**

```js
//写法示例
async function myFunction(){
    try{     
        await somethingThatReturnsAPromise();
    } catch(err){     
        console.log(err);
    }
} 
```

此外，可在 await 后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误

对于多个 **await**命令后面的异步操作，**如果不存在继发关系，最好让它们同时触发**（可用promise.all()）

```js
let foo = await getFoo();
let bar = await getBar();

// 改写成：
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
```

注意：await **只能用在async函数之中**，如果用在普通函数，会报错



----

## async/await 和 Promise 有什么关系？

### Promise

> Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象

### async/await

es2017的新语法，async/await就是 generator + promise的语法糖

async/await 和 Promise 的关系非常的巧妙，await必须在async内使用，并装饰一个Promise对象，**async返回的也是一个Promise对象**。

async/await中的return/throw会代理自己返回的Promise的resolve/reject，而一个Promise的resolve/reject会使得await得到返回值或抛出异常。

- 如果方法内**无await节点**
  - return 一个字面量则会得到一个{PromiseStatus: resolved}的Promise。
  - throw 一个Error则会得到一个{PromiseStatus: rejected}的Promise。
- 如果方法内**有await节点**
  - async会返回一个{PromiseStatus: pending}的Promise（发生切换，异步等待Promise的执行结果）。
  - Promise的resolve会使得await的代码节点获得相应的返回结果，并继续向下执行。
  - Promise的reject 会使得await的代码节点自动抛出相应的异常，终止向下继续执行。







---

## 请问什么是Proxy？使用场景有哪些?

**定义：** 用于定义基本操作的自定义行为

**本质：** 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程`(meta programming)`

元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作



Proxy 是 ES6 为了操作对象引入的一个新API，可以对目标对象的读取、函数调用等操作进行拦截，然后进行处理

**Proxy不直接操作对象，更像一种代理模式**，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些额外操作

```bash
#!/bin/bash
# metaprogram
echo '#!/bin/bash' >program
for ((I=1; I<=1024; I++)) do
    echo "echo $I" >>program
done
chmod +x program
```

这段程序每执行一次能帮我们生成一个名为`program`的文件，文件内容为1024行`echo`，如果我们手动来写1024行代码，效率显然低效

- 元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译

`Proxy` 亦是如此，**用于创建一个对象的代理，从而实现基本操作的拦截和自定义**（如属性查找、赋值、枚举、函数调用等）

`Proxy`为 构造函数，用来生成 `Proxy `实例

```js
var proxy = new Proxy(target, handler)
```

**参数**

`target`表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））

`handler`通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为

**handler解析**

关于`handler`拦截属性，有如下：

- get(target,propKey,receiver)：拦截对象属性的读取
- set(target,propKey,value,receiver)：拦截对象属性的设置
- has(target,propKey)：拦截`propKey in proxy`的操作，返回一个布尔值
- deleteProperty(target,propKey)：拦截`delete proxy[propKey]`的操作，返回一个布尔值
- ownKeys(target)：拦截`Object.keys(proxy)`、`for...in`等循环，返回一个数组
- getOwnPropertyDescriptor(target, propKey)：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象
- defineProperty(target, propKey, propDesc)：拦截`Object.defineProperty(proxy, propKey, propDesc）`，返回一个布尔值
- preventExtensions(target)：拦截`Object.preventExtensions(proxy)`，返回一个布尔值
- getPrototypeOf(target)：拦截`Object.getPrototypeOf(proxy)`，返回一个对象
- isExtensible(target)：拦截`Object.isExtensible(proxy)`，返回一个布尔值
- setPrototypeOf(target, proto)：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值
- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作
- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作

**Reflect**

若需要在`Proxy`内部调用对象的默认行为，建议使用`Reflect`，其是`ES6`中操作对象而提供的新 `API`

基本特点：

- 只要`Proxy`对象具有的代理方法，`Reflect`对象全部具有，以静态方法的形式存在
- 修改某些`Object`方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回`false`）
- 让`Object`操作都变成函数行为

基本用法：

一个 Proxy 对象由两个部分组成： target 、handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数：target 为目标对象， handler 是一个对象，声明了代理 target 的指定行为

```js
//具体实例:
let target = {     
    name: 'Tom',     
    age: 24 
} 
let handler = {     
    get: function(target, key) {         
        console.log('getting '+key);         
        return target[key]; // 不是target.key     
    },     
    set: function(target, key, value) {        
        console.log('setting '+key);         
        target[key] = value;     
    } 
} 
let proxy = new Proxy(target, handler) 
proxy.name     // 实际执行 handler.get 
proxy.age = 25 // 实际执行 handler.set 
// getting name 
// setting age
 // 25
```

Proxy的常用实例方法：

（1）、**get(target, propKey, receiver)，**用于 target 对象上 propKey 的读取操作。`get`接受三个参数，依次为目标对象、属性名和 `proxy` 实例本身，最后一个参数可选。

```js
let exam ={     
    name: "Tom",     
    age: 24 
} 
let proxy = new Proxy(exam, {   
    get(target, propKey, receiver) {     
        console.log('Getting ' + propKey);     
        return target[propKey];   
    } 
}) 
proxy.name  
// Getting name 
// "Tom"
```

`get`能够对数组增删改查进行拦截，下面是试下数组读取负数的索引

```js
function createArray(...elements) {
  let handler = {
    get(target, propKey, receiver) {
      let index = Number(propKey);
      if (index < 0) {
        propKey = String(target.length + index);
      }
      return Reflect.get(target, propKey, receiver);
    }
  };

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
}

let arr = createArray('a', 'b', 'c');
arr[-1] // c
```

注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错

```js
const target = Object.defineProperties({}, {
  foo: {
    value: 123,
    writable: false,
    configurable: false
  },
});

const handler = {
  get(target, propKey) {
    return 'abc';
  }
};

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
```



（2）、set(target, propKey, value, receiver)，用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那set方法将不起作用.

`set`方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 `Proxy` 实例本身

假定`Person`对象有一个`age`属性，该属性应该是一个不大于 200 的整数，那么可以使用`Proxy`保证`age`的属性值符合要求

```js
let validator = {     
    set: function(obj, prop, value) {         
        if (prop === 'age') {             
            if (!Number.isInteger(value)) {                 
                throw new TypeError ('The age is not an integer');}                                          }            
             if (value > 200) {                 
                 throw new RangeError('The age seems invalid'); }         
             }         // 对于满足条件的 age 属性以及其他属性，直接保存                     
             obj[prop] = value;     
         } 
 };

 let proxy= new Proxy({}, validator) 
 proxy.age = 100; 
 proxy.age           // 100 
 proxy.age = 'oppps' // 报错 
 proxy.age = 300     // 报错
```

如果目标对象自身的某个属性，不可写且不可配置，那么`set`方法将不起作用

```js
const obj = {};
Object.defineProperty(obj, 'foo', {
  value: 'bar',
  writable: false,
});

const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = 'baz';
  }
};

const proxy = new Proxy(obj, handler);
proxy.foo = 'baz';
proxy.foo // "bar"
```

注意，严格模式下，`set`代理如果没有返回`true`，就会报错

```js
'use strict';
const handler = {
  set: function(obj, prop, value, receiver) {
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  }
};
const proxy = new Proxy({}, handler);
proxy.foo = 'bar';
// TypeError: 'set' on proxy: trap returned falsish for property 'foo'
```

**deleteProperty()**

`deleteProperty`方法用于拦截`delete`操作，如果这个方法抛出错误或者返回`false`，当前属性就无法被`delete`命令删除

```js
var handler = {
  deleteProperty (target, key) {
    invariant(key, 'delete');
    Reflect.deleteProperty(target,key)
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === '_') {
    throw new Error(`无法删除私有属性`);
  }
}

var target = { _prop: 'foo' };
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: 无法删除私有属性
```

注意，目标对象自身的不可配置（configurable）的属性，不能被`deleteProperty`方法删除，否则报错

**取消代理**

```
Proxy.revocable(target, handler);
```



**使用场景**

`Proxy`其功能非常类似于设计模式中的代理模式，常用功能如下：

- 拦截和监视外部对对象的访问
- 降低函数或类的复杂度
- 在复杂操作前对操作进行校验或对所需资源进行管理

使用 `Proxy` 保障数据类型的准确性

```js
let numericDataStore = { count: 0, amount: 1234, total: 14 };
numericDataStore = new Proxy(numericDataStore, {
    set(target, key, value, proxy) {
        if (typeof value !== 'number') {
            throw Error("属性只能是number类型");
        }
        return Reflect.set(target, key, value, proxy);
    }
});

numericDataStore.count = "foo"
// Error: 属性只能是number类型

numericDataStore.count = 333
// 赋值成功
```

声明了一个私有的 `apiKey`，便于 `api` 这个对象内部的方法调用，但不希望从外部也能够访问 `api._apiKey`

```js
let api = {
    _apiKey: '123abc456def',
    getUsers: function(){ },
    getUser: function(userId){ },
    setUser: function(userId, config){ }
};
const RESTRICTED = ['_apiKey'];
api = new Proxy(api, {
    get(target, key, proxy) {
        if(RESTRICTED.indexOf(key) > -1) {
            throw Error(`${key} 不可访问.`);
        } 
        return Reflect.get(target, key, proxy);
    },
    set(target, key, value, proxy) {
        if(RESTRICTED.indexOf(key) > -1) {
            throw Error(`${key} 不可修改`);
        } 
        return Reflect.set(target, key, value, proxy);
    }
});

console.log(api._apiKey)
api._apiKey = '987654321'
// 上述都抛出错误
```

还能通过使用`Proxy`实现观察者模式

观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行

`observable`函数返回一个原始对象的 `Proxy` 代理，拦截赋值操作，触发充当观察者的各个函数

```js
const queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn);
const observable = obj => new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer());
  return result;
}
```

观察者函数都放进`Set`集合，当修改`obj`的值，在会`set`函数中拦截，自动执行`Set`所有的观察者



-----

## 谈谈 Object.defineProperty 与 Proxy 的区别

在 Vue2.x 的版本中，双向绑定是基于 Object.defineProperty 方式实现的。而 Vue3.x 版本中，使用了 ES6 中的 Proxy 代理的方式实现。

### Object.defineProperty(obj, prop, descriptor)

使用 Object.defineProperty 会产生三个主要的问题：

- **不能监听数组的变化**

在 Vue2.x 中解决数组监听的方法是将能够改变原数组的方法进行重写实现（比如：push、 pop、shift、unshift、splice、sort、reverse），举例：

```js
// 我们重写 push 方法
const originalPush = Array.prototype.push

Array.prototype.push = function() {
  // 我们在这个位置就可以进行 数据劫持 了
  console.log('数组被改变了')

  originalPush.apply(this, arguments)
}
```

- **必须遍历对象的每个属性**

可以通过 Object.keys() 来实现

- **必须深层遍历嵌套的对象**

通过递归深层遍历嵌套对象，然后通过 Object.keys() 来实现对每个属性的劫持

### Proxy

- **Proxy 针对的整个对象**，Object.defineProperty 针对单个属性，这就解决了 需要对对象进行深度递归（支持嵌套的复杂对象劫持）实现对每个属性劫持的问题

```js
// 定义一个复杂对象
const obj = {
    obj: {
        children: {
            a: 1
        }
    }
}

const objProxy = new Proxy(obj, {
    get(target, property, receiver){
        console.log('-- target --')
        return Reflect.get(target, property, receiver)
    },

    set(target, property, value, receiver) {
        console.log('-- set --')
        return Reflect.set(target, property, value, receiver)
    }
})

console.log(objProxy.obj) // 输出 '-- target --'  { children: { a: 1 } }
console.log(objProxy.a = 2) // 输出 '-- set --'  2
```

- Proxy **解决了 Object.defineProperty 无法劫持数组的问题**

```js
const ary = [1, 2, 3]

const aryProxy = new Proxy(ary, {
    get(target, property, receiver){
        console.log('-- target --')
        return Reflect.get(target, property, receiver)
    },
    set(target, property, value, receiver) {
        console.log('-- set --')
        return Reflect.set(target, property, value, receiver)
    }
})

console.log(aryProxy[0]) // 输出 '-- target --'  1
console.log(aryProxy.push(1)) // 输出 '-- set --'  4
```

- 比 Object.defineProperty 有更多的拦截方法，**对比一些新的浏览器，可能会对 Proxy 针正对性的优化**，有助于性能提升



---

## 请问什么是Reflect ？

Reflect 同样也是 ES6 为了操作对象引入的一个新API，可以**用于获取目标对象的行为**，与 Object 类似，但是更易读，它的方法与 Proxy 是对应的

ES6 将Object的一些明显属于语言内部的方法移植到了 Reflect 对象上（现阶段某些方法同时存在于 Object 和 Reflect 对象上）

Reflect 对象对某些方法的返回结果进行了修改，使其更合理

Reflect 对象使用函数的方式实现了 Object 的命令式操作

（1）、**Reflect.get(target, name, receiver)，**查找并返回 target 对象的 name 属性

```js
let exam = {     
    name: "Tom",     
    age: 24,     
    get info(){         
        return this.name + this.age;     
    } 
} 
Reflect.get(exam, 'name'); // "Tom"  
// 当target对象中存在 name 属性的getter方法， getter方法的this会绑定

// receiver 
let receiver = {     
    name: "Jerry",     
    age: 20 
} 
Reflect.get(exam, 'info', receiver); // Jerry20  

// 当 name 为不存在于target对象的属性时，返回 undefined 
Reflect.get(exam, 'birth'); // undefined   

// 当 target 不是对象时，会报错 
Reflect.get(1, 'name'); // TypeError
```

（2）、**Reflect.set(target, name, value, receiver)，**将 target 的name属性设置为 value，返回值为 boolean ，true 表示修改成功，false 表示失败（当 target 为不存在的对象时，会报错）

```js
let exam = {     
    name: "Tom",     
    age: 24,     
    set info(value){         
        return this.age = value;     
    } 
} 
exam.age; // 24 
Reflect.set(exam, 'age', 25); // true 
exam.age; // 25   

// value为空时会将name属性清除 
Reflect.set(exam, 'age', ); // true 
exam.age; // undefined   

// 当target对象中存在name属性setter方法时，setter方法中的this会绑定receiver, 所以修改的实际上是receiver的属性, 
let receiver = {     
    age: 18 
} 
Reflect.set(exam, 'info', 1, receiver); // true 
receiver.age; // 1   
let receiver1 = {     
    name: 'oppps' 
} 
Reflect.set(exam, 'info', 1, receiver1); 
receiver1.age; // 1
```

（3）**、Reflect.ownKeys(target)，**用于返回 target 对象的**所有属性**，等同于 Object.getOwnPropertyNames +Object.getOwnPropertySymbols

```js
var exam = {   
    name: 1,   
    [Symbol.for('age')]: 4 
} 
Reflect.ownKeys(exam) // ["name", Symbol(age)]
```



Reflect 对象不是构造函数，所以创建时不是用 new 来进行创建。

在 ES6 中增加这个对象的目的：

- **将 Object 对象的一些明显属于语言内部的方法**（比如 Object.defineProperty），**放到 Reflect 对象上**。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。
- **修改某些 Object 方法的返回结果，让其变得更合理**。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。
- **让 Object 操作都变成函数行为**。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。
- **Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法**。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。

```js
var loggedObj = new Proxy(obj, {
  get(target, name) {
    console.log("get", target, name);
    return Reflect.get(target, name);
  },
  deleteProperty(target, name) {
    console.log("delete" + name);
    return Reflect.deleteProperty(target, name);
  },
  has(target, name) {
    console.log("has" + name);
    return Reflect.has(target, name);
  },
});

```

上面代码中，每一个 Proxy 对象的拦截操作（get、delete、has），内部都调用对应的 Reflect 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。



----

## 怎么理解ES6中 Decorator 的？使用场景有哪些？

Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式

简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。

`ES6`中`Decorator`功能亦如此，其本质也不是什么高大上的结构，**就是一个普通的函数，用于扩展类属性和类方法**

这里定义一个士兵，这时候他什么装备都没有

```js
class soldier{ 
}
```

定义一个得到 AK 装备的函数，即装饰器

```js
function strong(target){
    target.AK = true
}
```

使用该装饰器对士兵进行增强

```js
@strong
class soldier{
}
```

这时候士兵就有武器了

```js
soldier.AK // true
```

上述代码虽然简单，但也能够清晰看到了使用`Decorator`两大优点：

- 代码可读性变强了，装饰器命名相当于一个注释
- 在不改变原有代码情况下，对原来功能进行扩展

`Docorator`修饰对象为下面两种：

- 类的装饰
- 类属性的装饰

### 类的装饰

当对类本身进行装饰的时候，能够接受一个参数，即类本身

将装饰器行为进行分解，大家能够有个更深入的了解

```js
@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;
```

下面`@testable`就是一个装饰器，`target`就是传入的类，即`MyTestableClass`，实现了为类添加静态属性

```js
@testable
class MyTestableClass {
  // ...
}

function testable(target) {
  target.isTestable = true;
}

MyTestableClass.isTestable // true
```

如果想要传递参数，可以在装饰器外层再封装一层函数

```js
function testable(isTestable) {
  return function(target) {
    target.isTestable = isTestable;
  }
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable // true

@testable(false)
class MyClass {}
MyClass.isTestable // false
```

### 类属性的装饰

当对类属性进行装饰的时候，能够接受三个参数：

- 类的原型对象
- 需要装饰的属性名
- 装饰属性名的描述对象

首先定义一个`readonly`装饰器

```js
function readonly(target, name, descriptor){
  descriptor.writable = false; // 将可写属性设为false
  return descriptor;
}
```

使用`readonly`装饰类的`name`方法

```js
class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}
```

相当于以下调用

```js
readonly(Person.prototype, 'name', descriptor);
```

如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行

```js
function dec(id){
    console.log('evaluated', id);
    return (target, property, descriptor) =>console.log('executed', id);
}

class Example {
    @dec(1)
    @dec(2)
    method(){}
}
// evaluated 1
// evaluated 2
// executed 2
// executed 1
```

外层装饰器`@dec(1)`先进入，但是内层装饰器`@dec(2)`先执行

### 注意

装饰器不能用于修饰函数，**因为函数存在变量声明情况**

```js
var counter = 0;

var add = function () {
  counter++;
};

@add
function foo() {
}
```

编译阶段，变成下面

```js
var counter;
var add;

@add
function foo() {
}

counter = 0;

add = function () {
  counter++;
};
```

意图是执行后`counter`等于 1，但是实际上结果是`counter`等于 0

### 使用场景

基于`Decorator`强大的作用，我们能够完成各种场景的需求，下面简单列举几种：

使用`react-redux`的时候，如果写成下面这种形式，既不雅观也很麻烦

```js
class MyReactComponent extends React.Component {}

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
```

通过装饰器就变得简洁多了

```js
@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component {}
```

将`mixins`，也可以写成装饰器，让使用更为简洁了

```js
function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list);
  };
}

// 使用
const Foo = {
  foo() { console.log('foo') }
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo() // "foo"
```

下面再讲讲`core-decorators.js`几个常见的装饰器

#### @antobind

`autobind`装饰器使得方法中的`this`对象，绑定原始对象

```js
import { autobind } from 'core-decorators';

class Person {
  @autobind
  getPerson() {
    return this;
  }
}

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
```

#### @readonly

`readonly`装饰器使得属性或方法不可写

```js
import { readonly } from 'core-decorators';

class Meal {
  @readonly
  entree = 'steak';
}

var dinner = new Meal();
dinner.entree = 'salmon';
// Cannot assign to read only property 'entree' of [object Object]
```

#### @deprecate

`deprecate`或`deprecated`装饰器在控制台显示一条警告，表示该方法将废除

```js
import { deprecate } from 'core-decorators';

class Person {
  @deprecate
  facepalm() {}

  @deprecate('功能废除了')
  facepalmHard() {}
}

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: 功能废除了

```



----

##  JavaScript中的简单数据类型有哪些？

```
JS `中有六种简单数据类型：`undefined`、`null`、`boolean`、`string`、`number`、`symbol
```

PS: ES10中的新特性 BigInt (任意精度整数)，目前还处于stage-4阶段，不出意外即将成为js的第七种基本数据类型和第二个数字数据类型。

但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型

```js
let x = y ? 1 : a;
```

上面代码中，`x`的值在编译阶段是无法获取的，只有等到程序运行时才能知道

虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制

常见的类型转换有：

- 强制转换（显示转换）
- 自动转换（隐式转换）

### **显示转换**

显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

- Number()
- parseInt()
- String()
- Boolean()

**Number()**

将任意类型的值转化为数值

先给出类型转换规则：



![img](https://static.vue-js.com/915b7300-6692-11eb-ab90-d9ae814b240d.png)



```js
Number(324) // 324

// 字符串：如果可以被解析为数值，则转换为相应的数值
Number('324') // 324

// 字符串：如果不可以被解析为数值，返回 NaN
Number('324abc') // NaN

// 空字符串转为0
Number('') // 0

// 布尔值：true 转成 1，false 转成 0
Number(true) // 1
Number(false) // 0

// undefined：转成 NaN
Number(undefined) // NaN

// null：转成0
Number(null) // 0

// 对象：通常转换成NaN(除了只包含单个数值的数组)
Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN
Number([5]) // 5
```

从上面可以看到，`Number`转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`

**parseInt()**

`parseInt`相比`Number`，就没那么严格了，`parseInt`函数逐个解析字符，**遇到不能转换的字符就停下来**

```js
parseInt('32a3') //32
```

**String()**

可以将任意类型的值转化成字符串

给出转换规则图：



![img](https://static.vue-js.com/48dd8eb0-6692-11eb-85f6-6fac77c0c9b3.png)



```js
// 数值：转为相应的字符串
String(1) // "1"

//字符串：转换后还是原来的值
String("a") // "a"

//布尔值：true转为字符串"true"，false转为字符串"false"
String(true) // "true"

//undefined：转为字符串"undefined"
String(undefined) // "undefined"

//null：转为字符串"null"
String(null) // "null"

//对象
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```

**Boolean()**

可以将任意类型的值转为布尔值，转换规则如下：



![img](https://static.vue-js.com/53bdad10-6692-11eb-ab90-d9ae814b240d.png)



```js
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false

Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

### **隐式转换**

在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？

我们这里可以归纳为两种情况发生隐式转换的场景：

- 比较运算（`==`、`!=`、`>`、`<`）、`if`、`while`需要布尔值地方
- 算术运算（`+`、`-`、`*`、`/`、`%`）

除了上面的场景，还要求运算符两边的操作数不是同一类型

**自动转换为布尔值**

在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用`Boolean`函数

可以得出个小结：

- undefined
- null
- false
- +0
- -0
- NaN
- ""

除了上面几种会被转化成`false`，其他都换被转化成`true`

**自动转换成字符串**

遇到预期为字符串的地方，就会将非字符串的值自动转为字符串

具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串

常发生在`+`运算中，一旦存在字符串，则会进行字符串拼接操作

```js
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```

**自动转换成数值**

除了`+`有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值

```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```

null`转为数值时，值为`0` 。`undefined`转为数值时，值为`NaN





----

