----



-----

## 1. 请问你了解OSI七层模型吗？

**OSI**（Open System Interconnect），即**开放式系统互联**。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。
**OSI定义了网络互连的七层框架**（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。

![img](E:\pogject\学习笔记\image\http\D6A70DA7466DF3865BABC8FDAA316E4C)

### 应用层

OSI参考模型中最靠近用户的一层，是**为计算机用户提供应用接口，也为用户直接提供各种网络服务**。我们常见应用层的网络服务协议有：**HTTP，HTTPS，FTP，POP3、SMTP等。**

作用：它是与其他计算机进行通信的应用，它是对应应用程序的通信服务的。各种应用软件，包括web应用。

协议：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS

HTTP（Hyper text Transfer Protocol）协议：超文本传输协议使用TCP的80端口

FTP（File Transfer Protocol）文本传输协议

SMTP（Simple Mail Transfer Protocol）简单邮件传输协议，TCP是我25端口用户发邮件。

POP3（Post Office Protocol version3）邮局协议版本3，TCP的110号端口，用于收邮件的。

DNS（Domain Name System）域名解析协议。使用TCP和UDP的53号端口，作用是把www的域名解析成IP地址。



### 表示层

**表示层提供各种用于应用层数据的编码和转换功能**,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。**数据压缩和加密**也是表示层可提供的转换功能之一。

作用：这一层的主要作用是定义数据格式和加密。



### 会话层

会话层就是**负责建立、管理和终止表示层实体之间的通信会话**。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

作用：控制应用程序的会话能力，它定义了一段会话的开始、控制和结束，包括对多个双向消息的控制和管理，以便在只完成一部分消息时可以通知应用。



### 传输层

传输层建立了主机端到端的链接，传输层的作用是**为上层协议提供端到端的可靠和透明的数据传输服务**，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，**TCP UDP就是在这一层。端口号既是这里的“端”。**

作用：对差错恢复协议和无差错恢复协议的选择，对同一主机上不同数据流的输入进行复用，对数据包进行重新排序。是最关键的一层，是唯一负责整体的数据传输和数据控制的。对上三层提供可靠的传输服务，对网络层提供可靠的目的地信息。在这一层数据的单位被称为数据段。

协议：TCP、UDP等



### 网络层

本层**通过IP寻址来建立两个节点之间的连接**，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的**IP层**。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

作用：主要负责寻找地址和路由选择，网络层还可以实现阻塞控制、网际互联等。

协议：IP、IPX、RIP、OSPF等



### 数据链路层 

将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

数据链路层又分为2个子层：**逻辑链路控制**子层（LLC）和**媒体访问控制**子层（MAC）。

 MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。

作用：负责物理层面上的互联的、节点间的通信传输；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）

协议：ARP、RARP、SDLC、HDLC、PPP、STP、帧中继等



### 物理层   

**实际最终信号的传输是通过物理层实现的**。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

作用：负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换 规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；该层为上层协议提供了一个传输数据的物理媒体。在这一层，数据的单位称为比特（bit）。

典型规范：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网等



---

## 2. 请问你了解TCP/IP五层协议吗？它与OSI七层模型有什么关系吗？

**TCP/IP协议**包含四个概念层，其中有三层对应于OSI模型中的相应层，TCP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。

- **网络接口层**

用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准**并不**定义与ISO数据链路层和物理层相对应的功能。相反，它定义像**地址解析协议**(Address Resolution Protocol,ARP)这样的协议，**提供TCP/IP协议的数据结构和实际物理硬件之间的接口。**

- **网络层**

对应于OSI七层模型的**网络层**。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。

- **传输层**

对应于OSI七层模型的**传输层**，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。

- **应用层**

对应于OSI七层模型的**应用层、表达层与会话层**。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。

TCP/IP五层协议与OSI的七层模型对应关系如下：

![img](E:\pogject\学习笔记\image\http\E3C7704B2554F5FA5553E2FF7A4E7F55)





----

## 3 请问你能阐述下TCP与UDP的区别吗？

TCP和UDP是OSI模型中的传输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。

- TCP是一种面向连接的、可靠的、基于**字节流**的传输层通信协议，是专门为了**在不可靠的网络中提供一个可靠的端对端字节流**而设计的，面向**字节流**。
- UDP（用户数据报协议）是iso参考模型中一种**无连接**的传输层协议，提供**简单不可靠的非连接传输层服务**，面向**报文**

**TCP(传输控制协议)**：充分实现了数据传输时各种控制功能，**可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制**。而这些在UDP都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过**检验和**、**序列号**、**确认应答**、**重发控制**、**连接管理**以及**窗口控制**等机制实现可靠性传输。

**UDP（用户数据报协议）**：不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDP也不负责重发。

TCP与UDP区别：

- (1) **是否连接**：TCP面向连接（如打电话要先拨号建立连接），UDP是**无连接**的，即发送数据之前不需要建立连接
- (2) **可靠性**：TCP提供可靠的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达，**UDP尽最大努力交付**，即不保证可靠交付
- (3) **数据流**： TCP面向**字节流**，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向**报文**的，UDP没有拥塞控制，**因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）**

- (4) **是否多端**： 每一条TCP连接只能是**点到点的**；UDP支持一对一，一对多，多对一和多对多的交互通信

- (5) **首部开销**： TCP首部开销**20字节**；UDP的首部开销小，只有**8个字节**。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，**而UDP有丢包**，**故TCP开销大**，UDP开销较小

- (6) **信道**： TCP的逻辑通信信道是**全双工的可靠信道**，UDP则是不可靠信道
- (7) **安全性**：由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，**也使其易于攻击**；UDP没有建立连接的过程，因而实时性较强，**也稍安全**

**应用场景选择**

- 对**实时性要求高和高速传输**的场合下使用UDP; 在可靠性要求低，**追求效率**的情况下使用UDP;
- 需要**传输大量数据且对可靠性要求高**的情况下使用TCP



---

## 4 请问你能阐述下TCP三次握手与四次挥手的过程吗？

### TCP三次握手

### ① 三次握手过程详解

三次握手的原文是 `three-way handshake`，整个名词的可以翻译为：**需要三个步骤才能建立握手/连接的机制**。当然，三次握手也可以叫 `three-message handshake`，**通过三条消息来建立的握手/连接**。

进行三次握手的**主要作用**就是为了确认双方的**接收能力和发送能力**是否正常、指定自己的 **初始化序列号(Init Sequense Number, `ISN`)** 为后面的可靠性传输做准备。

三次握手过程如下图：

![img](E:\pogject\学习笔记\image\http\TCP三次握手)

回顾一下图中字符的含义：

- `SYN`：连接请求/接收 报文段
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。**希望收到的下一个数据的第一个字节的序号**

**刚开始客户端处于 `Closed` 的状态，而服务端处于 `Listen` 状态**：

> CLOSED ：没有任何连接状态
>
> `LISTEN `：侦听来自远方 TCP 端口的连接请求

**1）第一次握手**：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 `SYN_Send` 状态。

> `SYN-SENT` ：在发送连接请求后等待匹配的连接请求

**2）第二次握手**：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 `SYN_REVD` 的状态。

> `SYN-RECEIVED`：在收到和发送一个连接请求后等待对连接请求的确认

**3）第三次握手**：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 `Establised` 状态。

服务器收到 ACK 报文之后，也处于 `Establised 状态`，至此，双方建立起了 TCP 连接。

> `ESTABLISHED`：代表一个打开的连接，数据可以传送给用户

### ② 为什么要三次握手

三次握手的目的是**建立可靠的通信信道**，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是**双方确认自己与对方的发送与接收是正常的**。

只有经过三次握手才能确认双发的收发功能都正常，缺一不可：

- 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：

  客户端什么都不能确认；

  **服务器确认了对方发送正常，自己接收正常**

  

- 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：

  客户端确认了：**自己发送、接收正常，对方发送、接收正常；**

  服务器确认了：对方发送正常，自己接收正常

  

- 第三次握手（客户端发送 ACK 报文给服务器）：

  客户端确认了：自己发送、接收正常，对方发送、接收正常；

  服务器确认了：**自己发送**、接收正常，对方发送、**接收正常**



### ③ ISN (Initial Sequence Number) 是固定的吗

三次握手的其中一个**重要功能**是客户端和服务端**交换 ISN**(Initial Sequence Number)，**以便让对方知道接下来接收数据的时候如何按序列号组装数据。**

当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，**因此每个连接都将具有不同的 ISN**。如果 ISN **是固定的，攻击者很容易猜出后续的确认号**，因此 ISN 是动态生成的。

### ④ 三次握手过程中可以携带数据吗

第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手绝对不可以携带数据**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。

**简单的记忆就是，请求连接/接收 即 `SYN = 1` 的时候不能携带数据**

而对于第三次的话，此时客户端已经处于 `ESTABLISHED` 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。

### ⑤ 半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### ⑥ SYN 洪泛攻击

SYN 攻击就是 **Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包**，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，**这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。**

### ⑦ 如果第三次握手丢失了，客户端服务端会如何处理

服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。**那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传**。如果**重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除**。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…



---

### TCP 四次挥手释放连接

### ① 四次挥手过程详解

建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的**半关闭**（half-close）特性造成的，TCP 提供了**连接的一端在结束它的发送后还能接收来自另一端数据的能力。**

TCP 连接的释放**需要发送四个包**（执行四个步骤），因此称为四次挥手(`Four-way handshake`)，**客户端或服务端均可主动发起挥手动作**。

![img](E:\pogject\学习笔记\image\js\TCP四次挥手)

回顾一下上图中符号的意思：

- `FIN` ：连接终止位
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。希望收到的下一个数据的第一个字节的序号

刚开始双方都处于`ESTABLISHED` 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：

**1）第一次挥手**：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并**停止再发送数据，主动关闭 TCP 连接**。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。

> `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

**2）第二次挥手**：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。

> `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；

**此时的 TCP 处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。

> `FIN-WAIT-2` - 从远程TCP等待连接中断请求；

**3）第三次挥手**：如果**服务端**也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。

> `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；

**4）第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 **`TIME_WAIT` （时间等待）状态**。

> `TIME-WAIT` - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；

> 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，**需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 `CLOSED` 状态**（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 `CLOSED` 状态。

### ② 为什么要四次挥手

由于 TCP 的**半关闭**（half-close）特性，**TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。

**通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手**。

举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

---

### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，**收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端**。

而关闭连接时，当收到对方的FIN报文时，**仅仅表示对方不再发送数据了但是还能接收数据**，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

---

## 5. tcp三次握手，为什么需要三次

两个目的：

1. 确保建立可靠连接
2. 避免资源浪费

**三次握手的目的是 "为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错"**，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。

如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，**B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认**，这个时候B端也能够知道连接没有建立



---

## 6 请问TCP如何保证数据的可靠传输的呢？

TCP提供一种面向连接的、可靠的字节流服务。其中，**面向连接**意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而**字节流服务**意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，**TCP不在字节流中插入记录标识符。**

TCP通过以下方式保证数据传输的可靠性：

**数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据

**对失序数据包重排序**：既然TCP报文段作为IP数据包来传输，而IP数据包的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层

**丢弃重复数据**：对于重复数据，能够丢弃重复数据

**应答机制**：当TCP收到发自TCP连接另一端的数据，**它将发送一个确认**。这个确认不是立即发送，通常将推迟几分之一秒

**超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。**如果不能及时收到一个确认，将重发这个报文段**

**流量控制**：TCP连接的每一方都有固定大小的缓冲空间。**TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据**，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的**流量控制协议**是**可变大小的滑动窗口协议**



----

## 7. 请问TCP如何拥塞控制呢？

**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个**前提**：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

拥塞控制代价：**需要获得网络内部流量分布的信息**。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。**这样就产生了额外的开销**。拥塞控制还需要将一些资源分配给各个用户单独使用，**使得网络资源不能更好地实现共享**。

几种常见**拥塞控制方法**：

慢开始(slow-start )、拥塞避免(congestion avoidance )、快重传( fastretransmit )和快恢复( fastrecovery )。



---

## 8. 请问你了解超文本传送协议HTTP吗？

HTTP是一个属于**应用层**的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议的主要特点可概括如下：

- **支持客户/服务器模式**。
- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- **灵活**：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- **无连接**：无连接的**含义是限制每次连接只处理一个请求**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- **无状态**：HTTP协议是无状态协议。无状态是**指协议对于事务处理没有记忆能力**。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。**另一方面，在服务器不需要先前信息时它的应答就较快。**



---

## 9. 请问HTTP和HTTPS两者有哪些区别？

**HTTP和HTTPS的基本概念**

HTTP：HTTP协议是超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：HTTPS是安全的超文本传输协议，是安全版的HTTP协议，使用**安全套接字层(SSL)**进行信息交换，是以安全为目标的HTTP通道，**即HTTP下加入SSL层**，HTTPS的安全基础是SSL（Secure Sockets Layer），因此加密的详细内容就需要SSL。

HTTPS协议的主要作用可以分为两种：一种是**建立一个信息安全通道，来保证数据传输的安全**；另一种就是**确认网站的真实性**。

HTTPS协议主要针对解决**HTTP协议以下不足**：

- 1、通信使用明文（不加密），内容可能会被窃听
- 2、不验证通信方身份，应此可能遭遇伪装
- 3、无法证明报文的完整性（即准确性），所以可能已遭篡改

  HTTP+加密+认证+完整性保护 = HTTPS，HTTP端口 **80**， HTTPS端口**443**

  HTTPS采用**对称加密**、SSL位于应用层与传输层TCP之间，原本数据由应用层直接交由传输层处理，**现在会经过SSL加密再进行传输**。

**2.HTTP与HTTPS有什么区别？**

HTTPS和HTTP的区别主要如下：

- 1、https协议**需要到ca申请证书**，一般免费证书较少，因而需要一定费用。
- 2、http是超文本传输协议，信息是**明文传输**，https则是具有安全性的ssl加密传输协议。
- 3、http和https使用的是**完全不同的连接方式**，**用的端口也不一样**，前者是**80**，后者是**443**。
- 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

注意：HTTPS也不是绝对安全的，**针对SSL的中间人攻击**方式主要有两类，分别是**SSL劫持攻击**和**SSL剥离攻击**。

SSL劫持攻击就是 SSL证书欺骗攻击，将自己接入到客户端和目标网站之间； 在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥。



---

## 10. http1.x 和http2.x区别

http1.x 和http2.x主要有以下4个区别：

1. HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。

   二进制传送的单位是帧和流。**帧组成了流，同时流还有流ID标示**

2. HTTP2支持多路复用

   **因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能**，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

3. HTTP2头部压缩

   HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张**头信息表**，所有字段都记录在这张表中，这样后面**每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值**

4. HTTP2支持服务器推送

   HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容



---

## 11. 说说对 HTTP3 的了解

由于TCP和UDP两者在运输层存在一定差异，TCP的传递效率与UDP相比有天然劣势，于是Google基于UDP开发出了新的协议**QUIC(Quick UDP Internet Connections)**，希望取代TCP提高传输效率，后经过协商将QUIC协议更名为HTTP/3。

TCP、UDP是我们所熟悉的传输层协议，UDP比TCP相比效率更高但并不具备传输可靠性。而QUIC便是看中UDP传输效率这一特性，并结合了TCP、TLS、HTTP/2的优势，加以优化。

于是在QUIC上层的应用层所运行的HTTP协议也就被称为HTTP/3。

![img](E:\pogject\学习笔记\image\http\http3)

HTTP/3新特性

(1) **零RTT建立连接**，

传统HTTP/2(所有HTTP/2的浏览器均基于HTTPS)传输数据前需要三次RTT，即使将第一次TLS握手的对称秘钥缓存也需要两次RTT才能传递数据。

对于HTTP/3而言，仅仅需要一次RTT即可传递数据，如果将其缓存，就可将RTT减少至零。

其核心就是DH秘钥交换算法。

- 客户端向服务端请求数据。
- 服务端生成g、p、a三个随机数，用三个随机数生成A。将a保留后，将g、p、A(Server Config)传递到客户端。
- 客户端生成随机数b，将b保留后，用g、p、b三个随机数生成B。
- 客户端再使用A、b、p生成秘钥K，用K**加密HTTP数据**并与B一同发送到服务端。
- 服务端再使用B、a、p得到相同秘钥K，并解密HTTP数据。

(2) **连接迁移**

传统连接通过源IP、源端口、目的IP、目的端口进行连接，当网络发生更换后连接再次建立时延较长。

HTTP/3使用Connection ID对连接保持，只要Connection ID不改变，连接仍可维持。

(3) **队头阻塞/多路复用**

- TCP作为面向连接的协议，对每次请求序等到ACK才可继续连接，一旦中间连接丢失将会产生队头阻塞。
- HTTP/1.1中提出Pipelining的方式，单个TCP连接可多次发送请求，但依旧会有中间请求丢失产生阻塞的问题。
- HTTP/2中将请求粒度减小，通过Frame的方式进行请求的发送。但在TCP层Frame组合得到Stream进行传输，一旦出现Stream中的Frame丢失，其后方的Stream都将会被阻塞。
- 对于HTTP/2而言，浏览器会默认采取TLS方式传输，TLS基于Record组织数据，每个Record包含16K，其中有12个TCP的包，一旦其中一个TCP包出现问题将会导致整个Record无法解密。这也是网络环境较差时HTTP/2的传输速度比HTTP/1.1更慢的原因。
- HTTP/3基于UDP的传输，不保证连接可靠性，也就没有对头阻塞的后果。同样传输单元与加密单元为Packet，在TLS下也可避免对头阻塞的问题。

(4) **拥塞控制**

- 热拔插：TCP对于拥塞控制在于传输层，QUIC可在应用层操作改变拥塞控制方法。
- 前向纠错(FEC)：将数据切割成包后可对每个包进行异或运算，将运算结果随数据发送。一旦丢失数据可据此推算。(带宽换时间)
- 单调递增的Packet Number：TCP在超时重传后的两次ACK接受情况并不支持的很好。导致RTT和RTO的计算有所偏差。HTTP/3对此进行改进，一旦重传后的Packet N会递增。
- ACK Delay: HTTP/3在计算RTT时健壮的考虑了服务端的ACK处理时延。
- 更多地ACK块: 一般每次请求都会对应一个ACK，但这样也会浪费(下载场景只需返回数据即可)。于是可设计成每次返回3个ACK block。在HTTP/3将其扩充成最多可携带256 个ACK block。

(5) **流量控制**

TCP使用滑动窗口的方式对发送方的流量进行控制。而对接收方并无限制。在QUIC中便补齐了这一短板。

QUIC中接收方从单挑Stream和整条连接两个角度动态调整接受的窗口大小。



---

## 12. http请求方法

http请求方式有以下8种，其中get和post是最常用的：

1、OPTIONS

向服务器查询支持的请求方法。返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性

2、HEAD

向服务器索与GET请求相一致的响应，只不过响应体将不会被返回，只返回报文首部。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

3、GET  

用于获取资源。向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url

4、POST  

用于发送实体主体。向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form

5、PUT  

用于上传文件。向指定资源位置上传其最新内容

6、DELETE  

用于删除文件。请求服务器删除Request-URL所标识的资源

7、TRACE

回显服务器收到的请求，主要用于测试或诊断。服务器会将通信路径返回给客户端，方便查询某个中间服务器的状态，设计 Max-Forwards 头部字段，每次经过一个服务器，数值减一

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。要求使用隧道协议连接代理服务器，主要是用 SSL、TLS 协议将通信内容加密后经过网络隧道传输。

9、PATCH

在 HTTP 协议中，请求方法 **PATCH** 用于**对资源进行部分修改**。



---

## 13. HTTPS如何保证安全

**HTTPS**（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。

HTTPS = HTTP + SSL/TLS，如今 SSL 已废弃，**所以现在只关注 HTTP + TLS**。为了解决 HTTP 协议的问题，HTTPS 引入了**数据加密**和**身份验证机制**。在开始传输数据之前，通过安全可靠的 TLS 协议进行加密，从而保证后续加密传输数据的安全性。

**TLS 协议**：**传输层安全性协议**（Transport Layer Security，**TLS**）及其前身**安全套接层**（Secure Sockets Layer，**SSL**）是一种安全协议，目的是为了保证**网络通信安全**和**数据完整性**。

**受 TLS 协议保护的通信过程**：先对传输的数据进行了加密（使用**对称加密算法**）。并且对称加密的密钥是为每一个连接唯一生成的（基于 TLS 握手阶段协商的加密算法和共享密钥），然后发送的每条消息都会通过消息验证码（Message authentication code, MAC），来进行消息完整性检查，最后还可以使用公钥对通信双方进行身份验证

**Https的作用**

- **内容加密** 建立一个信息安全通道，来保证数据传输的安全；
- **身份认证** 确认网站的真实性
- **数据完整性** 防止内容被第三方冒充或者篡改



---

## 14. 请问对称加密与非对称加密有什么区别？

**对称密钥加密**是指加密和解密使用同一个密钥的方式，这种方式存在的**最大问题就是密钥发送问题**，即如何安全地将密钥发给对方；

而**非对称加密**是指使用一对非对称密钥，即公钥和私钥，**公钥**可以随意发布，但**私钥**只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，**它非常的慢**，所以我们还是要用对称加密来传送消息，但**对称加密所使用的密钥**我们**可以通过非对称加密的方式发送出去**。



---

## 15. 非对称加密和对称加密，具体怎么实现的

**对称加密：**在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，**加密和解密都是使用的同一个密钥**。

**非对称加密：**指加密和解密使用不同密钥的加密算法。非对称加密算法需要两个密钥：**公钥**（publickey）**私钥**（privatekey）。

公钥与私钥是一对存在，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作**非对称加密算法**。

**解析：**

**1、对称加密算法的缺点**

- **要求提供一条安全的渠道使通讯双方在首次通讯时协商一个共同的密钥**。直接的面对面协商可能是不现实而且难于实施的，所以双方可能需要借助于邮件和电话等其它相对不够安全的手段来进行协商；
- **密钥的数目难于管理**。因为对于每一个合作者都需要使用不同的密钥，很难适应开放社会中大量的信息交流；
- 对称加密算法**一般不能提供信息完整性的鉴别**。它无法验证发送者和接受者的身份；
- **对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程**。对称加密是基于共同保守秘密来实现的，采用对称加密技术的贸易双方必须保证采用的是相同的密钥，保证彼此密钥的交换是安全可靠的，同时还要设定防止密钥泄密和更改密钥的程序。

**2、两种加密体制的特点**

非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。

对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥，所以保证其安全性就是保证密钥的安全。而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。

假设两个用户要加密交换数据，**双方交换公钥，使用时一方用对方的公钥加密**，另一方即**可用自己的私钥解密。**

如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得 十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以通过"信息发送者的公钥"来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的**缺点**是**加解密速度要远远慢于对称加密**，在某些极端情况下，甚至能比对称加密慢上1000倍。

> 非对称的好处显而易见，非对称加密体系不要求通信双方事先传递密钥或有任何约定就能完成保密通信，并且密钥管理方便，可实现防止假冒和抵赖，因此，更适合网络通信中的保密通信要求。

**3、什么是数字证书**

- **数字证书**就是**互联网通讯中标志通讯各方身份信息的一串数字**，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是**身份认证机构盖在数字身份证上的一个章或印**（或者说加在数字身份证上的一个签名）。
- 它是由权威机构——CA机构，又称为**证书授权**（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。
- **数字证书绑定了公钥及其持有者的真实身份**，它类似于现实生活中的居民身份证，所不同的是数字证书不再是纸质的证照，而是一段含有证书持有者身份信息并经过认证中心审核签发的电子数据，广泛用在电子商务和移动互联网中。

**4、什么是数字签名**

4.1 数字签名是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。

> 如果相同，则说明收到的信息是完整的，在传输过程中没有被修改；
> 否则说明信息被修改过，因此**数字签名能够验证信息的完整性。**
> 如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。

4.2 数字签名是个**加密**的过程，数字签名验证是个**解密**的过程。

4.3 数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。

非对称加密算法实现机密信息交换的**基本过程**是：

1. 甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；
2. 得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；
3. 甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。

**5、非对称加密和对称加密在HTTPS协议中的应用**

- 5.1 浏览器向服务器发出请求，询问对方支持的对称加密算法和非对称加密算法；服务器回应自己支持的算法。

- 5.2 浏览器选择双方都支持的加密算法，并请求服务器出示自己的证书；服务器回应自己的证书。

- 5.3 浏览器随机产生一个用于本次会话的对称加密的钥匙，并使用服务器证书中附带的公钥对该钥匙进行加密后传递给服务器；服务器为本次会话保持该对称加密的钥匙。第三方不知道服务器的私钥，即使截获了数据也无法解密。非对称加密让任何浏览器都可以与服务器进行加密会话。
- 5.4 浏览器使用对称加密的钥匙对请求消息加密后传送给服务器，服务器使用该对称加密的钥匙进行解密；服务器使用对称加密的钥匙对响应消息加密后传送给浏览器，浏览器使用该对称加密的钥匙进行解密。第三方不知道对称加密的钥匙，即使截获了数据也无法解密。对称加密提高了加密速度 。

**6、完整的非对称加密过程**

假如现在 你向支付宝 转账（术语数据信息），为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为：

1. 首先你要确认是否是支付宝的数字证书，如果确认为支付宝身份后，则对方真实可信。可以向对方传送信息
2. 你准备好要传送的数字信息（明文）计算要转的多少钱，对方支付宝账号等；
3. 你对数字信息进行哈希运算，得到一个信息摘要（客户端主要职责）；
4. 你用自己的私钥对信息摘要进行加密得到 你 的数字签名，并将其附在数字信息上；
5. 你随机产生一个加密密钥，并用此密码对要发送的信息进行加密（密文）；
6. 你用支付宝的公钥对刚才随机产生的加密密钥进行加密，将加密后的 DES 密钥连同密文一起传送给支付宝
7. 支付宝收到 你 传送来的密文和加密过的 DES 密钥，先用自己的私钥对加密的 DES 密钥进行解密，得到 你随机产生的加密密钥；
8. 支付宝 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；
9. 支付宝 用你 的公钥对 你的的数字签名进行解密，得到信息摘要；
10. 支付宝用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；
11. 支付宝将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过；
12. 确定收到信息，然后进行向对方进行付款交易，一次非对称密过程结束。



---

## 16. https加密解密流程

https加密解密流程分成以下8个步骤：

1. **客户端发起HTTPS请求** 这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址，然后连接到服务端的**443端口**。
2. **服务端的配置** 采用HTTPS协议的服务器必须要有一套**数字证书**，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。**这套证书其实就是一对公钥和私钥**。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
3. **传送证书** 这个证书其实就是**公钥**，只是包含了很多信息，如证书的颁发机构，过期时间等等。
4. **客户端解析证书** 这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个**随机值**。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5. **传送加密信息** 这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6. **服务端解密信息** 服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7. **传输加密后的信息** 这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。
8. **客户端解密信息** 客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。



---

## 17. 请问HTTP的请求和响应由哪几个部分组成？

HTTP**请求信息**由3部分组成：

- 请求方法（GET/POST）、URI、协议/版本

- 请求头(Request Header)：Content-Type、端口号Host、Cookie
- 请求正文：包含客户提交的查询字符串信息，请求头和请求正文之间是一个空行

**HTTP响应**也由3个部分构成：

- 状态行：状态代码及描述 如404、500等
- 响应头(Response Header)：Content-Type 、Server、Date
- 响应正文：html代码





----

## 18. 请问IP地址分为哪几类？

IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中**A、B、C是基本类**，D、E类作为多播和保留使用，为特殊地址。

每个IP地址包括两个标识码（ID），即**网络ID和主机ID**。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：

**A类地址：**以0开头，第一个字节范围：0~127；

**B类地址：**以10开头，第一个字节范围：128~191；

**C类地址：**以110开头，第一个字节范围：192~223；

**D类地址：**以1110开头，第一个字节范围为224~239；

**E类地址：**以1111开头，保留地址

**（1）、A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”**

一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。

A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。

**（2）、B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”**

一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。

B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。

**（3）、C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”**

一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。

C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。

**（4）、D类地址:多播地址，用于1对多通信，最高位必须是“1110”**

D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。

**（5）、E类地址:为保留地址，最高位必须是“1111”**



----

## 19. 请简介地址解析协议ARP的工作原理。

ARP是**地址解析协议**，其工作原理为：

（1）首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系；

（2）当源主机要发送数据时，**首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址**，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址；

（3）**当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址**，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址；

（4）源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。



---

## 20.有什么方法可以保持前后端实时通信

实现保持前后端实时通信的方式有以下几种

- WebSocket： IE10以上才支持，Chrome16, FireFox11,Safari7以及Opera12以上完全支持，移动端形势大
- event-source: IE完全不支持（注意是任何版本都不支持），Edge76，Chrome6,Firefox6,Safari5和Opera以上支持， 移动端形势大好
- AJAX轮询： 用于兼容低版本的浏览器
- 永久帧（ forever iframe）可用于兼容低版本的浏览器
- flash socket 可用于兼容低版本的浏览器

**这几种方式的优缺点**

**1.WebSocket**

- 优点：WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，可从HTTP升级而来，浏览器和服务器只需要一次握手，就可以进行持续的，双向的数据传输，因此能显著节约资源和带宽
- 缺点：1. 兼容性问题:不支持较低版本的IE浏览器（IE9及以下）2.不支持断线重连，需要手写心跳连接的逻辑 3.通信机制相对复杂

**2. server-sent-event（event-source）**

- 优点：（1）只需一次请求，便可以stream的方式多次传送数据，节约资源和带宽 （2）相对WebSocket来说简单易用 （3）内置断线重连功能(retry)
- 缺点： （1）是单向的，只支持服务端->客户端的数据传送，客户端到服务端的通信仍然依靠AJAX，没有”一家人整整齐齐“的感觉（2）兼容性令人担忧，IE浏览器完全不支持

**3. AJAX轮询**

- 优点：兼容性良好，对标低版本IE
- 缺点：请求中有大半是无用的请求，浪费资源

**4.Flash Socket**

- 缺点：（1）浏览器开启时flash需要用户确认，（2）加载时间长，用户体验较差 （3）大多数移动端浏览器不支持flash，为重灾区
- 优点： 兼容低版本浏览器

**5. 永久帧（ forever iframe）**

- 缺点： iframe会产生进度条一直存在的问题，用户体验差
- 优点：兼容低版本IE浏览器

**综上，综合兼容性和用户体验的问题，我在项目中选用了WebSocket ->server-sent-event -> AJAX轮询这三种方式做从上到下的兼容**



---

## 21. 常见http status

**1XX系列**：指定客户端应相应的某些动作，**代表请求已被接受，需要继续处理**。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。

**2XX系列**：代表**请求已成功被服务器接收、理解、并接受**。这系列中最常见的有200、201状态码。

**3XX系列**：代表**需要客户端采取进一步的操作才能完成请求**，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302、304状态码。

**4XX系列**：表示**请求错误**。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。

**5xx系列**：代表了**服务器在处理请求的过程中有错误或者异常状态发生**，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。

**2开头 （请求成功）表示成功处理了请求的状态代码。**

- **200** （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- **201** （已创建） 请求成功并且服务器创建了新的资源。
- 202 （已接受） 服务器已接受请求，但尚未处理。
- 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
- 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
- 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
- 206 （部分内容） 服务器成功处理了部分 GET 请求。

**3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。**

- **300** （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
- **301** （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
- **302** （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
- **304** （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
- 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
- **307** （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

- **400** （错误请求） 服务器不理解请求的语法。
- **401** （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- **403** （禁止） 服务器拒绝请求。
- **404** （未找到） 服务器找不到请求的网页。
- 405 （方法禁用） 禁用请求中指定的方法。
- 406 （不接受） 无法使用请求的内容特性响应请求的网页。
- 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
- **408** （请求超时） 服务器等候请求时发生超时。
- 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
- 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
- 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
- 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
- 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
- 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
- 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
- 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
- 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

**5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**

- **500** （服务器内部错误） 服务器遇到错误，无法完成请求。
- 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
- **502** （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
- **503** （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
- 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

---

## 22. 具体讲解一下http 的option  请求方式

除了post和get还有6种请求方式分别是：OPTIONS、HEAD、PUT、DELETE、TRACE、CONNECT、patch

**HTTP 的OPTIONS 方法** 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法

**作用**：

1. 检测服务器所支持的请求方法

   可以使用 OPTIONS 方法对服务器发起请求，以检测服务器支持哪些 HTTP 方法：

   ```bash
   curl -X OPTIONS http://example.org -i
   ```

2. CORS 中的预检请求

   在 **CORS** 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 [Access-Control-Request-Method](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method) 首部字段告知服务器实际请求所使用的 HTTP 方法；[Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers) 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。



---

## 23. FTP DNS 基于什么协议

DNS (Domain Name Service 域名服务) 协议基于 UDP协议

FTP (File Transfer Protocol 文件传输协议) 基于 TCP协议

DNS和FTP都是应用层协议



---

## 24. URL 路径包含什么, URI 是什么

**URL 路径包含什么**

一个完整的url分为4部分：

1. 协议 例 Http（超文本传输协议） 、Https
2. 域名 例`www.baidu.com`为网站名字。 `baidu.com`为一级域名，`www`是服务
3. 端口 不填写的话默认走的是80端口号
4. 路径 `http://www.baidu.com/路径1/路径2`。/表示根目录
5. 查询参数 `http://www.baidu.com/路径1/路径1.2?name="man"`(可有可无)

**URI 是什么**

**URI**是**一个用于标识互联网资源名称的字符串**。 该种标识允许用户对网络中（一般指[万维网](https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/万维网)）的资源通过特定的协议进行交互操作。URI的最常见的形式是**统一资源定位符**（URL），经常指定为非正式的网址。更罕见的用法是**统一资源名称**（URN），其目的是通过提供一种途径。用于在特定的命名空间资源的标识，以补充网址。

**URI**（**统一资源标识符**）是一个指向资源的字符串。最通常用在 [URL](https://developer.mozilla.org/zh-CN/docs/Glossary/URL) 上来指定Web上资源文件的具体位置。相比之下，[URN](https://developer.mozilla.org/zh-CN/docs/Glossary/URN) 是在给定的命名空间用名字指向具体的资源，如：书本的ISBN。

**扩展**：

URL和URN是URI的子集，URI属于URL更高层次的抽象，一种字符串文本标准。



---

## 25. 301和302的含义

301和302都是重定向的状态码，重定向（Redirect）是指通过各种方法将客户端的网络请求重新定义或指定一个新方向转到其他位置（重定向包括**网页重定向**、**域名重定向**）。

301 redirect: 301 代表**永久性转移**(Permanently Moved)

302 redirect: 302 代表**暂时性转移**(Temporarily Moved )

**相同点：**都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）

**不同点：**

1. 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；

   302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

2. 302会出现“网址劫持”现象，从A网址302重定向到B网址，由于部分搜索引擎无法总是抓取到目标网址，或者B网址对用户展示不够友好，因此浏览器会仍旧显示A网址，但是所用的网页内容却是B网址上的内容。

**应用场景**

301：域名需要切换、协议从http变成https；

302：未登录时访问已登录页时跳转到登录页面、404后跳转首页



---

## 26. DNS是什么

DNS（Domain Name Server，域名服务器）是**进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。**

### DNS

DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。

DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。

域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。

DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器

简单来讲，**`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址**

- IP 地址：**一长串能够唯一地标记网络上的计算机的数字**
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

![img](E:\pogject\学习笔记\image\http\DNS1)

### 域名

域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...

![img](E:\pogject\学习笔记\image\http\DNS2)

例如`www.xxx.com`，`www`为三级域名、`xxx`为二级域名、`com`为顶级域名，系统为用户做了兼容，域名末尾的根域名`.`一般不需要输入

在域名的每一层都会有一个域名服务器，如下图：

![img](E:\pogject\学习笔记\image\http\DNS3)

除此之外，还有电脑默认的本地域名服务器

### 查询方式

DNS 查询的方式有两种：

#### 递归查询

- 递归查询：如果 A 请求 B，**那么 B 作为请求的接收者一定要给 A 想要的答案**

![img](E:\pogject\学习笔记\image\http\DNS4)

#### 迭代查询

- 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容**，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求**

![img](E:\pogject\学习笔记\image\js\DNS5)

### 域名缓存

在域名服务器解析的时候，使用缓存保存域名和`IP`地址的映射

计算机中`DNS`的记录也分成了两种缓存方式：

- **浏览器缓存**：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- **操作系统缓存**：操作系统的缓存其实是用户自己配置的 `hosts` 文件

### 查询过程

解析域名的过程如下：

- 首先搜索**浏览器的 DNS 缓存**，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索**操作系统的 DNS 缓存**
- 若仍然没有命中，则**操作系统**将域名发送至**本地域名服务器**，本地域名服务器采用**递归查询**自己的 DNS 缓存，查找成功则返回结果
- 若**本地域名服务器**的 DNS 缓存没有命中，则**本地域名服务器**向**上级域名服务器**进行迭代查询
  - 首先**本地域名服务器**向**根域名服务器**发起请求，**根域名服务器**返回**顶级域名服务器的地址**给**本地服务器**
  - **本地域名服务器**拿到这个**顶级域名服务器的地址**后，就向**其**发起请求，获取**权限域名服务器的地址**
  - **本地域名服务器**根据权限域名服务器的地址向其发起请求，**最终得到该域名对应的 IP 地址**
- **本地域名服务器**将得到的 IP 地址返回给**操作系统**，同时自己将 IP 地址缓存起来
- **操作系统**将 IP 地址返回给**浏览器**，同时自己也将 IP 地址缓存起
- 至此，**浏览器**就得到了域名对应的 IP 地址，并将 IP 地址缓存起

流程如下图所示：

![img](https://static.vue-js.com/bec3c740-b78f-11eb-ab90-d9ae814b240d.png)





---

## 27.http缓存有几种？

### 缓存策略

在阐述HTTP不同缓存策略之前，我们需要知道用户刷新/访问行为 的手段分成三类：

- 在URI输入栏中输入然后回车/通过书签访问
- F5/点击工具栏中的刷新按钮/右键菜单重新加载
- Ctl+F5 （**完全不使用HTTP缓存**）

不同的刷新手段，会导致浏览器使用不同的缓存策略，我们下面会分析到

HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。
响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。

浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：
强制缓存和协商缓存，强缓优先于协商缓存。

- 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
- 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified
  通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

HTTP缓存都是从第二次请求开始的：

- 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；

- 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：

  ![img](E:\pogject\学习笔记\image\http\HTTP缓存2)

### http缓存的分类

根据**是否需要重新向服务器发起请求来分类**，可分为(强制缓存，协商缓存) 

根据**是否可以被单个或者多个用户使用来分类**，可分为(私有缓存，共享缓存) 

强制缓存如果生效，不需要再和服务器发生交互，**而协商缓存不管是否生效，都需要与服务端发生交互**。下面是强制缓存和协商缓存的一些对比：

![img](E:\pogject\学习笔记\image\js\http缓存)



### 强制缓存

强制缓存**在缓存数据未失效的情况下**（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），**那么就会直接使用浏览器的缓存数据**，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。**这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了**。

这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，**所以Ctrl + F5一顿操作之后就好了**。 跟强制缓存相关的header头属性有（Pragma/Cache-Control/Expires）， Pragma和Cache-control共存时，**Pragma的优先级是比Cache-Control高的。**

先看看浏览器请求资源的情况：

![浏览器第一次请求资源](E:\pogject\学习笔记\image\http\1073178728-5bed42a8401b1_articlex)

强制缓存：
在浏览器已经缓存数据的情况下，使用强制缓存去请求数据的流程是这样的：

![强制缓存](E:\pogject\学习笔记\image\http\1447835885-5adfe19706507_articlex)
从流程图可以看到，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，不需要再请求服务器，那么浏览器是如何判断缓存数据是否失效呢？

- 强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk
- 控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）
- **Cache-control是一个相对时间**，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。
- **Expires是一个绝对时间**。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求
- **Cache-Control的优先级比Expires的优先级高**。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。
  如果同时存在则使用Cache-control。

对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control)：

**强缓存-expires**

- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。
- Expires 是 HTTP 1.0 的字段，表示缓存到期时间，**是一个绝对的时间 (当前时间+缓存时间)**。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。它的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。
- 优势特点
  - HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。
  - 以时刻标识失效时间。
- 劣势问题
  - 时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。
  - 存在版本问题，到期之前的修改客户端是不可知的。



**强缓存-cache-control**

- 已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。
- 这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些Cache-control字段常用的值：(完整的列表可以查看MDN)
  - max-age：即最大有效时间。
  - must-revalidate：如果超过了max-age的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
  - no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜。
  - no-store: **真正意义上的“不要缓存”**。所有内容都不走缓存，包括强制和对比。
  - public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
  - private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。
- **Cache-control 的优先级高于 Expires**，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。
- 该字段可以在请求头或者响应头设置，可组合使用多种指令：
  - 可缓存性
    - public：浏览器和缓存服务器都可以缓存页面信息
    - private：default，代理服务器不可缓存，只能被单个用户缓存
    - no-cache：浏览器器和服务器都不应该缓存页面信息，**但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。**可配合private，过期时间设置为过去时间。
    - only-if-cache：**客户端只接受已缓存的响应**
  - 到期
    - max-age=：缓存存储的最大周期，超过这个周期被认为过期。
    - s-maxage=：设置共享缓存，比如can。会覆盖max-age和expires。
    - max-stale[=]：客户端愿意接收一个已经过期的资源
    - min-fresh=：客户端希望在指定的时间内获取最新的响应
    - stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应
      的时间长度。
    - stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。
  - 重新验证和重新加载
    - must-revalidate：如页面过期，则去服务器进行获取。
    - proxy-revalidate：用于共享缓存。
    - immutable：响应正文不随时间改变。
  - 其他
    - no-store：绝对禁止缓存
    - no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。
- 优势特点
  - HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。
  - 比Expires多了很多选项设置。
- 劣势问题
  - 存在版本问题，到期之前的修改客户端是不可知的。



### 协商缓存

当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置**为no-cache时**(即**不走强缓存**)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。

**如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据**，这样就减少了服务器的数据传输压力。

**如果数据有更新就会返回200状态码**，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现



### 私有缓存（浏览器级缓存）

私有缓存只能用于单独的用户：Cache-Control: Private



### 共享缓存（代理级缓存）

共享缓存可以被多个用户使用: Cache-Control: Public



---

## 28. 协商缓存原理，谁跟谁协商，如何协商？

协商缓存: 向服务器发送请求，服务器会根据这个请求的request header的一些**参数**来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

服务器和请求协商，**根据请求头携带的参数进行协商**

协商缓存的HTTP相关头部Last-Modified / If-Modified-Since， **Etag / If-None-Match (优先级比Last-Modified / If-Modified-Since高**)，每次请求需要让服务器判断一下资源是否更新过，从而决定浏览器是否使用缓存，如果是，则返回304，否则重新完整响应。

看一下HTTP缓存的一个总概流程图：
![img](E:\pogject\学习笔记\image\http\1555253303-5b4b22be9160d_articlex)



**协商缓存**

- 协商缓存的状态码由服务器决策返回200或者304
- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。
- 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。
- 协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）
- Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标
  识，只要资源变化，Etag就会重新生成。
- Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。

**协商缓存-协商缓存-Last-Modified/If-Modified-since**

- 服务器通过Last-Modified字段告知客户端，**资源最后一次被修改的时间**，例如Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT
- 浏览器将这个值和内容一起记录在缓存数据库中。
- 下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此**在请求头中将上次的Last-Modified的值写入到请求头的If-Modified-Since字段**
- **服务器会将If-Modified-Since的值与Last-Modified字段进行对比**。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。
- 优势特点
  - 不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。
- 劣势问题
  - **只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端**。例如周期性重写，这种情况下该资源包含的数据实际上一样的。
  - **以时刻作为标识，无法识别一秒内进行多次修改的情况**。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
  - **某些服务器不能精确的得到文件的最后修改时间**。
  - **如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间**，尽管文件可能没有变化，所以起不到缓存的作用。

**协商缓存-Etag/If-None-match**

- 为了解决上述问题，出现了一组新的字段Etag和If-None-Match

- Etag**存储的是文件的特殊标识**(一般都是 hash 生成的)，服务器存储着文件的Etag字段。之后的流程和Last-Modified一致，只是Last-Modified字段和它所表示的更新时间改变成了**Etag字段和它所表示的文件 hash**，**把If-Modified-Since变成了If-None-Match**。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。

- 浏览器在发起请求时，服务器返回在Response header中返回**请求资源的唯一标识**。在下一次请求时，会**将上一次返回的Etag值赋值给If-No-Matched并添加在Request Header中**。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。

  

**Etag 的优先级高于 Last-Modified**。

- 优势特点

  - **可以更加精确的判断资源是否被修改**，可以识别一秒内多次修改的情况。
  - 不存在版本问题，每次请求都回去服务器进行校验。

- 劣势问题

  - **计算ETag值需要性能损耗**。
  - **分布式服务器存储的情况下，计算ETag的算法如果不一样**，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETag不匹配的情况。
  
  

---

## 29. no-store 和 no-cache 的区别

no-cache 和 no-store 都是 HTTP 协议头 Cache-Control 的值。

区别是：

- no-store

  **彻底禁用缓存**，所有内容都不会被缓存到缓存或临时文件中。

- no-cache

  在浏览器使用缓存前，会往返对比 ETag，如果 ETag 没变，返回 304，则使用缓存。



---

## 30.Cache-Control和expires区别是什么，哪个优先级高

**Cache-Control和expires区别：**

Cache-Control**设置时间长度**

Expires **设置时间点**

**优先级：**

强缓存expires和cache-control同时存在时，**则cache-control会覆盖expires**，expires无论有没有过期，都无效。 即：**cache-control优先级 > expires优先级。**



---

#### 5.27 GET和POST区别

**参考答案**：

1. get用来获取数据，post用来提交数据
2. get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制
3. get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，而post请求会把请求的数据放在http请求体中。
4. get是明文传输，post是放在请求体中，**但是开发者可以通过抓包工具看到，也相当于是明文的。**
5. **get请求会保存在浏览器历史记录中**，还可能保存在web服务器的日志中

---



---



---

#### 5.30 怎么用UDP实现可靠传输，两条连接

**参考答案**：

最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。

详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

目前有如下开源程序利用udp实现了可靠的数据传输。分别为***RUDP、RTP、UDT\***。

1、RUDP（Reliable User Datagram Protocol）

***RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等\***，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。

2、RTP（Real Time Protocol）

***RTP为数据提供了具有实时特征的端对端传送服务\***，如在组播或单播网络服务下的交互式视频音频或模拟数据。

应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。

RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。

3、UDT（UDP-based Data Transfer Protocol）

基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。***UDT的主要目的是支持高速广域网上的海量数据传输\***，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。

顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。

---

#### 5.31 数据量很大的时候UDP怎么可靠传输

**参考答案**：

基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。***UDT的主要目的是支持高速广域网上的海量数据传输\***，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。

顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。

---

#### 5.32 TCP断点重传怎么实现的

**参考答案**:

断点续传的关键是**断点**，所以在制定传输协议的时候要设计好，如下图，我自定义了一个交互协议，每次下载请求都会带上下载的起始点，这样就可以支持从断点下载了，其实HTTP里的断点续传也是这个原理，在HTTP的头里有个可选的字段RANGE，表示下载的范围

#### ![img](E:\pogject\学习笔记\image\js\TCP断点重传)

---

#### 5.33 http多个tcp连接怎么实现的？

**参考答案**：

某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免

---

#### 5.34 keep-alive是什么？

**参考答案**：

**什么是KeepAlive**

- KeepAlive可以简单理解为**一种状态保持或重用机制**，比如当一条连接建立后，我们不想它立刻被关闭，如果实现了KeepAlive机制，就可以通过它来实现连接的保持
- HTTP的KeepAlive在HTTP 1.0版本默认是关闭的，但在HTTP1.1是默认开启的；操作系统里TCP的KeepAlive默认也是关闭，但一般应用都会修改设置来开启。**因此网上TCP流量中基于KeepAlive的是主流**
- HTTP的KeepAlive和TCP的KeepAlive有一定的依赖关系，名称又一样，因此经常被混淆，但其实是不同的东西，下面具体分析一下

**TCP为什么要做KeepAlive**

- 我们都知道TCP的三次握手和四次挥手。当两端通过三次握手建立TCP连接后，就可以传输数据了，数据传输完毕，连接并不会自动关闭，而是一直保持。只有两端分别通过发送各自的FIN报文时，才会关闭自己侧的连接。
- 这个关闭机制看起来简单明了，但实际网络环境千变万化，衍生出了各种问题。假设因为实现缺陷、突然崩溃、恶意攻击或网络丢包等原因，一方一直没有发送FIN报文，则连接会一直保持并消耗着资源，**为了防止这种情况，一般接收方都会主动中断一段时间没有数据传输的TCP连接**，比如LVS会默认中断90秒内没有数据传输的TCP连接，F5会中断5分钟内没有数据传输的TCP连接
- 但有的时候我们的确不希望中断空闲的TCP连接，因为建立一次TCP连接需要经过一到两次的网络交互，且由于TCP的slow start机制，新的TCP连接开始数据传输速度是比较慢的，我们希望通过**连接池模式**，保持一部分空闲连接，当需要传输数据时，可以从连接池中直接拿一个空闲的TCP连接来全速使用，这样对性能有很大提升
- 为了支持这种情况，TCP实现了KeepAlive机制。**KeepAlive机制并不是TCP规范的一部分**，但无论Linux和Windows都实现实现了该机制。TCP实现里KeepAlive默认都是关闭的，且是每个连接单独设置的，而不是全局设置
- 另外有一个特殊情况就是，当某应用进程关闭后，如果还有该进程相关的TCP连接，一般来说操作系统会自动关闭这些连接

---

#### 5.35 tcp/ip协议栈、网络模型

**参考答案**:

**TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架**，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是**应用层、传输层、网络层和链路层**，

- **链路层**：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；
- **网络层**：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；
- **传输层**：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
- **应用层**：定义数据格式，并按照对应的格式解读数据。

---

#### 5.36 504 如何排查

**参考答案**：

排查步骤：

1. 检查500/502/504错误截图，判断是负载均衡问题，高防/安全网络配置问题，还是后端ECS配置问题。
2. 如果有高防/安全网络，请确认高防/安全网络的七层转发配置正确。
3. 请确认是所有客户端都有问题，还仅仅是部分客户端有问题。如果仅仅是部分客户端问题，排查该客户端是否被云盾阻挡，或者负载均衡域名或者IP是否被ISP运营商拦截。
4. 检查负载均衡状态，是否有后端ECS健康检查失败的情况，如果有健康检查失败，解决健康检查失败问题。
5. 在客户端用hosts文件将负载均衡的服务地址绑定到后端服务器的IP地址上，确认是否是后端问题。如果5XX错误间断发生，很可能是后端某一台ECS服务器的配置问题。
6. 尝试将七层负载均衡切换为四层负载均衡，查看问题是否会复现。
7. 检查后端ECS服务器是否存在CPU、内存、磁盘或网络等性能瓶颈。
8. 如果确认是后端服务器问题，请检查后端ECS Web服务器日志是否有相关错误，Web服务是否正常运行，确认Web访问逻辑是否有问题，卸载服务器上杀毒软件重启测试。
9. 检查后端ECS Linux操作系统的TCP内核参数是否配置正确。

---

#### 5.37 tcp 是如何确保有效传输的，拥塞控制

**参考答案**：

通过以下7种方式确保有效传输

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

**TCP 拥塞控制**

TCP不仅可以可以控制端到端的数据传输，还可以对网络上的传输进行监控。这使得TCP非常强大智能，它会根据网络情况来调整自己的收发速度。网络顺畅时就可以发的快，拥塞时就发的相对慢一些。拥塞控制算法主要有四种：**慢启动，拥塞避免，快速重传，快速恢复。**

- 慢启动和拥塞避免
  慢启动和拥塞避免算法必须被TCP发送端用来控制正在向网络输送的数据量。为了
  实现这些算法，必须向TCP每连接状态加入两个参量。拥塞窗口（cwnd）是对发送端收到确
  认（ACK）之前能向网络传送的最大数据量的一个发送端限制，接收端通知窗口（rwnd）是对
  未完成数据量的接收端限制。cwnd和rwnd的最小值决定了数据传送。
  另一个状态参量，慢启动阀值（ssthresh），被用来确定是用慢启动还是用拥塞避免
  算法来控制数据传送。
  在不清楚环境的情况下向网络传送数据，要求TCP缓慢地探测网络以确定可用流量，避免突然传送大量数据而使网络拥塞。在开始慢启动时cwnd为1，每收到一个用于确认新数据的ACK至多增加SMSS（SENDER MAXIMUM SEGMENT SIZE）字节。
  慢启动算法在cwndssthresh时使用。当cwnd和ssthresh相等时，发送端既可以使用慢启动也可以使用拥塞避免。
  当拥塞发生时，ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。如果是超时重传，cwnd被设置为1个报文段（这就是慢启动，其实慢启动也不慢，它是指数性增长，只是它的起始比较低）当达到ssthresh时，进入拥塞避免算法（拥塞避免是线性增长）。
- 快速重传和快速恢复
  当接收端收到一个顺序混乱的数据，它应该立刻回复一个重复的ACK。这个ACK的目的是通知发送端收到了一个顺序紊乱的数据段，以及期望的序列号。发送端收到这个重复的ACK可能有多种原因，可能丢失或者是网络对数据重新排序等。在收到三个重复ACK之后（包含第一次收到的一共四个同样的ACK），TCP不等重传定时器超时就重传看起来已经丢失（可能数据绕路并没有丢失）的数据段。因为这个在网络上并没有超时重传那么恶劣，所以不会进入慢启动，**而进入快速恢复**。快速恢复首先会把ssthresh减半(一般还会四舍五入到数据段的倍数)，然后cwnd=ssthresh+收到重复ACK报文段累计的大小。

---

#### 5.38 CDN

**参考答案**：

CDN的全称是Content Delivery Network，即**内容分发网络**。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。

---



---

#### 5.41 介绍下 HTTPS 中间人攻击

**参考答案**：

https 协议由 http + ssl 协议构成。

中间人攻击过程如下：

1. 服务器向客户端发送公钥；
2. 攻击者**截获公钥**，保留在自己手上；
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端；
4. 客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器；
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥；
6. 同时生成假的加密 hash 值，发给服务器；
7. 服务器用私钥解密获得假秘钥；
8. 服务器用假秘钥加密传输信息；

防范方法：

服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（**现有 HTTPS 很难被劫持**，除非信任了劫持者的 CA 证书）。

---

#### 5.42 SSL 连接断开后如何恢复？

**参考答案**：

**Session ID**

每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的密钥，而不用重新生成一把。

**Session Ticket**

session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器可能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

---

#### 5.43 hosts 文件是什么？

**参考答案**：

hosts 文件是个没有扩展名的系统文件，其作用就是将网址域名和其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个 url 时，系统会首先自动从 hosts 文件中寻找对应的 IP 地址。

---

#### 5.44 同域请求的并发数限制的原因

**参考答案**：

浏览器的并发请求数目限制是针对同一域名的，同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞（chorme和firefox的限制请求数都是**6个**）。

限制其数量的**原因**是：基于浏览器端口的限制和线程切换开销的考虑，浏览器为了保护自己不可能无限量的并发请求，如果一次性将所有请求发送到服务器，也会造成服务器的负载上升。

---

#### 5.45 cdn加速原理

**参考答案**：

1. 当用户点击网站页面上的url时，经过本地dns系统解析，dns系统会将域名的解析权给交cname指向的cdn专用dns服务器。
2. cdn的dns服务器将cdn的全局负载均衡设备ip地址返回给用户。
3. 用户向cdn的全局负载均衡设备发起内容url访问请求。
4. cdn全局负载均衡设备根据用户ip，以及用户请求的内容url，选择一台用户所属区域的区域负载均衡设备
5. **区域负载均衡设备**会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址全局负载均衡设备把服务器的IP地址返回给用户。
6. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器 就要向它的上一级缓存服务器发起请求内容，直至追溯到网站的源服务器将内容拉回给用户。

---

6. 

---

#### 5.47 常用的http请求头以及响应头详

**参考答案：**

**一、常用的http请求头**

**1.Accept**

- **Accept: text/html** 浏览器可以接受服务器回发的类型为 text/html。
- **Accept: \*/\*** 代表浏览器可以处理所有类型,(**一般浏览器发给服务器都是发这个**)。

**2.Accept-Encoding**

- **Accept-Encoding: gzip, deflate** 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。

**3.Accept-Language**

- **Accept-Language:zh-CN,zh;q=0.9** 浏览器申明自己接收的语言。

**4.Connection**

- **Connection: keep-alive** 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
- **Connection: close** 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

**5.Host（发送请求时，该报头域是必需的）**

- **Host：** 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。

**6.Referer**

- **Referer:** 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

**7.User-Agent**

- **User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36** 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

**8.Cache-Control**

- **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
- **`\**Cache-Control:public** `**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
- **Cache-Control:must-revalidate** 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
- **Cache-Control:no-cache** 响应不会被缓存,而是实时向服务器端请求资源。
- **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
- **Cache-Control:no-store**在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

**9.Cookie**

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

**10.Range（用于断点续传）**

- **Range:bytes=0-5** 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

**二、常用的http响应头**

**1.Cache-Control（对应请求中的Cache-Control）**

- **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
- ***\*Cache-Control:public\**** 浏览器和缓存服务器都可以缓存页面信息。
- **Cache-Control:must-revalidate** 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
- **Cache-Control:no-cache** 浏览器和缓存服务器都不应该缓存页面信息。
- **Cache-Control:max-age=10** 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。
- **Cache-Control:no-store** 请求和响应的信息都不应该被存储在对方的磁盘系统中。

**2.Content-Type**

- **Content-Type：text/html;charset=UTF-8** 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

**3.Content-Encoding**

- **Content-Encoding:gzip** 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

**4.Date**

- **Date: Tue, 03 Apr 2018 03:52:28 GMT** 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

**5.Server**

- **Server：Tengine/1.4.6** 这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**

**6.Transfer-Encoding**

- **Transfer-Encoding：chunked** 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

**7.Expires**

- **Expires:Sun, 1 Jan 2000 01:00:00 GMT** 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。**所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的**，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

**8.Last-Modified**

- **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT** 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

**9.Connection**

- **Connection：keep-alive** 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

**10.Etag**

- **ETag: "737060cd8c284d8af7ad3082f209582d"** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

**11.Refresh**

- **Refresh: ** 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。

**12.Access-Control-Allow-Origin**

- **Access-Control-Allow-Origin: \*** *号代表所有网站可以跨域资源共享，如果当前字段为*那么Access-Control-Allow-Credentials就不能为true
- **Access-Control-Allow-Origin: [www.baidu.com](http://www.baidu.com/)** 指定哪些网站可以跨域资源共享

**13.Access-Control-Allow-Methods**

- **Access-Control-Allow-Methods：GET,POST,PUT,DELETE** 允许哪些方法来访问

**14.Access-Control-Allow-Credentials**

- **Access-Control-Allow-Credentials: true** 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true

**15.Content-Range**

- **Content-Range: bytes 0-5/7877** 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

---

#### 5.48 fetch 请求方式

**参考答案**：

**fetch**

Fetch API 是近年来被提及将要取代XHR的技术新标准，是一个 HTML5 的 API。
Fetch 并不是XHR的升级版本，而是从一个全新的角度来思考的一种设计。Fetch 是基于 Promise 语法结构，而且它的设计足够低阶，这表示它可以在实际需求中进行更多的弹性设计。对于**XHR**所提供的能力来说，Fetch 已经足够取代XHR，并且提供了更多拓展的可能性。

**基本用法**

```js
// 获取 some.json 资源  
fetch('some.json')  
 .then(function(response) {  
    return response.json();  
 })  
 .then(function(data) {  
    console.log('data', data);  
 })  
 .catch(function(error) {  
    console.log('Fetch Error: ', error);  
 });  

// 采用ES2016的 async/await 语法  
async function() {  
 try {  
    const response = await fetch('some.json');  
    const data = response.json();  
    console.log('data', data);  
 } catch (error) {  
    console.log('Fetch Error: ', error)  
 }  
}
```

**fetch.Post请求**

```js
fetch('https://www.api.com/api/xxx', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
    },
    body: 'a=1&b=2',
}).then(resp => resp.json()).then(resp => {
    console.log(resp)
});
```

**fetch.Get请求**

```js
fetch('https://www.api.com/api/xxx?location=北京&key=bc08513d63c749aab3761f77d74fe820',{
    method:'GET'
}) // 返回一个Promise对象
.then((res)=>{
    return res.json();
})
.then((res)=>{
    console.log(res) // res是最终的结果
})
```

**fetch请求网页**

```js
fetch('https://www.api.com/api/xxx')
    .then(response => response.text())
    .then(data => console.log(data));
```

**自定义header**

```js
var headers = new Headers({
    "Content-Type": "text/plain",
    "X-Custom-Header": "aaabbbccc",
});

var formData = new FormData();
formData.append('name', 'lxa');
formData.append('file', someFile);

var config = {
    credentials: 'include', // 支持cookie
    headers: headers, // 自定义头部
    method: 'POST', // post方式请求
    body: formData // post请求携带的内容
};

fetch('https://www.api.com/api/xxx', config)
    .then(response => response.json())
    .then(data => console.log(data));

// 或者这样添加头部
var content = "Hello World";
var myHeaders = new Headers();
myHeaders.append("Content-Type", "text/plain");
myHeaders.append("Content-Length", content.length.toString());
myHeaders.append("X-Custom-Header", "ProcessThisImmediately");

```

**fetch其他参数**

- method: 请求的方法，例如：GET,POST。
- headers: 请求头部信息，可以是一个简单的对象，也可以是 Headers 类实例化的一个对象。
- body: 需要发送的信息内容，可以是Blob,BufferSource,FormData,URLSearchParams或者USVString。注意，GET,HEAD方法不能包含body。
- mode: 请求模式，分别有cors,no-cors,same-origin,navigate这几个可选值。
  - cors: 允许跨域，要求响应中Acess-Control-Allow-Origin这样的头部表示允许跨域。
  - no-cors: 只允许使用HEAD,GET,POST方法。
  - same-origin: 只允许同源请求，否则直接报错。
  - navigate: 支持页面导航。
- credentials: 表示是否发送cookie，有三个选项
  - omit: 不发送cookie。
  - same-origin: 仅在同源时发送cookie。
  - include: 发送cookie。
- cache: 表示处理缓存的策略。
- redirect: 表示发生重定向时，有三个选项
  - follow: 跟随。
  - error: 发生错误。
  - manual: 需要用户手动跟随。
- integrity: 包含一个用于验证资资源完整性的字符串

```js
var URL = 'https://www.api.com/api/xxx';  
// 实例化 Headers  
var headers = new Headers({  
    "Content-Type": "text/plain",  
    "Content-Length": content.length.toString(),  
    "X-Custom-Header": "ProcessThisImmediately",  
});  
var getReq = new Request(URL, {method: 'GET', headers: headers });  
fetch(getReq).then(function(response) {  
    return response.json();  
}).catch(function(error) {  
    console.log('Fetch Error: ', error);  
});

```

---



---

#### 5.52 什么是粘包问题，如何解决？

**参考答案**：

默认情况下，TCP 连接会采用延迟传送算法（Nagle 算法），在数据发送之前缓存他们。如果短时间有多个数据发送，会缓冲到一起作一次发送（缓冲大小是socket.bufferSize），这样可以减少 IO 消耗提高性能。（TCP 会出现这个问题，HTTP 协议解决了这个问题）

解决方法

1. 多次发送之前间隔一个等待时间：处理简单，但是影响传输效率；
2. 关闭 Nagle 算法：消耗资源高，整体性能下降；
3. 封包/拆包：使用一些有标识来进行封包拆包（类似 HTTP 协议头尾）；

---

9. 

-----------------------------------

---



---



---