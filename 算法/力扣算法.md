

## 1.两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum =function(nums,target){
    len_nums=nums.length;
    for (let i=0; i<len_nums-1; i++){
        for (let j=i+1; j<len_nums; j++){
            if (nums[i]+nums[j]==target) {
                return [i,j];
            }
        }
    }
};

let str1 = [2, 4, 0, 5, 0,5, 0, 9,0];
let str2 = [9, 9, 9 ];
let result=twoSum(str1,6);
//console.log(typeof result);
console.log(result);
```



## 2.两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    //直接在l1上操作
    let temp=0;
    let head=l1;  //存储l1的头结点，方便返回

    while (l1.next){
        if (l2.next) {
            temp+=l1.val+l2.val;
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
            l2=l2.next;
        }else{
            //当l1更长时
            temp+=l1.val+l2.val;  //计算l2的最后一个
            l2.val=0;  //然后把l2值设置为0
            l1.val=temp%10;
            temp=Math.floor(temp/10);
            l1=l1.next;
        }
    }

    while(l2.next){
        //当l2更长时
        temp+=l1.val+l2.val;  //计算l1的最后一个
        l1.val=temp%10;
        l1.next=new ListNode();  //在l1后加next结点，值设为0
        l1=l1.next;
        l1.val=0;  
        temp=Math.floor(temp/10);
        l2=l2.next;
    }
    temp+=l1.val+l2.val;  //读取最后的一个，就算l1和l2刚好长度相同也一样
    l1.val=temp%10;
    temp=Math.floor(temp/10);
    if (temp===1) {
        //最后是否会进位
        l1.next=new ListNode();
        l1=l1.next;
        l1.val=1;
    }
    return head;

};
```

注意 当li.next()返回false后在后面的要计算当前位的值.



## 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**提示：**

- `0 <= s.length <= 5 * 104`

- `s` 由英文字母、数字、符号和空格组成

- **例 1:**

  ```
  输入: s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s==="") {return 0;}
    let maxLen=1;
    let flag;
    let count=1;
    let newArr=[];  //存储子串数组
    for (let i=0;i<s.length;i++){
        newArr.push(s[i]);
        flag=true;
        for (let j=i+1;j<s.length;j++){
            if (newArr.includes(s[j])) {
                //当子串数组中已有时
                maxLen=count>maxLen ? count : maxLen;
                flag=false;
                count=1;
                newArr=[];
                break;
            }else{
                newArr.push(s[j]);
                count++;
            }
        }
        if (flag) {
            maxLen=count>maxLen ? count : maxLen;
            break;
        }
    }
    return maxLen;
};


let str1 = "heflfdddswertllo";
let result=lengthOfLongestSubstring(str1);
console.log(result);
```



## 4. 寻找两个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    let newArr=new Array();
    //双指针
    let i=0;
    let j=0;
    while(i<nums1.length && j<nums2.length){
        if (nums1[i]<=nums2[j]) {
            newArr.push(nums1[i]);
            i++;
        }
        if (nums2[j]<=nums1[i]) {
            console.log(nums2[j]);
            newArr.push(nums2[j]);
            j++;
        }
    }

    while (i<nums1.length){
        newArr.push(nums1[i]);
        i++;
    }
    while(j<nums2.length){
        newArr.push(nums2[j]);
        j++;
    }
    //return newArr;
    let n=nums1.length+nums2.length;
    if (n%2===0) {
        return parseFloat((newArr[n/2]+newArr[n/2-1])/2);
    }else{
        return parseFloat(newArr[Math.floor(n/2)]);
    }
    console.log(newArr);
};


let str1 = [1,2];
let str2=[3,4];
let result=findMedianSortedArrays(str1,str2);
console.log(result);
```

## 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```

```



## 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

示例 1：

输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var repeatedStringMatch = function(a, b) {
    //首先只要b中有字母不在a中,则不可能b为a的子串
    let len_a=a.length;
    let len_b=b.length;

    let set=new Set();
    for (let i=0;i<len_a;i++){
        set.add(a[i]);
    }
    for (let i=0;i<len_b;i++){
        if (!set.has(b[i])) {
            return -1;
        }
    }
    let newStr=a;
    //判断b与a的长度，a当重复后长度最多超过b长度的2倍，如果2倍长度没有找到则返回-1
    let n=len_b%len_a===0 ? len_b/len_a : Math.floor(len_b/len_a)+1;
    if (len_a>=len_b) {
        //当a长时，返回值最多为2
        if (newStr.indexOf(b)!==-1) {
            return 1;
        }else{
            newStr+=a;
            if (newStr.indexOf(b)!==-1) {
                return 2;
            }else{
                return -1;
            }
        }
    }else{
        //当b长时，a长度最多增加到b的2倍
        for (let i=0;i<n-1;i++){
            newStr+=a;
        }
        while (newStr.length<2*len_b){
            if (newStr.indexOf(b)!==-1) {
                return n;
            }else{
                newStr+=a;
                n++;
            }
        }
        if (newStr.indexOf(b)!==-1) {
            return n;
        }else{
            return -1;
        }
        
    }
    return 0;
};


let str1 = "abc";
let str2="cabcabca";

let result=repeatedStringMatch(str1,str2);
console.log(result);
```



## 1154.  一年中的第几天

给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

提示：

date.length == 10
date[4] == date[7] == '-'，其他的 date[i] 都是数字
date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

```js
/**
 * @param {string} date
 * @return {number}
 */
var dayOfYear = function(date) {
    let y=Number(date.split("-")[0]);
    let m=Number(date.split("-")[1]);
    let d=Number(date.split("-")[2]);
    monthOfDays=[31,28,31,30,31,30,31,31,30,31,30,31];

    let is_leap;//是否是闰年
    if (y%400===0) {
        is_leap=true;
    }else if(y%4===0 && y%100!==0){
        is_leap=true;
    }else{
        is_leap=false;
    }

    let total=0;
    for (let i=0;i<m-1;i++){
        total+=monthOfDays[i]
    }
    total+=d;
    if (m>2 && is_leap) {
        total+=1;  //当2月后且是闰年再加一天
    }

    return total;
};

let str1 = "2021-12-21";

let result=dayOfYear(str1);
console.log(result);
```

**普通闰年:公历年份是4的倍数的，一般是闰年。（如2004年就是闰年）；
世纪闰年:公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是世纪闰年，2000年是世纪闰年）；**