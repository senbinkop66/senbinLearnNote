# 字符串

## 串是什么

数据结构中，字符串要单独用一种存储结构来存储，称为串存储结构。这里的串指的就是字符串。

严格意义上讲，串存储结构也是一种线性存储结构，因为字符串中的字符之间也具有"一对一"的逻辑关系。只不过，与之前所学的线性存储结构不同，串结构只用于存储字符类型的数据。

无论学习哪种编程语言，操作最多的总是字符串。数据结构中，根据串中存储字符的数量及特点，对一些特殊的串进行了命名，比如说：
**空串**：存储 0 个字符的串，例如 S = ""（双引号紧挨着）；
**空格串**：只包含空格字符的串，例如 S = "     "（双引号包含 5 个空格）；
**子串和主串**：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = "shujujiegou"，b = "shuju"，由于 a  中也包含 "shuju"，因此串 a 和串 b 是主串和子串的关系；

需要注意的是，空格串和空串不同，空格串中含有字符，只是都是空格而已。另外，只有串 b 整体出现在串 a 中，才能说 b 是 a 的子串，比如 "shujiejugou" 和 "shuju" 就不是主串和子串的关系。

另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。

例如，串 a = "shujujiegou"，串 b = "jiegou"，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 'j' 的位置是 6。

## 串存储结构的具体实现

存储一个字符串，数据结构包含以下 3 种具体存储结构：

1. 定长顺序存储：实际上就是用普通数组（又称静态数组）存储。例如 C 语言使用普通数据存储字符串的代码为 char a[20] = "data.biancheng.net"；
2. 堆分配存储：用动态数组存储字符串；
3. 块链存储：用[链表](http://c.biancheng.net/view/3336.html)存储字符串；

## 串的定长顺序存储结构

顺序存储结构（顺序表）的底层实现用的是数组，根据创建方式的不同，数组又可分为静态数组和动态数组，因此顺序存储结构的具体实现其实有两种方式。
通常所说的数组都指的是静态数组，如 str[10]，静态数组的长度是固定的。与静态数组相对应的，还有动态数组，它使用 malloc 和 free 函数动态申请和释放空间，因此动态数组的长度是可变的。

串的定长顺序存储结构，可以简单地理解为采用 "固定长度的顺序存储结构" 来存储字符串，因此限定了其底层实现只能使用静态数组。

使用定长顺序存储结构存储字符串时，需结合目标字符串的长度，预先申请足够大的内存空间。

例如，采用定长顺序存储结构存储 "data.biancheng.net"，通过目测得知此字符串长度为 18，因此我们申请的数组空间长度至少为 19（最后一位存储字符串的结束标志 '\0'），用 C 语言表示为：

```c
char str[19] = "data.biancheng.net";
```

## 串的堆分配存储结构

串的堆分配存储，其具体实现方式是采用动态数组存储字符串。

通常，编程语言会将程序占有的内存空间分成多个不同的区域，程序包含的数据会被分门别类并存储到对应的区域。拿 C 语言来说，程序会将内存分为 4 个区域，分别为堆区、[栈](http://c.biancheng.net/view/3349.html)区、数据区和代码区，其中的堆区是本节所关注的。

与其他区域不同，堆区的内存空间需要程序员手动使用 malloc 函数申请，并且在不用后要手动通过 free 函数将其释放。

C 语言中使用 malloc 函数最多的场景是给数组分配空间，这类数组称为动态数组。例如：

```c
char * a = (char*)malloc(5*sizeof(char));
```

此行代码创建了一个动态数组 a，通过使用 malloc 申请了 5 个 char 类型大小的堆存储空间。

动态数组相比普通数组（静态数组）的优势是长度可变，换句话说，根据需要动态数组可额外申请更多的堆空间（使用 relloc 函数）：

```c
a = (char*)realloc(a, 10*sizeof(char));
```

通过使用这行代码，之前具有 5 个 char 型存储空间的动态数组，其容量扩大为可存储 10 个 char 型数据。

## 串的块链存储结构

串的块链存储，指的是使用[链表](http://c.biancheng.net/view/3336.html)结构存储字符串。

本节实现串的块链存储使用的是无头节点的[单链表](http://c.biancheng.net/view/3336.html)。当然根据实际需要，你也可以自行决定所用链表的结构（[双向链表](http://c.biancheng.net/view/3342.html)还是单链表，有无头节点）。

我们知道，单链表中的 "单" 强调的仅仅是链表各个节点只能有一个指针，并没有限制数据域中存储数据的具体个数。因此在设计链表节点的结构时，可以令各节点存储多个数据。

链表各节点存储数据个数的多少可参考以下几个因素：

1. 串的长度和存储空间的大小：若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；反之，如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑；
2. 程序实现的功能：如果实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各节点存储数据的数量；反之，就需要再结合其他因素。

## BF算法（串模式匹配算法）

## KMP算法（快速模式匹配算法）



# 实现 Trie (前缀树)

## 一、字典树的概念

Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。
与二叉查找树不同，Trie树的键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

Trie树优点是最大限度地减少无谓的字符串比较，查询效率比较高。核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

（1） 插入、查找的时间复杂度均为O(N)，其中N为字符串长度。
（2） 空间复杂度是26^n级别的，非常庞大（可采用双数组实现改善）。

它有3个基本性质：

根节点不包含字符，除根节点外每一个节点都只包含一个字符。
从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
每个节点的所有子节点包含的字符都不相同。

## 二、Trie树和DFA，确定有限状态自动机

trie树实际上是一个DFA，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式即链表来表示状态转移，但由于要线性查询，会造成效率低下。

 

## 三、Trie树的实现

Trie树的创建要考虑的是父节点如何保存孩子节点，主要有链表和数组两种方式：

（1）使用节点数组，因为是英文字符，可以用Node[26]来保存孩子节点(如果是数字我们可以用Node[10])，这种方式最快，但是并不是所有节点都会有很多孩子，所以这种方式浪费的空间太多
（2）用一个链表根据需要动态添加节点。这样我们就可以省下不小的空间，但是缺点是搜索的时候需要遍历这个链表，增加了时间复杂度。

（1）查询操作

查询操作非常简单。比如要查找int，顺着路径i -> in -> int就找到了。

（2）如何构建

Trie树的构建也很简单，无非是逐一把每则单词的每个字母插入Trie。
插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。

#### 字典树

Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：

指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。
布尔字段isEnd，表示该节点是否为字符串的结尾。

#### 插入字符串

我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：

- 子节点存在。沿着指针移动到子节点，继续处理下一个字符。
- 子节点不存在。创建一个新的子节点，记录在children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。
- 重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。

#### 查找前缀

我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：

子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
子节点不存在。说明字典树中不包含该前缀，返回空指针。
重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。

若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。



## **四、字典树应用场景**

**（1） 字符串检索**
事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。
举例：
给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。
给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。

**（2）字符串最长公共前缀**
Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。
举例：
给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？
解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。
而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：
\1. 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；
\2. 求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；

**（3）排序**

Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。
比如给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。

**（4） 作为其他数据结构和算法的辅助结构**
如后缀树，AC自动机等

**（5）词频统计**
trie树在这里的应用类似哈夫曼树，
比如词频统计使用哈希表或者堆都可以，但是如果内存有限，就可以用trie树来压缩空间，因为trie树的公共前缀都是用一个节点保存的。

**（6）字符串搜索的前缀匹配**
trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。
Trie树检索的时间复杂度可以做到n，n是要检索单词的长度，
如果使用暴力检索，需要指数级O(N2)的时间复杂度。







----

# 堆

堆（Heap）是一种特殊的二叉树：

1. 堆是一个完全二叉树
2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中的每个节点的值

## 分类

堆分为两种：`大顶堆` 和 `小顶堆` 。

- 大顶堆：父顶点的值大于所有子顶点的值。
- 小顶堆：父顶点的值小于所有子顶点的值。

大顶堆：
![img](https://img.kancloud.cn/bc/58/bc585c066f684abfc06cbd52c0c23199_410x304.png)

小顶堆：
![img](https://img.kancloud.cn/92/ca/92caa577acc264a09aaf7b9b2eebb6b1_900x458.png)

## 存储

堆是一种二叉树，有两种存储方式：

- 数组
- 链表

堆是一种完全二叉树，**而完全二叉树使用 `数组` 存储比较合适**。

![img](https://img.kancloud.cn/36/7c/367c25251bdf4400bc285f53280b1b6e_1166x814.png)

当以数组保存二叉树时有以下几个重要公式。

1. 对于下标为 i 节点（子节点）
   左子节点下标：2i+1
   右子节点下标：2i+2
2. 对于下标为 i 的节点（父节点）
   父节点下标：Math.floor( (i-1) / 2 )
3. 最后一个非叶子节点的节点的下标
   Math.floor(len/2) - 1

## 应用场景

1. 排序 ---》 堆排序（时间复杂度：O(nlogn)
2. 优先队列（优先级高的放到前面）

## 操作

二叉堆的操作有三种：

- 插入节点
- 删除节点
- 构建二叉堆

### 插入节点

当向二叉堆中插入新节点时的操作：

1. 将新节点先放到 `最后`
2. 然后依次和父节点比较，然后 `上浮`

### 删除节点

删除节点时，一般就是删除堆是根节点，过程和插入节点正好相反：

1. 删除顶节点
2. 将最后一个节点拿到父节点
3. 和子节点比较并 `下沉`

### 构建二叉堆

排序从最后一个 `非叶子节点 Math.floor(数组长度/2)-1` 开始比较并 （大/小）上浮。



## 代码实现小顶堆

```

```

