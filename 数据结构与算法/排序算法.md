## 十大经典排序算法

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：

![排序算法表](E:\pogject\学习笔记\image\算法\排序算法表.png)

### 关于时间复杂度

平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。

线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；

O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序

线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

### **关于稳定性**

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

名词解释：

- n：数据规模
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

------

## 冒泡排序

冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，**一次比较两个元素，如果他们的顺序错误就把他们交换过来**。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。

### 1. 算法步骤

比较相邻的元素。如果第一个比第二个大，就交换他们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 2. 动图演示

![bubbleSort](E:\pogject\学习笔记\image\算法\bubbleSort.gif)

### 3. 什么时候最快

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

### 4. 什么时候最慢

当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。

### 5. JavaScript 代码实现

```js
function bubbleSort(arr){
    //冒泡排序
    let n=arr.length;
    for (let i=0;i<n-1;i++){
        for(let j=0;j<n-1-i;j++){
            if (arr[j]>arr[j+1]) {  //相邻元素两两比对
                let temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    return arr;
}

let test=[2,4,1,6,5,8,9,3,7,0];
let result=bubbleSort(test);
console.log(result);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```



------

## 选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，**数据规模越小越好**。唯一的好处可能就是不占用额外的内存空间了吧。

### 1. 算法步骤

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

### 2. 动图演示

![selectionSort](E:\pogject\学习笔记\image\算法\selectionSort.gif)

### 3.JavaScript 代码实现

```js
function selectionSort(arr){
    //选择排序
    let n=arr.length;
    let minIndex,temp;
    for (let i=0;i<n-1;i++){
        minIndex=i;
        for(let j=i+1;j<n;j++){
            //寻找每一轮最小的数
            if (arr[j]<arr[minIndex]) {
              //从小到大排序,大到小是arr[j]>arr[minIndex
                minIndex=j;
            }
        }
        temp=arr[i];
        arr[i]=arr[minIndex];
        arr[minIndex]=temp;
    }
    return arr;
}

let test=[2,4,1,6,5,8,9,3,7,0];
let result=selectionSort(test);
console.log(result);
```



------

## 插入排序

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 1. 算法步骤

将第一待排序序列第一个元素看做一个有序序列，**把第二个元素到最后一个元素当成是未排序序列**。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### 2. 动图演示

![insertionSort](E:\pogject\学习笔记\image\算法\insertionSort.gif)

### 3.JavaScript 代码实现

```js
function insertionSort(arr){
    //插入排序
    let n=arr.length;
    let preIndex,current;
    for (let i=0;i<n;i++){
        preIndex=i-1;
        current=arr[i];
        while(preIndex>=0 && arr[preIndex]>current){
            arr[preIndex+1]=arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1]=current;
    }
    return arr;
}

let test=[2,4,1,6,5,8,9,3,7,0];
let result=insertionSort(test);
console.log(result);
```



------

## 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：

1. 插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。
2. 但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。

希尔排序的基本思想是：**先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序**，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

Shell 排序又称缩小增量排序, 由D. L. Shell在1959年提出，是对直接插入排序的改进。

原理： Shell排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。

Shell排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量d i  逐渐缩小，分组数减少，各组的记录数增多，但由于已经按d i − 1  分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此Shell排序在效率上比直接插入排序有较大的改进。

在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为Shell排序最后一轮的增量d就为1。


### 1. 算法步骤

选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

按增量序列个数 k，对序列进行 k 趟排序；

每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 2. 动图演示

![Sorting_shellsort_anim](E:\pogject\学习笔记\image\算法\Sorting_shellsort_anim.gif)



### 3.JavaScript 代码实现

```js
function shellSort(arr){
    //希尔排序
    let n=arr.length;
    let temp,gap=1;
    while(gap<n/3){
        // 动态定义间隔序列
        gap=gap*3+1;
    }
    for (gap;gap>0;gap=Math.floor(gap/3)){
       for(let i=gap;i<n;i++){
            temp=arr[i];
            let j=i-gap;
            for(j;j>=0 && arr[j]>temp;j-=gap){
                arr[j+gap]=arr[j];
            }
            arr[j+gap]=temp;
       }
    }
    return arr;
}

let test=[2,4,1,6,5,8,9,3,7,0];
let result=shellSort(test);
console.log(result);
```



------

## 归并排序

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
- 自下而上的迭代；

在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：

> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.
>
> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。

说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。

### 1. 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

### 2. 动图演示

![mergeSort](E:\pogject\学习笔记\image\算法\mergeSort.gif)

![归并排序示例](E:\pogject\学习笔记\image\算法\归并排序示例.png)

### 3.JavaScript 代码实现

```js
function mergeSort(arr){
    //归并排序
    let n=arr.length;
    if(n<2){
        return arr;
    }
    let middle=Math.floor(n/2);
    let left=arr.slice(0,middle);
    let right=arr.slice(middle);

    return merge(mergeSort(left),mergeSort(right));
}

function merge(left,right){
    let result=[];
    while(left.length && right.length){
        if (left[0]<=right[0]) {
            result.push(left.shift());
        }else{
            result.push(right.shift());
        }
    }
    while(left.length){
        result.push(left.shift());
    }
    while(right.length){
        result.push(right.shift());
    }
    return result;
}

let test=[2,4,1,6,5,8,9,3,7,0];
let result=mergeSort(test);
console.log(result);
```



------

## 快速排序