## TCP 和 UDP

**用户数据报协议 UDP**（User Datagram Protocol）：

- **UDP 在传送数据之前不需要先建立连接**，远程主机在收到 UDP 报文后，不需要给出任何确认。
- 虽然 UDP **不提供可靠交付**，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

**传输控制协议 TCP**（Transmission Control Protocol）：

- TCP 提供**面向连接**的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
- TCP 不提供广播或多播服务。由于 TCP 要提供**可靠**的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
- TCP **一般用于文件传输、发送和接收邮件、远程登录等场景**。

---

## TCP 报文段首部格式

TCP 报文段的具体格式大家可以不必都记住，但是其中的几个**控制位**与我们接下来要讲的三次握手和四次挥手息息相关，大家一定要牢记。

![img](E:\pogject\学习笔记\image\js\TCP报文)

首部固定部分各字段意义如下：

- 1 - **源端口和目的端口**：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址

- 2 -**序号/序列号**（Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。**初始序号**称为 Init Sequense Number, ISN（序号/序列号这个字段很重要）

  例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。

- 3 - **确认号 ack**：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。

- 4 - **数据偏移**（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。

- 5 - **保留**：占 6 位，应置为 0，保留为今后使用。

 大家看上图，保留位的右边还有 6 个控制位（重要），这是**TCP 用来说明该报文段性质**的：

- **紧急位 URG**

  ：当 URG = 1 时，**表明此报文段中有紧急数据，是高优先级的数据，应尽快发送**，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）

  举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。

- **确认 ACK**：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。**TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。**

- **推送 PSH**：当**两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应**。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。

- **复位 RST**：当 RST = 1 时，**表明 TCP 连接中出现了严重错误**（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。

- **同步 SYN**：SYN = 1 表示这是一个连接请求或连接接受报文。

  当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。

- **终止 FIN**：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。



---

## TCP 三次握手建立连接

### ① 三次握手过程详解

三次握手的原文是 `three-way handshake`，整个名词的可以翻译为：**需要三个步骤才能建立握手/连接的机制**。当然，三次握手也可以叫 `three-message handshake`，**通过三条消息来建立的握手/连接**。

进行三次握手的**主要作用**就是为了确认双方的**接收能力和发送能力**是否正常、指定自己的 **初始化序列号(Init Sequense Number, `ISN`)** 为后面的可靠性传输做准备。

三次握手过程如下图：

![img](E:\pogject\学习笔记\image\js\TCP三次握手)

回顾一下图中字符的含义：

- `SYN`：连接请求/接收 报文段
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。**希望收到的下一个数据的第一个字节的序号**

**刚开始客户端处于 `Closed` 的状态，而服务端处于 `Listen` 状态**：

> CLOSED ：没有任何连接状态
>
> `LISTEN `：侦听来自远方 TCP 端口的连接请求

**1）第一次握手**：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 `SYN_Send` 状态。

> `SYN-SENT` ：在发送连接请求后等待匹配的连接请求

**2）第二次握手**：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 `SYN_REVD` 的状态。

> `SYN-RECEIVED`：在收到和发送一个连接请求后等待对连接请求的确认

**3）第三次握手**：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 `Establised` 状态。

服务器收到 ACK 报文之后，也处于 `Establised 状态`，至此，双方建立起了 TCP 连接。

> `ESTABLISHED`：代表一个打开的连接，数据可以传送给用户

### ② 为什么要三次握手

三次握手的目的是**建立可靠的通信信道**，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是**双方确认自己与对方的发送与接收是正常的**。

只有经过三次握手才能确认双发的收发功能都正常，缺一不可：

- 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：

  客户端什么都不能确认；

  **服务器确认了对方发送正常，自己接收正常**

  

- 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：

  客户端确认了：**自己发送、接收正常，对方发送、接收正常；**

  服务器确认了：对方发送正常，自己接收正常

  

- 第三次握手（客户端发送 ACK 报文给服务器）：

  客户端确认了：自己发送、接收正常，对方发送、接收正常；

  服务器确认了：**自己发送**、接收正常，对方发送、**接收正常**



### ③ ISN (Initial Sequence Number) 是固定的吗

三次握手的其中一个**重要功能**是客户端和服务端**交换 ISN**(Initial Sequence Number)，**以便让对方知道接下来接收数据的时候如何按序列号组装数据。**

当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，**因此每个连接都将具有不同的 ISN**。如果 ISN **是固定的，攻击者很容易猜出后续的确认号**，因此 ISN 是动态生成的。

### ④ 三次握手过程中可以携带数据吗

第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手绝对不可以携带数据**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。

**简单的记忆就是，请求连接/接收 即 `SYN = 1` 的时候不能携带数据**

而对于第三次的话，此时客户端已经处于 `ESTABLISHED` 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。

### ⑤ 半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### ⑥ SYN 洪泛攻击

SYN 攻击就是 **Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包**，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

### ⑦ 如果第三次握手丢失了，客户端服务端会如何处理

服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。**那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传**。如果**重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除**。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…



---

## TCP 四次挥手释放连接

### ① 四次挥手过程详解

建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的**半关闭**（half-close）特性造成的，TCP 提供了**连接的一端在结束它的发送后还能接收来自另一端数据的能力。**

TCP 连接的释放**需要发送四个包**（执行四个步骤），因此称为四次挥手(`Four-way handshake`)，**客户端或服务端均可主动发起挥手动作**。

![img](E:\pogject\学习笔记\image\js\TCP四次挥手)

回顾一下上图中符号的意思：

- `FIN` ：连接终止位
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。希望收到的下一个数据的第一个字节的序号

刚开始双方都处于`ESTABLISHED` 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：

**1）第一次挥手**：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并**停止再发送数据，主动关闭 TCP 连接**。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。

> `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

**2）第二次挥手**：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。

> `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；

**此时的 TCP 处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。

> `FIN-WAIT-2` - 从远程TCP等待连接中断请求；

**3）第三次挥手**：如果**服务端**也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。

> `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；

**4）第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 **`TIME_WAIT` （时间等待）状态**。

> `TIME-WAIT` - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；

> 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，**需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 `CLOSED` 状态**（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 `CLOSED` 状态。

### ② 为什么要四次挥手

由于 TCP 的**半关闭**（half-close）特性，**TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。

**通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手**。

举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

---

## 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

而关闭连接时，当收到对方的FIN报文时，**仅仅表示对方不再发送数据了但是还能接收数据**，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

---

# TCP拥塞控制

## 什么是拥塞控制

拥塞： 即在某一时间段，若对网络对资源的需求超过了可用的资源数。网络的性能就要变坏。若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。

了解了拥塞，我们再来看看针对拥塞，所采用的拥塞控制。

拥塞控制： 防止过多的数据注入到网络中，这样可以使网络中的路由器和链路不至过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，路由器，以及与降低网络传输性能有关的所有因素。

当网络数据传输过程中出现拥塞时，分组将会丢失，但此时发送方会继续重传从而导致网络拥塞程度升高。因此当发生拥塞时，应当控制发送方的速率

> - **控制拥塞**是为了降低网络拥塞程度
> - **流量控制**是为了让接收方来得及接收数据

![在这里插入图片描述](E:\pogject\学习笔记\image\js\拥塞控制1)

## 拥塞控制的代价

当然，控制的同时也会出现相应的代价。

**拥塞控制代价：** 需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。

## 拥塞窗口

在发送数据时， 发送方维持一个**拥塞窗口 cwnd** ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的**发送窗口**等于拥塞窗口。

发送方控制拥塞窗口的**原则**是：**只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去**。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
那么拥塞窗口的大小是如何变化的呢？我们从慢开始算法开始讲起。

## TCP拥塞控制的四个算法

- **慢开始**
- **拥塞避免**
- **快重传**
- **快恢复**

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量

> 拥塞窗口只是一个状态变量，控制发送报文段个数。真正决定传输速率的是发送方的**滑动窗口**

![在这里插入图片描述](E:\pogject\学习笔记\image\js\拥塞控制2)

### 慢开始

发送方发送数据的最初执行是慢开始，令cwnd=1，发送方只能发送一个报文段。当收到接收方的确认信息后，将cwnd加倍（2、4、8、16……）

当主机开始发送数据时，如果立即将大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。

因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个**最大报文段MSS**的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。

> 注：**MSS（最大报文段长度）**：最大报文段长度MSS选项是TCP协议定义的一个选项，MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。

每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。

另，**慢开始的“慢”**并不是指cwnd的增长速率慢，而是**指在TCP开始发送报文段时先设置cwnd=1**，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：

当 cwnd < ssthresh 时，使用上述的慢开始算法。
当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

### 拥塞避免

拥塞避免是在慢开始的基础上，由于慢开始到后面数据传输量依然很大，增长非常快，网络拥塞概率增高，**故设置一个门限 ssthresh**。当 cwnd>ssthresh时，**进入拥塞避免，每一次cwnd不再成倍增加而是 +1**

**若出现超时，则令 ssthresh = cwnd/2**，然后重新执行慢开始算法

即降低门限为当前超时的拥塞窗口值一半

拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

无论在慢开始阶段还是在拥塞避免阶段，**只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）**。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

这样做的**目的**就是要**迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。**

![在这里插入图片描述](E:\pogject\学习笔记\image\js\拥塞控制3)
（1)当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。

（2）在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1（如下图），然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。
![在这里插入图片描述](E:\pogject\学习笔记\image\js\拥塞控制4)

（3） 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。

**强调：**“拥塞避免”**并非指完全能够避免了拥塞**。利用以上的措施要完全避免网络拥塞还是不可能的。**“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。**



### 快重传

接收方会对最后一个已收到的有序报文段进行确认，**当连续回复三个相同的确认消息时，说明其下一个报文段丢失了**，发送方执行快重传



如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。

快重传算法： **快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。

![在这里插入图片描述](E:\pogject\学习笔记\image\js\拥塞控制5)

如图所示，接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。**显然，接收方不能确认M4，因为M4是收到的失序报文段。**根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。**但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方**。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。**这样，发送方共收到了 接收方的四个对M2的确认**，其中后三个都是重复确认。

快重传算法还规定，**发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3**，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

与快重传配合使用的还有**快恢复算法**，其过程有以下两个要点：
（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去**不执行**慢开始算法。
（2）由于发送方现在认为网络很可能没有发生拥塞，**因此与慢开始不同之处是现在不执行慢开始算法**（即拥塞窗口cwnd现在不设置为1），**而是把cwnd值设置为 慢开始门限ssthresh减半后的数值**，然后开始**执行拥塞避免算法**（“加法增大”），使拥塞窗口缓慢地线性增大。

下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。
区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。
![在这里插入图片描述](E:\pogject\学习笔记\image\js\拥塞控制6)

### 快恢复

快恢复是在快重传的现象下，为了避免拥塞，对cwnd进行了设置

虽然出现了报文段丢失，但发送方并不觉得此时已经发生了拥塞，此时并不执行慢开始算法（cwnd=1），**而是将 cwnd设置为门限的一半，然后逐次+1**

**快恢复就是在快重传的情况下，将cwnd设置为门限的一半进行数据传输**

---

