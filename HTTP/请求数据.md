

# Fetch 

Fetch API 提供了一个获取资源的接口（包括跨域请求）。任何使用过 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 的人都能轻松上手，而且新的 API 提供了更强大和灵活的功能集。

## [概念和用法](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#概念和用法)

Fetch 的核心在于对 HTTP 接口的抽象，包括 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)，[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)，[`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)，`Body`，以及用于初始化异步请求的 [`global fetch`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)。得益于 JavaScript 实现的这些抽象好的 HTTP 模块，其他接口能够很方便的使用这些功能。

[Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) 是大量使用Fetch的API的一个示例。

除此之外，Fetch 还利用到了请求的异步特性——它是基于 `Promise` 的。



Fetch 提供了对 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) （以及其他与网络请求有关的）对象的通用定义。使之今后可以被使用到更多地应用场景中：无论是 service worker、Cache API、又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式。

它同时还为有关联性的概念，例如CORS和HTTP原生头信息，提供一种新的定义，取代它们原来那种分离的定义。

发送请求或者获取资源，需要使用 [`WindowOrWorkerGlobalScope.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法。它在很多接口中都被实现了，更具体地说，是在 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 和 [`WorkerGlobalScope`](https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope) 接口上。因此在几乎所有环境中都可以用这个方法获取到资源。

 `fetch()` 必须接受一个参数——资源的路径。**无论请求成功与否，它都返回一个 Promise 对象**，resolve 对应请求的 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)。你也可以传一个可选的第二个参数 `init`（参见 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)）。

一旦 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 被返回，就可以使用一些方法来定义内容的形式，以及应当如何处理内容（参见 `Body`）。

你也可以通过 [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 和 [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 的构造函数直接创建请求和响应，但是我们不建议这么做。他们应该被用于创建其他 API 的结果（比如，service workers 中的 [`FetchEvent.respondWith`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith)）。

> **注意**：更多关于 Fetch API 的用法，参考 [Using Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)，以及一些概念 [Fetch basic concepts](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Basic_concepts)。

### [中止 fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#中止_fetch)

浏览器已经开始为 [`AbortController`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 和 [`AbortSignal`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal) 接口（也就是Abort API）添加实验性支持，允许像 Fetch 和 XHR 这样的操作在还未完成时被中止 。请参阅接口页面了解更多详情。

## [Fetch 接口](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#fetch_接口)

- [`WindowOrWorkerGlobalScope.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)

  包含了`fetch()` 方法，用于获取资源。

- [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)

  相当于 response/request 的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。

- [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)

  相当于一个资源请求。

- [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)

  相当于请求的响应

## [Fetch mixin](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#fetch_mixin)

- `Body`

  提供了与 response/request 中的 body 有关的方法，可以定义它的内容形式以及处理方式。

## [Guard](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Basic_concepts#guard)

Guard 是 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象的特性，基于不同的情况，它可以有以下取值：`immutable、``request、``request-no-cors、``response 或 ``none。`

当使用 [`Headers()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers) [constructor](https://developer.mozilla.org/zh-CN/docs/Glossary/Constructor) 创建一个新的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象的时候，它的 guard 被设置成 `none（默认值）。当创建 `[`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 或 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象的时候，它将拥有一个按照以下规则实现的与之关联的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象：

| 新对象的类型                                                 | 创建时的构造函数                                             | 关联的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象的 guard |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) | [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) | `request`                                                    |
| [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request)，[`mode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/mode) 设置成 `no-cors` | `request-no-cors`                                            |                                                              |
| [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) | [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) | `response`                                                   |
| [`error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error) 或 [`redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect) 方法 | `immutable`                                                  |                                                              |

头信息的 guard 会影响 [`set()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/set)、[`delete()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/delete) 和 [`append()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/append) 方法。如果你试图修改 guard 是 `immutable 的 `[`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象，那么会抛出一个 `TypeError。以下情况则不会抛出错误：`

- guard 是 `request` 并且头信息中的 name 不是 [forbidden header name](https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name)
- guard 是 `request-no-cors` 并且头信息中的 name/value 是 [simple header](https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header)
- guard 是 `response` 并且头信息中的 name 不是 [forbidden response header name (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_response_header_name)

# 使用 Fetch

[Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API) 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法，该方法提供了一种简单，合理的方式来**跨网络异步获取资源**。

这种功能以前是使用 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如 [`Service Workers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 和 HTTP 的扩展。

请注意，`fetch` 规范与 `jQuery.ajax()` 主要有以下的**不同**：

- 当接收到一个代表错误的 HTTP 状态码时，从 `fetch()` 返回的 Promise **不会被标记为 reject**，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 [`ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 属性为 false ），**仅当网络故障时或请求被阻止时，才会标记为 reject。**
- `fetch` **不会发送跨域 cookies**，除非你使用了 *credentials* 的[初始化选项](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch#参数)。（自[2018 年 8 月](https://github.com/whatwg/fetch/pull/585)以后，默认的 credentials 政策变更为 `same-origin`。Firefox 也在 61.0b13 版本中进行了修改）

一个基本的 fetch 请求设置起来很简单。看看下面的代码：

```js
  fetch("http://127.0.0.1/test/ajax/test.json")
    .then(response => response.json())
    .then(data => console.log(data));
```

这里我们通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 `fetch()` 到的资源路径，然后返回一个包含响应结果的 promise（一个 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象）。

当然它只是一个 HTTP 响应，而不是真的 JSON。**为了获取JSON的内容，我们需要使用 [`json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json) 方法**（该方法返回一个将响应 body 解析成 JSON 的 promise）。

> **备注：** [Body](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#body) 还有其他相似的方法，用于获取其他类型的内容。

最好使用符合[内容安全策略 (CSP)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)的链接而不是使用直接指向资源地址的方式来进行 fetch 的请求。

### [支持的请求参数](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#支持的请求参数)

`fetch()` 接受第二个可选参数，一个可以控制不同配置的 `init` 对象：

参考 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)，查看所有可选的配置和更多描述。

```js
// Example POST method implementation:
async function postData(url = '', data = {}) {
  // Default options are marked with *
  const response = await fetch(url, {
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, *cors, same-origin
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, *same-origin, omit
    headers: {
      'Content-Type': 'application/json'
      // 'Content-Type': 'application/x-www-form-urlencoded',
    },
    redirect: 'follow', // manual, *follow, error
    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    body: JSON.stringify(data) // body data type must match "Content-Type" header
  });
  return response.json(); // parses JSON response into native JavaScript objects
}

postData('https://example.com/answer', { answer: 42 })
  .then(data => {
    console.log(data); // JSON data parsed by `data.json()` call
  });
```

注意：`mode: "no-cors"` 仅允许使用一组有限的 HTTP 请求头：

- `Accept`
- `Accept-Language`
- `Content-Language`
- `Content-Type` 允许使用的值为：`application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`

### [发送带凭据的请求](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#发送带凭据的请求)

为了让浏览器发送包含凭据的请求（即使是跨域源），要将 `credentials: 'include'` 添加到传递给 `fetch()` 方法的 `init` 对象。

```js
fetch('https://example.com', {
  credentials: 'include'
});
```

**备注：** 当请求使用 `credentials: 'include'` 时，响应的 `Access-Control-Allow-Origin` 不能使用通配符 "`*`"。在这种情况下，`Access-Control-Allow-Origin` **必须是当前请求的源**，在使用 CORS Unblock 插件的情况下请求仍会失败。

**备注：** 无论怎么设置，**浏览器都不应在 *预检请求* 中发送凭据**。了解更多：[跨域资源共享 > 附带身份凭证的请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#附带身份凭证的请求)

如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 `credentials: 'same-origin'`。

```js
// The calling script is on the origin 'https://example.com'

fetch('https://example.com', {
  credentials: 'same-origin'
});
```

要改为确保浏览器不在请求中包含凭据，请使用 `credentials: 'omit'`。

```js
fetch('https://example.com', {
  credentials: 'omit'
})
```

### [上传 JSON 数据](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传_json_数据)

使用 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) POST JSON数据

```js
  let data = {username: "example"};

  fetch("http://127.0.0.1/test/ajax/",{
    method:"POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  })
    .then(response => response.json())
    .then(data => console.log("Success:", data))
    .catch((error) => {
      console.log("Error:", error);
    });

```

### [上传文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传文件)

可以通过 HTML `<input type="file" />` 元素，[`FormData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData) 和 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 上传文件。

```js
  const formData = new FormData();
  const fileField = document.querySelector('input[type="file"]');
  formData.append("username", "abc123");
  formData.append("avatar", fileField.files[0]);

  fetch("http://127.0.0.1/test/ajax/", {
    method: "PUT",
    body: formData
  })
  .then(response => response.json())
  .then(result => {
    console.log("Success:", result);
  })
  .catch(error => {
    console.error("Error:", error);
  });
```

### [上传多个文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传多个文件)

可以通过 HTML `<input type="file" multiple />` 元素，[`FormData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData) 和 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 上传文件。

```js
const formData = new FormData();
const photos = document.querySelector('input[type="file"][multiple]');

formData.append('title', 'My Vegas Vacation');
for (let i = 0; i < photos.files.length; i++) {
  formData.append(`photos_${i}`, photos.files[i]);
}

fetch('https://example.com/posts', {
  method: 'POST',
  body: formData,
})
.then(response => response.json())
.then(result => {
  console.log('Success:', result);
})
.catch(error => {
  console.error('Error:', error);
});
```

### [逐行处理文本文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#逐行处理文本文件)

从响应中读取的分块不是按行分割的，并且是 `Uint8Array` 数组类型（不是字符串类型）。如果你想通过 `fetch()` 获取一个文本文件并逐行处理它，那需要自行处理这些复杂情况。以下示例展示了一种创建行迭代器来处理的方法（简单起见，假设文本是 UTF-8 编码的，且不处理 `fetch()` 的错误）。

```js
  async function* makeTextFileLineIterator(fileURL) {
    const utf8Decoder = new TextDecoder("utf8");
    const response = await fetch(fileURL);
    const reader = response.body.getReader();

    let {value: chunk, done: readerDone } = await reader.read();
    chunk = chunk ? utf8Decoder.decode(chunk) : "";

    const re = /\n|\r|\r\n/gm;
    let startIndex = 0;
    let result;
    for (;;){
      result = re.exec(chunk);
      if (!result) {
        if (readerDone) {
          break;
        }
        let remainder = chunk.substr(startIndex);
        ({value: chunk, done: readerDone} = await reader.read());
        chunk = remainder + (chunk ? utf8Decoder.decode(chunk) : "");
        startIndex = re.lastIndex = 0;
        continue;
      }
      yield chunk.substring(startIndex, result.index);
      startIndex = re.lastIndex;
    }
    if (startIndex < chunk.length) {
      // last line didn't end in a newline char
      yield chunk.substr(startIndex);
    }
  }

  async function run() {
    for await (let line of makeTextFileLineIterator(urlOfFile)){
      processLine(line);
    }
  }

  run();
```

### [检测请求是否成功](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#检测请求是否成功)

如果遇到网络故障或服务端的 CORS 配置错误时，[`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) promise 将会 reject，带上一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 对象。虽然这个情况经常是遇到了权限问题或类似问题——比如 404 不是一个网络故障。**想要精确的判断 `fetch()` 是否成功，需要包含 promise resolved 的情况，此时再判断 [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 是否为 true。**类似以下代码：

```js
  fetch("flowers.jpg")
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not OK");
      }
      return response.blob();
    })
    .then(myBlob => {
      myImage.src = URL.createObjectURL(myBlob);
    })
    .catch(error => {
      console.log('There has been a problem with your fetch operation:', error);
    });
```



### [自定义请求对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#自定义请求对象)

除了传给 `fetch()` 一个资源的地址，你还可以通过使用 [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 构造函数来创建一个 request 对象，然后再作为参数传给 `fetch()`：

```html
<img src="" id="img1">
<script type="text/javascript">

  const myHeaders = new Headers();
  const myRequest = new Request("image1/bg1.jpg", {
    method: "GET",
    headers: myHeaders,
    mode: "cors",
    cache: "default",
  });
  let myImage = document.getElementById("img1");
  fetch(myRequest)
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not OK");
      }
      return response.blob();
    })
    .then(myBlob => {
      myImage.src = URL.createObjectURL(myBlob);
    })
    .catch(error => {
      console.log('There has been a problem with your fetch operation:', error);
    });

</script>
```

`Request()` 和 `fetch()` 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：

```js
const anotherRequest = new Request(myRequest, myInit);
```

这个很有用，因为 request 和 response bodies 只能被使用一次（译者注：这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。**创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 `init` 参数**。创建拷贝必须在读取 body 之前进行，而且读取拷贝的 body 也会将原始请求的 body 标记为已读。

> **备注：** [`clone()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/clone) 方法也可以用于创建一个拷贝。它和上述方法一样，如果 request 或 response 的 body 已经被读取过，那么将执行失败。区别在于， `clone()` 出的 body 被读取不会导致原 body 被标记为已读取。

## [Headers](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#headers)

使用 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 的接口，你可以通过 [`Headers()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers) 构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多键值对：

```js
const content = 'Hello World';
const myHeaders = new Headers();

myHeaders.append('Content-Type', 'text/plain');
myHeaders.append('Content-Length', content.length.toString());
myHeaders.append('X-Custom-Header', 'ProcessThisImmediately');
```

也可以传入一个多维数组或者对象字面量：

```js
const myHeaders = new Headers({
  'Content-Type': 'text/plain',
  'Content-Length': content.length.toString(),
  'X-Custom-Header': 'ProcessThisImmediately'
});
```

它的内容可以被获取：

```js
console.log(myHeaders.has('Content-Type')); // true
console.log(myHeaders.has('Set-Cookie')); // false
myHeaders.set('Content-Type', 'text/html');
myHeaders.append('X-Custom-Header', 'AnotherValue');

console.log(myHeaders.get('Content-Length')); // 11
console.log(myHeaders.get('X-Custom-Header')); // ['ProcessThisImmediately', 'AnotherValue']

myHeaders.delete('X-Custom-Header');
console.log(myHeaders.get('X-Custom-Header')); // null
```

虽然一些操作只能在 [`ServiceWorkers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 中使用，但是它提供了更方便的操作 Headers 的 API。

**如果使用了一个不合法的 HTTP Header 属性名，那么 Headers 的方法通常都抛出 TypeError 异常**。如果不小心写入了一个不可写的属性（[见下方](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#guard)），也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：

```js
const myResponse = Response.error();
try {
  myResponse.headers.set('Origin', 'http://mybank.com');
} catch (e) {
  console.log('Cannot pretend to be a bank!');
}
```

最好在**在使用之前检查内容类型 `content-type` 是否正确**，比如：

```js
fetch(myRequest)
  .then(response => {
     const contentType = response.headers.get('content-type');
     if (!contentType || !contentType.includes('application/json')) {
       throw new TypeError("Oops, we haven't got JSON!");
     }
     return response.json();
  })
  .then(data => {
      /* process your data further */
  })
  .catch(error => console.error(error));
```

### [Guard](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#guard)

由于 Headers 可以在 request 中被发送或者在 response 中被接收，并且规定了哪些参数是可写的，**Headers 对象有一个特殊的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。**

可能的值如下：

- `none`：默认的。
- `request`：从 request 中获得的 headers（[`Request.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/headers)）只读。
- `request-no-cors`：从不同域（[`Request.mode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/mode) `no-cors`）的 request 中获得的 headers 只读。
- `response`：从 response 中获得的 headers（[`Response.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/headers)）只读。
- `immutable`：在 ServiceWorkers 中最常用的，**所有的 headers 都只读**。

> **备注：** 你不可以添加或者修改一个 guard 属性是 `request` 的 Request Header 的 `Content-Length` 属性。同样地，插入 `Set-Cookie` 属性到一个 response header 是不允许的，因此，Service Worker 中，不能给合成的 Response 设置 cookie。

## [Response 对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#response_对象)

如上所述，[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 实例是在 `fetch()` 处理完 promise 之后返回的。

你会用到的最常见的 response 属性有：

- [`Response.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/status) — 整数（默认值为 200）为response的状态码。
- [`Response.statusText`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/statusText) — 字符串（默认值为 ""），该值与 HTTP 状态码消息对应。 注意：HTTP/2 [不支持](https://fetch.spec.whatwg.org/#concept-response-status-message)状态消息
- [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) — 如上所示，该属性是来检查 response 的状态是否在 200 - 299（包括200 和 299）这个范围内。该属性返回一个布尔值。

它的实例也可用通过 JavaScript 来创建，但只有在 [`ServiceWorkers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 中使用 [`respondWith()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith) 方法并提供了一个自定义的 response 来接受 request 时才真正有用：

```js
const myBody = new Blob();

addEventListener('fetch', event => {
  // ServiceWorker intercepting a fetch
  event.respondWith(
    new Response(myBody, {
      headers: { 'Content-Type': 'text/plain' }
    })
  );
});
```

[`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 构造方法接受两个可选参数—— response 的 body 和一个初始化对象（与[`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 所接受的 init 参数类似）。

> **备注：** 静态方法 [`error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error) 只是返回了错误的 response。与此类似地，[`redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect) 只是返回了一个可以重定向至某 URL 的 response。这些也只与 Service Worker 有关。

## [Body](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#body)

不管是请求还是响应都能够包含 body 对象。body 也可以是以下任意类型的实例。

- [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
- [`ArrayBufferView`](https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBufferView) (Uint8Array等)
- [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)/File
- string
- [`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)
- [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)

Body 类定义了以下方法（这些方法都被 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)所实现）以获取 body 内容。这些方法都会返回一个被解析后的 Promise 对象和数据。

- [`Request.arrayBuffer()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/arrayBuffer) / [`Response.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/arrayBuffer)
- [`Request.blob()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/blob) / [`Response.blob()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/blob)
- [`Request.formData()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData) / [`Response.formData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/formData)
- [`Request.json()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/json) / [`Response.json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json)
- [`Request.text()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/text) / [`Response.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/text)

**相比于XHR，这些方法让非文本化数据的使用更加简单。**

请求体可以由传入 body 参数来进行设置：

```js
const form = new FormData(document.getElementById('login-form'));
fetch('/login', {
  method: 'POST',
  body: form
});
```

request 和 response（包括 `fetch()` 方法）都会试着自动设置 `Content-Type`。如果没有设置 `Content-Type` 值，发送的请求也会自动设值。

## [特性检测](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#特性检测)

Fetch API 的支持情况，可以通过检测 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers), [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request), [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 或 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 是否在 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 或 [`Worker`](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker) 域中来判断。例如：

```js
if (window.fetch) {
  // run my fetch request here
} else {
  // do something with XMLHttpRequest?
}
```



# Cross-global fetch usage

本文解释了在fetch时发生的边缘情况（以及潜在的其他APIs展示相同类型的资源检索行为）。当从“iframe”发起包含相对url的跨源fetch时，相对url用于针对当前全局位置而不是iframe的位置进行解析。

## [边缘情况](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Cross-global_fetch_usage#边缘情况)

大多数网站几乎不会遇到这种边缘情况。如下：

- 需要一个同源的 iframe
- 该同源 iframe 需要具有不同基址位置
- 必须使用跨全局的 fetch 函数, 例如. `frame.contentWindow.fetch()`
- 传递给 fetch 函数的是相对 URL

## [遇到的问题](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Cross-global_fetch_usage#遇到的问题)

以前，我们从当前全局 URL 中解析相对 URL，例如：

```js
let absolute = new URL(relative, window.location.href)
```

这样做不是什么大问题，只是表现出这种行为的不同 API 与规范中定义的行为的不一致可能导致问题的进一步发展。

## [解决方案](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Cross-global_fetch_usage#解决方案)

在 Firefox 60 及以后版本中，Mozilla 对相对 URL 的解析是相对于拥有`fetch()`函数的全局的。（见 [bug 1432272](https://bugzilla.mozilla.org/show_bug.cgi?id=1432272)）。因此在上述情形中，**URL 是相对于 iframe 的地址进行解析的**：

```js
let absolute = new URL(relative, frame.contentWindow.location.href)
```

---

# Response

 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 的 `Response` 接口呈现了对一次请求的响应数据。

你可以使用 [`Response.Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 构造函数来创建一个 `Response` 对象，但通常更可能遇到的情况是，其他的API操作返回了一个 Response 对象。例如一个service worker 的 [`Fetchevent.respondWith`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith)，或者一个简单的 [`GlobalFetch.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#构造函数)

- [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response)

  创建一个新的 `Response` 对象。

`**Response()**` 构造函数创建了一个新的 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象.

### [语法](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response#语法)

```js
let myResponse = new Response(body, init);
```

### [参数](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response#参数)

- *body* 可选

  一个定义 response 中 body 的对象. 可以为 `null` ，或是以下其中一个:[`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)[`BufferSource` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource)[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)[`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)[`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)[`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)

- *init* 可选

  一个参数(options)对象，包含要应用到 response 上的任何自定义设置. 可能参数(options)是:

  `status`: response 的状态码, 例如:`200`.

  `statusText`: 和状态码关联的状态消息, 例如: `OK`.

  `headers`: 你想加到 response 上的任何 headers, 包含了一个 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象或满足对象语法的 [`ByteString`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String) key/value 对 (详见 [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)).

## [例子](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response#例子)

在我们的 [Fetch Response 示例](https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-response)中 (参见[Fetch Response live](https://mdn.github.io/fetch-examples/fetch-response/)) 我们使用构造函数创建了一个新的Response 对象，传递一个新的 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 作为 body, 和一个包含自定义 `status` 和`statusText`的 init 对象:

```js
var myBlob = new Blob();
var init = { "status" : 200 , "statusText" : "SuperSmashingGreat!" };
var myResponse = new Response(myBlob,init);
```

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#属性)

- [`Response.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/headers) 只读

  包含此 Response 所关联的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象。

- [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 只读

  包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。

- [`Response.redirected`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirected) 只读

  表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。

- [`Response.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/status) 只读

  包含 Response 的状态码 （例如 `200` 表示成功）。

- [`Response.statusText`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/statusText) 只读

  包含了**与该 Response 状态码一致的状态信息**（例如，OK对应 `200`）。

- [`Response.type`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/type) 只读

  包含 Response 的类型（例如，`basic`、`cors`）。

- [`Response.url`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/url) 只读

  包含 Response 的URL。

- `Response.useFinalURL`

  包含了一个布尔值，来标示这是否是该 Response 的最终 URL。

`Response` 实现了 `Body` 接口，所以以下属性亦可用：

- [`Body.body` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) 只读

  一个简单的 getter，用于暴露一个 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 类型的 body 内容。

- [`Body.bodyUsed` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/bodyUsed) 只读

  包含了一个[`布尔值` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)来标示该 Response 是否读取过 `Body`。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#方法)

- [`Response.clone()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/clone)

  创建一个 `Response` 对象的克隆。

- [`Response.error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error)

  返回一个绑定了网络错误的新的 `Response` 对象。

- [`Response.redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect)

  用另一个 URL 创建一个新的 `Response`。

`Response` 实现了 `Body` 接口，所以以下方法同样可用：

- [`Body.arrayBuffer()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 格式的 Promise 对象。**

- [`Body.blob()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/blob)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 格式的 Promise 对象。**

- [`Body.formData()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/formData)

  读取[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 格式的 Promise 对象。**

- [`Body.json()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/json)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 `JSON` 格式的 Promise 对象。**

- [`Body.text()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/text)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 格式的 Promise 对象。**

你也可以使用 [`Response.Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 这样的构造方法，来创建自定义的 `Response` 对象：

```js
const response = new Response();
```

## [示例](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#示例)

在我们的[基础实例](https://github.com/mdn/fetch-examples/tree/gh-pages/basic-fetch) ([点击运行](https://mdn.github.io/fetch-examples/basic-fetch/)) 中 , 我们使用了一个简单的函数调用 , 调用了 `fetch()` 函数来获取一张图片并将其显示在 HTML 的 IMG 标签中 , `fetch()` 函数返回了一个 Promise，它使用与资源获取操作相关联的 Response 对象进行解析. 你会注意到，由于我们正在请求一张图片，我们需要运行[`Body.blob` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/blob)（[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 实现了），以为响应提供正确的 MIME 类型。

```js
const image = document.querySelector('.my-image');

fetch('flowers.jpg').then(function(response) {
  return response.blob();
}).then(function(blob) {
  const objectURL = URL.createObjectURL(blob);
  image.src = objectURL;
});
```

---



# Blob

`Blob` 对象表示一个**不可变、原始数据的类文件对象**。它的数据可以按文本或二进制的格式进行读取，也可以转换成 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 来用于数据操作。 

Blob 表示的不一定是JavaScript原生格式的数据。[`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 接口基于`Blob`，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

要从其他非blob对象和数据构造一个 `Blob`，请使用 [`Blob()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob) 构造函数。要创建一个 blob 数据的子集 blob，请使用 [`slice()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) 方法。要获取用户文件系统上的文件对应的 `Blob` 对象，请参阅 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 文档。

接受 `Blob` 对象的API也被列在 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 文档中。

**注意：**`slice()` 方法原本接受 `length` 作为第二个参数，以表示复制到新 `Blob` 对象的字节数。如果设置的参数使 `start + length` 超出了源 `Blob` 对象的大小，则返回从开始到结尾的所有数据。

> **注意：**`slice()` 方法在某些浏览器和版本上带有浏览器引擎前缀：比如 Firefox 12 及更早版本的`blob.mozSlice()` 和 Safari 中的`blob.webkitSlice()`。 没有浏览器引擎前缀的老版本 `slice()` 方法有不同的语义，并且已过时。Firefox 30 取消了对 `blob.mozSlice()` 的支持。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#构造函数)

- [`Blob(blobParts[, options\])`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob)

  返回一个新创建的 `Blob` 对象，其内容由参数中给定的数组串联组成。

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#属性)

- [`Blob.size`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size) 只读

  `Blob` 对象中**所包含数据的大小（字节）**。

- [`Blob.type`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type) 只读

  一个字符串，**表明该 `Blob` 对象所包含数据的 MIME 类型**。如果类型未知，则该值为空字符串。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#方法)

- [`Blob.slice([start[, end[, contentType\]]])`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice)

  返回一个新的 `Blob` 对象，包含了源 `Blob` 对象中指定范围内的数据。

- [`Blob.stream()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream)

  返回一个能读取blob内容的 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)。

- [`Blob.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text)

  返回一个promise且包含blob所有内容的UTF-8格式的 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)。

- [`Blob.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer)

  返回一个promise且包含blob所有内容的二进制格式的 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 

## [示例](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#示例)

### [Blob 构造函数用法举例](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#blob_构造函数用法举例)

[`Blob() 构造函数`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob)允许通过其它对象创建 Blob 对象。比如，用字符串构建一个 blob：

```js
  let debug = {hello: "world"};
  let blob = new Blob([JSON.stringify(debug, null, 2)], {type: "application/json"});
  console.log(blob.size);  // 22
```

> [`BlobBuilder`](https://developer.mozilla.org/zh-CN/docs/Web/API/BlobBuilder) 接口提供了另外一种创建`Blob` 对象的方式，但该方式现在已经废弃，不应继续使用：

```
var builder = new BlobBuilder();
var fileParts = ['<a id="a"><b id="b">hey!</b></a>'];
builder.append(fileParts[0]);
var myBlob = builder.getBlob('text/xml');
```

### [示例：使用 Blob 创建一个指向类型化数组的URL](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#示例：使用_blob_创建一个指向类型化数组的url)

参考下面的代码：

```js
var typedArray = GetTheTypedArraySomehow();
var blob = new Blob([typedArray.buffer], {type: 'application/octet-stream'}); // 传入一个合适的 MIME 类型
var url = URL.createObjectURL(blob);
// 会产生一个类似 blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串
// 你可以像使用普通 URL 那样使用它，比如用在 img.src 上。
```

### [示例：从 Blob 中提取数据](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#示例：从_blob_中提取数据)

一种从Blob中读取内容的方法是使用 [`FileReader`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader)。以下代码将 Blob 的内容作为类型数组读取：

```js
var reader = new FileReader();
reader.addEventListener("loadend", function() {
   // reader.result 包含被转化为类型数组 typed array 的 blob
});
reader.readAsArrayBuffer(blob);
```

另一种读取Blob中内容的方式是使用Response对象。下述代码将Blob中的内容读取为文本：

```js
var text = await (new Response(blob)).text();
```

通过使用 [`FileReader`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader) 的其它方法可以把 Blob 读取为字符串或者数据URL。

---

# URL API

URL API是一个URL标准的组件，它定义了有效的[Uniform Resource Locator](https://developer.mozilla.org/zh-CN/docs/Glossary/URL)和访问、操作URL的API。URL标准还定义了像域名、主机和IP地址等概念，并尝试以标准的方式去描述用于以键/值对的形式提交web表单内容的遗留`application/x-www-form-urlencoded` [MIME type](https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type) 。

## [URL的概念和用法](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#url的概念和用法)

URL标准的主要内容是由URL的定义以及它的结构和解析方式决定的。还介绍了与网络上计算机寻址有关的各种术语的定义，**并指定了解析IP地址和DOM地址的算法**。大多数开发人员更感兴趣的是API本身。

### [使用URL组件](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#使用url组件)

给指定的URL创建一个 [`URL`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL) 对象将解析URL并通过其属性对其组成部分的快速访问。

```js
  let addr = new URL("https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API");
  let host = addr.host;
  let path = addr.pathname;
  console.log(host);  // developer.mozilla.org
  console.log(path);  // /zh-CN/docs/Web/API/URL_API
```

上面的代码片段为您正在阅读的文章创建一个`URL`对象，然后获取 [`host`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/host) 和 [`pathname`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/pathname) 属性。在本例中，这些字符串的值分别是`developer.mozilla.org` 和`/zh-CN/docs/Web/API/URL_API`。

### [修改URL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#修改url)

`URL`对象的大部分属性都是可设置的；您可以向它们写入新值来更改对象所表示的URL。例如，要创建一个URL对象并设置它的用户名：

```js
  let myUsername = "kop";
  let addr = new URL("https://mysite.com/login");
  addr.username = myUsername;
  console.log(addr.href);  // https://kop@mysite.com/login
```

设置 [`username`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/username) 值不仅是设置该属性的值，而且更新整个URL。执行上面的代码片段后， [`addr.href`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/href) 的返回值是`https://kop@mysite.com/login`。对于任何可写属性都是如此。

### [查询](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#查询)

 [`search`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/search) 属性在URL上包含URL的查询字符串部分。例如，如果URL是`https://mysite.com/login?user=someguy&page=news`，那么`search` 属性的值是`?user=someguy&page=news`。您还可以使用 [`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams) 对象的 [`get()`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/get) 查找单个参数的值：

```js
  let addr = new URL("https://mysite.com/login?user=someguy&page=news");
  try {
    loginUser(addr.searchParams.get("user"));
    gotoPage(addr.searchParams.get("page"));
  } catch(err){
    showErrorMessage(err);
  }
```

例如，在上面的代码片段中，从查询中提取用户名和目标页面，并将其传递给适当的函数，站点代码使用这些函数登录并将用户路由到站点的目的页面。

`URLSearchParams`中的其他函数允许修改改、添加和删除键和值，甚至对参数列表进行排序。

## [例子](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#例子)

如果希望处理URL中包含的参数，可以手动进行处理，但是创建一个URL对象更容易。下面的`fillTableWithParameters()`函数接受一个表示[``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table)的  [`HTMLTableElement`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLTableElement) 对象作为输入。将行添加到表中，每个行对应参数中找到的键，第一列包含键，第二列包含值。

注意，在生成表之前调用 [`URLSearchParams.sort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/sort) 对参数列表进行排序。

​     

```js
function fillTableWithParameters(tbl) {
  let url = new URL(document.location.href);
  url.searchParams.sort();
  let keys = url.searchParams.keys();

  for (let key of keys) {
    let val = url.searchParams.get(key);
    let row = document.createElement("tr");
    let cell = document.createElement("td");
    cell.innerText = key;
    row.appendChild(cell);
      
    cell = document.createElement("td");
    cell.innerText = val;
      
    row.appendChild(cell);
    tbl.appendChild(row);
  };
}
```

----

# XMLHttpRequest

`XMLHttpRequest`（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。`XMLHttpRequest` 在 [AJAX](https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX) 编程中被大量使用。



尽管名称如此，`XMLHttpRequest` 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。

如果您的通信流程需要从服务器端接收事件或消息数据，请考虑通过 [`EventSource`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource) 接口使用 [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)。对于全双工的通信， [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) 可能是更好的选择。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#构造函数)

- [`XMLHttpRequest()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/XMLHttpRequest)

  该构造函数用于初始化一个 `XMLHttpRequest` 实例对象。在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#属性)

*此接口继承了 [`XMLHttpRequestEventTarget`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestEventTarget) 和 [`EventTarget`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget) 的属性。*

- [`XMLHttpRequest.onreadystatechange`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readystatechange_event)

  当 `readyState` 属性发生变化时，调用的 `event handler`。

- [`XMLHttpRequest.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState) 只读

  返回 一个无符号短整型（`unsigned short`）数字，代表请求的状态码。

- [`XMLHttpRequest.response`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/response) 只读

  返回一个 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)、[`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)、[`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)，或 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString)，具体是哪种类型取决于 [`XMLHttpRequest.responseType`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType) 的值。其中包含整个响应实体（response entity body）。

- [`XMLHttpRequest.responseText`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseText) 只读

  返回一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString)，该 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString) 包含对请求的响应，如果请求未成功或尚未发送，则返回 `null`。

- [`XMLHttpRequest.responseType`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType)

  一个用于定义响应类型的枚举值（enumerated value）。

- [`XMLHttpRequest.responseURL`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseURL) 只读

  返回经过序列化（serialized）的响应 URL，如果该 URL 为空，则返回空字符串。

- [`XMLHttpRequest.responseXML`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseXML) 只读

  返回一个 [`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)，其中包含该请求的响应，如果请求未成功、尚未发送或是不能被解析为 XML 或 HTML，则返回 `null`。

- [`XMLHttpRequest.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status) 只读

  返回一个无符号短整型（`unsigned short`）数字，代表请求的响应状态。

- [`XMLHttpRequest.statusText`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/statusText) 只读

  返回一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString)，其中包含 HTTP 服务器返回的响应状态。与 [`XMLHTTPRequest.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status) 不同的是，它包含完整的响应状态文本（例如，"`200 OK`"）。

> **注意：**根据 HTTP/2 规范（[8.1.2.4](https://http2.github.io/http2-spec/#rfc.section.8.1.2.4) [Response Pseudo-Header Fields](https://http2.github.io/http2-spec/#HttpResponse)，响应伪标头字段），HTTP/2 没有定义任何用于携带 HTTP/1.1 状态行中包含的版本（version）或者原因短语（reason phrase）的方法。

[`XMLHttpRequest.timeout`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/timeout)

一个无符号长整型（`unsigned long`）数字，表示该请求的最大请求时间（毫秒），若超出该时间，请求会自动终止。

XMLHttpRequestEventTarget.ontimeout

当请求超时调用的 `event handler`。

[`XMLHttpRequest.upload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload) 只读

`XMLHttpRequestUpload`，**代表上传进度**。

[`XMLHttpRequest.withCredentials`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials)

一个[`布尔值` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，用来指定跨域 `Access-Control` 请求是否应当带有授权信息，如 cookie 或授权 header 头。

### [非标准属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#非标准属性)

- [`XMLHttpRequest.channel`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/channel)只读

  一个 `nsIChannel`，对象在执行请求时使用的通道。

- [`XMLHttpRequest.mozAnon`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozAnon)只读

  一个布尔值，如果为真，请求将在没有 cookie 和身份验证 header 头的情况下发送。

- [`XMLHttpRequest.mozSystem`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozSystem)只读

  一个布尔值，如果为真，则在请求时不会强制执行同源策略。

- [`XMLHttpRequest.mozBackgroundRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozBackgroundRequest)

  一个布尔值，它指示对象是否是后台服务器端的请求。

- [`XMLHttpRequest.mozResponseArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozResponseArrayBuffer) 已废弃 Gecko 6 只读

  一个 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)，把请求的响应作为一个 JavaScript TypedArray。

- `XMLHttpRequest.multipart`已废弃 Gecko 22

  **这是一个 Gecko 专有属性，是一个布尔值，已在 Firefox/Gecko 22 中被删除。**请考虑使用 [Server-Sent Event](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)、[Web Socket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)、或来自进度事件的 `responseText` 代替。

### [事件处理器](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#事件处理器)

作为 `XMLHttpRequest` 实例的属性之一，所有浏览器都支持 `onreadystatechange`。

后来，许多浏览器实现了一些额外的事件（`onload`、`onerror`、`onprogress` 等）。详见[Using XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)。

更多现代浏览器，包括 Firefox，除了可以设置 `on*` 属性外，也提供标准的监听器 [`addEventListener()`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener) API 来监听`XMLHttpRequest` 事件。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#方法)

- [`XMLHttpRequest.abort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort)

  如果请求已被发出，则立刻中止请求。

- [`XMLHttpRequest.getAllResponseHeaders()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getAllResponseHeaders)

  以字符串的形式返回所有用 [CRLF](https://developer.mozilla.org/zh-CN/docs/Glossary/CRLF) 分隔的响应头，如果没有收到响应，则返回 `null`。

- [`XMLHttpRequest.getResponseHeader()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getResponseHeader)

  返回包含指定响应头的字符串，如果响应尚未收到或响应中不存在该报头，则返回 `null`。

- [`XMLHttpRequest.open()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open)

  初始化一个请求。该方法只能在 JavaScript 代码中使用，若要在 native code 中初始化请求，请使用 [`openRequest()`](https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIXMLHttpRequest)。

- [`XMLHttpRequest.overrideMimeType()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/overrideMimeType)

  覆写由服务器返回的 MIME 类型。

- [`XMLHttpRequest.send()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send)

  发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。

- [`XMLHttpRequest.setRequestHeader()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader)

  设置 HTTP 请求头的值。必须在 `open()` 之后、`send()` 之前调用 `setRequestHeader()` 方法。

### [非标准方法](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#非标准方法)

- `XMLHttpRequest.init()`

  在 C++ 代码中初始化一个 XHR 对象。

  >**警告：**该方法不能在 JavaScript 代码中使用。

- `XMLHttpRequest.openRequest()`

  初始化一个请求。这个方法只能在原生 C++ 代码中使用；如果用 JavaScript 代码来初始化请求，使用 [`open()`](https://developer.mozilla.org/zh-cn/nsIXMLHttpRequest#open()) 代替。可参考 `open()` 的文档。

- `XMLHttpRequest.sendAsBinary()`Deprecated

  `send()` 方法的变体，用来发送二进制数据。

## [事件](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#事件)

- [`abort`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort_event)

  当 request 被停止时触发，例如当程序调用 [`XMLHttpRequest.abort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort) 时。 也可以使用 [`onabort`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/abort_event) 属性。

- [`error`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/error_event)

  当 request 遭遇错误时触发。 也可以使用 [`onerror`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/error_event) 属性

- [`load`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/load_event)

  [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)请求成功完成时触发。 也可以使用 [`onload`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/load_event) 属性.

- [`loadend`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadend_event)

  当请求结束时触发, 无论请求成功 ( [`load`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/load_event)) 还是失败 ([`abort`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort_event) 或 [`error`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/error_event))。 也可以使用 `onloadend` 属性。

- [`loadstart`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadstart_event)

  接收到响应数据时触发。 也可以使用 [`onloadstart`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/loadstart_event) 属性。

- [`progress`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/progress_event)

  当请求接收到更多数据时，周期性地触发。 也可以使用 [`onprogress`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/progress_event) 属性。

- [`timeout`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/timeout_event)

  在预设时间内没有接收到响应时触发。 也可以使用 `ontimeout` 属性。

# 使用 XMLHttpRequest

在该教程中，我们将使用[`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 来发送 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 请求以实现网站和服务器之间的数据交换。`XMLHttpRequest`常见和晦涩的使用情况都将包含在例子中。

发送一个 HTTP 请求，需要创建一个 `XMLHttpRequest` 对象，打开一个 URL，最后发送请求。当所有这些事务完成后，该对象将会包含一些诸如响应主体或 [HTTP status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) 的有用信息。
