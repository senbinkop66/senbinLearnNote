

# Fetch 

Fetch API 提供了一个获取资源的接口（包括跨域请求）。任何使用过 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 的人都能轻松上手，而且新的 API 提供了更强大和灵活的功能集。

## [概念和用法](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#概念和用法)

Fetch 的核心在于对 HTTP 接口的抽象，包括 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)，[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)，[`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)，`Body`，以及用于初始化异步请求的 [`global fetch`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)。得益于 JavaScript 实现的这些抽象好的 HTTP 模块，其他接口能够很方便的使用这些功能。

[Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) 是大量使用Fetch的API的一个示例。

除此之外，Fetch 还利用到了请求的异步特性——它是基于 `Promise` 的。



Fetch 提供了对 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) （以及其他与网络请求有关的）对象的通用定义。使之今后可以被使用到更多地应用场景中：无论是 service worker、Cache API、又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式。

它同时还为有关联性的概念，例如CORS和HTTP原生头信息，提供一种新的定义，取代它们原来那种分离的定义。

发送请求或者获取资源，需要使用 [`WindowOrWorkerGlobalScope.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法。它在很多接口中都被实现了，更具体地说，是在 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 和 [`WorkerGlobalScope`](https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope) 接口上。因此在几乎所有环境中都可以用这个方法获取到资源。

 `fetch()` 必须接受一个参数——资源的路径。**无论请求成功与否，它都返回一个 Promise 对象**，resolve 对应请求的 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)。你也可以传一个可选的第二个参数 `init`（参见 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)）。

一旦 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 被返回，就可以使用一些方法来定义内容的形式，以及应当如何处理内容（参见 `Body`）。

你也可以通过 [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 和 [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 的构造函数直接创建请求和响应，但是我们不建议这么做。他们应该被用于创建其他 API 的结果（比如，service workers 中的 [`FetchEvent.respondWith`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith)）。

> **注意**：更多关于 Fetch API 的用法，参考 [Using Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)，以及一些概念 [Fetch basic concepts](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Basic_concepts)。

### [中止 fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#中止_fetch)

浏览器已经开始为 [`AbortController`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 和 [`AbortSignal`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal) 接口（也就是Abort API）添加实验性支持，允许像 Fetch 和 XHR 这样的操作在还未完成时被中止 。请参阅接口页面了解更多详情。

## [Fetch 接口](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#fetch_接口)

- [`WindowOrWorkerGlobalScope.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)

  包含了`fetch()` 方法，用于获取资源。

- [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)

  相当于 response/request 的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。

- [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)

  相当于一个资源请求。

- [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)

  相当于请求的响应

## [Fetch mixin](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#fetch_mixin)

- `Body`

  提供了与 response/request 中的 body 有关的方法，可以定义它的内容形式以及处理方式。

## [Guard](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Basic_concepts#guard)

Guard 是 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象的特性，基于不同的情况，它可以有以下取值：`immutable、``request、``request-no-cors、``response 或 ``none。`

当使用 [`Headers()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers) [constructor](https://developer.mozilla.org/zh-CN/docs/Glossary/Constructor) 创建一个新的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象的时候，它的 guard 被设置成 `none（默认值）。当创建 `[`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 或 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象的时候，它将拥有一个按照以下规则实现的与之关联的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象：

| 新对象的类型                                                 | 创建时的构造函数                                             | 关联的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象的 guard |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) | [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) | `request`                                                    |
| [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request)，[`mode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/mode) 设置成 `no-cors` | `request-no-cors`                                            |                                                              |
| [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) | [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) | `response`                                                   |
| [`error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error) 或 [`redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect) 方法 | `immutable`                                                  |                                                              |

头信息的 guard 会影响 [`set()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/set)、[`delete()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/delete) 和 [`append()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/append) 方法。如果你试图修改 guard 是 `immutable 的 `[`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象，那么会抛出一个 `TypeError。以下情况则不会抛出错误：`

- guard 是 `request` 并且头信息中的 name 不是 [forbidden header name](https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name)
- guard 是 `request-no-cors` 并且头信息中的 name/value 是 [simple header](https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header)
- guard 是 `response` 并且头信息中的 name 不是 [forbidden response header name (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_response_header_name)

# 使用 Fetch

[Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API) 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法，该方法提供了一种简单，合理的方式来**跨网络异步获取资源**。

这种功能以前是使用 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如 [`Service Workers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 和 HTTP 的扩展。

请注意，`fetch` 规范与 `jQuery.ajax()` 主要有以下的**不同**：

- 当接收到一个代表错误的 HTTP 状态码时，从 `fetch()` 返回的 Promise **不会被标记为 reject**，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 [`ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 属性为 false ），**仅当网络故障时或请求被阻止时，才会标记为 reject。**
- `fetch` **不会发送跨域 cookies**，除非你使用了 *credentials* 的[初始化选项](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch#参数)。（自[2018 年 8 月](https://github.com/whatwg/fetch/pull/585)以后，默认的 credentials 政策变更为 `same-origin`。Firefox 也在 61.0b13 版本中进行了修改）

一个基本的 fetch 请求设置起来很简单。看看下面的代码：

```js
  fetch("http://127.0.0.1/test/ajax/test.json")
    .then(response => response.json())
    .then(data => console.log(data));
```

这里我们通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 `fetch()` 到的资源路径，然后返回一个包含响应结果的 promise（一个 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象）。

当然它只是一个 HTTP 响应，而不是真的 JSON。**为了获取JSON的内容，我们需要使用 [`json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json) 方法**（该方法返回一个将响应 body 解析成 JSON 的 promise）。

> **备注：** [Body](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#body) 还有其他相似的方法，用于获取其他类型的内容。

最好使用符合[内容安全策略 (CSP)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)的链接而不是使用直接指向资源地址的方式来进行 fetch 的请求。

### [支持的请求参数](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#支持的请求参数)

`fetch()` 接受第二个可选参数，一个可以控制不同配置的 `init` 对象：

参考 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)，查看所有可选的配置和更多描述。

```js
// Example POST method implementation:
async function postData(url = '', data = {}) {
  // Default options are marked with *
  const response = await fetch(url, {
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, *cors, same-origin
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, *same-origin, omit
    headers: {
      'Content-Type': 'application/json'
      // 'Content-Type': 'application/x-www-form-urlencoded',
    },
    redirect: 'follow', // manual, *follow, error
    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    body: JSON.stringify(data) // body data type must match "Content-Type" header
  });
  return response.json(); // parses JSON response into native JavaScript objects
}

postData('https://example.com/answer', { answer: 42 })
  .then(data => {
    console.log(data); // JSON data parsed by `data.json()` call
  });
```

注意：`mode: "no-cors"` 仅允许使用一组有限的 HTTP 请求头：

- `Accept`
- `Accept-Language`
- `Content-Language`
- `Content-Type` 允许使用的值为：`application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`

### [发送带凭据的请求](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#发送带凭据的请求)

为了让浏览器发送包含凭据的请求（即使是跨域源），要将 `credentials: 'include'` 添加到传递给 `fetch()` 方法的 `init` 对象。

```js
fetch('https://example.com', {
  credentials: 'include'
});
```

**备注：** 当请求使用 `credentials: 'include'` 时，响应的 `Access-Control-Allow-Origin` 不能使用通配符 "`*`"。在这种情况下，`Access-Control-Allow-Origin` **必须是当前请求的源**，在使用 CORS Unblock 插件的情况下请求仍会失败。

**备注：** 无论怎么设置，**浏览器都不应在 *预检请求* 中发送凭据**。了解更多：[跨域资源共享 > 附带身份凭证的请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#附带身份凭证的请求)

如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 `credentials: 'same-origin'`。

```js
// The calling script is on the origin 'https://example.com'

fetch('https://example.com', {
  credentials: 'same-origin'
});
```

要改为确保浏览器不在请求中包含凭据，请使用 `credentials: 'omit'`。

```js
fetch('https://example.com', {
  credentials: 'omit'
})
```

### [上传 JSON 数据](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传_json_数据)

使用 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) POST JSON数据

```js
  let data = {username: "example"};

  fetch("http://127.0.0.1/test/ajax/",{
    method:"POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  })
    .then(response => response.json())
    .then(data => console.log("Success:", data))
    .catch((error) => {
      console.log("Error:", error);
    });

```

### [上传文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传文件)

可以通过 HTML `<input type="file" />` 元素，[`FormData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData) 和 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 上传文件。

```js
  const formData = new FormData();
  const fileField = document.querySelector('input[type="file"]');
  formData.append("username", "abc123");
  formData.append("avatar", fileField.files[0]);

  fetch("http://127.0.0.1/test/ajax/", {
    method: "PUT",
    body: formData
  })
  .then(response => response.json())
  .then(result => {
    console.log("Success:", result);
  })
  .catch(error => {
    console.error("Error:", error);
  });
```

### [上传多个文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传多个文件)

可以通过 HTML `<input type="file" multiple />` 元素，[`FormData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData) 和 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 上传文件。

```js
const formData = new FormData();
const photos = document.querySelector('input[type="file"][multiple]');

formData.append('title', 'My Vegas Vacation');
for (let i = 0; i < photos.files.length; i++) {
  formData.append(`photos_${i}`, photos.files[i]);
}

fetch('https://example.com/posts', {
  method: 'POST',
  body: formData,
})
.then(response => response.json())
.then(result => {
  console.log('Success:', result);
})
.catch(error => {
  console.error('Error:', error);
});
```

### [逐行处理文本文件](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#逐行处理文本文件)

从响应中读取的分块不是按行分割的，并且是 `Uint8Array` 数组类型（不是字符串类型）。如果你想通过 `fetch()` 获取一个文本文件并逐行处理它，那需要自行处理这些复杂情况。以下示例展示了一种创建行迭代器来处理的方法（简单起见，假设文本是 UTF-8 编码的，且不处理 `fetch()` 的错误）。

```js
  async function* makeTextFileLineIterator(fileURL) {
    const utf8Decoder = new TextDecoder("utf8");
    const response = await fetch(fileURL);
    const reader = response.body.getReader();

    let {value: chunk, done: readerDone } = await reader.read();
    chunk = chunk ? utf8Decoder.decode(chunk) : "";

    const re = /\n|\r|\r\n/gm;
    let startIndex = 0;
    let result;
    for (;;){
      result = re.exec(chunk);
      if (!result) {
        if (readerDone) {
          break;
        }
        let remainder = chunk.substr(startIndex);
        ({value: chunk, done: readerDone} = await reader.read());
        chunk = remainder + (chunk ? utf8Decoder.decode(chunk) : "");
        startIndex = re.lastIndex = 0;
        continue;
      }
      yield chunk.substring(startIndex, result.index);
      startIndex = re.lastIndex;
    }
    if (startIndex < chunk.length) {
      // last line didn't end in a newline char
      yield chunk.substr(startIndex);
    }
  }

  async function run() {
    for await (let line of makeTextFileLineIterator(urlOfFile)){
      processLine(line);
    }
  }

  run();
```

### [检测请求是否成功](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#检测请求是否成功)

如果遇到网络故障或服务端的 CORS 配置错误时，[`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) promise 将会 reject，带上一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 对象。虽然这个情况经常是遇到了权限问题或类似问题——比如 404 不是一个网络故障。**想要精确的判断 `fetch()` 是否成功，需要包含 promise resolved 的情况，此时再判断 [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 是否为 true。**类似以下代码：

```js
  fetch("flowers.jpg")
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not OK");
      }
      return response.blob();
    })
    .then(myBlob => {
      myImage.src = URL.createObjectURL(myBlob);
    })
    .catch(error => {
      console.log('There has been a problem with your fetch operation:', error);
    });
```



### [自定义请求对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#自定义请求对象)

除了传给 `fetch()` 一个资源的地址，你还可以通过使用 [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 构造函数来创建一个 request 对象，然后再作为参数传给 `fetch()`：

```html
<img src="" id="img1">
<script type="text/javascript">

  const myHeaders = new Headers();
  const myRequest = new Request("image1/bg1.jpg", {
    method: "GET",
    headers: myHeaders,
    mode: "cors",
    cache: "default",
  });
  let myImage = document.getElementById("img1");
  fetch(myRequest)
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not OK");
      }
      return response.blob();
    })
    .then(myBlob => {
      myImage.src = URL.createObjectURL(myBlob);
    })
    .catch(error => {
      console.log('There has been a problem with your fetch operation:', error);
    });

</script>
```

`Request()` 和 `fetch()` 接受同样的参数。你甚至可以传入一个已存在的 request 对象来创造一个拷贝：

```js
const anotherRequest = new Request(myRequest, myInit);
```

这个很有用，因为 request 和 response bodies 只能被使用一次（译者注：这里的意思是因为设计成了 stream 的方式，所以它们只能被读取一次）。**创建一个拷贝就可以再次使用 request/response 了，当然也可以使用不同的 `init` 参数**。创建拷贝必须在读取 body 之前进行，而且读取拷贝的 body 也会将原始请求的 body 标记为已读。

> **备注：** [`clone()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/clone) 方法也可以用于创建一个拷贝。它和上述方法一样，如果 request 或 response 的 body 已经被读取过，那么将执行失败。区别在于， `clone()` 出的 body 被读取不会导致原 body 被标记为已读取。

## [Headers](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#headers)

使用 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 的接口，你可以通过 [`Headers()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/Headers) 构造函数来创建一个你自己的 headers 对象。一个 headers 对象是一个简单的多键值对：

```js
const content = 'Hello World';
const myHeaders = new Headers();

myHeaders.append('Content-Type', 'text/plain');
myHeaders.append('Content-Length', content.length.toString());
myHeaders.append('X-Custom-Header', 'ProcessThisImmediately');
```

也可以传入一个多维数组或者对象字面量：

```js
const myHeaders = new Headers({
  'Content-Type': 'text/plain',
  'Content-Length': content.length.toString(),
  'X-Custom-Header': 'ProcessThisImmediately'
});
```

它的内容可以被获取：

```js
console.log(myHeaders.has('Content-Type')); // true
console.log(myHeaders.has('Set-Cookie')); // false
myHeaders.set('Content-Type', 'text/html');
myHeaders.append('X-Custom-Header', 'AnotherValue');

console.log(myHeaders.get('Content-Length')); // 11
console.log(myHeaders.get('X-Custom-Header')); // ['ProcessThisImmediately', 'AnotherValue']

myHeaders.delete('X-Custom-Header');
console.log(myHeaders.get('X-Custom-Header')); // null
```

虽然一些操作只能在 [`ServiceWorkers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 中使用，但是它提供了更方便的操作 Headers 的 API。

**如果使用了一个不合法的 HTTP Header 属性名，那么 Headers 的方法通常都抛出 TypeError 异常**。如果不小心写入了一个不可写的属性（[见下方](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#guard)），也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：

```js
const myResponse = Response.error();
try {
  myResponse.headers.set('Origin', 'http://mybank.com');
} catch (e) {
  console.log('Cannot pretend to be a bank!');
}
```

最好在**在使用之前检查内容类型 `content-type` 是否正确**，比如：

```js
fetch(myRequest)
  .then(response => {
     const contentType = response.headers.get('content-type');
     if (!contentType || !contentType.includes('application/json')) {
       throw new TypeError("Oops, we haven't got JSON!");
     }
     return response.json();
  })
  .then(data => {
      /* process your data further */
  })
  .catch(error => console.error(error));
```

### [Guard](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#guard)

由于 Headers 可以在 request 中被发送或者在 response 中被接收，并且规定了哪些参数是可写的，**Headers 对象有一个特殊的 guard 属性。这个属性没有暴露给 Web，但是它影响到哪些内容可以在 Headers 对象中被操作。**

可能的值如下：

- `none`：默认的。
- `request`：从 request 中获得的 headers（[`Request.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/headers)）只读。
- `request-no-cors`：从不同域（[`Request.mode`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/mode) `no-cors`）的 request 中获得的 headers 只读。
- `response`：从 response 中获得的 headers（[`Response.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/headers)）只读。
- `immutable`：在 ServiceWorkers 中最常用的，**所有的 headers 都只读**。

> **备注：** 你不可以添加或者修改一个 guard 属性是 `request` 的 Request Header 的 `Content-Length` 属性。同样地，插入 `Set-Cookie` 属性到一个 response header 是不允许的，因此，Service Worker 中，不能给合成的 Response 设置 cookie。

## [Response 对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#response_对象)

如上所述，[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 实例是在 `fetch()` 处理完 promise 之后返回的。

你会用到的最常见的 response 属性有：

- [`Response.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/status) — 整数（默认值为 200）为response的状态码。
- [`Response.statusText`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/statusText) — 字符串（默认值为 ""），该值与 HTTP 状态码消息对应。 注意：HTTP/2 [不支持](https://fetch.spec.whatwg.org/#concept-response-status-message)状态消息
- [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) — 如上所示，该属性是来检查 response 的状态是否在 200 - 299（包括200 和 299）这个范围内。该属性返回一个布尔值。

它的实例也可用通过 JavaScript 来创建，但只有在 [`ServiceWorkers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 中使用 [`respondWith()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith) 方法并提供了一个自定义的 response 来接受 request 时才真正有用：

```js
const myBody = new Blob();

addEventListener('fetch', event => {
  // ServiceWorker intercepting a fetch
  event.respondWith(
    new Response(myBody, {
      headers: { 'Content-Type': 'text/plain' }
    })
  );
});
```

[`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 构造方法接受两个可选参数—— response 的 body 和一个初始化对象（与[`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 所接受的 init 参数类似）。

> **备注：** 静态方法 [`error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error) 只是返回了错误的 response。与此类似地，[`redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect) 只是返回了一个可以重定向至某 URL 的 response。这些也只与 Service Worker 有关。

## [Body](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#body)

不管是请求还是响应都能够包含 body 对象。body 也可以是以下任意类型的实例。

- [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
- [`ArrayBufferView`](https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBufferView) (Uint8Array等)
- [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)/File
- string
- [`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)
- [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)

Body 类定义了以下方法（这些方法都被 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)所实现）以获取 body 内容。这些方法都会返回一个被解析后的 Promise 对象和数据。

- [`Request.arrayBuffer()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/arrayBuffer) / [`Response.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/arrayBuffer)
- [`Request.blob()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/blob) / [`Response.blob()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/blob)
- [`Request.formData()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData) / [`Response.formData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/formData)
- [`Request.json()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/json) / [`Response.json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json)
- [`Request.text()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Request/text) / [`Response.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/text)

**相比于XHR，这些方法让非文本化数据的使用更加简单。**

请求体可以由传入 body 参数来进行设置：

```js
const form = new FormData(document.getElementById('login-form'));
fetch('/login', {
  method: 'POST',
  body: form
});
```

request 和 response（包括 `fetch()` 方法）都会试着自动设置 `Content-Type`。如果没有设置 `Content-Type` 值，发送的请求也会自动设值。

## [特性检测](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#特性检测)

Fetch API 的支持情况，可以通过检测 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers), [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request), [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 或 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 是否在 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 或 [`Worker`](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker) 域中来判断。例如：

```js
if (window.fetch) {
  // run my fetch request here
} else {
  // do something with XMLHttpRequest?
}
```



# Cross-global fetch usage

本文解释了在fetch时发生的边缘情况（以及潜在的其他APIs展示相同类型的资源检索行为）。当从“iframe”发起包含相对url的跨源fetch时，相对url用于针对当前全局位置而不是iframe的位置进行解析。

## [边缘情况](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Cross-global_fetch_usage#边缘情况)

大多数网站几乎不会遇到这种边缘情况。如下：

- 需要一个同源的 iframe
- 该同源 iframe 需要具有不同基址位置
- 必须使用跨全局的 fetch 函数, 例如. `frame.contentWindow.fetch()`
- 传递给 fetch 函数的是相对 URL

## [遇到的问题](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Cross-global_fetch_usage#遇到的问题)

以前，我们从当前全局 URL 中解析相对 URL，例如：

```js
let absolute = new URL(relative, window.location.href)
```

这样做不是什么大问题，只是表现出这种行为的不同 API 与规范中定义的行为的不一致可能导致问题的进一步发展。

## [解决方案](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Cross-global_fetch_usage#解决方案)

在 Firefox 60 及以后版本中，Mozilla 对相对 URL 的解析是相对于拥有`fetch()`函数的全局的。（见 [bug 1432272](https://bugzilla.mozilla.org/show_bug.cgi?id=1432272)）。因此在上述情形中，**URL 是相对于 iframe 的地址进行解析的**：

```js
let absolute = new URL(relative, frame.contentWindow.location.href)
```

---

# Response

 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 的 `Response` 接口呈现了对一次请求的响应数据。

你可以使用 [`Response.Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 构造函数来创建一个 `Response` 对象，但通常更可能遇到的情况是，其他的API操作返回了一个 Response 对象。例如一个service worker 的 [`Fetchevent.respondWith`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith)，或者一个简单的 [`GlobalFetch.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#构造函数)

- [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response)

  创建一个新的 `Response` 对象。

`**Response()**` 构造函数创建了一个新的 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象.

### [语法](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response#语法)

```js
let myResponse = new Response(body, init);
```

### [参数](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response#参数)

- *body* 可选

  一个定义 response 中 body 的对象. 可以为 `null` ，或是以下其中一个:[`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)[`BufferSource` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/BufferSource)[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)[`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)[`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)[`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)

- *init* 可选

  一个参数(options)对象，包含要应用到 response 上的任何自定义设置. 可能参数(options)是:

  `status`: response 的状态码, 例如:`200`.

  `statusText`: 和状态码关联的状态消息, 例如: `OK`.

  `headers`: 你想加到 response 上的任何 headers, 包含了一个 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象或满足对象语法的 [`ByteString`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String) key/value 对 (详见 [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)).

## [例子](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response#例子)

在我们的 [Fetch Response 示例](https://github.com/mdn/fetch-examples/tree/gh-pages/fetch-response)中 (参见[Fetch Response live](https://mdn.github.io/fetch-examples/fetch-response/)) 我们使用构造函数创建了一个新的Response 对象，传递一个新的 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 作为 body, 和一个包含自定义 `status` 和`statusText`的 init 对象:

```js
var myBlob = new Blob();
var init = { "status" : 200 , "statusText" : "SuperSmashingGreat!" };
var myResponse = new Response(myBlob,init);
```

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#属性)

- [`Response.headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/headers) 只读

  包含此 Response 所关联的 [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象。

- [`Response.ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 只读

  包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。

- [`Response.redirected`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirected) 只读

  表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。

- [`Response.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/status) 只读

  包含 Response 的状态码 （例如 `200` 表示成功）。

- [`Response.statusText`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/statusText) 只读

  包含了**与该 Response 状态码一致的状态信息**（例如，OK对应 `200`）。

- [`Response.type`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/type) 只读

  包含 Response 的类型（例如，`basic`、`cors`）。

- [`Response.url`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/url) 只读

  包含 Response 的URL。

- `Response.useFinalURL`

  包含了一个布尔值，来标示这是否是该 Response 的最终 URL。

`Response` 实现了 `Body` 接口，所以以下属性亦可用：

- [`Body.body` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) 只读

  一个简单的 getter，用于暴露一个 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 类型的 body 内容。

- [`Body.bodyUsed` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/bodyUsed) 只读

  包含了一个[`布尔值` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)来标示该 Response 是否读取过 `Body`。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#方法)

- [`Response.clone()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/clone)

  创建一个 `Response` 对象的克隆。

- [`Response.error()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error)

  返回一个绑定了网络错误的新的 `Response` 对象。

- [`Response.redirect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect)

  用另一个 URL 创建一个新的 `Response`。

`Response` 实现了 `Body` 接口，所以以下方法同样可用：

- [`Body.arrayBuffer()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 格式的 Promise 对象。**

- [`Body.blob()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/blob)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 格式的 Promise 对象。**

- [`Body.formData()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/formData)

  读取[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 格式的 Promise 对象。**

- [`Body.json()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/json)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 `JSON` 格式的 Promise 对象。**

- [`Body.text()` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/text)

  读取 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），**并返回一个被解析为 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 格式的 Promise 对象。**

你也可以使用 [`Response.Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 这样的构造方法，来创建自定义的 `Response` 对象：

```js
const response = new Response();
```

## [示例](https://developer.mozilla.org/zh-CN/docs/Web/API/Response#示例)

在我们的[基础实例](https://github.com/mdn/fetch-examples/tree/gh-pages/basic-fetch) ([点击运行](https://mdn.github.io/fetch-examples/basic-fetch/)) 中 , 我们使用了一个简单的函数调用 , 调用了 `fetch()` 函数来获取一张图片并将其显示在 HTML 的 IMG 标签中 , `fetch()` 函数返回了一个 Promise，它使用与资源获取操作相关联的 Response 对象进行解析. 你会注意到，由于我们正在请求一张图片，我们需要运行[`Body.blob` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Response/blob)（[`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 实现了），以为响应提供正确的 MIME 类型。

```js
const image = document.querySelector('.my-image');

fetch('flowers.jpg').then(function(response) {
  return response.blob();
}).then(function(blob) {
  const objectURL = URL.createObjectURL(blob);
  image.src = objectURL;
});
```

---



# Blob

`Blob` 对象表示一个**不可变、原始数据的类文件对象**。它的数据可以按文本或二进制的格式进行读取，也可以转换成 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 来用于数据操作。 

Blob 表示的不一定是JavaScript原生格式的数据。[`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 接口基于`Blob`，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

要从其他非blob对象和数据构造一个 `Blob`，请使用 [`Blob()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob) 构造函数。要创建一个 blob 数据的子集 blob，请使用 [`slice()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) 方法。要获取用户文件系统上的文件对应的 `Blob` 对象，请参阅 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 文档。

接受 `Blob` 对象的API也被列在 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 文档中。

**注意：**`slice()` 方法原本接受 `length` 作为第二个参数，以表示复制到新 `Blob` 对象的字节数。如果设置的参数使 `start + length` 超出了源 `Blob` 对象的大小，则返回从开始到结尾的所有数据。

> **注意：**`slice()` 方法在某些浏览器和版本上带有浏览器引擎前缀：比如 Firefox 12 及更早版本的`blob.mozSlice()` 和 Safari 中的`blob.webkitSlice()`。 没有浏览器引擎前缀的老版本 `slice()` 方法有不同的语义，并且已过时。Firefox 30 取消了对 `blob.mozSlice()` 的支持。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#构造函数)

- [`Blob(blobParts[, options\])`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob)

  返回一个新创建的 `Blob` 对象，其内容由参数中给定的数组串联组成。

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#属性)

- [`Blob.size`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size) 只读

  `Blob` 对象中**所包含数据的大小（字节）**。

- [`Blob.type`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type) 只读

  一个字符串，**表明该 `Blob` 对象所包含数据的 MIME 类型**。如果类型未知，则该值为空字符串。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#方法)

- [`Blob.slice([start[, end[, contentType\]]])`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice)

  返回一个新的 `Blob` 对象，包含了源 `Blob` 对象中指定范围内的数据。

- [`Blob.stream()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream)

  返回一个能读取blob内容的 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)。

- [`Blob.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text)

  返回一个promise且包含blob所有内容的UTF-8格式的 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)。

- [`Blob.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer)

  返回一个promise且包含blob所有内容的二进制格式的 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 

## [示例](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#示例)

### [Blob 构造函数用法举例](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#blob_构造函数用法举例)

[`Blob() 构造函数`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob)允许通过其它对象创建 Blob 对象。比如，用字符串构建一个 blob：

```js
  let debug = {hello: "world"};
  let blob = new Blob([JSON.stringify(debug, null, 2)], {type: "application/json"});
  console.log(blob.size);  // 22
```

> [`BlobBuilder`](https://developer.mozilla.org/zh-CN/docs/Web/API/BlobBuilder) 接口提供了另外一种创建`Blob` 对象的方式，但该方式现在已经废弃，不应继续使用：

```
var builder = new BlobBuilder();
var fileParts = ['<a id="a"><b id="b">hey!</b></a>'];
builder.append(fileParts[0]);
var myBlob = builder.getBlob('text/xml');
```

### [示例：使用 Blob 创建一个指向类型化数组的URL](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#示例：使用_blob_创建一个指向类型化数组的url)

参考下面的代码：

```js
var typedArray = GetTheTypedArraySomehow();
var blob = new Blob([typedArray.buffer], {type: 'application/octet-stream'}); // 传入一个合适的 MIME 类型
var url = URL.createObjectURL(blob);
// 会产生一个类似 blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串
// 你可以像使用普通 URL 那样使用它，比如用在 img.src 上。
```

### [示例：从 Blob 中提取数据](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob#示例：从_blob_中提取数据)

一种从Blob中读取内容的方法是使用 [`FileReader`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader)。以下代码将 Blob 的内容作为类型数组读取：

```js
var reader = new FileReader();
reader.addEventListener("loadend", function() {
   // reader.result 包含被转化为类型数组 typed array 的 blob
});
reader.readAsArrayBuffer(blob);
```

另一种读取Blob中内容的方式是使用Response对象。下述代码将Blob中的内容读取为文本：

```js
var text = await (new Response(blob)).text();
```

通过使用 [`FileReader`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader) 的其它方法可以把 Blob 读取为字符串或者数据URL。

---

# URL API

URL API是一个URL标准的组件，它定义了有效的[Uniform Resource Locator](https://developer.mozilla.org/zh-CN/docs/Glossary/URL)和访问、操作URL的API。URL标准还定义了像域名、主机和IP地址等概念，并尝试以标准的方式去描述用于以键/值对的形式提交web表单内容的遗留`application/x-www-form-urlencoded` [MIME type](https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type) 。

## [URL的概念和用法](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#url的概念和用法)

URL标准的主要内容是由URL的定义以及它的结构和解析方式决定的。还介绍了与网络上计算机寻址有关的各种术语的定义，**并指定了解析IP地址和DOM地址的算法**。大多数开发人员更感兴趣的是API本身。

### [使用URL组件](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#使用url组件)

给指定的URL创建一个 [`URL`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL) 对象将解析URL并通过其属性对其组成部分的快速访问。

```js
  let addr = new URL("https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API");
  let host = addr.host;
  let path = addr.pathname;
  console.log(host);  // developer.mozilla.org
  console.log(path);  // /zh-CN/docs/Web/API/URL_API
```

上面的代码片段为您正在阅读的文章创建一个`URL`对象，然后获取 [`host`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/host) 和 [`pathname`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/pathname) 属性。在本例中，这些字符串的值分别是`developer.mozilla.org` 和`/zh-CN/docs/Web/API/URL_API`。

### [修改URL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#修改url)

`URL`对象的大部分属性都是可设置的；您可以向它们写入新值来更改对象所表示的URL。例如，要创建一个URL对象并设置它的用户名：

```js
  let myUsername = "kop";
  let addr = new URL("https://mysite.com/login");
  addr.username = myUsername;
  console.log(addr.href);  // https://kop@mysite.com/login
```

设置 [`username`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/username) 值不仅是设置该属性的值，而且更新整个URL。执行上面的代码片段后， [`addr.href`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/href) 的返回值是`https://kop@mysite.com/login`。对于任何可写属性都是如此。

### [查询](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#查询)

 [`search`](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/search) 属性在URL上包含URL的查询字符串部分。例如，如果URL是`https://mysite.com/login?user=someguy&page=news`，那么`search` 属性的值是`?user=someguy&page=news`。您还可以使用 [`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams) 对象的 [`get()`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/get) 查找单个参数的值：

```js
  let addr = new URL("https://mysite.com/login?user=someguy&page=news");
  try {
    loginUser(addr.searchParams.get("user"));
    gotoPage(addr.searchParams.get("page"));
  } catch(err){
    showErrorMessage(err);
  }
```

例如，在上面的代码片段中，从查询中提取用户名和目标页面，并将其传递给适当的函数，站点代码使用这些函数登录并将用户路由到站点的目的页面。

`URLSearchParams`中的其他函数允许修改改、添加和删除键和值，甚至对参数列表进行排序。

## [例子](https://developer.mozilla.org/zh-CN/docs/Web/API/URL_API#例子)

如果希望处理URL中包含的参数，可以手动进行处理，但是创建一个URL对象更容易。下面的`fillTableWithParameters()`函数接受一个表示[``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table)的  [`HTMLTableElement`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLTableElement) 对象作为输入。将行添加到表中，每个行对应参数中找到的键，第一列包含键，第二列包含值。

注意，在生成表之前调用 [`URLSearchParams.sort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/sort) 对参数列表进行排序。

​     

```js
function fillTableWithParameters(tbl) {
  let url = new URL(document.location.href);
  url.searchParams.sort();
  let keys = url.searchParams.keys();

  for (let key of keys) {
    let val = url.searchParams.get(key);
    let row = document.createElement("tr");
    let cell = document.createElement("td");
    cell.innerText = key;
    row.appendChild(cell);
      
    cell = document.createElement("td");
    cell.innerText = val;
      
    row.appendChild(cell);
    tbl.appendChild(row);
  };
}
```

----

# XMLHttpRequest

`XMLHttpRequest`（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。`XMLHttpRequest` 在 [AJAX](https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX) 编程中被大量使用。



尽管名称如此，`XMLHttpRequest` 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。

如果您的通信流程需要从服务器端接收事件或消息数据，请考虑通过 [`EventSource`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource) 接口使用 [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)。对于全双工的通信， [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) 可能是更好的选择。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#构造函数)

- [`XMLHttpRequest()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/XMLHttpRequest)

  该构造函数用于初始化一个 `XMLHttpRequest` 实例对象。在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#属性)

*此接口继承了 [`XMLHttpRequestEventTarget`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestEventTarget) 和 [`EventTarget`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget) 的属性。*

- [`XMLHttpRequest.onreadystatechange`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readystatechange_event)

  当 `readyState` 属性发生变化时，调用的 `event handler`。

- [`XMLHttpRequest.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState) 只读

  返回 一个无符号短整型（`unsigned short`）数字，代表请求的状态码。

- [`XMLHttpRequest.response`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/response) 只读

  返回一个 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)、[`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)、[`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)，或 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString)，具体是哪种类型取决于 [`XMLHttpRequest.responseType`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType) 的值。其中包含整个响应实体（response entity body）。

- [`XMLHttpRequest.responseText`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseText) 只读

  返回一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString)，该 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString) 包含对请求的响应，如果请求未成功或尚未发送，则返回 `null`。

- [`XMLHttpRequest.responseType`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType)

  一个用于定义响应类型的枚举值（enumerated value）。

- [`XMLHttpRequest.responseURL`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseURL) 只读

  返回经过序列化（serialized）的响应 URL，如果该 URL 为空，则返回空字符串。

- [`XMLHttpRequest.responseXML`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseXML) 只读

  返回一个 [`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)，其中包含该请求的响应，如果请求未成功、尚未发送或是不能被解析为 XML 或 HTML，则返回 `null`。

- [`XMLHttpRequest.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status) 只读

  返回一个无符号短整型（`unsigned short`）数字，代表请求的响应状态。

- [`XMLHttpRequest.statusText`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/statusText) 只读

  返回一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString)，其中包含 HTTP 服务器返回的响应状态。与 [`XMLHTTPRequest.status`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status) 不同的是，它包含完整的响应状态文本（例如，"`200 OK`"）。

> **注意：**根据 HTTP/2 规范（[8.1.2.4](https://http2.github.io/http2-spec/#rfc.section.8.1.2.4) [Response Pseudo-Header Fields](https://http2.github.io/http2-spec/#HttpResponse)，响应伪标头字段），HTTP/2 没有定义任何用于携带 HTTP/1.1 状态行中包含的版本（version）或者原因短语（reason phrase）的方法。

[`XMLHttpRequest.timeout`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/timeout)

一个无符号长整型（`unsigned long`）数字，表示该请求的最大请求时间（毫秒），若超出该时间，请求会自动终止。

XMLHttpRequestEventTarget.ontimeout

当请求超时调用的 `event handler`。

[`XMLHttpRequest.upload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload) 只读

`XMLHttpRequestUpload`，**代表上传进度**。

[`XMLHttpRequest.withCredentials`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials)

一个[`布尔值` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，用来指定跨域 `Access-Control` 请求是否应当带有授权信息，如 cookie 或授权 header 头。

### [非标准属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#非标准属性)

- [`XMLHttpRequest.channel`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/channel)只读

  一个 `nsIChannel`，对象在执行请求时使用的通道。

- [`XMLHttpRequest.mozAnon`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozAnon)只读

  一个布尔值，如果为真，请求将在没有 cookie 和身份验证 header 头的情况下发送。

- [`XMLHttpRequest.mozSystem`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozSystem)只读

  一个布尔值，如果为真，则在请求时不会强制执行同源策略。

- [`XMLHttpRequest.mozBackgroundRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozBackgroundRequest)

  一个布尔值，它指示对象是否是后台服务器端的请求。

- [`XMLHttpRequest.mozResponseArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozResponseArrayBuffer) 已废弃 Gecko 6 只读

  一个 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)，把请求的响应作为一个 JavaScript TypedArray。

- `XMLHttpRequest.multipart`已废弃 Gecko 22

  **这是一个 Gecko 专有属性，是一个布尔值，已在 Firefox/Gecko 22 中被删除。**请考虑使用 [Server-Sent Event](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)、[Web Socket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)、或来自进度事件的 `responseText` 代替。

### [事件处理器](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#事件处理器)

作为 `XMLHttpRequest` 实例的属性之一，所有浏览器都支持 `onreadystatechange`。

后来，许多浏览器实现了一些额外的事件（`onload`、`onerror`、`onprogress` 等）。详见[Using XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)。

更多现代浏览器，包括 Firefox，除了可以设置 `on*` 属性外，也提供标准的监听器 [`addEventListener()`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener) API 来监听`XMLHttpRequest` 事件。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#方法)

- [`XMLHttpRequest.abort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort)

  如果请求已被发出，则立刻中止请求。

- [`XMLHttpRequest.getAllResponseHeaders()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getAllResponseHeaders)

  以字符串的形式返回所有用 [CRLF](https://developer.mozilla.org/zh-CN/docs/Glossary/CRLF) 分隔的响应头，如果没有收到响应，则返回 `null`。

- [`XMLHttpRequest.getResponseHeader()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getResponseHeader)

  返回包含指定响应头的字符串，如果响应尚未收到或响应中不存在该报头，则返回 `null`。

- [`XMLHttpRequest.open()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open)

  初始化一个请求。该方法只能在 JavaScript 代码中使用，若要在 native code 中初始化请求，请使用 [`openRequest()`](https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIXMLHttpRequest)。

- [`XMLHttpRequest.overrideMimeType()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/overrideMimeType)

  覆写由服务器返回的 MIME 类型。

- [`XMLHttpRequest.send()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send)

  发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。

- [`XMLHttpRequest.setRequestHeader()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader)

  设置 HTTP 请求头的值。必须在 `open()` 之后、`send()` 之前调用 `setRequestHeader()` 方法。

### [非标准方法](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#非标准方法)

- `XMLHttpRequest.init()`

  在 C++ 代码中初始化一个 XHR 对象。

  >**警告：**该方法不能在 JavaScript 代码中使用。

- `XMLHttpRequest.openRequest()`

  初始化一个请求。这个方法只能在原生 C++ 代码中使用；如果用 JavaScript 代码来初始化请求，使用 [`open()`](https://developer.mozilla.org/zh-cn/nsIXMLHttpRequest#open()) 代替。可参考 `open()` 的文档。

- `XMLHttpRequest.sendAsBinary()`Deprecated

  `send()` 方法的变体，用来发送二进制数据。

## [事件](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest#事件)

- [`abort`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort_event)

  当 request 被停止时触发，例如当程序调用 [`XMLHttpRequest.abort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort) 时。 也可以使用 [`onabort`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/abort_event) 属性。

- [`error`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/error_event)

  当 request 遭遇错误时触发。 也可以使用 [`onerror`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/error_event) 属性

- [`load`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/load_event)

  [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)请求成功完成时触发。 也可以使用 [`onload`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/load_event) 属性.

- [`loadend`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadend_event)

  当请求结束时触发, 无论请求成功 ( [`load`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/load_event)) 还是失败 ([`abort`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort_event) 或 [`error`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/error_event))。 也可以使用 `onloadend` 属性。

- [`loadstart`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadstart_event)

  接收到响应数据时触发。 也可以使用 [`onloadstart`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/loadstart_event) 属性。

- [`progress`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/progress_event)

  当请求接收到更多数据时，周期性地触发。 也可以使用 [`onprogress`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/XMLHttpRequest/progress_event) 属性。

- [`timeout`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/timeout_event)

  在预设时间内没有接收到响应时触发。 也可以使用 `ontimeout` 属性。

# 使用 XMLHttpRequest

在该教程中，我们将使用[`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 来发送 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 请求以实现网站和服务器之间的数据交换。`XMLHttpRequest`常见和晦涩的使用情况都将包含在例子中。

发送一个 HTTP 请求，需要创建一个 `XMLHttpRequest` 对象，打开一个 URL，最后发送请求。当所有这些事务完成后，该对象将会包含一些诸如响应主体或 [HTTP status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) 的有用信息。

```js
  function reqListener(){
    console.log(this.responseText);
  }

  let oReq = new XMLHttpRequest();
  oReq.addEventListener("load",reqListener);
  oReq.open("GET","http://127.0.0.1/test/genomefile.txt");
  oReq.send();
```

## [请求类型](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#请求类型)

通过 `XMLHttpRequest` 生成的请求可以有两种方式来获取数据，**异步模式或同步模式**。请求的类型是由这个 `XMLHttpRequest` 对象的 [open()](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open) 方法的**第三个参数`async`的值**决定的。如果该参数的值为 `false`，则该 `XMLHttpRequest`请求以同步模式进行，否则该过程将以异步模式完成。这两种类型请求的详细讨论和指南可以在[同步和异步请求](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests)页找到。

> **注意：**`XMLHttpRequest` 构造函数并不仅限于 XML 文档。它之所以使用“XML”开头是因为在它诞生之时，**原先用于异步数据交换的主要格式便是XML。**

## [处理响应](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#处理响应)

W3C规范定义了 [`XMLHttpRequest()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/XMLHttpRequest) 对象的几种类型的[响应属性](https://xhr.spec.whatwg.org/)。这些属性告诉客户端关于 `XMLHttpRequest` 返回状态的重要信息。一些处理非文本返回类型的用例，可能包含下面章节所描述的一些操作和分析。

### [分析并操作 responseXML属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#分析并操作_responsexml属性)

如果你使用 `XMLHttpRequest` 来获得一个远程的 XML 文档的内容，[`responseXML`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseXML) 属性将会是一个由 XML 文档解析而来的 DOM 对象，这很难被操作和分析。这里有五种主要的分析 XML 文档的方式：

1. 使用 [XPath](https://developer.mozilla.org/zh-CN/docs/Web/XPath) 定位到文档的指定部分。
2. 手动 [解析和序列化 XML](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Parsing_and_serializing_XML) 为字符串或对象。
3. 使用 [XMLSerializer](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLSerializer) 把 DOM 树序列化成字符串或文件。
4. 如果你预先知道 XML 文档的内容，你可以使用 [RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)。如果你用 `RegExp` 扫描时受到换行符的影响，你也许想要删除所有的换行符。然而，这种方法是"最后手段"，因为如果 XML 代码发生轻微变化，该方法将可能失败。

### [解析和操作包含 HTML 文档的 responseText 属性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#解析和操作包含_html_文档的_responsetext_属性)

如果使用 `XMLHttpRequest` 从远端获取一个 HTML 页面，则所有 HTML 标记会以字符串的形式存放在responseText 属性里，这样就使得操作和解析这些标记变得困难。解析这些HTML标记主要有三种方式：

1. 使用 `XMLHttpRequest.responseXML` 属性。
2. 将内容通过 `fragment.body.innerHTML` 注入到一个 [文档片段](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment) 中，并遍历 DOM 中的片段。
3. 如果你预先知道 HTML 文档的内容，你可以使用 [RegExp ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)。如果你用 RegExp 扫描时受到换行符的影响，你也许想要删除所有的换行符。 然而，这种方法是"最后手段"，因为如果 HTML 代码发生轻微变化，该方法将可能失败。

## [处理二进制数据](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#处理二进制数据)

尽管 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 一般用来发送和接收文本数据，但其实也可以发送和接收二进制内容。**有许多经过良好测试的方法来强制使用 `XMLHttpRequest` 发送二进制数据**。利用 `XMLHttpRequest` 对象的 [`overrideMimeType()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/overrideMimeType) 方法是一个解决方案，虽然它并不是一个标准方法。

```js
var oReq = new XMLHttpRequest();
oReq.open("GET", url);
// 以二进制字符串形式检索未处理的数据
oReq.overrideMimeType("text/plain; charset=x-user-defined");
/* ... */
```

然而，自从 [`responseType`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType) 属性目前支持大量附加的内容类型后，已经出现了很多的现代技术，它们使得发送和接收二进制数据变得更加容易。

例如，考虑以下代码，它使用 `"arraybuffer"` 的 `responseType` 来将远程内容获取到一个存储原生二进制数据的 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 对象中。

```js
var oReq = new XMLHttpRequest();

oReq.onload = function(e) {
  var arraybuffer = oReq.response; // 不是 responseText ！
  /* ... */
}
oReq.open("GET", url);
oReq.responseType = "arraybuffer";
oReq.send();
```

更多示例请参考 [发送和接收二进制数据](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data)。

`XMLHttpRequest` 提供了各种在请求被处理期间发生的事件以供监听。这包括定期进度通知、 错误通知，等等。

支持 DOM 的 progress 事件监测之于 `XMLHttpRequest` 传输，遵循 Web API [进度事件规范](https://dev.w3.org/2006/webapi/progress/Progress.html)：这些事件实现了 [`ProgressEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/ProgressEvent) 接口。

- `progress (en-US)`

  检索的数据量发生了变化。

- `load (en-US)`

  传输完成，所有数据保存在 `response` 中。

```js
  let oReq = new XMLHttpRequest();
  oReq.addEventListener("progress", updateProgress);
  oReq.addEventListener("load", transferComplete);
  oReq.addEventListener("error", transferFailed);
  oReq.addEventListener("abort",transferCanceled);

  oReq.open("GET","http://127.0.0.1/test/genomefile.txt");
  oReq.send();

  // 服务端到客户端的传输进程（下载）
  function updateProgress(oEvent){
    if (oEvent.lengthComputable) {
      let percentCOmplete = oEvent.loaded / oEvent.total * 100;
      console.log(percentCOmplete);
      // ...
    }else{
      // 总大小未知时不能计算进程信息
    }
  }

  function transferComplete(oEvent){
    console.log("The transfer is complete.");
  }

  function transferFailed(evt) {
    console.log("An error occurred while transferring the file.");
  }

  function transferCanceled(evt) {
    console.log("The transfer has been canceled by the user.");
  }
```

第 3-6 行为多种事件添加了事件监听，这些事件在使用 `XMLHttpRequest` 执行数据传输时被发出。

> **注意：** 你需要**在请求调用 `open()` 之前添加事件监听**。否则 `progress` 事件将不会被触发。

在上一个例子中，progress 事件被指定由 `updateProgress()` 函数处理，并接收到传输的总字节数和已经传输的字节数，**它们分别在事件对象的 `total` 和 `loaded` 属性里**。但是如果 `lengthComputable` 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。

progress 事件同时存在于下载和上传的传输。下载相关事件在 `XMLHttpRequest` 对象上被触发，就像上面的例子一样。上传相关事件在 `XMLHttpRequest.upload` 对象上被触发，像下面这样：

```js
var oReq = new XMLHttpRequest();

oReq.upload.addEventListener("progress", updateProgress);
oReq.upload.addEventListener("load" , transferComplete);
oReq.upload.addEventListener("error", transferFailed  );
oReq.upload.addEventListener("abort", transferCanceled);

oReq.open();
```

> **注意：**progress 事件在使用 `file:` 协议的情况下是无效的。

**注意：**从 Gecko 9.0 开始，进度事件现在可以依托于每一个传入的数据块，包括进度事件被触发前在已经接受了最后一个数据包且连接已经被关闭的情况下接收到的最后一个块。**这种情况下，当该数据包的 load 事件发生时 progress 事件会被自动触发**。这使你可以只关注 progress 事件就可以可靠的监测进度。

> **注意：**在 Gecko 12.0 中，当 `responseType` 为 "moz-blob" 时，如果你的 progress 事件被触发，则响应的值是一个包含了接收到的数据的 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 。

使用 `loadend` 事件可以侦测到所有的三种加载结束条件（`abort`、`load`，或 `error`）：

```js
req.addEventListener("loadend", loadEnd);

function loadEnd(e) {
  console.log("The transfer finished (although we don't know if it succeeded or not).");
}
```

需要注意的是，**没有方法可以确切的知道** `loadend` 事件接收到的信息是来自何种条件引起的操作终止；但是你可以在所有传输结束的时候使用这个事件处理。

## [提交表单和上传文件](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#提交表单和上传文件)

`XMLHttpRequest` 的实例有两种方式提交表单：

- 使用 AJAX
- 使用 [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) API

第二种方式（使用 `FormData` API）是最简单最快捷的，但是缺点是被收集的数据无法使用[ JSON.stringify()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) 转换为一个 JSON 字符串。
只使用 AJAX 则更为复杂，但也更灵活、更强大。

### [仅使用 XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#仅使用_xmlhttprequest)

在大多数用例中，提交表单时即便不使用 `FormData` API 也不会要求其他的 API。唯一的例外情况是，**如果你要上传一个或多个文件**，你需要额外的 `FileReader` API。

#### 提交方法简介

一个 html <form> 可以用以下四种方式发送：

- 使用 `POST` 方法，并将 `enctype` 属性设置为 `application/x-www-form-urlencoded` (默认)
- 使用 `POST` 方法，并将 `enctype` 属性设置为 `text/plain`
- 使用 `POST` 方法，并将 `enctype` 属性设置为 `multipart/form-data`
- 使用 `GET` 方法（**这种情况下 `enctype` 属性会被忽略**）

现在，我们提交一个表单，它里面有两个字段，分别被命名为 `foo` 和 `baz`。如果你用 `POST` 方法，那么服务器将会接收到一个字符串类似于下面三种情况之一，其中的区别依赖于你采用何种编码类型：

- 方法：`POST`；编码类型：`application/x-www-form-urlencoded`（默认）:

```tex
Content-Type: application/x-www-form-urlencoded

foo=bar&baz=The+first+line.%0D%0AThe+second+line.%0D%0A
```

- 方法：`POST`；编码类型：`text/plain`：

```
Content-Type: text/plain

foo=bar
baz=The first line.
The second line.
```

- 方法：`POST`；编码类型：`multipart/form-data`：

  ```http
  Content-Type: multipart/form-data; boundary=---------------------------314911788813839
  
  -----------------------------314911788813839
  Content-Disposition: form-data; name="foo"
  
  bar
  -----------------------------314911788813839
  Content-Disposition: form-data; name="baz"
  
  The first line.
  The second line.
  
  -----------------------------314911788813839--
  ```

相反的，如果你用 `GET` 方法，像下面这样的字符串将被简单的附加到 URL：

```js
?foo=bar&baz=The%20first%20line.%0AThe%20second%20line.
```

#### 一个小框架

所有这些事情都是由浏览器在你提交一个 <form> 的时候自动完成的。但是如果你想要用 JavaScript 做同样的事情，你不得不告诉解释器所有的事。那么，如何发送表单这件事在使用纯粹的 AJAX 时会复杂到无法在这里解释清楚。基于这个原因，我们提供一个完整的（但仍然教条的）框架，它可以使用所有的四种提交方式，甚至上传文件：

```html
<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Sending forms with pure AJAX &ndash; MDN</title>
<script type="text/javascript">

"use strict";

/*\
|*|
|*|  :: XMLHttpRequest.prototype.sendAsBinary() Polyfill ::
|*|
|*|  https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#sendAsBinary()
\*/

if (!XMLHttpRequest.prototype.sendAsBinary) {
  XMLHttpRequest.prototype.sendAsBinary = function(sData) {
    var nBytes = sData.length, ui8Data = new Uint8Array(nBytes);
    for (var nIdx = 0; nIdx < nBytes; nIdx++) {
      ui8Data[nIdx] = sData.charCodeAt(nIdx) & 0xff;
    }
    /* send as ArrayBufferView...: */
    this.send(ui8Data);
    /* ...or as ArrayBuffer (legacy)...: this.send(ui8Data.buffer); */
  };
}

/*\
|*|
|*|  :: AJAX Form Submit Framework ::
|*|
|*|  https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest
|*|
|*|  This framework is released under the GNU Public License, version 3 or later.
|*|  https://www.gnu.org/licenses/gpl-3.0-standalone.html
|*|
|*|  Syntax:
|*|
|*|   AJAXSubmit(HTMLFormElement);
\*/

var AJAXSubmit = (function () {

  function ajaxSuccess () {
    /* console.log("AJAXSubmit - Success!"); */
    console.log(this.responseText);
    /* you can get the serialized data through the "submittedData" custom property: */
    /* console.log(JSON.stringify(this.submittedData)); */
  }

  function submitData (oData) {
    /* the AJAX request... */
    var oAjaxReq = new XMLHttpRequest();
    oAjaxReq.submittedData = oData;
    oAjaxReq.onload = ajaxSuccess;
    if (oData.technique === 0) {
      /* method is GET */
      oAjaxReq.open("get", oData.receiver.replace(/(?:\?.*)?$/,
          oData.segments.length > 0 ? "?" + oData.segments.join("&") : ""), true);
      oAjaxReq.send(null);
    } else {
      /* method is POST */
      oAjaxReq.open("post", oData.receiver, true);
      if (oData.technique === 3) {
        /* enctype is multipart/form-data */
        var sBoundary = "---------------------------" + Date.now().toString(16);
        oAjaxReq.setRequestHeader("Content-Type", "multipart\/form-data; boundary=" + sBoundary);
        oAjaxReq.sendAsBinary("--" + sBoundary + "\r\n" +
            oData.segments.join("--" + sBoundary + "\r\n") + "--" + sBoundary + "--\r\n");
      } else {
        /* enctype is application/x-www-form-urlencoded or text/plain */
        oAjaxReq.setRequestHeader("Content-Type", oData.contentType);
        oAjaxReq.send(oData.segments.join(oData.technique === 2 ? "\r\n" : "&"));
      }
    }
  }

  function processStatus (oData) {
    if (oData.status > 0) { return; }
    /* the form is now totally serialized! do something before sending it to the server... */
    /* doSomething(oData); */
    /* console.log("AJAXSubmit - The form is now serialized. Submitting..."); */
    submitData (oData);
  }

  function pushSegment (oFREvt) {
    this.owner.segments[this.segmentIdx] += oFREvt.target.result + "\r\n";
    this.owner.status--;
    processStatus(this.owner);
  }

  function plainEscape (sText) {
    /* How should I treat a text/plain form encoding?
       What characters are not allowed? this is what I suppose...: */
    /* "4\3\7 - Einstein said E=mc2" ----> "4\\3\\7\ -\ Einstein\ said\ E\=mc2" */
    return sText.replace(/[\s\=\\]/g, "\\$&");
  }

  function SubmitRequest (oTarget) {
    var nFile, sFieldType, oField, oSegmReq, oFile, bIsPost = oTarget.method.toLowerCase() === "post";
    /* console.log("AJAXSubmit - Serializing form..."); */
    this.contentType = bIsPost && oTarget.enctype ? oTarget.enctype : "application\/x-www-form-urlencoded";
    this.technique = bIsPost ?
        this.contentType === "multipart\/form-data" ? 3 : this.contentType === "text\/plain" ? 2 : 1 : 0;
    this.receiver = oTarget.action;
    this.status = 0;
    this.segments = [];
    var fFilter = this.technique === 2 ? plainEscape : escape;
    for (var nItem = 0; nItem < oTarget.elements.length; nItem++) {
      oField = oTarget.elements[nItem];
      if (!oField.hasAttribute("name")) { continue; }
      sFieldType = oField.nodeName.toUpperCase() === "INPUT" ? oField.getAttribute("type").toUpperCase() : "TEXT";
      if (sFieldType === "FILE" && oField.files.length > 0) {
        if (this.technique === 3) {
          /* enctype is multipart/form-data */
          for (nFile = 0; nFile < oField.files.length; nFile++) {
            oFile = oField.files[nFile];
            oSegmReq = new FileReader();
            /* (custom properties:) */
            oSegmReq.segmentIdx = this.segments.length;
            oSegmReq.owner = this;
            /* (end of custom properties) */
            oSegmReq.onload = pushSegment;
            this.segments.push("Content-Disposition: form-data; name=\"" +
                oField.name + "\"; filename=\"" + oFile.name +
                "\"\r\nContent-Type: " + oFile.type + "\r\n\r\n");
            this.status++;
            oSegmReq.readAsBinaryString(oFile);
          }
        } else {
          /* enctype is application/x-www-form-urlencoded or text/plain or
             method is GET: files will not be sent! */
          for (nFile = 0; nFile < oField.files.length;
              this.segments.push(fFilter(oField.name) + "=" + fFilter(oField.files[nFile++].name)));
        }
      } else if ((sFieldType !== "RADIO" && sFieldType !== "CHECKBOX") || oField.checked) {
        /* NOTE: this will submit _all_ submit buttons. Detecting the correct one is non-trivial. */
        /* field type is not FILE or is FILE but is empty */
        this.segments.push(
          this.technique === 3 ? /* enctype is multipart/form-data */
            "Content-Disposition: form-data; name=\"" + oField.name + "\"\r\n\r\n" + oField.value + "\r\n"
          : /* enctype is application/x-www-form-urlencoded or text/plain or method is GET */
            fFilter(oField.name) + "=" + fFilter(oField.value)
        );
      }
    }
    processStatus(this);
  }

  return function (oFormElement) {
    if (!oFormElement.action) { return; }
    new SubmitRequest(oFormElement);
  };

})();

</script>
</head>
<body>

<h1>Sending forms with pure AJAX</h1>

<h2>Using the GET method</h2>

<form action="register.php" method="get" onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Registration example</legend>
    <p>
      First name: <input type="text" name="firstname" /><br />
      Last name: <input type="text" name="lastname" />
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>

<h2>Using the POST method</h2>
<h3>Enctype: application/x-www-form-urlencoded (default)</h3>

<form action="register.php" method="post" onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Registration example</legend>
    <p>
      First name: <input type="text" name="firstname" /><br />
      Last name: <input type="text" name="lastname" />
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>

<h3>Enctype: text/plain</h3>

<form action="register.php" method="post" enctype="text/plain"
    onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Registration example</legend>
    <p>
      Your name: <input type="text" name="user" />
    </p>
    <p>
      Your message:<br />
      <textarea name="message" cols="40" rows="8"></textarea>
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>

<h3>Enctype: multipart/form-data</h3>

<form action="register.php" method="post" enctype="multipart/form-data"
    onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Upload example</legend>
    <p>
      First name: <input type="text" name="firstname" /><br />
      Last name: <input type="text" name="lastname" /><br />
      Sex:
      <input id="sex_male" type="radio" name="sex" value="male" />
      <label for="sex_male">Male</label>
      <input id="sex_female" type="radio" name="sex" value="female" />
      <label for="sex_female">Female</label><br />
      Password: <input type="password" name="secret" /><br />
      What do you prefer:
      <select name="image_type">
        <option>Books</option>
        <option>Cinema</option>
        <option>TV</option>
      </select>
    </p>
    <p>
      Post your photos:
      <input type="file" multiple name="photos[]">
    </p>
    <p>
      <input id="vehicle_bike" type="checkbox" name="vehicle[]" value="Bike" />
      <label for="vehicle_bike">I have a bike</label><br />
      <input id="vehicle_car" type="checkbox" name="vehicle[]" value="Car" />
      <label for="vehicle_car">I have a car</label>
    </p>
    <p>
      Describe yourself:<br />
      <textarea name="description" cols="50" rows="8"></textarea>
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>

</body>
</html>
```



要测试它的话，创建一个名为 `register.php` 的页面（作为示例表单的 `action` 属性）并且只输入以下内容：

```php
<?php
/* register.php */

header("Content-type: text/plain");

/*
NOTE: You should never use `print_r()` in production scripts, or
otherwise output client-submitted data without sanitizing it first.
Failing to sanitize can lead to cross-site scripting vulnerabilities.
*/

echo ":: data received via GET ::\n\n";
print_r($_GET);

echo "\n\n:: Data received via POST ::\n\n";
print_r($_POST);

echo "\n\n:: Data received as \"raw\" (text/plain encoding) ::\n\n";
if (isset($HTTP_RAW_POST_DATA)) { echo $HTTP_RAW_POST_DATA; }

echo "\n\n:: Files received ::\n\n";
print_r($_FILES);
```

激活这些代码的语法很简单：

```js
AJAXSubmit(myForm);
```

> **注意:** 该框架使用 [`FileReader`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader) API 进行文件的上传。这是一个较新的 API 并且还未在 IE9 及以下版本的浏览器中实现。因此，使用 AJAX 上传仍是一项**实验性的技术**。如果你不需要上传 二进制文件，该框架在大多数浏览器中运行良好。

> **注意:** 发送二进制内容的最佳途径是通过 [`ArrayBuffers`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 或 [`Blobs`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 结合 [`send()`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send) 方法甚至 `FileReader` API 的 [`readAsArrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsArrayBuffer) 方法。但是，自从该脚本的目的变成处理 [可字符串化](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) 的原始数据以来，我们使用 `sendAsBinary()` 方法结合 `FileReader` API 的 [`readAsBinaryString()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsBinaryString) 方法。同样地，上述脚本仅当你处理小文件时行之有效。**如果不打算上传二进制内容，就考虑使用 `FormData` API 来替代。**

> **注意:** 非标准的 `sendAsBinary` 方法从 Gecko 31 (Firefox 31 / Thunderbird 31 / SeaMonkey 2.28) 开始将会废弃并且会很快被移除。标准方法 `send(Blob data)` 将会取而代之。

### [使用 FormData 对象](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#使用_formdata_对象)

[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 构造函数**能使你编译一个键/值对的集合**，然后使用 `XMLHttpRequest` 发送出去。其主要用于发送表格数据，但是也能被单独用来传输表格中用户指定的数据。传输的数据格式与表格使用 `submit()` 方法发送数据的格式一致，如果该表格的编码类型被设为 "multipart/form-data". FormData 对象可以被结合 `XMLHttpRequest` 的多种方法利用。例如，想了解如何利用 FormData 与 XMLHttpRequests, 请转到 [Using FormData Objects](https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects) 页面。为了说教的目的，这里有一个早期的[例子](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest$edit#A_little_vanilla_framework)，被转译成了使用 **`FormData` API** 的形式。注意以下代码片段：

```html
<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" charset="UTF-8" />
<title>Sending forms with FormData &ndash; MDN</title>
<script>
"use strict";

function ajaxSuccess () {
  console.log(this.responseText);
}

function AJAXSubmit (oFormElement) {
  if (!oFormElement.action) { return; }
  var oReq = new XMLHttpRequest();
  oReq.onload = ajaxSuccess();
  if (oFormElement.method.toLowerCase() === "post") {
    oReq.open("post", oFormElement.action);
    oReq.send(new FormData(oFormElement));
  } else {
    var oField, sFieldType, nFile, sSearch = "";
    for (var nItem = 0; nItem < oFormElement.elements.length; nItem++) {
      oField = oFormElement.elements[nItem];
      if (!oField.hasAttribute("name")) { continue; }
      sFieldType = oField.nodeName.toUpperCase() === "INPUT" ?
          oField.getAttribute("type").toUpperCase() : "TEXT";
      if (sFieldType === "FILE") {
        for (nFile = 0; nFile < oField.files.length;
            sSearch += "&" + escape(oField.name) + "=" + escape(oField.files[nFile++].name));
      } else if ((sFieldType !== "RADIO" && sFieldType !== "CHECKBOX") || oField.checked) {
        sSearch += "&" + escape(oField.name) + "=" + escape(oField.value);
      }
    }
    oReq.open("get", oFormElement.action.replace(/(?:\?.*)?$/, sSearch.replace(/^&/, "?")), true);
    oReq.send(null);
  }
}
</script>
</head>
<body>

<h1>Sending forms with FormData</h1>

<h2>Using the GET method</h2>

<form action="register.php" method="get" onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Registration example</legend>
    <p>
      First name: <input type="text" name="firstname" /><br />
      Last name: <input type="text" name="lastname" />
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>

<h2>Using the POST method</h2>
<h3>Enctype: application/x-www-form-urlencoded (default)</h3>

<form action="register.php" method="post" onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Registration example</legend>
    <p>
      First name: <input type="text" name="firstname" /><br />
      Last name: <input type="text" name="lastname" />
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>

<h3>Enctype: text/plain</h3>

<p>The text/plain encoding is not supported by the FormData API.</p>

<h3>Enctype: multipart/form-data</h3>

<form action="register.php" method="post" enctype="multipart/form-data"
    onsubmit="AJAXSubmit(this); return false;">
  <fieldset>
    <legend>Upload example</legend>
    <p>
      First name: <input type="text" name="firstname" /><br />
      Last name: <input type="text" name="lastname" /><br />
      Sex:
      <input id="sex_male" type="radio" name="sex" value="male" />
      <label for="sex_male">Male</label>
      <input id="sex_female" type="radio" name="sex" value="female" />
      <label for="sex_female">Female</label><br />
      Password: <input type="password" name="secret" /><br />
      What do you prefer:
      <select name="image_type">
        <option>Books</option>
        <option>Cinema</option>
        <option>TV</option>
      </select>
    </p>
    <p>
      Post your photos:
      <input type="file" multiple name="photos[]">
    </p>
    <p>
      <input id="vehicle_bike" type="checkbox" name="vehicle[]" value="Bike" />
      <label for="vehicle_bike">I have a bike</label><br />
      <input id="vehicle_car" type="checkbox" name="vehicle[]" value="Car" />
      <label for="vehicle_car">I have a car</label>
    </p>
    <p>
      Describe yourself:<br />
      <textarea name="description" cols="50" rows="8"></textarea>
    </p>
    <p>
      <input type="submit" value="Submit" />
    </p>
  </fieldset>
</form>
</body>
</html>
```

> **注意:** 如之前所述，**[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 对象并不是 [可字符串化(stringifiable)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) 的对象。**如果你想要字符串化一个提交数据，请使用这个 [早期的纯 AJAX 例子](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#a_little_vanilla_framework). 同时也要注意，尽管这个例子中有一些 `file` <Input>字段，**但当你通过** **`FormData` API 提交一个表格时，也无须使用 [`FileReader`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader) API**: 文件被自动加载并上传。



## [获取最后修改日期](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#获取最后修改日期)

```js
function getHeaderTime () {
  console.log(this.getResponseHeader("Last-Modified"));  /* 一个合法的 GMTString 日期或 null */
}

var oReq = new XMLHttpRequest();
oReq.open("HEAD" /* 仅需要头部信息(headers)时请使用 HEAD! */, "yourpage.html");
oReq.onload = getHeaderTime;
oReq.send();
```

### [最后修改日期改变后的操作](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#最后修改日期改变后的操作)

先创建两个函数：

```js
function getHeaderTime () {
  var nLastVisit = parseFloat(window.localStorage.getItem('lm_' + this.filepath));
  var nLastModif = Date.parse(this.getResponseHeader("Last-Modified"));

  if (isNaN(nLastVisit) || nLastModif > nLastVisit) {
    window.localStorage.setItem('lm_' + this.filepath, Date.now());
    isFinite(nLastVisit) && this.callback(nLastModif, nLastVisit);
  }
}

function ifHasChanged(sURL, fCallback) {
  var oReq = new XMLHttpRequest();
  oReq.open("HEAD" /* 使用 HEAD - 我们仅需要头部信息(headers)! */, sURL);
  oReq.callback = fCallback;
  oReq.filepath = sURL;
  oReq.onload = getHeaderTime;
  oReq.send();
}
```

测试

```js
/* 测试一下这个文件："yourpage.html"... */

ifHasChanged("yourpage.html", function (nModif, nVisit) {
  console.log("The page '" + this.filepath + "' has been changed on " + (new Date(nModif)).toLocaleString() + "!");
});
```

如果你想要了解 ***当前页面是否发生了改变，\***请阅读这篇文章：[`document.lastModified`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/lastModified).

## [跨站的 XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#跨站的_xmlhttprequest)

现代浏览器可以通过执行 WebApps 工作小组通过的 [Access Control for Cross-Site Requests](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 标注来支持跨站请求。只要服务器端的配置允许您从您的 Web 应用发送请求，就可以使用 `XMLHttpRequest` 。 否则，会抛出一个 `INVALID_ACCESS_ERR` 异常

## [绕过缓存](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#绕过缓存)

一般地，如果缓存中有相应内容， `XMLHttpRequest` 会试图从缓存中读取内容。绕过缓存的方法见下述代码：

```js
var req = new XMLHttpRequest();
req.open('GET', url, false);
req.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE;
req.send(null);
```

> **Note:** 这个方法只工作于基于 Gecko内核的软件, 也就是通道属性是 Gecko-specific.

还有一个跨浏览器兼容的方法，就是给 URL 添加时间戳。请确保你酌情地添加了 "?" or "&" 。例如，将：

```js
http://foo.com/bar.html -> http://foo.com/bar.html?12345
http://foo.com/bar.html?foobar=baz -> http://foo.com/bar.html?foobar=baz&12345
```

因为本地缓存都是以 URL 作为索引的，这样就可以使每个请求都是唯一的，也就可以这样来绕开缓存。

你也可以用下面的方法自动更改缓存：

```js
var oReq = new XMLHttpRequest();

oReq.open("GET", url + ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime());
oReq.send(null);
```

## [安全性](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#安全性)

要启用跨站脚本，推荐的做法是对 XMLHttpRequest 的响应使用 the `Access-Control-Allow-Origin `的 HTTP 头。

### [XMLHttpRequests 被停止](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#xmlhttprequests_被停止)

如果你的 XMLHttpRequest 收到 `status=0` 和 `statusText=null` 的返回，这意味着请求无法执行。 就是[无法发送](https://www.w3.org/TR/XMLHttpRequest/#dom-xmlhttprequest-unsent). 一个可能导致的原因是当 [`XMLHttpRequest` origin](https://www.w3.org/TR/XMLHttpRequest/#xmlhttprequest-origin) (创建的 XMLHttpRequest) 改变时，XMLHttpRequest 执行 `open()`.。这种情况是可能发生的，举个例子，我们在一个窗口的`onunload`事件中关闭XMLHttpRequest，但实际上在即将关闭窗口时，之前创建的XMLHttpRequest仍然在那里，最后当这个窗口失去焦点、另一个窗口获得焦点时，它还是发送了请求（也就是`open()`）。最有效的避免这个问题的方法是为新窗口的`activate`事件设置一个监听器，一旦窗口关闭，它的`unload (en-US)`事件便触发。

## [Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#worker)

设置 `overrideMimeType` 后在 [`Worker`](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker) 中无法正常工作，详见 [bug 678057](https://bugzilla.mozilla.org/show_bug.cgi?id=678057)。其他浏览器也许会以不同的手段处理。

---

# HTML in XMLHttpRequest

W3C [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 规范为 [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)添加HTML语法解析功能, 此前仅支持XML语法解析。该功能允许Web应用程序使用`XMLHttpRequest作为解析的DOM。`

## [局限](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#局限)

为了阻止同步使用XMLHttpRequest，**HTML在同步模式下不支持使用**。并且，**只有当responseType属性设置为'document'的情况下，HTML支持才可用**。这种限制避免了浪费时间解析HTML，而传统代码在默认模式下使用XMLHttpRequest来检索text/html资源的responseText. 此外，该限制避免了遗留代码的问题，该代码假定Http错误页面（通常具有text/html响应正文）的responseXML为空。

## [用法](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#用法)

使用XMLHttpRequest将HTML资源恢复为DOM就像使用XMLHttpRequest将XML资源恢复为DOM一样，除了您不能使用同步模式，您必须通过将字符串“document”分配给responseType属性来显式请求文档调用open（）之后调用send（）之前的XMLHttpRequest对象。

```js
var xhr = new XMLHttpRequest();
xhr.onload = function() {
  console.log(this.responseXML.title);
}
xhr.open("GET", "file.html");
xhr.responseType = "document";
xhr.send();
```

## [功能检测](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#功能检测)

### [方法1](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#方法1)

该方法依赖于功能的“强制异步”性质。当你尝试设置一个以“sync”方式打开的XMLHttpRequest对象后，尝试将设置responseType会在实现该功能的浏览器上引发错误，其他浏览器则运行良好。

```js
function HTMLinXHR() {
  if (!window.XMLHttpRequest)
    return false;
  var req = new window.XMLHttpRequest();
  req.open('GET', window.location.href, false);
  try {
    req.responseType = 'document';
  } catch(e) {
    return true;
  }
  return false;
}
```

### [方法2](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#方法2)

 检测浏览器是否支持XMLHttpRequest中的HTML解析有两个挑战。首先，检测结果是异步获取的，因为HTML支持仅在异步模式下可用。其次，您必须通过 HTTP 实际获取测试文档，因为使用 data:URL 进行测试最终会同时测试 data:URL 支持。

因此，为了检测HTML支持，服务器上需要一个测试HTML文件。这个测试文件很小，格式不是很完整：

```
<title>&amp;&<</title>
```

如果文件名为detect.html，以下功能可用于检测HTML解析支持：

```js
function detectHtmlInXhr(callback) {
  if (!window.XMLHttpRequest) {
    window.setTimeout(function() { callback(false); }, 0);
    return;
  }
  var done = false;
  var xhr = new window.XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (this.readyState == 4 && !done) {
      done = true;
      callback(!!(this.responseXML && this.responseXML.title && this.responseXML.title == "&&<"));
    }
  }
  xhr.onabort = xhr.onerror = function() {
    if (!done) {
      done = true;
      callback(false);
    }
  }
  try {
    xhr.open("GET", "detect.html");
    xhr.responseType = "document";
    xhr.send();
  } catch (e) {
    window.setTimeout(function() {
      if (!done) {
        done = true;
        callback(false);
      }
    }, 0);
  }
}
```

参数callback是一个函数，如果HTML解析是支持的，则将以true作为唯一参数被异步调用，如果不支持HTML解析，则为false。

## [字符编码](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#字符编码)

如果在HTTP Content-Type 头部中声明了字符编码，则使用该字符编码。否则，如果存在字节顺序标记，则使用由字节顺序标记指示的编码。否则，如果有一个meta tag声明文件的前1024个字节中的编码，则使用该编码。否则，文件被解码为UTF-8。

## [老版本的浏览器中处理HTML](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest#老版本的浏览器中处理html)

XMLHttpRequest最初只支持XML解析。 HTML解析支持是最近的一个补充。对于较老的浏览器，您甚至可以使用与正则表达式关联的responseText属性，以获取例如已知其ID的HTML元素的源代码：

```js
function getHTML (oXHR, sTargetId) {
  var  rOpen = new RegExp("<(?!\!)\\s*([^\\s>]+)[^>]*\\s+id\\=[\"\']" + sTargetId + "[\"\'][^>]*>" ,"i"),
       sSrc = oXHR.responseText, aExec = rOpen.exec(sSrc);

  return aExec ? (new RegExp("(?:(?:.(?!<\\s*" + aExec[1] + "[^>]*[>]))*.?<\\s*" + aExec[1] + "[^>]*[>](?:.(?!<\\s*\/\\s*" + aExec[1] + "\\s*>))*.?<\\s*\/\\s*" + aExec[1] + "\\s*>)*(?:.(?!<\\s*\/\\s*" + aExec[1] + "\\s*>))*.?", "i")).exec(sSrc.slice(sSrc.indexOf(aExec[0]) + aExec[0].length)) || "" : "";
}

var oReq = new XMLHttpRequest();
oReq.open("GET", "yourPage.html", true);
oReq.onload = function () { console.log(getHTML(this, "intro")); };
oReq.send(null);
```

---

# WebSocket

`WebSocket` 对象提供了用于创建和管理 [WebSocket](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API) 连接，以及可以通过该连接发送和接收数据的 API。

使用` WebSocket()`[ ](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket)构造函数来构造一个` WebSocket` 。

## [构造函数](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#构造函数)

- [`WebSocket(url[, protocols\])`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/WebSocket)

  返回一个 `WebSocket` 对象。

## [常量](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#常量)

| **Constant**           | **Value** |
| ---------------------- | --------- |
| `WebSocket.CONNECTING` | `0`       |
| `WebSocket.OPEN`       | `1`       |
| `WebSocket.CLOSING`    | `2`       |
| `WebSocket.CLOSED`     | `3`       |

## [属性](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#属性)

- [`WebSocket.binaryType`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/binaryType)

  使用二进制的数据类型连接。

- [`WebSocket.bufferedAmount`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/bufferedAmount) 只读

  未发送至服务器的字节数。

- [`WebSocket.extensions`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/extensions) 只读

  服务器选择的扩展。

- [`WebSocket.onclose`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/close_event)

  用于指定连接关闭后的回调函数。

- [`WebSocket.onerror`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/WebSocket/error_event)

  用于指定连接失败后的回调函数。

- [`WebSocket.onmessage`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/WebSocket/message_event)

  用于指定当从服务器接受到信息时的回调函数。

- [`WebSocket.onopen`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/open_event)

  用于指定连接成功后的回调函数。

- [`WebSocket.protocol`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/protocol) 只读

  服务器选择的下属协议。

- [`WebSocket.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/readyState) 只读

  当前的链接状态。

- [`WebSocket.url`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/url) 只读

  WebSocket 的绝对路径。

## [方法](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#method_overview)

- [`WebSocket.close([code[, reason\]])`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/close)

  关闭当前链接。

- [`WebSocket.send(data)`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/send)

  对要传输的数据进行排队。

## [事件](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#事件)

使用 `addEventListener()` 或将一个事件监听器赋值给本接口的 `on*eventname*` 属性，来监听下面的事件。

- [`close`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/close_event)

  当一个 `WebSocket` 连接被关闭时触发。 也可以通过 [`onclose`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/close_event) 属性来设置。

- [`error`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/error_event)

  当一个 `WebSocket` 连接因错误而关闭时触发，例如无法发送数据时。 也可以通过 [`onerror`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/WebSocket/error_event) 属性来设置.

- [`message`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/message_event)

  当通过 `WebSocket` 收到数据时触发。 也可以通过 [`onmessage`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/WebSocket/message_event) 属性来设置。

- [`open`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/open_event)

  当一个 `WebSocket` 连接成功时触发。 也可以通过 [`onopen`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/open_event) 属性来设置。

## [示例](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#attributes)

```js
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});
```

---

# 同步和异步请求

`XMLHttpRequest` 支持同步和异步通信。但是，一般来说，出于性能原因，异步请求应优先于同步请求。

同步请求阻止代码的执行，这会导致屏幕上出现“冻结”和无响应的用户体验。

## [异步请求](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#异步请求)

如果你使用`XMLHttpRequest`发送异步请求,**那么当请求的响应数据完全收到之时，会执行一个指定的回调函数**，而在执行异步请求的同时,浏览器会正常地执行其他事务的处理。

### [例子：在控制台输出页面源文件](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#例子：在控制台输出页面源文件)

这个例子演示了如何进行一个简单的异步请求。

```js
  const xhr = new XMLHttpRequest();

  xhr.open("GET", "http://127.0.0.1/test/genomefile.txt", true);

  xhr.onload = function(e){
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        console.log(xhr.responseText);
      }else{
        console.error(xhr.statusText);
      }
    }
  };

  xhr.onerror = function(e){
    console.error(xhr.statusText);
  };

  xhr.send();
```

第2行中指定第三个参数为`true`，`表示该请求`应该以**异步模式**执行。

第3行创建一个事件处理函数对象，并将其分配给请求的`onload`属性。此处理程序查看请求的`readyState`，以查看事务是否在第4行完成，如果是，并且HTTP状态为200，则转储接收到的内容。如果发生错误，则显示错误消息。

第15行实际上启动了请求。**只要请求的状态发生变化，就会调用回调程序。**

### [例子：创建一个标准的方法来读取外部文件](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#例子：创建一个标准的方法来读取外部文件)

在一些需求情况下,必须读取多个外部文件. 这是一个标准的函数. 该函数使用`XMLHttpRequest`对象进行异步请求.而且可以为每个文件读取完成后指定不同的回调函数.

```js
  function xhrSuccess() {
    this.callback.apply(this, this.arguments);
  }

  function xhrError() {
    console.error(this.statusText);
  }

  function loadFile(url, callback){
    const xhr = new XMLHttpRequest();
    xhr.callback = callback;
    xhr.arguments = Array.prototype.slice.call(arguments, 2);
    xhr.onload = xhrSuccess;
    xhr.onerror = xhrError;
    xhr.open("GET", url, true);
    xhr.send(null);
  }

  function showMessage(message){
    console.log(message + this.responseText);
  }

  loadFile("http://127.0.0.1/test/genomefile.txt", showMessage, "New message!\n\n");
```

实用函数loadFile的签名声明（i）要读取的目标URL（通过HTTP GET），（ii）成功完成XHR操作时执行的函数，以及（iii）任意列表的附加参数“通过“XHR对象到成功回调函数。

第1行声明XHR操作成功完成时调用的函数。它又调用已经分配给XHR对象（第7行）属性的loadFile函数（本例中为函数showMessage）的调用中指定的回调函数。提供给调用函数loadFile的附加参数（如果有的话）被“应用”到回调函数的运行中。

第5行声明XHR操作无法成功完成时调用的函数。

第7行存储XHR对象，成功回调函数作为loadFile的第二个参数给出。

第12行将参数赋给loadFile的调用。从第三个参数开始，收集所有剩余的参数，分配给变量xhr的arguments属性，传递给成功回调函数xhrSuccess，最终提供给函数调用的回调函数（在本例中为showMessage） xhrSuccess。

第15行为其第三个参数指定了true，表示该请求应该被异步处理。

第16行实际启动请求。

### [例子：使用超时](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#例子：使用超时)

你可以使用一个超时设置,来**避免你的代码为了等候读取请求的返回数据长时间执行**.超时毫秒数可以通过为`XMLHttpRequest`对象的`timeout` 属性赋值来指定：

```js
  function xhrSuccess() {
    if (this.readyState === 4) {
      if (this.status === 200) {
        this.callback.apply(this, this.arguments);
      }
    }
  }

  function xhrError() {
    console.error(this.statusText);
  }
  function xhrTimeout() {
    console.error("The request for " + url + " timed out.");
  }

  function loadFile(url, timeout, callback){
    const xhr = new XMLHttpRequest();

    xhr.callback = callback;
    xhr.arguments = Array.prototype.slice.call(arguments, 3);
    xhr.onload = xhrSuccess;
    xhr.onerror = xhrError;
    xhr.ontimeout = xhrTimeout;

    xhr.open("GET", url, true);
    xhr.send(null);
  }

  function showMessage(message){
    console.log(message + this.responseText);
  }

  loadFile("http://127.0.0.1/test/genomefile.txt", 2000, showMessage, "New message!\n\n");
```

你还可以为`timeout`事件的`ontimeout`事件句柄指定事件处理函数。

如上，我们指定的超时时间为 2000 ms。

`timeout`属性添加于Gecko 12.0  Gecko 12.0。

