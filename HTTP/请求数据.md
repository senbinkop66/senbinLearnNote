

# Fetch 

Fetch API 提供了一个获取资源的接口（包括跨域请求）。任何使用过 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 的人都能轻松上手，而且新的 API 提供了更强大和灵活的功能集。

## [概念和用法](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#概念和用法)

Fetch 提供了对 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) （以及其他与网络请求有关的）对象的通用定义。使之今后可以被使用到更多地应用场景中：无论是 service worker、Cache API、又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式。

它同时还为有关联性的概念，例如CORS和HTTP原生头信息，提供一种新的定义，取代它们原来那种分离的定义。

发送请求或者获取资源，需要使用 [`WindowOrWorkerGlobalScope.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法。它在很多接口中都被实现了，更具体地说，是在 [`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window) 和 [`WorkerGlobalScope`](https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope) 接口上。因此在几乎所有环境中都可以用这个方法获取到资源。

 `fetch()` 必须接受一个参数——资源的路径。**无论请求成功与否，它都返回一个 Promise 对象**，resolve 对应请求的 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)。你也可以传一个可选的第二个参数 `init`（参见 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)）。

一旦 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 被返回，就可以使用一些方法来定义内容的形式，以及应当如何处理内容（参见 `Body`）。

你也可以通过 [`Request()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request/Request) 和 [`Response()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/Response) 的构造函数直接创建请求和响应，但是我们不建议这么做。他们应该被用于创建其他 API 的结果（比如，service workers 中的 [`FetchEvent.respondWith`](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/respondWith)）。

> **注意**：更多关于 Fetch API 的用法，参考 [Using Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)，以及一些概念 [Fetch basic concepts](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Basic_concepts)。

### [中止 fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#中止_fetch)

浏览器已经开始为 [`AbortController`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 和 [`AbortSignal`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal) 接口（也就是Abort API）添加实验性支持，允许像 Fetch 和 XHR 这样的操作在还未完成时被中止 。请参阅接口页面了解更多详情。

## [Fetch 接口](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#fetch_接口)

- [`WindowOrWorkerGlobalScope.fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)

  包含了`fetch()` 方法，用于获取资源。

- [`Headers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)

  相当于 response/request 的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。

- [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)

  相当于一个资源请求。

- [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)

  相当于请求的响应

## [Fetch mixin](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API#fetch_mixin)

- `Body`

  提供了与 response/request 中的 body 有关的方法，可以定义它的内容形式以及处理方式。

# 使用 Fetch

[Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API) 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) 方法，该方法提供了一种简单，合理的方式来**跨网络异步获取资源**。

这种功能以前是使用 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如 [`Service Workers`](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 和 HTTP 的扩展。

请注意，`fetch` 规范与 `jQuery.ajax()` 主要有以下的**不同**：

- 当接收到一个代表错误的 HTTP 状态码时，从 `fetch()` 返回的 Promise **不会被标记为 reject**，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 [`ok`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok) 属性为 false ），**仅当网络故障时或请求被阻止时，才会标记为 reject。**
- `fetch` **不会发送跨域 cookies**，除非你使用了 *credentials* 的[初始化选项](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch#参数)。（自[2018 年 8 月](https://github.com/whatwg/fetch/pull/585)以后，默认的 credentials 政策变更为 `same-origin`。Firefox 也在 61.0b13 版本中进行了修改）

一个基本的 fetch 请求设置起来很简单。看看下面的代码：

```js
  fetch("http://127.0.0.1/test/ajax/test.json")
    .then(response => response.json())
    .then(data => console.log(data));
```

这里我们通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 `fetch()` 到的资源路径，然后返回一个包含响应结果的 promise（一个 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象）。

当然它只是一个 HTTP 响应，而不是真的 JSON。**为了获取JSON的内容，我们需要使用 [`json()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json) 方法**（该方法返回一个将响应 body 解析成 JSON 的 promise）。

> **备注：** [Body](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#body) 还有其他相似的方法，用于获取其他类型的内容。

最好使用符合[内容安全策略 (CSP)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)的链接而不是使用直接指向资源地址的方式来进行 fetch 的请求。

### [支持的请求参数](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#支持的请求参数)

`fetch()` 接受第二个可选参数，一个可以控制不同配置的 `init` 对象：

参考 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)，查看所有可选的配置和更多描述。

```js
// Example POST method implementation:
async function postData(url = '', data = {}) {
  // Default options are marked with *
  const response = await fetch(url, {
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, *cors, same-origin
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, *same-origin, omit
    headers: {
      'Content-Type': 'application/json'
      // 'Content-Type': 'application/x-www-form-urlencoded',
    },
    redirect: 'follow', // manual, *follow, error
    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    body: JSON.stringify(data) // body data type must match "Content-Type" header
  });
  return response.json(); // parses JSON response into native JavaScript objects
}

postData('https://example.com/answer', { answer: 42 })
  .then(data => {
    console.log(data); // JSON data parsed by `data.json()` call
  });
```

注意：`mode: "no-cors"` 仅允许使用一组有限的 HTTP 请求头：

- `Accept`
- `Accept-Language`
- `Content-Language`
- `Content-Type` 允许使用的值为：`application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`

### [发送带凭据的请求](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#发送带凭据的请求)

为了让浏览器发送包含凭据的请求（即使是跨域源），要将 `credentials: 'include'` 添加到传递给 `fetch()` 方法的 `init` 对象。

```js
fetch('https://example.com', {
  credentials: 'include'
});
```

**备注：** 当请求使用 `credentials: 'include'` 时，响应的 `Access-Control-Allow-Origin` 不能使用通配符 "`*`"。在这种情况下，`Access-Control-Allow-Origin` **必须是当前请求的源**，在使用 CORS Unblock 插件的情况下请求仍会失败。

**备注：** 无论怎么设置，**浏览器都不应在 *预检请求* 中发送凭据**。了解更多：[跨域资源共享 > 附带身份凭证的请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#附带身份凭证的请求)

如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加 `credentials: 'same-origin'`。

```js
// The calling script is on the origin 'https://example.com'

fetch('https://example.com', {
  credentials: 'same-origin'
});
```

要改为确保浏览器不在请求中包含凭据，请使用 `credentials: 'omit'`。

```js
fetch('https://example.com', {
  credentials: 'omit'
})
```

### [上传 JSON 数据](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#上传_json_数据)

使用 [`fetch()`](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch) POST JSON数据

```js
  let data = {username: "example"};

  fetch("http://127.0.0.1/test/ajax/",{
    method:"POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(data),
  })
    .then(response => response.json())
    .then(data => console.log("Success:", data))
    .catch((error) => {
      console.log("Error:", error);
    });

```

